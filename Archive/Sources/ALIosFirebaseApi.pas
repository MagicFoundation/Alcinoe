type

  // @abstract The match type of the Dynamic Link.
  // typedef NS_ENUM(NSUInteger, FIRDLMatchType)
  FIRDLMatchType = NSUInteger;

const

  // The match has not been achieved.
  FIRDLMatchTypeNone = 0;

  // The match between the Dynamic Link and this device may not be perfect, hence you should not
  // reveal any personal information related to the Dynamic Link.
  FIRDLMatchTypeWeak = 1;

  // The match between the Dynamic Link and this device has high confidence but small possibility of
  // error still exist.
  FIRDLMatchTypeDefault = 2;

  // The match between the Dynamic Link and this device is exact, hence you may reveal personal
  // information related to the Dynamic Link.
  FIRDLMatchTypeUnique = 3;

type

  {***********************************}
  // @abstract A received Dynamic Link.
  // NS_SWIFT_NAME(DynamicLink)
  // @interface FIRDynamicLink : NSObject
  FIRDynamicLinkClass = interface(NSObjectClass)
  ['{8B7B39DF-9834-42FD-92CB-02C3C3748E10}']
  end;
  FIRDynamicLink = interface(NSObject)
  ['{EE614A78-F2E5-4375-B9CC-42AE9D53976E}']

    // @abstract The URL that was passed to the app.
    // @property(nonatomic, copy, readonly, nullable) NSURL *url;
    function url: NSURL; cdecl;

    // @abstract The match confidence of the received Dynamic Link.
    // @property(nonatomic, assign, readonly) FIRDynamicLinkMatchConfidence matchConfidence DEPRECATED_MSG_ATTRIBUTE("Use FIRDynamicLink.matchType (DynamicLink.DLMatchType) instead.");
    // function matchConfidence: FIRDynamicLinkMatchConfidence; cdecl;

    // @abstract The match type of the received Dynamic Link.
    // @property(nonatomic, assign, readonly) FIRDLMatchType matchType;
    function matchType: FIRDLMatchType; cdecl;

    // @abstract The minimum iOS application version that supports the Dynamic Link. This is retrieved
    // from the imv= parameter of the Dynamic Link URL. Note: This is not the minimum iOS system
    // version, but the minimum app version. If app version of the opening app is less than the
    // value of this property, than app expected to open AppStore to allow user to download most
    // recent version. App can notify or ask user before opening AppStore.
    // @property(nonatomic, copy, readonly, nullable) NSString *minimumAppVersion;
    function minimumAppVersion: NSString; cdecl;

  end;
  TFIRDynamicLink = class(TOCGenericImport<FIRDynamicLinkClass, FIRDynamicLink>) end;
  PFIRDynamicLink = Pointer;

  {*************************************************************************}
  // @abstract A class that checks for pending Dynamic Links and parses URLs.
  // NS_SWIFT_NAME(DynamicLinks)
  // @interface FIRDynamicLinks : NSObject
  FIRDynamicLinksClass = interface(NSObjectClass)
  ['{2A698C78-6CB4-405B-9C4A-941080815FE7}']

    // @abstract Shared instance of FIRDynamicLinks. Returns nil on iOS versions prior to 8.
    // @return Shared instance of FIRDynamicLinks.
    // + (nullable instancetype)dynamicLinks NS_SWIFT_NAME(dynamicLinks());
    function dynamicLinks: Pointer; cdecl;

    // @abstract Performs basic FDL self diagnostic. Method effect on startup latency is quite small
    // and no user-visble UI is presented. This method should be used for debugging purposes.
    // App developers are encouraged to include output, generated by this method, to the support
    // requests sent to Firebase support.
    // @param completionHandler Handler that will be called when diagnostic completes.
    // If value of the completionHandler is nil than diagnostic output will be printed to
    // the standard output.
    // diagnosticOutput String that includes diagnostic information.
    // hasErrors Param will have YES value if diagnostic method detected error, NO otherwise.
    // + (void)performDiagnosticsWithCompletion:(void (^_Nullable)(NSString *diagnosticOutput, BOOL hasErrors))completionHandler;
    //procedure performDiagnosticsWithCompletion(completionHandler: TFirebaseDynamicLinksCompletionHandler); cdecl;

  end;
  FIRDynamicLinks = interface(NSObject)
  ['{BF93C1FD-608E-4D4D-9CA0-BA22BF7FFA14}']

    // @abstract Determine whether FIRDynamicLinks should handle the given URL. This does not
    // guarantee that |dynamicLinkFromCustomSchemeURL:| will return a non-nil value, but it means
    // the client should not attempt to handle the URL.
    // @param url Custom scheme URL.
    // @return Whether the URL can be handled by FIRDynamicLinks.
    // - (BOOL)shouldHandleDynamicLinkFromCustomSchemeURL:(NSURL *)url NS_SWIFT_NAME(shouldHandleDynamicLink(fromCustomSchemeURL:));
    function shouldHandleDynamicLinkFromCustomSchemeURL(url: NSURL): Boolean; cdecl;

    // @abstract Get a Dynamic Link from a custom scheme URL. This method parses URLs with a custom
    // scheme, for instance, "comgoogleapp://google/link?deep_link_id=abc123". It is suggested to
    // call it inside your |UIApplicationDelegate|'s
    // |application:openURL:sourceApplication:annotation| and |application:openURL:options:|
    // methods.
    // @param url Custom scheme URL.
    // @return Dynamic Link object if the URL is valid and has link parameter, otherwise nil.
    // - (nullable FIRDynamicLink *)dynamicLinkFromCustomSchemeURL:(NSURL *)url NS_SWIFT_NAME(dynamicLink(fromCustomSchemeURL:));
    function dynamicLinkFromCustomSchemeURL(url: NSURL): FIRDynamicLink; cdecl;

    // @abstract Get a Dynamic Link from a universal link URL. This method parses universal link
    // URLs, for instance,
    // "https://example.app.goo.gl?link=https://www.google.com&ibi=com.google.app&ius=comgoogleapp".
    // It is suggested to call it inside your |UIApplicationDelegate|'s
    // |application:continueUserActivity:restorationHandler:| method.
    // @param url Custom scheme URL.
    // @return Dynamic Link object if the URL is valid and has link parameter, otherwise nil.
    // - (nullable FIRDynamicLink *)dynamicLinkFromUniversalLinkURL:(NSURL *)url NS_SWIFT_NAME(dynamicLink(fromUniversalLink:));
    function dynamicLinkFromUniversalLinkURL(url: NSURL): FIRDynamicLink; cdecl;

    // @abstract Convenience method to handle a Universal Link whether it is long or short. A long link
    // will call the handler immediately, but a short link may not.
    // @param url A Universal Link URL.
    // @param completion A block that handles the outcome of attempting to create a FIRDynamicLink.
    // @return YES if FIRDynamicLinks is handling the link, otherwise, NO.
    // - (BOOL)handleUniversalLink:(NSURL *)url completion:(FIRDynamicLinkUniversalLinkHandler)completion;
    //function handleUniversalLink(url: NSURL; completion: FIRDynamicLinkUniversalLinkHandler): Boolean; cdecl;

    // @abstract Retrieves the details of the Dynamic Link that the shortened URL represents.
    // @param url A Short Dynamic Link.
    // @param completion Block to be run upon completion.
    // - (void)resolveShortLink:(NSURL *)url completion:(FIRDynamicLinkResolverHandler)completion;
    //procedure resolveShortLink(url: NSURL; completion: FIRDynamicLinkResolverHandler); cdecl;

    // @abstract Determines if a given URL matches the given short Dynamic Link format.
    // @param url A URL.
    // @return YES if the URL is a short Dynamic Link, otherwise, NO.
    // - (BOOL)matchesShortLinkFormat:(NSURL *)url;
    function matchesShortLinkFormat(url: NSURL): Boolean; cdecl;

  end;
  TFIRDynamicLinks = class(TOCGenericImport<FIRDynamicLinksClass, FIRDynamicLinks>) end;
  PFIRDynamicLinks = Pointer;




implementation



{$IF defined(CPUARM)}

// you must also add in the linker flags -Objc else you have the error
// Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[__NSCFString fira_UTF32Length]: unrecognized selector sent to instance 0x1758c350
// this is also written in the firebase doc: https://firebase.google.com/docs/ios/setup (Add the ObjC linker flag in your Other Linker Settings in your target's build settings.)
// but when i add -ObjC i have this error : https://stackoverflow.com/questions/49722316/why-under-ios-when-i-add-objc-i-have-error-ld-framework-not-found-fbsdkcorekit
// so i Add instead -force_load:
// -force_load C:\Dev\MagicFoundation\Alcinoe\Libraries\ios\firebase\FirebaseCore.framework\FirebaseCore
// -force_load C:\Dev\MagicFoundation\Alcinoe\Libraries\ios\firebase\FirebaseCoreDiagnostics.framework\FirebaseCoreDiagnostics
// -force_load C:\Dev\MagicFoundation\Alcinoe\Libraries\ios\firebase\FirebaseAnalytics.framework\FirebaseAnalytics
// -force_load C:\Dev\MagicFoundation\Alcinoe\Libraries\ios\firebase\FirebaseDynamicLinks.framework\FirebaseDynamicLinks
// -force_load C:\Dev\MagicFoundation\Alcinoe\Libraries\ios\firebase\FirebaseInstanceID.framework\FirebaseInstanceID
// -force_load C:\Dev\MagicFoundation\Alcinoe\Libraries\ios\firebase\FirebaseMessaging.framework\FirebaseMessaging
// -force_load C:\Dev\MagicFoundation\Alcinoe\Libraries\ios\firebase\FirebaseNanoPB.framework\FirebaseNanoPB
// -force_load C:\Dev\MagicFoundation\Alcinoe\Libraries\ios\firebase\nanopb.framework\nanopb
// -force_load C:\Dev\MagicFoundation\Alcinoe\Libraries\ios\firebase\Protobuf.framework\Protobuf
// -force_load C:\Dev\MagicFoundation\Alcinoe\Libraries\ios\firebase\GoogleToolboxForMac.framework\GoogleToolboxForMac

procedure StubProc1;  cdecl; external 'FirebaseCore'         name 'OBJC_CLASS_$_FIRApp';
procedure StubProc2;  cdecl; external 'FirebaseInstanceID'   name 'OBJC_CLASS_$_FIRInstanceID';
procedure StubProc3;  cdecl; external 'FirebaseMessaging'    name 'OBJC_CLASS_$_FIRMessagingMessageInfo';
procedure StubProc4;  cdecl; external 'FirebaseMessaging'    name 'OBJC_CLASS_$_FIRMessagingRemoteMessage';
procedure StubProc5;  cdecl; external 'FirebaseMessaging'    name 'OBJC_CLASS_$_FIRMessagingDelegate';
procedure StubProc6;  cdecl; external 'FirebaseMessaging'    name 'OBJC_CLASS_$_FIRMessaging';
procedure StubProc7;  cdecl; external 'FirebaseDynamicLinks' name 'OBJC_CLASS_$_FIRDynamicLink';
procedure StubProc8;  cdecl; external 'FirebaseDynamicLinks' name 'OBJC_CLASS_$_FIRDynamicLinks';
procedure StubProc9;  cdecl; external 'FirebaseAnalytics'    name 'OBJC_CLASS_$_FIRAnalytics'; // << else the firebase analytics will be not included
procedure StubProc10; cdecl; external 'FirebaseNanoPB'       name 'nano_decode_repeated_string'; // << else (without -force_load: FirebaseNanoPB) I have Error: "_nano_decode_repeated_string", referenced from: ....
procedure StubProc11; cdecl; external 'nanopb'               name 'pb_encode_varint'; // << else (without -force_load: nanopb) I have Error: "_pb_encode_varint", referenced from: ....
procedure StubProc12; cdecl; external 'Protobuf'             name 'OBJC_CLASS_$_GPBRootObject'; // else (without -force_load: Protobuf) I have Error: "_OBJC_CLASS_$_GPBRootObject", referenced from: ...
procedure StubProc13; cdecl; external '/System/Library/Frameworks/SystemConfiguration.framework/SystemConfiguration' name 'SCNetworkReachabilityUnscheduleFromRunLoop'; // else I have Error: "_SCNetworkReachabilityUnscheduleFromRunLoop", referenced from: ....
procedure StubProc14; cdecl; external '/System/Library/Frameworks/StoreKit.framework/StoreKit' name 'OBJC_CLASS_$_SKPaymentQueue'; // else I have Error: "_OBJC_CLASS_$_SKPaymentQueue", referenced from: ...
procedure StubProc15; cdecl; external '/System/Library/Frameworks/WebKit.framework/WebKit' name 'OBJC_CLASS_$_WKWebView'; // else I have Error: "_OBJC_CLASS_$_WKWebView", referenced from: ...

{$ELSE}

// i don't know how to do under ios simulator :(

{$ENDIF}

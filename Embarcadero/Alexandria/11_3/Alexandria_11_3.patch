Index: Embarcadero/Alexandria/11_3/fmx/FMX.Canvas.D2D.pas
===================================================================
diff --git a/Embarcadero/Alexandria/11_3/fmx/FMX.Canvas.D2D.pas b/Embarcadero/Alexandria/11_3/fmx/FMX.Canvas.D2D.pas
--- a/Embarcadero/Alexandria/11_3/fmx/FMX.Canvas.D2D.pas	(revision 1)
+++ b/Embarcadero/Alexandria/11_3/fmx/FMX.Canvas.D2D.pas	(working copy)
@@ -2897,8 +2897,10 @@
     HitTestPoint := APoint - TopLeft - TPointF.Create(Padding.Left, Padding.Top);
     FLayout.HitTestPoint(HitTestPoint.X, HitTestPoint.Y, TrailingHit, Inside, HitTestMetrics);
     Result := HitTestMetrics.textPosition;
-    if TrailingHit then
-      Result := Result + Integer(HitTestMetrics.length);
+    //https://quality.embarcadero.com/browse/RSP-39734
+    if Result >= 0 then Inc(Result); // HitTestMetrics.textPosition look like zero based
+    //if TrailingHit then
+    //  Result := Result + Integer(HitTestMetrics.length);
   end
   else if ((APoint.X < LRect.Left) or SameValue(APoint.X, LRect.Left, TEpsilon.Position)) and
     ((APoint.Y > LRect.Top) or SameValue(APoint.Y, LRect.Top, TEpsilon.Position)) and
Index: Embarcadero/Alexandria/11_3/fmx/FMX.Canvas.GPU.Helpers.pas
===================================================================
diff --git a/Embarcadero/Alexandria/11_3/fmx/FMX.Canvas.GPU.Helpers.pas b/Embarcadero/Alexandria/11_3/fmx/FMX.Canvas.GPU.Helpers.pas
--- a/Embarcadero/Alexandria/11_3/fmx/FMX.Canvas.GPU.Helpers.pas	(revision 1)
+++ b/Embarcadero/Alexandria/11_3/fmx/FMX.Canvas.GPU.Helpers.pas	(working copy)
@@ -15,8 +15,8 @@
 {$SCOPEDENUMS ON}
 
 uses
-  System.Types, System.UITypes, FMX.Types, FMX.Types3D, FMX.Materials.Canvas, FMX.Graphics, 
-  System.Math.Vectors;
+  System.Types, System.UITypes, FMX.Types, FMX.Types3D, FMX.Materials.Canvas, FMX.Graphics,
+  System.Math.Vectors, Alcinoe.FMX.Types3D;
 
 type
   TDrawingMode = (Normal, WriteStencilInvert, ReadStencil, ClearStencil);
@@ -313,8 +313,10 @@
 
   if Material <> nil then
     M := Material
-  else if Texture <> nil then
-    M := FTexMat
+  else if Texture <> nil then begin
+    if (Texture is TalTexture) and (TalTexture(Texture).material <> nil) then M := TalTexture(Texture).material  // https://quality.embarcadero.com/browse/RSP-23501
+    else M := FTexMat
+  end
   else
     M := FSolidMat;
 
@@ -424,7 +426,8 @@
 var
   SolidDecl: TVertexDeclaration;
 begin
-  if FCurrentMaterial = FTexMat then
+  if (FCurrentMaterial = FTexMat) or
+     (FCurrentMaterial is TALCanvasTextureMaterial) then // https://quality.embarcadero.com/browse/RSP-23501
   begin
     SetLength(SolidDecl, 3);
     SolidDecl[0].Format := TVertexFormat.Vertex;
@@ -433,7 +436,8 @@
     SolidDecl[1].Offset := 12;
     SolidDecl[2].Format := TVertexFormat.Color0;
     SolidDecl[2].Offset := 20;
-    FTexMat.Texture := FCurrentTexture;
+    if (FCurrentMaterial = FTexMat) then FTexMat.Texture := FCurrentTexture
+    else TALCanvasTextureMaterial(FCurrentMaterial).Texture := FCurrentTexture; // https://quality.embarcadero.com/browse/RSP-23501
     FContext.DrawPrimitives(TPrimitivesKind.Triangles, @FBatchVertexBuffer[0], @FBatchIndexBuffer[0], SolidDecl,
       SizeOf(TVertexBufferItem), FBatchedVertices, SizeOf(TIndexBufferItem), FBatchedIndices, FCurrentMaterial, 1);
   end else if FCurrentMaterial <> FSolidMat then
Index: Embarcadero/Alexandria/11_3/fmx/FMX.Canvas.GPU.pas
===================================================================
diff --git a/Embarcadero/Alexandria/11_3/fmx/FMX.Canvas.GPU.pas b/Embarcadero/Alexandria/11_3/fmx/FMX.Canvas.GPU.pas
--- a/Embarcadero/Alexandria/11_3/fmx/FMX.Canvas.GPU.pas	(revision 1)
+++ b/Embarcadero/Alexandria/11_3/fmx/FMX.Canvas.GPU.pas	(working copy)
@@ -72,6 +72,8 @@
 procedure RegisterCanvasClasses;
 procedure UnregisterCanvasClasses;
 
+function CanvasHelper: TCanvasHelper; // << https://quality.embarcadero.com/browse/RSP-18797
+
 implementation
 
 uses
@@ -1212,6 +1214,12 @@
   TCanvasGpu.FreeResources;
 end;
 
+//https://quality.embarcadero.com/browse/RSP-18797
+function CanvasHelper: TCanvasHelper;
+begin
+  result := TCanvasGpu.FCanvasHelper;
+end;
+
 initialization
   TCustomCanvasGpu.ModulateColor := $FFFFFFFF;
   TCustomCanvasGpu.AlignToPixels := False;
Index: Embarcadero/Alexandria/11_3/fmx/FMX.Context.GLES.pas
===================================================================
diff --git a/Embarcadero/Alexandria/11_3/fmx/FMX.Context.GLES.pas b/Embarcadero/Alexandria/11_3/fmx/FMX.Context.GLES.pas
--- a/Embarcadero/Alexandria/11_3/fmx/FMX.Context.GLES.pas	(revision 1)
+++ b/Embarcadero/Alexandria/11_3/fmx/FMX.Context.GLES.pas	(working copy)
@@ -188,7 +188,7 @@
 {$IFDEF MACOS}
   Macapi.CoreFoundation,
 {$ENDIF}
-  FMX.Consts, FMX.Canvas.GPU, FMX.Materials, FMX.Utils;
+  FMX.Consts, FMX.Canvas.GPU, FMX.Materials, FMX.Utils, Alcinoe.FMX.Types3D;
 
 class procedure TGlesDiagnostic.CollectErrors;
 const
@@ -1312,8 +1312,15 @@
 
         if Texture = nil then
           glBindTexture(GL_TEXTURE_2D, 0)
-        else
+        else begin
+          {$IF defined(ANDROID)}
+          // https://quality.embarcadero.com/browse/RSP-16830
+          if (Texture is TalTexture) and (TalTexture(Texture).material is TALCanvasExternalOESTextureMaterial) then
+            glBindTexture(GL_TEXTURE_EXTERNAL_OES, Texture.Handle)
+          else
+          {$ENDIF}
           glBindTexture(GL_TEXTURE_2D, Texture.Handle);
+        end;
 
         glUniform1i(Variable.Index, Variable.TextureUnit);
         glActiveTexture(GL_TEXTURE0);
Index: Embarcadero/Alexandria/11_3/fmx/FMX.Controls.pas
===================================================================
diff --git a/Embarcadero/Alexandria/11_3/fmx/FMX.Controls.pas b/Embarcadero/Alexandria/11_3/fmx/FMX.Controls.pas
--- a/Embarcadero/Alexandria/11_3/fmx/FMX.Controls.pas	(revision 1)
+++ b/Embarcadero/Alexandria/11_3/fmx/FMX.Controls.pas	(working copy)
@@ -115,7 +115,7 @@
     /// <summary>Register a class to create hint instances. When a new THint instance is needed, the registered classes are invoked
     /// to create the needed instance.</summary>
     class procedure RegisterClass(const AClass: THintClass);
-    /// <summary>Returns an instance created by the first available registered class. This method can return nil if there are no classes 
+    /// <summary>Returns an instance created by the first available registered class. This method can return nil if there are no classes
     /// registered or none of the registered classes can create a THint instance.</summary>
     class function CreateNewInstance(const AHandle: TWindowHandle): THint;
     /// <summary>Returns True if there are some THint class registered.</summary>
@@ -515,6 +515,11 @@
     procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Single); virtual;
     procedure MouseWheel(Shift: TShiftState; WheelDelta: Integer; var Handled: Boolean); virtual;
     procedure MouseClick(Button: TMouseButton; Shift: TShiftState; X, Y: Single); virtual;
+    procedure ChildrenMouseDown(const AObject: TControl; Button: TMouseButton; Shift: TShiftState; X, Y: Single); virtual; // https://quality.embarcadero.com/browse/RSP-24397
+    procedure ChildrenMouseMove(const AObject: TControl; Shift: TShiftState; X, Y: Single); virtual; // https://quality.embarcadero.com/browse/RSP-24397
+    procedure ChildrenMouseUp(const AObject: TControl; Button: TMouseButton; Shift: TShiftState; X, Y: Single); virtual; // https://quality.embarcadero.com/browse/RSP-24397
+    procedure ChildrenMouseEnter(const AObject: TControl); virtual; // https://quality.embarcadero.com/browse/RSP-24397
+    procedure ChildrenMouseLeave(const AObject: TControl); virtual; // https://quality.embarcadero.com/browse/RSP-24397
     procedure KeyDown(var Key: Word; var KeyChar: WideChar; Shift: TShiftState); virtual;
     procedure KeyUp(var Key: Word; var KeyChar: WideChar; Shift: TShiftState); virtual;
     procedure DialogKey(var Key: Word; Shift: TShiftState); virtual;
@@ -2220,6 +2225,7 @@
   TabStop: IControl;
   ChildControl: TControl;
   NeedRepaint: Boolean;
+  i: integer; // https://quality.embarcadero.com/browse/RSP-21013
 begin
   DisableDisappear := True;
   try
@@ -2226,7 +2232,10 @@
     if AObject is TControl then
     begin
       ChildControl := TControl(AObject);
-      ChildControl.FUpdating := FUpdating;
+      //https://quality.embarcadero.com/browse/RSP-21013
+      //ChildControl.FUpdating := FUpdating;
+      for I := 1 to FUpdating do
+        ChildControl.beginUpdate;
     end
     else
       ChildControl := nil;
@@ -2266,7 +2275,8 @@
         ChildControl.TempCanvas := TempCanvas;
       if FInPaintTo then
         ChildControl.FInPaintTo := True;
-      ChildControl.FUpdating := FUpdating;
+      //https://quality.embarcadero.com/browse/RSP-21013
+      //ChildControl.FUpdating := FUpdating;
       if not FSimpleTransform then
         ChildControl.FSimpleTransform := False;
       ChildControl.RecalcEnabled;
@@ -2296,8 +2306,20 @@
   var
     I: Integer;
   begin
-    for I := 1 to AControl.FUpdating do
-      AControl.EndUpdate;
+    // https://quality.embarcadero.com/browse/RSP-21013
+    // Also no need to call EndUpdate when we are destroying
+    // AControl because at this level most of the members
+    // of Acontrol have been freed and if we call EndUpdate
+    // with this transient state it's can cause trouble if
+    // AControl have a custom overloaded EndUpdate. Also
+    // in any case endupdate will not be call for any of
+    // the childreen of AControl as the property FControls
+    // of Acontrol used in EndUpdate to enumerate all childreen
+    // of Acontrol is already freed.
+    if (not (csDestroying in ComponentState)) and
+       (not (csDestroying in AControl.ComponentState)) then
+      for I := 1 to FUpdating do
+        AControl.EndUpdate;
   end;
 
 var
@@ -3676,7 +3698,7 @@
   Result := Touch.InteractiveGestures;
   if Result = [] then
     if (Parent <> nil) and Supports(Parent, IGestureControl, LGObj) then
-      Result := LGObj.GetListOfInteractiveGestures;                 
+      Result := LGObj.GetListOfInteractiveGestures;
 end;
 
 function TControl.GetLocked: Boolean;
@@ -4122,6 +4144,7 @@
   ApplyTriggerEffect(Self, 'IsMouseOver');
   if Assigned(FOnMouseEnter) then
     FOnMouseEnter(Self);
+  if fparentControl <> nil then fparentControl.ChildrenMouseEnter(Self); // https://quality.embarcadero.com/browse/RSP-24397
 end;
 
 procedure TControl.DoMouseLeave;
@@ -4131,6 +4154,7 @@
   ApplyTriggerEffect(Self, 'IsMouseOver');
   if Assigned(FOnMouseLeave) then
     FOnMouseLeave(Self);
+  if fparentControl <> nil then fparentControl.ChildrenMouseLeave(Self); // https://quality.embarcadero.com/browse/RSP-24397
 end;
 
 function TControl.GetCanFocus: Boolean;
@@ -4422,7 +4446,7 @@
     end;
 
   if not Handled and (FParent <> nil) and (EventInfo.GestureID <> sgiNoGesture) and Supports(Parent, IGestureControl, LGObj) then
-    LGObj.CMGesture(EventInfo);                  
+    LGObj.CMGesture(EventInfo);
 end;
 
 function TControl.ConvertLocalPointFrom(const AControl: TControl; const AControlLocalPoint: TPointF): TPointF;
@@ -4547,6 +4571,7 @@
 
   if Assigned(FOnMouseDown) then
     FOnMouseDown(Self, Button, Shift, X, Y);
+  if fparentControl <> nil then fparentControl.ChildrenMouseDown(Self, Button, Shift, X, Y); // https://quality.embarcadero.com/browse/RSP-24397
   if FAutoCapture then
     Capture;
   if Button = TMouseButton.mbLeft then
@@ -4569,6 +4594,7 @@
 begin
   if Assigned(FOnMouseMove) then
     FOnMouseMove(Self, Shift, X, Y);
+  if fparentControl <> nil then fparentControl.ChildrenMouseMove(Self, Shift, X, Y); // https://quality.embarcadero.com/browse/RSP-24397
 end;
 
 procedure TControl.MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Single);
@@ -4577,6 +4603,7 @@
 
   if Assigned(FOnMouseUp) then
     FOnMouseUp(Self, Button, Shift, X, Y);
+  if fparentControl <> nil then fparentControl.ChildrenMouseUp(Self, Button, Shift, X, Y); // https://quality.embarcadero.com/browse/RSP-24397
   if FPressed then
   begin
     FPressed := False;
@@ -4591,6 +4618,41 @@
     FOnMouseWheel(Self, Shift, WheelDelta, Handled)
 end;
 
+// https://quality.embarcadero.com/browse/RSP-24397
+procedure TControl.ChildrenMouseDown(const AObject: TControl; Button: TMouseButton; Shift: TShiftState; X, Y: Single);
+begin
+  if fParentControl <> nil then
+    fParentControl.ChildrenMouseDown(AObject, Button, Shift, X, Y);
+end;
+
+// https://quality.embarcadero.com/browse/RSP-24397
+procedure TControl.ChildrenMouseMove(const AObject: TControl; Shift: TShiftState; X, Y: Single);
+begin
+  if fParentControl <> nil then
+    fParentControl.ChildrenMouseMove(AObject, Shift, X, Y);
+end;
+
+// https://quality.embarcadero.com/browse/RSP-24397
+procedure TControl.ChildrenMouseUp(const AObject: TControl; Button: TMouseButton; Shift: TShiftState; X, Y: Single);
+begin
+  if fParentControl <> nil then
+    fParentControl.ChildrenMouseUp(AObject, Button, Shift, X, Y);
+end;
+
+// https://quality.embarcadero.com/browse/RSP-24397
+procedure TControl.ChildrenMouseEnter(const AObject: TControl);
+begin
+  if fParentControl <> nil then
+    fParentControl.ChildrenMouseEnter(AObject);
+end;
+
+// https://quality.embarcadero.com/browse/RSP-24397
+procedure TControl.ChildrenMouseLeave(const AObject: TControl);
+begin
+  if fParentControl <> nil then
+    fParentControl.ChildrenMouseLeave(AObject);
+end;
+
 procedure TControl.DragEnter(const Data: TDragObject; const Point: TPointF);
 var
   Operation: TDragOperation;
@@ -6013,7 +6075,7 @@
   KillResourceLink;
   if csLoading in ComponentState then
     Exit;
-  Repaint;                             
+  Repaint;
 end;
 
 procedure TStyledControl.AdjustSize;
@@ -7171,7 +7233,7 @@
 var
   LFontColor: TAlphaColor;
 begin
-                                                                                          
+
 {$IFDEF LONGINT64}
   IdentToAlphaColor(Reader.ReadIdent, Integer(LFontColor));
 {$ELSE !LONGINT64}
Index: Embarcadero/Alexandria/11_3/fmx/FMX.Filter.pas
===================================================================
diff --git a/Embarcadero/Alexandria/11_3/fmx/FMX.Filter.pas b/Embarcadero/Alexandria/11_3/fmx/FMX.Filter.pas
--- a/Embarcadero/Alexandria/11_3/fmx/FMX.Filter.pas	(revision 1)
+++ b/Embarcadero/Alexandria/11_3/fmx/FMX.Filter.pas	(working copy)
@@ -607,7 +607,7 @@
     begin
       if CompareText(FValues[I].Name, 'Output') = 0 then
       begin
-        if not FProcessing and FModified then 
+        if not FProcessing and FModified then
           Apply;
         Result := TFilterManager.GetTexture(FPass);
         FValues[I].Value := Result;
@@ -838,17 +838,19 @@
 
 function TFilter.InputTexture: TTexture;
 begin
-  if TCanvasStyle.NeedGPUSurface in TCanvasManager.DefaultCanvas.GetCanvasStyle then
-    Result := TContextManager.DefaultContextClass.BitmapToTexture(FInputBitmap)
-  else
+  //https://quality.embarcadero.com/browse/RSP-20825
+  //if TCanvasStyle.NeedGPUSurface in TCanvasManager.DefaultCanvas.GetCanvasStyle then
+  //  Result := TContextManager.DefaultContextClass.BitmapToTexture(FInputBitmap)
+  //else
     Result := FInput;
 end;
 
 function TFilter.TargetTexture: TTexture;
 begin
-  if TCanvasStyle.NeedGPUSurface in TCanvasManager.DefaultCanvas.GetCanvasStyle then
-    Result := TContextManager.DefaultContextClass.BitmapToTexture(FTargetBitmap)
-  else
+  //https://quality.embarcadero.com/browse/RSP-20825
+  //if TCanvasStyle.NeedGPUSurface in TCanvasManager.DefaultCanvas.GetCanvasStyle then
+  //  Result := TContextManager.DefaultContextClass.BitmapToTexture(FTargetBitmap)
+  //else
     Result := FTarget;
 end;
 
Index: Embarcadero/Alexandria/11_3/fmx/FMX.Forms.pas
===================================================================
diff --git a/Embarcadero/Alexandria/11_3/fmx/FMX.Forms.pas b/Embarcadero/Alexandria/11_3/fmx/FMX.Forms.pas
--- a/Embarcadero/Alexandria/11_3/fmx/FMX.Forms.pas	(revision 1)
+++ b/Embarcadero/Alexandria/11_3/fmx/FMX.Forms.pas	(working copy)
@@ -4374,7 +4374,10 @@
 
 procedure TCommonCustomForm.SetHovered(const Value: IControl);
 begin
-  if (Value <> FHovered) then
+  //https://quality.embarcadero.com/browse/RSP-36612
+  if ((Value <> nil) and (FHovered = nil)) or
+     ((Value = nil) and (FHovered <> nil)) or
+     ((Value <> nil) and (FHovered <> nil) and (Value.GetObject <> FHovered.GetObject)) then
   begin
     if FHovered <> nil then
     begin
@@ -4851,7 +4854,10 @@
     LControl := AControl
   else
     LControl := nil;
-  if LControl <> FLastHinted then
+  //https://quality.embarcadero.com/browse/RSP-36612
+  if ((LControl <> nil) and (FLastHinted = nil)) or
+     ((LControl = nil) and (FLastHinted <> nil)) or
+     ((LControl <> nil) and (FLastHinted <> nil) and (LControl.GetObject <> FLastHinted.GetObject)) then
   begin
     if Application.ShowHint and (LControl <> nil) then
     begin
@@ -5628,7 +5634,10 @@
 
 procedure TCommonCustomForm.SetCaptured(const Value: IControl);
 begin
-  if FCaptured <> Value then
+  //https://quality.embarcadero.com/browse/RSP-36612
+  if ((Value <> nil) and (FCaptured = nil)) or
+     ((Value = nil) and (FCaptured <> nil)) or
+     ((Value <> nil) and (FCaptured <> nil) and (Value.GetObject <> FCaptured.GetObject)) then
   begin
     if FCaptured <> nil then
     begin
@@ -5922,7 +5931,10 @@
 
 procedure TCommonCustomForm.SetActiveControl(const AControl: IControl);
 begin
-  if AControl <> FActiveControl then
+  //https://quality.embarcadero.com/browse/RSP-36612
+  if ((AControl <> nil) and (FActiveControl = nil)) or
+     ((AControl = nil) and (FActiveControl <> nil)) or
+     ((AControl <> nil) and (FActiveControl <> nil) and (AControl.GetObject <> FActiveControl.GetObject)) then
   begin
     if FActiveControl <> nil then
       FActiveControl.RemoveFreeNotify(Self);
Index: Embarcadero/Alexandria/11_3/fmx/FMX.Platform.iOS.pas
===================================================================
diff --git a/Embarcadero/Alexandria/11_3/fmx/FMX.Platform.iOS.pas b/Embarcadero/Alexandria/11_3/fmx/FMX.Platform.iOS.pas
--- a/Embarcadero/Alexandria/11_3/fmx/FMX.Platform.iOS.pas	(revision 1)
+++ b/Embarcadero/Alexandria/11_3/fmx/FMX.Platform.iOS.pas	(working copy)
@@ -1,4 +1,4 @@
-{*******************************************************}
+ï»¿{*******************************************************}
 {                                                       }
 {              Delphi FireMonkey Platform               }
 {                                                       }
@@ -1526,7 +1526,13 @@
     WindowManager.NativeWindow.makeKeyAndVisible;
 
     // Post initialization
-    PlatformCocoaTouch.HandleApplicationEvent(TApplicationEvent.FinishedLaunching, nil);
+    // https://quality.embarcadero.com/browse/RSP-40351
+    Var LContext := TiOSOpenApplicationContext.Create(string.Empty, string.Empty, options);
+    Try
+      PlatformCocoaTouch.HandleApplicationEvent(TApplicationEvent.FinishedLaunching, LContext);
+    finally
+      LContext.Free;
+    End;
     FMX.Forms.Application.RealCreateForms;
     TiOSHelper.CurrentDevice.beginGeneratingDeviceOrientationNotifications;
   finally
Index: Embarcadero/Alexandria/11_3/fmx/FMX.Platform.Screen.Android.pas
===================================================================
diff --git a/Embarcadero/Alexandria/11_3/fmx/FMX.Platform.Screen.Android.pas b/Embarcadero/Alexandria/11_3/fmx/FMX.Platform.Screen.Android.pas
--- a/Embarcadero/Alexandria/11_3/fmx/FMX.Platform.Screen.Android.pas	(revision 1)
+++ b/Embarcadero/Alexandria/11_3/fmx/FMX.Platform.Screen.Android.pas	(working copy)
@@ -258,9 +258,11 @@
   function ScaleRect(const ARect: TRect; const AScale: Single): TRect;
   begin
     Result.Left := Trunc(ARect.Left / AScale);
-    Result.Right := Trunc(ARect.Right / AScale);
+    //https://quality.embarcadero.com/browse/RSP-41516
+    Result.Right := ceil(ARect.Right / AScale);
     Result.Top := Trunc(ARect.Top / AScale);
-    Result.Bottom := Trunc(ARect.Bottom / AScale);
+    //https://quality.embarcadero.com/browse/RSP-41516
+    Result.Bottom := ceil(ARect.Bottom / AScale);
   end;
 
   function CalculatePhysicalWorkarea(const ANativeDisplay: JDisplay; const APhysicalBounds: TRect): TRect;
Index: Embarcadero/Alexandria/11_3/fmx/FMX.Platform.UI.Android.pas
===================================================================
diff --git a/Embarcadero/Alexandria/11_3/fmx/FMX.Platform.UI.Android.pas b/Embarcadero/Alexandria/11_3/fmx/FMX.Platform.UI.Android.pas
--- a/Embarcadero/Alexandria/11_3/fmx/FMX.Platform.UI.Android.pas	(revision 1)
+++ b/Embarcadero/Alexandria/11_3/fmx/FMX.Platform.UI.Android.pas	(working copy)
@@ -26,7 +26,7 @@
   TAndroidMotionManager = class;
   TTextServiceAndroid = class;
 
-  TRender<T: class> = class(TJavaLocal, JRunnable)
+  TRender<T: class> = class(TJavaLocal, JChoreographer_FrameCallback) // https://quality.embarcadero.com/browse/RSP-38660
   private
     [Weak] FContext: T;
     FIsNeededUpdate: Boolean;
@@ -41,14 +41,14 @@
     /// <summary>Posts event to event bus for future rendering.</summary>
     procedure PostRender;
 
-    { JRunnable }
-    procedure run; cdecl;
+    { JChoreographer_FrameCallback } // https://quality.embarcadero.com/browse/RSP-38660
+    procedure doFrame(frameTimeNanos: Int64); cdecl; // https://quality.embarcadero.com/browse/RSP-38660
   public
     property Context: T read FContext;
   end;
 
   /// <summary>Render of form. It is responsible for drawing FireMonkey form on native Surface.</summary>
-  TFormRender = class(TRender<TAndroidWindowHandle>, JRunnable)
+  TFormRender = class(TRender<TAndroidWindowHandle>, JChoreographer_FrameCallback) // https://quality.embarcadero.com/browse/RSP-38660
   public
     /// <summary>Renders form Immediately.</summary>
     procedure Render; override;
@@ -1159,7 +1159,8 @@
   FOwner.FFormBounds.Width := w / PlatformAndroid.WindowService.Scale;
   FOwner.FFormBounds.Height:= h / PlatformAndroid.WindowService.Scale;
 
-  FormBounds := FOwner.Bounds.Truncate;
+  //https://quality.embarcadero.com/browse/RSP-41516
+  FormBounds := FOwner.Bounds.Ceiling;
   FOwner.Form.SetBoundsF(FormBounds.Left, FormBounds.Top, FormBounds.Width, FormBounds.Height);
 end;
 
@@ -1332,7 +1333,8 @@
   else
   begin
     if FWasFormRealignedFirstTime then
-      FFormBounds := TRectF.Create(0, 0, FormLayout.getWidth / Scale, FormLayout.getHeight / Scale)
+      //https://quality.embarcadero.com/browse/RSP-41516
+      FFormBounds := TRectF.Create(0, 0, Ceil(FormLayout.getWidth / Scale), Ceil(FormLayout.getHeight / Scale))
     else
       FFormBounds := TRectF.Create(0, 0, Screen.Width, Screen.Height - TAndroidFormScreenLocationCache.Instance.GetContentViewYOffset);
     LayoutParams.leftMargin := 0;
@@ -2776,7 +2778,7 @@
 begin
   TMessageManager.DefaultManager.Unsubscribe(TApplicationEventMessage, ApplicationEventHandler);
   AtomicIncrement(FRefCount);
-  TAndroidHelper.MainHandler.removeCallbacks(Self);
+  TJChoreographer.JavaClass.getInstance.removeFrameCallback(Self); // https://quality.embarcadero.com/browse/RSP-38660
   AtomicDecrement(FRefCount);
   inherited;
 end;
@@ -2786,7 +2788,7 @@
   if not FIsNeededUpdate then
   begin
     FIsNeededUpdate := True;
-    TAndroidHelper.MainHandler.post(Self);
+    TJChoreographer.JavaClass.getInstance.postFrameCallback(Self); // https://quality.embarcadero.com/browse/RSP-38660
   end;
 end;
 
@@ -2794,7 +2796,7 @@
 begin
 end;
 
-procedure TRender<T>.run;
+procedure TRender<T>.doFrame(frameTimeNanos: Int64); // https://quality.embarcadero.com/browse/RSP-38660
 begin
   Render;
   FIsNeededUpdate := False;
Index: Embarcadero/Alexandria/11_3/fmx/FMX.Presentation.Android.Style.pas
===================================================================
diff --git a/Embarcadero/Alexandria/11_3/fmx/FMX.Presentation.Android.Style.pas b/Embarcadero/Alexandria/11_3/fmx/FMX.Presentation.Android.Style.pas
--- a/Embarcadero/Alexandria/11_3/fmx/FMX.Presentation.Android.Style.pas	(revision 1)
+++ b/Embarcadero/Alexandria/11_3/fmx/FMX.Presentation.Android.Style.pas	(working copy)
@@ -71,7 +71,7 @@
   end;
 
   /// <summary>Render of native view.</summary>
-  TAndroidPresentationRender = class(TRender<TAndroidNativeScene>, JRunnable)
+  TAndroidPresentationRender = class(TRender<TAndroidNativeScene>, JChoreographer_FrameCallback)
   public
     procedure Render; override;
   end;
Index: Embarcadero/Alexandria/11_3/fmx/FMX.StrokeBuilder.pas
===================================================================
diff --git a/Embarcadero/Alexandria/11_3/fmx/FMX.StrokeBuilder.pas b/Embarcadero/Alexandria/11_3/fmx/FMX.StrokeBuilder.pas
--- a/Embarcadero/Alexandria/11_3/fmx/FMX.StrokeBuilder.pas	(revision 1)
+++ b/Embarcadero/Alexandria/11_3/fmx/FMX.StrokeBuilder.pas	(working copy)
@@ -88,8 +88,10 @@
 
 implementation
 
+//https://quality.embarcadero.com/browse/RSP-41618
+
 uses
-  System.UIConsts, System.Generics.Collections, FMX.Types, System.SysUtils;
+  System.UIConsts, System.Generics.Collections;
 
 function PointFDot(const P1, P2: TPointF): Single;
 begin
@@ -96,142 +98,6 @@
   Result := (P1.X * P2.X) + (P1.Y * P2.Y);
 end;
 
-type
-  TVertex = record
-    P: TPointF;
-    I: Integer;
-    class operator Implicit(const APoint: TPointF): TVertex;
-  end;
-
-  TEndCaps = (Start, Stop);
-  TEndCap = set of TEndCaps;
-
-  TStrokeBuilderHelper = class helper for TStrokeBuilder
-    procedure StartSegment(const P1, P2: TPointF; var A, B: TVertex);
-    procedure EdgePoints(const P, Direction: TPointF; var A, B: TVertex);
-    function AddVertex(var V: TVertex): Integer;
-    procedure Triangle(var A, B, C: TVertex);
-    procedure Quad(var A, B, C, D: TVertex);
-    procedure Arc(const O: TPointF; var A, B, C: TVertex; Clockwise: Boolean);
-  end;
-
-class operator TVertex.Implicit(const APoint: TPointF): TVertex;
-begin
-  Result.I := -1;
-  Result.P := APoint;
-end;
-
-procedure Intersect(const A: TVertex; var B: TVertex; const C, D: TVertex);
-var
-  D1, D2: TPointF;
-  Denom, Numer: Single;
-begin
-  D1 := B.P - A.P;
-  D2 := D.P - C.P;
-  Denom := D1.CrossProduct(D2);
-  if Abs(Denom) < Epsilon then
-    Exit;
-  Numer := D2.CrossProduct(A.P - C.P) / Denom;
-  B.I := -1;
-  B.P := A.P + Numer * D1;
-end;
-
-procedure TStrokeBuilderHelper.StartSegment(const P1, P2: TPointF; var A, B: TVertex);
-var
-  D1: TPointF;
-begin
-  D1 := (P2 - P1).Normalize;
-  EdgePoints(P1, D1, A, B);
-end;
-
-procedure TStrokeBuilderHelper.EdgePoints(const P, Direction: TPointF; var A, B: TVertex);
-begin
-  A.I := -1;
-  A.P.X := P.X + FHalfThickness * direction.Y;
-  A.P.Y := P.Y - FHalfThickness * direction.X;
-  B.I := -1;
-  B.P.X := P.X - FHalfThickness * direction.Y;
-  B.P.Y := P.Y + FHalfThickness * direction.X;
-end;
-
-function TStrokeBuilderHelper.AddVertex(var V: TVertex): Integer;
-begin
-  if V.I < 0 then
-  begin
-    V.I := FCurrentVertex;
-    InsertVertex(V.P, FStrokeColor);
-  end;
-  Result := V.I;
-end;
-
-procedure TStrokeBuilderHelper.Triangle(var A, B, C: TVertex);
-begin
-  AddVertex(A);
-  AddVertex(B);
-  AddVertex(C);
-  InsertIndex(A.I);
-  InsertIndex(B.I);
-  InsertIndex(C.I);
-end;
-
-procedure TStrokeBuilderHelper.Quad(var A, B, C, D: TVertex);
-begin
-  AddVertex(A);
-  AddVertex(B);
-  AddVertex(D);
-  AddVertex(C);
-  InsertIndex(B.I);
-  InsertIndex(C.I);
-  InsertIndex(D.I);
-  InsertIndex(D.I);
-  InsertIndex(A.I);
-  InsertIndex(B.I);
-end;
-
-procedure TStrokeBuilderHelper.Arc(const O: TPointF; var A, B, C: TVertex; Clockwise: Boolean);
-var
-  P1, P2: TPointF;
-  A1, A2: Single;
-  n: Integer;
-  P, Z, V: TVertex;
-  Angle, R: Single;
-  SN, CS: Single;
-begin
-  P1 := B.P - O;
-  P2 := C.P - O;
-  A1 := ArcTan2(P1.Y, P1.X);
-  A2 := ArcTan2(P2.Y, P2.X);
-  if Clockwise then
-  begin
-    if A2 > A1 then
-      A2 := A2 - 2 * PI;
-  end
-  else
-  begin
-    if A1 > A2 then
-      A1 := A1 - 2 * PI;
-  end;
-  angle := A2 - A1;
-
-  n := Round(Abs(angle) / (10 * PI / 180));
-  if n < 1 then
-    n := 1;
-  P := B;
-  Z := A;
-  for var i := 0 to n - 2 do
-  begin
-    R := (i + 1) *  angle / n;
-    SinCos(R, SN, CS);
-    V.I := -1;
-    V.P.X := O.X + CS * P1.X - SN * P1.Y;
-    V.P.Y := O.Y + SN * P1.X + CS * P1.Y;
-    Triangle(Z, P, V);
-    P := V;
-  end;
-  V := C;
-  Triangle(Z, P, V);
-end;
-
 {$REGION 'Stroke Builder implementation'}
 
 function TStrokeBuilder.GetMatrixScale: TPointF;
@@ -1056,458 +922,145 @@
 end;
 
 procedure TStrokeBuilder.BuildIntermPolygon(const Points: TPolygon; const Opacity: Single; BreakAtEnd: Boolean);
-const
-  COS_170_DEGREE = -0.98;
 var
-  CurScale: TPointF;
-  CurIndex: Integer;
-  FirstPoint: Integer;
+  StepSize, Distance: Single;
+  CurScale, SrcPos, DestPos, PieceDirVec, ThickPerp: TPointF;
+  SrcPosValid, DestPosValid: Boolean;
+  PatternStepCount, CurIndex, TempVertexCount, TempIndexCount: Integer;
+begin
+  if Length(Points) < 2 then
+  begin
+    InitArrays(0, 0);
+    Exit;
+  end;
 
-  procedure PolyLine(Start, Count: Integer);
-  var
-    Closed: Boolean;
-    Loop: Boolean;
-    SaveThickness: Single;
-    SaveColor: TAlphaColor;
-    First, I: Integer;
-    P1, P2, P3: TPointF;
-    D1: TPointF;
-    L1: Single;
-    A, B, C, D, E, F: TVertex;
+  CurScale := GetMatrixScale;
 
-    Dashes: array of Single;
-    iDash : Integer;
-    DashLen: Single;
+  FThickness := FBrush.Thickness * (CurScale.X + CurScale.Y) * 0.5;
+  FHalfThickness := FThickness * 0.5;
+  FStrokeColor := PremultiplyAlpha(MakeColor(FBrush.Color, Opacity));
 
-    EndCap: TEndCap;
+  FUndeterminedMode := True;
+  InitArrayPointers;
 
-    procedure NextDash;
-    begin
-      iDash := (iDash + 1) mod Length(Dashes);
-      DashLen := Dashes[iDash];
-    end;
+  PatternStepCount := GetPatternStepCount;
+  if PatternStepCount < 1 then
+  begin
+    InitArrays(0, 0);
+    Exit;
+  end;
 
-    procedure EndSegment(var A, B: TVertex; P1, P2: TPointF);
-    var
-      C, D, O: TVertex;
-      D1: TPointF;
-      L1: Single;
-    begin
-      D1 := (P2 - P1).Normalize;
-      L1 := (P2 - P1).Length;
+  StepSize := FThickness * PatternStepCount;
 
-      while L1 > DashLen do
-      begin
-        O.P := P1;
-        P1 := P1 + D1 * DashLen;
-        L1 := L1 - DashLen;
-        EdgePoints(P1, D1, C, D);
-        if not Odd(iDash) then
-        begin
-          if Brush.Cap = TStrokeCap.Round then
-          begin
-            if TEndCaps.Start in EndCap then
-            begin
-              O.P := O.P + D1 * FHalfThickness;
-              EdgePoints(O.P, D1, A, B);
-              O.I := -1;
-              Arc(O.P, O, B, A, False);
-            end;
-            O.P := P1 - D1 * FHalfThickness;
-            EdgePoints(O.P, D1, E, F);
-            Quad(A, B, F, E);
-            O.I := -1;
-            Arc(O.P, O, E, F, False);
-          end
-          else
-            Quad(A, B, D, C);
-        end;
-        A := C;
-        B := D;
-        NextDash;
-        EndCap := [TEndCaps.Start, TEndCaps.Stop];
-      end;
+  CurIndex := 0;
 
-      if Odd(iDash) or (L1 < FThickness) then
-        Exit;
+  SrcPosValid := False;
+  DestPosValid := False;
 
-      if Brush.Cap = TStrokeCap.Round then
-      begin
-        if TEndCaps.Start in EndCap then
-        begin
-          P1 := P1 + D1 * FHalfThickness;
-          EdgePoints(P1, D1, A, B);
-          O := P1;
-          Arc(P1, O, B, A, False);
-        end;
-        P2 := P2 - D1 * FHalfThickness;
-      end;
-      EdgePoints(P2, D1, C, D);
-      Quad(A, B, D, C);
-      if Brush.Cap = TStrokeCap.Round then
-      begin
-        O := P2;
-        Arc(P2, O, C, D, False);
-      end;
-    end;
+  while CurIndex < Length(Points) do
+  begin
+    if (CurIndex >= Length(Points) - 1) and BreakAtEnd then
+      Break;
 
-    procedure DrawJoin(var A, B: TVertex; var P1, P2: TPointF; const P3: TPointF; Visible: Boolean = True);
-    const
-      COS_170_DEGREE = -0.98;
-    var
-      D1, D2: TPointF;
-      L1: Single;
-      C, D: TVertex;                 //    A........C E..........G
-      E, F: TVertex;                 //  P1:        :P2          :P3
-      G, H: TVertex;                 //    B........D F..........H
-      O: TVertex;
-      Style: TStrokeJoin;
-      CosAngle: Single;
-      Clockwise: Boolean;
+    if not SrcPosValid then
+    begin
+      SrcPos := Points[CurIndex];
 
-      procedure Capsule;
+      if (SrcPos.X >= $FFFF) or (SrcPos.Y >= $FFFF) then
       begin
-        if Brush.Cap = TStrokeCap.Round then
-        begin
-          if TEndCaps.Start in EndCap then
-          begin
-            P1 := P1 + D1 * FHalfThickness;
-            EdgePoints(P1, D1, A, B);
-            O := P1;
-            Arc(P1, O, B, A, False);
-          end;
-          if (L1 > FHalfThickness) or not (TEndCaps.Start in EndCap) then
-            Quad(A, B, D, C)
-          else
-          begin
-            C := A;
-            D := B;
-          end;
-        end else
-          Quad(A, B, D, C);
+        DestPosValid := False;
+        Inc(CurIndex);
+        Continue;
       end;
 
+      SrcPos := SrcPos * FMatrix;
+    end
+    else
+      SrcPosValid := False;
+
+    if not DestPosValid then
     begin
-      D1 := (P2 - P1).Normalize;
-      L1 := (P2 - P1).Length;
-      D2 := (P3 - P2).Normalize;
+      DestPos := Points[(CurIndex + 1) mod Length(Points)];
 
-      Style := Brush.Join;
-      CosAngle := D1.AngleCosine(D2);
-      if (Style = TStrokeJoin.Miter) and (CosAngle < COS_170_DEGREE) then
-        Style := TStrokeJoin.Bevel;
-
-      while L1 > DashLen do
+      if (DestPos.X >= $FFFF) or (DestPos.Y >= $FFFF) then
       begin
-        O.P := P1;
-        P1 := P1 + D1 * DashLen;
-        L1 := L1 - DashLen;
-        EdgePoints(P1, D1, C, D);
-        if Visible and not Odd(iDash) then
+        DestPos := Points[CurIndex];
+        if (DestPos.X >= $FFFF) or (DestPos.Y >= $FFFF) then
         begin
-          if Brush.Cap = TStrokeCap.Round then
-          begin
-            if TEndCaps.Start in EndCap then
-            begin
-              O.P := O.P + D1 * FHalfThickness;
-              EdgePoints(O.P, D1, A, B);
-              O.I := -1;
-              Arc(O.P, O, B, A, False);
-            end;
-            O.P := P1 - D1 * FHalfThickness;
-            EdgePoints(O.P, D1, E, F);
-            Quad(A, B, F, E);
-            O.I := -1;
-            Arc(O.P, O, E, F, False);
-          end else
-            Quad(A, B, D, C);
+          Inc(CurIndex);
+          Continue;
         end;
-        A := C;
-        B := D;
-        NextDash;
-        EndCap := [TEndCaps.Start, TEndCaps.Stop];
-      end;
-      DashLen := DashLen - L1;
-      if Odd(iDash) then
-        Visible := False;
 
-      if Visible then
-      begin
-        if (L1 < FHalfThickness) and (TEndCaps.Start in EndCap) then
-        begin
-          P1 := P2 - D2 * L1;
-          EdgePoints(P1, D2, A, B);
-          D1 := D2;
-          Style := TStrokeJoin.Miter;
-        end;
-        if (DashLen < FHalfThickness) and (TEndCaps.Start in EndCap) then
-        begin
-          if Brush.Cap = TStrokeCap.Round then
-          begin
-            if TEndCaps.Start in EndCap then
-            begin
-              P1 := P1 + D1 * FHalfThickness;
-              EdgePoints(P1, D1, A, B);
-              O := P1;
-              Arc(P1, O, B, A, False);
-            end;
-            P1 := P1 + D1 * (DashLen + L1 - FThickness);
-            EdgePoints(P1, D1, C, D);
-            Quad(A, B, D, C);
-            O := P1;
-            Arc(P1, O, C, D, False);
-          end
-          else
-          begin
-            P1 := P1 + D1 * (DashLen + L1);
-            EdgePoints(P1, D1, C, D);
-            Quad(A, B, D, C);
-          end;
-          P2 := P2 + D2 * DashLen;
-          NextDash;
-          Visible := False;
-        end;
-      end;
-
-      EdgePoints(P2, D1, C, D);
-      EdgePoints(P2, D2, E, F);
-      EdgePoints(P3, D2, G, H);
-
-      if Style = TStrokeJoin.Miter then
-      begin
-        Intersect(A, C, E, G);
-        Intersect(B, D, F, H);
-        if Visible then
-          Capsule;
-        A := C;
-        B := D;
+        DestPos := DestPos * FMatrix;
       end
       else
-      begin
-        if CosAngle >= COS_170_DEGREE then
-        begin
-          Clockwise := (D1.X * D2.Y - D2.X * D1.Y) < 0;
-          if Clockwise then
-          begin
-            Intersect(A, C, E, G);
-            if Visible then
-            begin
-              Capsule;
-              case Style of
-                TStrokeJoin.Bevel: Triangle(C, D, F);
-                TStrokeJoin.Round: Arc(P2, C, D, F, True);
-              end;
-            end;
-            D := F;
-          end
-          else
-          begin
-            Intersect(B, D, F, H);
-            if Visible then
-            begin
-              Capsule;
-              case Style of
-                TStrokeJoin.Bevel: Triangle(D, C, E);
-                TStrokeJoin.Round: Arc(P2, D, C, E, False);
-              end;
-            end;
-            C := E;
-          end;
-          A := C;
-          B := D;
-        end
-        else
-        begin
-          if Visible then
-            Quad(A, B, D, C);
-          A := D;
-          B := C;
-        end;
-      end;
-
-      P1 := P2;
-      P2 := P3;
-      if Visible then
-        EndCap := [TEndCaps.Stop]
-      else
-        EndCap := [TEndCaps.Start, TEndCaps.Stop];
-    end;
-
-  begin
-    if Count < 2 then
-      Exit;
-
-    Closed := Points[Start].EqualsTo(Points[Start + Count - 1]);
-    if Closed then
-    begin
-      Dec(Count);
-      if Count = 2 then
-        Exit;
+        DestPos := DestPos * FMatrix;
     end
     else
-      Closed := not BreakAtEnd;
+      DestPosValid := False;
 
-    case Brush.Dash of
-      TStrokeDash.Dash       : Dashes := [3 * FThickness, FThickness];
-      TStrokeDash.Dot        : Dashes := [FThickness, FThickness];
-      TStrokeDash.DashDot    : Dashes := [3 * FThickness, FThickness, FThickness, FThickness];
-      TStrokeDash.DashDotDot : Dashes := [3 * FThickness, FThickness, FThickness, FThickness, FThickness, FThickness];
-      TStrokeDash.Custom:
-      begin
-        SetLength(Dashes, Length(Brush.DashArray));
-        for I := 0 to Length(Dashes) - 1 do
-          if Odd(I) then
-            Dashes[I] := Brush.DashArray[I] * FThickness - FThickness
-          else
-            Dashes[I] := Brush.DashArray[I] * FThickness + FThickness
-      end;
-    else
-      Dashes := [Single.MaxValue];
-    end;
-    iDash := 0;
-    DashLen := Dashes[iDash];
+    Distance := DestPos.Distance(SrcPos);
 
-    if  FThickness < 3 then
+    if Distance >= StepSize then
     begin
-      SaveThickness := FHalfThickness;
-      FHalfThickness := 1.75 * FHalfThickness;
-      F.I := -1;
-      if Closed then
-      begin
-        First := 0;
-        F.P := Points[Start + Count - 1] * FMatrix;
-      end
-      else
-      begin
-        First := 1;
-        F.P := Points[Start] * FMatrix;
-      end;
-      for I := First to Count - 1 do
-      begin
-        E := F;
-        F.I := -1;
-        F.P := Points[Start + I] * FMatrix;
-        D1 := (F.P - E.P);
-        L1 := D1.Length;
-        D1 := D1/L1;
+      PieceDirVec := (DestPos - SrcPos).Normalize;
+      ThickPerp := TPointF.Create(-PieceDirVec.Y, PieceDirVec.X) * FHalfThickness;
 
-        while L1 > 0 do
-        begin
-          if odd(iDash) then
-          begin
-            if L1 < DashLen then
-            begin
-              DashLen := DashLen - L1;
-              Break;
-            end;
-            E.I := -1;
-            E.P := E.P + DashLen * D1;
-            L1 := L1 - DashLen;
-            NextDash;
-          end
-          else
-          begin
-            if L1 > DashLen then
-            begin
-              F.I := -1;
-              F.P := E.P + DashLen * D1;
-              L1 := L1 - DashLen;
-              NextDash;
-            end
-            else
-            begin
-              F.P := Points[Start + I] * FMatrix;
-              DashLen := DashLen - L1;
-              L1 := 0;
-            end;
-            EdgePoints(E.P, D1, A, B);
-            EdgePoints(F.P, D1, C, D);
-            AddVertex(E);
-            AddVertex(F);
-            SaveColor := FStrokeColor;
-            FStrokeColor := MakeColor(FStrokeColor, 0.25);
-            AddVertex(A);
-            Quad(A, E, F, C);
-            AddVertex(B);
-            Quad(B, E, F, D);
-            FStrokeColor := SaveColor;
-            E := F;
-          end;
-        end;
-      end;
-      FHalfThickness := SaveThickness;
-      Exit;
-    end;
+      InsertSegment(SrcPos, PieceDirVec, ThickPerp, DestPos, False);
 
-    Loop := Closed;
-    if Loop then
-    begin
-      L1 := (Points[Start + Count - 1] * FMatrix - Points[Start] * FMatrix).Length;
-      for I := 0 to Count - 2 do
-      begin
-        L1 := L1 + (Points[Start + I + 1] * FMatrix - Points[Start + I] * FMatrix).Length;
-        while L1 > DashLen do
-        begin
-          L1 := L1 - DashLen;
-          NextDash;
-        end;
-        DashLen := DashLen - L1;
-        L1 := 0;
-      end;
-      Loop := (DashLen > FThickness) and not Odd(iDash);
-      iDash := 0;
-      DashLen := Dashes[0];
-    end;
+      SrcPos := SrcPos + (PieceDirVec * StepSize);
 
-    if Loop then
-    begin
-      P1 := Points[Start + Count - 1] * FMatrix;
-      P2 := Points[Start] * FMatrix;
-      P3 := Points[Start + 1] * FMatrix;
-      StartSegment(P1, P2, A, B);
-      EndCap := [TEndCaps.Stop];
-      DrawJoin(A, B, P1, P2, P3, False);
-      EndCap := [TEndCaps.Stop];
-      iDash := 0;
-      DashLen := Dashes[0] - FHalfThickness;
-    end
-    else
-    begin
-      P1 := Points[Start + 0] * FMatrix;
-      P2 := Points[Start + 1] * FMatrix;
-      D1 := (P2 - P1).Normalize;
-      P1 := P1 - D1 * FHalfThickness;
-      StartSegment(P1, P2, A, B);
-      EndCap := [TEndCaps.Start, TEndCaps.Stop];
+      SrcPosValid := True;
+      DestPosValid := True;
+      Continue;
     end;
 
-    for I := 0 to Count - 3 do
+    if (CurIndex = Length(Points) - 1) or (Points[CurIndex + 1].X >= $FFFF) or (Points[CurIndex + 1].Y >= $FFFF) or
+      ((CurIndex < Length(Points) - 2) and (Points[CurIndex + 1].X < $FFFF) and (Points[CurIndex + 1].Y < $FFFF) and
+      (Points[CurIndex + 2].X < $FFFF) and (Points[CurIndex + 2].Y < $FFFF) and
+      (Points[CurIndex + 1].Distance(Points[CurIndex + 2]) > StepSize)) then
     begin
-      P3 := Points[Start + I + 2] * FMatrix;
-      DrawJoin(A, B, P1, P2, P3);
-    end;
+      ComputeBuildEstimates(1 + Distance / StepSize, TempVertexCount, TempIndexCount);
 
-    if Closed then
-    begin
-      P3 := Points[Start] * FMatrix;
-      DrawJoin(A, B, P1, P2, P3);
-      if Loop then
+      if FSegmentCount > 1 then
       begin
-        P3 := Points[Start + 1] * FMatrix;
-        DrawJoin(A, B, P1, P2, P3);
+        PieceDirVec := (DestPos - SrcPos).Normalize();
+        ThickPerp := TPointF.Create(-PieceDirVec.Y, PieceDirVec.X) * FHalfThickness;
+
+        InsertSegment(SrcPos, PieceDirVec, ThickPerp, DestPos, True);
+      end;
+
+      if CurIndex < Length(Points) - 1 then
+      begin
+        Inc(CurIndex);
+        Continue;
       end
       else
-        EndSegment(A, B, P1, P3);
-    end
-    else
-    begin
-      D1 := (P2 - P1).Normalize;
-      P2 := P2 + D1 * FHalfThickness;
-      EndSegment(A, B, P1, P2);
+        Break;
     end;
+
+    SrcPosValid := True;
+    Inc(CurIndex);
   end;
 
+  FinalizeArrays;
+end;
+
+procedure TStrokeBuilder.BuildIntermPath(const Path: TPathData; const Opacity: Single);
+var
+  Points: TPolygon;
 begin
+  Path.FlattenToPolygon(Points, 1);
+  BuildIntermPolygon(Points, Opacity, (Path.Count > 0) and (Path[Path.Count - 1].Kind <> TPathPointKind.Close));
+end;
+
+procedure TStrokeBuilder.BuildSolidPolygon(const Points: TPolygon; const Opacity: Single; BreakAtEnd: Boolean);
+var
+  StepSize, Distance: Single;
+  CurScale, SrcPos, DestPos, PieceDirVec, ThickPerp: TPointF;
+  SrcPosValid, DestPosValid, PrevVerticesPlaced: Boolean;
+  CurIndex: Integer;
+begin
   if Length(Points) < 2 then
   begin
     InitArrays(0, 0);
@@ -1523,258 +1076,154 @@
   FUndeterminedMode := True;
   InitArrayPointers;
 
-  FirstPoint := 0;
+  //StepSize := FThickness;
+  //if StepSize < 2 then
+  //  StepSize := 2;
+  Stepsize := 1;
+
   CurIndex := 0;
+
+  SrcPosValid := False;
+  DestPosValid := False;
+  PrevVerticesPlaced := False;
+
   while CurIndex < Length(Points) do
   begin
-    if Points[CurIndex] = PolygonPointBreak then
+    if (CurIndex >= Length(Points) - 1) and BreakAtEnd and (Points[0] <> Points[Length(Points) - 1]) then
+      Break;
+
+    if not SrcPosValid then
     begin
-      PolyLine(FirstPoint, CurIndex - FirstPoint);
-      FirstPoint := CurIndex + 1;
-    end;
-    Inc(CurIndex);
-  end;
-  PolyLine(FirstPoint, CurIndex - FirstPoint);
+      SrcPos := Points[CurIndex];
 
-  FinalizeArrays;
-end;
+      if (SrcPos.X >= $FFFF) or (SrcPos.Y >= $FFFF) then
+      begin
+        DestPosValid := False;
+        PrevVerticesPlaced := False;
+        Inc(CurIndex);
+        Continue;
+      end;
 
-procedure TStrokeBuilder.BuildIntermPath(const Path: TPathData; const Opacity: Single);
-var
-  Points: TPolygon;
-begin
-  Path.FlattenToPolygon(Points, 1);
-  BuildIntermPolygon(Points, Opacity, (Path.Count > 0) and (Path[Path.Count - 1].Kind <> TPathPointKind.Close));
-end;
-
-procedure TStrokeBuilder.BuildSolidPolygon(const Points: TPolygon; const Opacity: Single; BreakAtEnd: Boolean);
-const
-  COS_170_DEGREE = -0.98;
-var
-  CurScale: TPointF;
-  CurIndex: Integer;
-  FirstPoint: Integer;
-
-  procedure PolyLine(Start, Count: Integer);
-  var
-    Closed: Boolean;
-    SaveThickness: Single;
-    SaveColor: TAlphaColor;
-    First, I: Integer;
-    P0, P1: TPointF;
-    L1: Single;
-    D1, D2: TPointF;
-    A, B, C, D, E, F, G, H, V: TVertex;
-    Style: TStrokeJoin;
-    CosAngle: Single;
-    Clockwise: Boolean;
-    NoCap: Boolean;
-  begin
-    if Count < 2 then
-      Exit;
-
-    Closed := Points[Start].EqualsTo(Points[Start + Count - 1]);
-    if Closed then
-    begin
-      Dec(Count);
-      if Count < 2 then
-        Exit;
+      SrcPos := SrcPos * FMatrix;
     end
     else
-      Closed := not BreakAtEnd;
+      SrcPosValid := False;
 
-    if FThickness < 3 then
+    if not DestPosValid then
     begin
-      SaveThickness := FHalfThickness;
-      FHalfThickness := 1.75 * FHalfThickness;
-      F.I := -1;
-      if Closed then
+      DestPos := Points[(CurIndex + 1) mod Length(Points)];
+
+      if (DestPos.X >= $FFFF) or (DestPos.Y >= $FFFF) then
       begin
-        First := 0;
-        F.P := Points[Start + Count - 1] * FMatrix;
+        DestPos := Points[CurIndex];
+        if (DestPos.X >= $FFFF) or (DestPos.Y >= $FFFF) then
+        begin
+          PrevVerticesPlaced := False;
+          Inc(CurIndex);
+          Continue;
+        end;
+
+        DestPos := DestPos * FMatrix;
       end
       else
-      begin
-        First := 1;
-        F.P := Points[Start] * FMatrix;
-      end;
-      for I := First to Count - 1 do
-      begin
-        E := F;
-        F.I := -1;
-        F.P := Points[Start + I] * FMatrix;
-        D1 := (F.P - E.P);
-        L1 := D1.Length;
-        D1 := D1/L1;
-        EdgePoints(E.P, D1, A, B);
-        EdgePoints(F.P, D1, C, D);
+        DestPos := DestPos * FMatrix;
+    end
+    else
+      DestPosValid := False;
 
-        AddVertex(E);
-        AddVertex(F);
-        SaveColor := FStrokeColor;
-        FStrokeColor := MakeColor(FStrokeColor, 0.25);
-        AddVertex(A);
-        Quad(A, E, F, C);
-        AddVertex(B);
-        Quad(B, E, F, D);
-        FStrokeColor := SaveColor;
-      end;
-      FHalfThickness := SaveThickness;
-      Exit;
-    end;
+    Distance := DestPos.Distance(SrcPos);
 
-    if Closed then
+    if Distance >= StepSize then
     begin
-      NoCap := True;
-      P0 := Points[Start + Count - 2] * FMatrix;
-      P1 := Points[Start + Count - 1] * FMatrix;
-      Dec(Start, 2);
-      Inc(Count, 3);
-    end
-    else
-    begin
-      NoCap := False;
-      P0 := Points[Start] * FMatrix;
-      P1 := Points[Start + 1] * FMatrix;
-    end;
+      PieceDirVec := (DestPos - SrcPos).Normalize;
+      ThickPerp := TPointF.Create(-PieceDirVec.Y, PieceDirVec.X) * FHalfThickness;
 
-    D2 := (P1 - P0).Normalize;
+      InsertVertex(SrcPos - ThickPerp, FStrokeColor);
+      InsertVertex(SrcPos + ThickPerp, FStrokeColor);
 
-    if (Brush.Cap = TStrokeCap.Flat) and not Closed then
-      P0 := P0 - D2 * FHalfThickness;
+      if PrevVerticesPlaced then
+      begin
+        InsertIndex(FCurrentVertex - 3);
+        InsertIndex(FCurrentVertex - 1);
+        InsertIndex(FCurrentVertex - 2);
 
-    EdgePoints(P0, D2, A, B);
-    EdgePoints(P1, D2, G, H);
+        InsertIndex(FCurrentVertex - 2);
+        InsertIndex(FCurrentVertex - 4);
+        InsertIndex(FCurrentVertex - 3);
+      end;
 
-    if (Brush.Cap = TStrokeCap.Round) and not Closed then
-    begin
-      V.I := -1;
-      V.P := P0;
-      Arc(P0, V, B, A, False);
+      PrevVerticesPlaced := True;
+
+      SrcPos := SrcPos + (PieceDirVec * StepSize);
+
+      SrcPosValid := True;
+      DestPosValid := True;
+      Continue;
     end;
 
-    for I := 0 to Count - 3 do
+    if ((CurIndex < Length(Points) - 2) and (Points[CurIndex + 1].X < $FFFF) and (Points[CurIndex + 1].Y < $FFFF) and
+      (Points[CurIndex + 2].X < $FFFF) and (Points[CurIndex + 2].Y < $FFFF) and
+      (Points[CurIndex + 1].Distance(Points[CurIndex + 2]) > StepSize)) then
     begin
-      P0 := P1;
-      if Closed and (I = Count - 3) then
-        P1 := Points[Start + 2] * FMatrix
-      else
-        P1 := Points[Start + I + 2] * FMatrix;
-      D1 := D2;
-      D2 := (P1 - P0).Normalize;
+      PieceDirVec := (DestPos - SrcPos).Normalize;
+      ThickPerp := TPointF.Create(-PieceDirVec.Y, PieceDirVec.X) * FHalfThickness;
 
-      CosAngle := D1.AngleCosine(D2);
-      Style := Brush.Join;
-      if (Style = TStrokeJoin.Miter) and (CosAngle < COS_170_DEGREE) then
-        Style := TStrokeJoin.Bevel;
+      InsertVertex(DestPos - ThickPerp, FStrokeColor);
+      InsertVertex(DestPos + ThickPerp, FStrokeColor);
 
-      C := G;
-      D := H;
-      EdgePoints(P0, D2, E, F);
-      EdgePoints(P1, D2, G, H);
+      if PrevVerticesPlaced then
+      begin
+        InsertIndex(FCurrentVertex - 3);
+        InsertIndex(FCurrentVertex - 1);
+        InsertIndex(FCurrentVertex - 2);
 
-      if Style = TStrokeJoin.Miter then
+        InsertIndex(FCurrentVertex - 2);
+        InsertIndex(FCurrentVertex - 4);
+        InsertIndex(FCurrentVertex - 3);
+      end;
+
+      if CurIndex < Length(Points) - 1 then
       begin
-        Intersect(A, C, E, G);
-        Intersect(B, D, F, H);
-        if not NoCap then
-          Quad(A, B, D, C);
-        A := C;
-        B := D;
+        Inc(CurIndex);
+        Continue;
       end
       else
-      begin
-        if CosAngle >= COS_170_DEGREE then
-        begin
-          Clockwise := (D1.X * D2.Y - D2.X * D1.Y) < 0;
-          if Clockwise then
-          begin
-            Intersect(A, C, E, G);
-            if NoCap = False then
-            begin
-              Quad(A, B, D, C);
-              case Style of
-                TStrokeJoin.Bevel: Triangle(C, D, F);
-                TStrokeJoin.Round: Arc(P0, C, D, F, True);
-              end;
-            end;
-            A := C;
-            B := D;
-            D := F;
-          end
-          else
-          begin
-            Intersect(B, D, F, H);
-            if NoCap = False then
-            begin
-              Quad(A, B, D, C);
-              case Style of
-                TStrokeJoin.Bevel: Triangle(D, C, E);
-                TStrokeJoin.Round: Arc(P0, D, C, E, False);
-              end;
-            end;
-            A := C;
-            B := D;
-            C := E;
-          end;
-          A := C;
-          B := D;
-        end
-        else if not NoCap then
-        begin
-          if Style = TStrokeJoin.Round then
-            Arc(P0, D, C, E, False);
-          Quad(A, B, D, C);
-          A := D;
-          B := C;
-        end;
-      end;
-      NoCap := False;
+        Break;
     end;
 
-    if not Closed then
+    if (CurIndex = Length(Points) - 1) or (Points[CurIndex + 1].X >= $FFFF) or (Points[CurIndex + 1].Y >= $FFFF) then
     begin
-      if Brush.Cap = TStrokeCap.Flat then
-        P1 := P1 + D2 * FHalfThickness;
-      EdgePoints(P1, D2, C, D);
-      Quad(A, B, D, C);
-      if Brush.Cap = TStrokeCap.Round then
-      begin
-        V.I := -1;
-        V.P := P1;
-        Arc(P1, V, C, D, False);
-      end;
-    end;
-  end;
+      PieceDirVec := (DestPos - SrcPos).Normalize;
+      ThickPerp := TPointF.Create(-PieceDirVec.Y, PieceDirVec.X) * FHalfThickness;
 
-begin
-  if Length(Points) < 2 then
-  begin
-    InitArrays(0, 0);
-    Exit;
-  end;
+      InsertVertex(DestPos - ThickPerp, FStrokeColor);
+      InsertVertex(DestPos + ThickPerp, FStrokeColor);
 
-  CurScale := GetMatrixScale;
+      if PrevVerticesPlaced then
+      begin
+        InsertIndex(FCurrentVertex - 3);
+        InsertIndex(FCurrentVertex - 1);
+        InsertIndex(FCurrentVertex - 2);
 
-  FThickness := FBrush.Thickness * (CurScale.X + CurScale.Y) * 0.5;
-  FHalfThickness := FThickness * 0.5;
-  FStrokeColor := PremultiplyAlpha(MakeColor(FBrush.Color, Opacity));
+        InsertIndex(FCurrentVertex - 2);
+        InsertIndex(FCurrentVertex - 4);
+        InsertIndex(FCurrentVertex - 3);
+      end;
 
-  FUndeterminedMode := True;
-  InitArrayPointers;
+      PrevVerticesPlaced := False;
 
-  FirstPoint := 0;
-  CurIndex := 0;
-  while CurIndex < Length(Points) do
-  begin
-    if Points[CurIndex] = PolygonPointBreak then
-    begin
-      PolyLine(FirstPoint, CurIndex - FirstPoint);
-      FirstPoint := CurIndex + 1;
+      if CurIndex < Length(Points) - 1 then
+      begin
+        Inc(CurIndex);
+        Continue;
+      end
+      else
+        Break;
     end;
+
+    SrcPosValid := True;
     Inc(CurIndex);
   end;
-  PolyLine(FirstPoint, CurIndex - FirstPoint);
 
   FinalizeArrays;
 end;
Index: Embarcadero/Alexandria/11_3/fmx/FMX.VirtualKeyboard.Android.pas
===================================================================
diff --git a/Embarcadero/Alexandria/11_3/fmx/FMX.VirtualKeyboard.Android.pas b/Embarcadero/Alexandria/11_3/fmx/FMX.VirtualKeyboard.Android.pas
--- a/Embarcadero/Alexandria/11_3/fmx/FMX.VirtualKeyboard.Android.pas	(revision 1)
+++ b/Embarcadero/Alexandria/11_3/fmx/FMX.VirtualKeyboard.Android.pas	(working copy)
@@ -218,8 +218,15 @@
   VKRect.TopLeft := ConvertPixelToPoint(TPointF.Create(newFrame.Left, newFrame.Top)).Round;
   VKRect.BottomRight := ConvertPixelToPoint(TPointF.Create(newFrame.Right, newFrame.Bottom)).Round;
 
-  if (FNeedNotifyAboutFrameChanges or ((MainActivity.getVirtualKeyboard.isVirtualKeyboardShown) and (VKRect.Height > 0)))
-     and (FPreviousVKRect <> VKRect) then
+  // https://quality.embarcadero.com/browse/RSP-24737
+  // I made the conclusion that the event onVirtualKeyboardWillHidden and onVirtualKeyboardWillShown
+  // are inconsistent. often the onVirtualKeyboardWillHidden is not fired (for exemple when you
+  // click on the return key of the keybord in the bottom left) and sometime (more hard to reproduce
+  // but I guarantee I see it) the onVirtualKeyboardWillShown is not fired. But what seam consistant
+  // is the fire to this function onVirtualKeyboardFrameChanged with good value for VKRect
+  // So I decide to only take care of this event
+
+  if (FPreviousVKRect <> VKRect) then
     try
       FKeyboardService.SendNotificationAboutKeyboardEvent(VKRect);
       FPreviousVKRect := VKRect;
Index: Embarcadero/Alexandria/11_3/rtl/android/Androidapi.JNI.App.pas
===================================================================
diff --git a/Embarcadero/Alexandria/11_3/rtl/android/Androidapi.JNI.App.pas b/Embarcadero/Alexandria/11_3/rtl/android/Androidapi.JNI.App.pas
--- a/Embarcadero/Alexandria/11_3/rtl/android/Androidapi.JNI.App.pas	(revision 1)
+++ b/Embarcadero/Alexandria/11_3/rtl/android/Androidapi.JNI.App.pas	(working copy)
@@ -16,7 +16,8 @@
   Androidapi.JNI.JavaTypes,
   Androidapi.JNI.Os,
   Androidapi.JNI.Util,
-  Androidapi.JNI.Widget;
+  Androidapi.JNI.Widget,
+  Androidapi.JNI.Net; // https://quality.embarcadero.com/browse/RSP-39511
 
 type
 // ===== Forward declarations =====
@@ -76,6 +77,20 @@
 
 // ===== Interface declarations =====
 
+  // https://quality.embarcadero.com/browse/RSP-39511
+  // This dummy class is just to avoid circular reference
+  JAudioAttributesClass = interface(JObjectClass)
+    ['{FDBDFCB3-4B3F-4E1B-9007-4E5B9EA6546A}']
+  end;
+
+  // https://quality.embarcadero.com/browse/RSP-39511
+  // This dummy class is just to avoid circular reference
+  [JavaSignature('android/media/AudioAttributes')]
+  JAudioAttributes = interface(JObject)
+    ['{CEC09B65-8360-46BD-A5E8-780E4927C9AA}']
+  end;
+  TJAudioAttributes = class(TJavaGenericImport<JAudioAttributesClass, JAudioAttributes>) end;
+
   JActionBarClass = interface(JObjectClass)
     ['{C1A41981-8687-4794-91A5-AA384F60A546}']
     {class} function _GetDISPLAY_HOME_AS_UP: Integer; cdecl;
@@ -1469,7 +1484,7 @@
 
   JNotificationClass = interface(JObjectClass)
     ['{4584515F-7E22-49A9-A55B-A6DE3BFD7E1C}']
-    //{class} function _GetAUDIO_ATTRIBUTES_DEFAULT: JAudioAttributes; cdecl;
+    {class} function _GetAUDIO_ATTRIBUTES_DEFAULT: JAudioAttributes; cdecl; // https://quality.embarcadero.com/browse/RSP-39511
     {class} function _GetBADGE_ICON_LARGE: Integer; cdecl;
     {class} function _GetBADGE_ICON_NONE: Integer; cdecl;
     {class} function _GetBADGE_ICON_SMALL: Integer; cdecl;
@@ -1553,7 +1568,7 @@
     {class} function init: JNotification; cdecl; overload;
     {class} function init(icon: Integer; tickerText: JCharSequence; when: Int64): JNotification; cdecl; overload;//Deprecated
     {class} function init(parcel: JParcel): JNotification; cdecl; overload;
-    //{class} property AUDIO_ATTRIBUTES_DEFAULT: JAudioAttributes read _GetAUDIO_ATTRIBUTES_DEFAULT;
+    {class} property AUDIO_ATTRIBUTES_DEFAULT: JAudioAttributes read _GetAUDIO_ATTRIBUTES_DEFAULT; // https://quality.embarcadero.com/browse/RSP-39511
     {class} property BADGE_ICON_LARGE: Integer read _GetBADGE_ICON_LARGE;
     {class} property BADGE_ICON_NONE: Integer read _GetBADGE_ICON_NONE;
     {class} property BADGE_ICON_SMALL: Integer read _GetBADGE_ICON_SMALL;
@@ -1813,7 +1828,7 @@
     procedure setLockscreenVisibility(lockscreenVisibility: Integer); cdecl;
     procedure setName(name: JCharSequence); cdecl;
     procedure setShowBadge(showBadge: Boolean); cdecl;
-    //procedure setSound(sound: Jnet_Uri; audioAttributes: JAudioAttributes); cdecl;
+    procedure setSound(sound: Jnet_Uri; audioAttributes: JAudioAttributes); cdecl; // https://quality.embarcadero.com/browse/RSP-39511
     procedure setVibrationPattern(vibrationPattern: TJavaArray<Int64>); cdecl;
     function shouldShowLights: Boolean; cdecl;
     function shouldVibrate: Boolean; cdecl;
@@ -2276,6 +2291,7 @@
 
 procedure RegisterTypes;
 begin
+  TRegTypes.RegisterType('Androidapi.JNI.App.JAudioAttributes', TypeInfo(Androidapi.JNI.App.JAudioAttributes)); // dummy class to avoid circular reference - https://quality.embarcadero.com/browse/RSP-39511
   TRegTypes.RegisterType('Androidapi.JNI.App.JActionBar', TypeInfo(Androidapi.JNI.App.JActionBar));
   TRegTypes.RegisterType('Androidapi.JNI.App.JActionBar_LayoutParams', TypeInfo(Androidapi.JNI.App.JActionBar_LayoutParams));
   TRegTypes.RegisterType('Androidapi.JNI.App.JActionBar_OnMenuVisibilityListener', TypeInfo(Androidapi.JNI.App.JActionBar_OnMenuVisibilityListener));
Index: Embarcadero/Alexandria/11_3/rtl/android/Androidapi.JNI.Location.pas
===================================================================
diff --git a/Embarcadero/Alexandria/11_3/rtl/android/Androidapi.JNI.Location.pas b/Embarcadero/Alexandria/11_3/rtl/android/Androidapi.JNI.Location.pas
--- a/Embarcadero/Alexandria/11_3/rtl/android/Androidapi.JNI.Location.pas	(revision 1)
+++ b/Embarcadero/Alexandria/11_3/rtl/android/Androidapi.JNI.Location.pas	(working copy)
@@ -582,7 +582,9 @@
   [JavaSignature('android/location/LocationListener')]
   JLocationListener = interface(IJavaInstance)
     ['{D1CF3FB5-3BCB-4959-98D7-BD4D8F93D839}']
-    procedure onLocationChanged(location: JLocation); cdecl;
+    procedure onFlushComplete(requestCode: Integer); cdecl; // https://quality.embarcadero.com/browse/RSP-41343
+    procedure onLocationChanged(location: JLocation); overload; cdecl; // https://quality.embarcadero.com/browse/RSP-41343
+    procedure onLocationChanged(locations: JList); overload; cdecl; // https://quality.embarcadero.com/browse/RSP-41343
     procedure onProviderDisabled(provider: JString); cdecl;
     procedure onProviderEnabled(provider: JString); cdecl;
     procedure onStatusChanged(provider: JString; status: Integer; extras: JBundle); cdecl;
@@ -592,6 +594,7 @@
   JLocationManagerClass = interface(JObjectClass)
     ['{031AE82C-2EEE-41E4-94F8-24C4D7059246}']
     {class} function _GetGPS_PROVIDER: JString; cdecl;
+    {class} function _GetFUSED_PROVIDER: JString; cdecl; // https://quality.embarcadero.com/browse/RSP-41343
     {class} function _GetKEY_LOCATION_CHANGED: JString; cdecl;
     {class} function _GetKEY_PROVIDER_ENABLED: JString; cdecl;
     {class} function _GetKEY_PROXIMITY_ENTERING: JString; cdecl;
@@ -601,6 +604,7 @@
     {class} function _GetPASSIVE_PROVIDER: JString; cdecl;
     {class} function _GetPROVIDERS_CHANGED_ACTION: JString; cdecl;
     {class} property GPS_PROVIDER: JString read _GetGPS_PROVIDER;
+    {class} property FUSED_PROVIDER: JString read _GetFUSED_PROVIDER; // https://quality.embarcadero.com/browse/RSP-41343
     {class} property KEY_LOCATION_CHANGED: JString read _GetKEY_LOCATION_CHANGED;
     {class} property KEY_PROVIDER_ENABLED: JString read _GetKEY_PROVIDER_ENABLED;
     {class} property KEY_PROXIMITY_ENTERING: JString read _GetKEY_PROXIMITY_ENTERING;
Index: Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.AVFoundation.pas
===================================================================
diff --git a/Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.AVFoundation.pas b/Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.AVFoundation.pas
--- a/Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.AVFoundation.pas	(revision 1)
+++ b/Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.AVFoundation.pas	(working copy)
@@ -730,6 +730,8 @@
     function timedMetadata: NSArray; cdecl;
     function tracks: NSArray; cdecl;
     function videoComposition: AVVideoComposition; cdecl;
+    procedure addOutput(output: AVPlayerItemOutput); cdecl; // https://quality.embarcadero.com/browse/RSP-16853
+    procedure removeOutput(output: AVPlayerItemOutput); cdecl; // https://quality.embarcadero.com/browse/RSP-16853
   end;
   TAVPlayerItem = class(TOCGenericImport<AVPlayerItemClass, AVPlayerItem>)  end;
 
Index: Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.CoreImage.pas
===================================================================
diff --git a/Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.CoreImage.pas b/Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.CoreImage.pas
--- a/Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.CoreImage.pas	(revision 1)
+++ b/Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.CoreImage.pas	(working copy)
@@ -218,8 +218,25 @@
   end;
   TCIFaceFeature = class(TOCGenericImport<CIFaceFeatureClass, CIFaceFeature>)  end;
 
+function kCIInputImageKey: NSString; // https://quality.embarcadero.com/browse/RSP-19878
+function kCIInputRadiusKey: NSString; // https://quality.embarcadero.com/browse/RSP-19878
 
-
 implementation
 
+// https://quality.embarcadero.com/browse/RSP-19878
+const
+  CoreImageFwk: string = '/System/Library/Frameworks/CoreImage.framework/CoreImage';
+
+// https://quality.embarcadero.com/browse/RSP-19878
+function kCIInputImageKey: NSString;
+begin
+  result := CocoaNSStringConst(CoreImageFwk, 'kCIInputImageKey');
+end;
+
+// https://quality.embarcadero.com/browse/RSP-19878
+function kCIInputRadiusKey: NSString;
+begin
+  result := CocoaNSStringConst(CoreImageFwk, 'kCIInputRadiusKey');
+end;
+
 end.
Index: Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.CoreLocation.pas
===================================================================
diff --git a/Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.CoreLocation.pas b/Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.CoreLocation.pas
--- a/Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.CoreLocation.pas	(revision 1)
+++ b/Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.CoreLocation.pas	(working copy)
@@ -33,7 +33,9 @@
   kCLAuthorizationStatusNotDetermined = 0;
   kCLAuthorizationStatusRestricted = 1;
   kCLAuthorizationStatusAuthorizedAlways  = kCLAuthorizationStatusAuthorized ;
-  kCLAuthorizationStatusAuthorizedWhenInUse = 4; 
+  kCLAuthorizationStatusAuthorizedWhenInUse = 4;
+  CLAccuracyAuthorizationFullAccuracy = 0; // https://quality.embarcadero.com/browse/RSP-41352
+  CLAccuracyAuthorizationReducedAccuracy = 1; // https://quality.embarcadero.com/browse/RSP-41352
   kCLErrorDenied = 1;
   kCLErrorGeocodeCanceled = 10;
   kCLErrorGeocodeFoundNoResult = 8;
@@ -45,12 +47,12 @@
   kCLErrorRegionMonitoringFailure = 5;
   kCLErrorRegionMonitoringResponseDelayed = 7;
   kCLErrorRegionMonitoringSetupDelayed = 6;
-  kCLLocationAccuracyThreeKilometers: Double = 3000;
-  kCLLocationAccuracyKilometer: Double = 1000;
-  kCLLocationAccuracyHundredMeters: Double = 100;
-  kCLLocationAccuracyNearestTenMeters: Double = 10;
-  kCLLocationAccuracyBest: Double = -1;
-  kCLLocationAccuracyBestForNavigation: Double = -1;
+  //kCLLocationAccuracyThreeKilometers: Double = 3000; //https://quality.embarcadero.com/browse/RSP-41388
+  //kCLLocationAccuracyKilometer: Double = 1000; //https://quality.embarcadero.com/browse/RSP-41388
+  //kCLLocationAccuracyHundredMeters: Double = 100; //https://quality.embarcadero.com/browse/RSP-41388
+  //kCLLocationAccuracyNearestTenMeters: Double = 10; //https://quality.embarcadero.com/browse/RSP-41388
+  //kCLLocationAccuracyBest: Double = -1; //https://quality.embarcadero.com/browse/RSP-41388
+  //kCLLocationAccuracyBestForNavigation: Double = -1; //https://quality.embarcadero.com/browse/RSP-41388
   CLRegionStateUnknown = 0;
   CLRegionStateInside = 1;
   CLRegionStateOutside = 2;
@@ -80,6 +82,7 @@
 type
 {$M+}
   CLAuthorizationStatus = Integer;
+  CLAccuracyAuthorization = NSInteger; // https://quality.embarcadero.com/browse/RSP-41352
   CLDeviceOrientation = Integer;
   CLHeadingComponentValue = Double;
   CLLocationAccuracy = Double;
@@ -108,8 +111,10 @@
 
   CLLocationManagerDelegate = interface;
 
+  CLBeaconIdentityConstraint = interface; // https://quality.embarcadero.com/browse/RSP-18621
   CLPlacemark = interface;
   CLRegion = interface;
+  CLVisit = interface; // https://quality.embarcadero.com/browse/RSP-18621
   CLLocationManager = interface;
   CLGeocoder = interface;
   CLHeading = interface;
@@ -125,11 +130,16 @@
     procedure locationManager(manager: CLLocationManager; didUpdateToLocation: CLLocation; fromLocation: CLLocation); overload; cdecl;
     procedure locationManager(manager: CLLocationManager; monitoringDidFailForRegion: CLRegion; withError: NSError); overload; cdecl;
     procedure locationManager(manager: CLLocationManager; didChangeAuthorizationStatus: CLAuthorizationStatus); overload; cdecl;
+    procedure locationManagerDidChangeAuthorization(manager: CLLocationManager); cdecl; // https://quality.embarcadero.com/browse/RSP-18621
     [MethodName('locationManager:didUpdateLocations:')]
     procedure locationManagerDidUpdateLocations(manager: CLLocationManager; locations: NSArray); cdecl;
     function locationManagerShouldDisplayHeadingCalibration(manager: CLLocationManager): Boolean; cdecl;
     [MethodName('locationManager:didDetermineState:forRegion:')]
     procedure locationManagerDidDetermineStateForRegion(manager: CLLocationManager; state: CLRegionState; region: CLRegion); cdecl;
+    [MethodName('locationManager:didRangeBeacons:satisfyingConstraint:')]  // https://quality.embarcadero.com/browse/RSP-18621
+    procedure locationManagerDidRangeBeaconsSatisfyingConstraint(manager: CLLocationManager; didRangeBeacons: NSArray; satisfyingConstraint: CLBeaconIdentityConstraint); cdecl;  // https://quality.embarcadero.com/browse/RSP-18621
+    [MethodName('locationManager:didFailRangingBeaconsForConstraint:error:')]  // https://quality.embarcadero.com/browse/RSP-18621
+    procedure locationManagerDidFailRangingBeaconsForConstraintError(manager: CLLocationManager; didFailRangingBeaconsForConstraint: CLBeaconIdentityConstraint; error: NSError); cdecl;  // https://quality.embarcadero.com/browse/RSP-18621
     [MethodName('locationManager:didRangeBeacons:inRegion:')]
     procedure locationManagerDidRangeBeaconsInRegion(manager: CLLocationManager; beacons: NSArray; region: CLBeaconRegion); cdecl;
     [MethodName('locationManager:rangingBeaconsDidFailForRegion:withError:')]
@@ -144,10 +154,30 @@
     procedure locationManagerDidResumeLocationUpdates(manager: CLLocationManager); cdecl;
     [MethodName('locationManager:didFinishDeferredUpdatesWithError:')]
     procedure locationManagerDidFinishDeferredUpdatesWithError(manager: CLLocationManager; error: NSError); cdecl;
+    [MethodName('locationManager:didVisit:')]                                             // https://quality.embarcadero.com/browse/RSP-18621
+    procedure locationManagerDidVisit(manager: CLLocationManager; visit: CLVisit); cdecl; // https://quality.embarcadero.com/browse/RSP-18621
   end;
 
 // ===== Interface declarations =====
 
+  // https://quality.embarcadero.com/browse/RSP-18621
+  CLBeaconIdentityConstraintClass = interface(NSObjectClass)
+    ['{60F2EA64-0E56-459B-8FCC-ABE5C7885429}']
+  end;
+  CLBeaconIdentityConstraint = interface(NSObject)
+    ['{67C0B6E9-BCFA-4C05-9ED1-C9AB032EC813}']
+    function UUID: NSUUID; cdecl;
+    function major: NSNumber; cdecl;
+    function minor: NSNumber; cdecl;
+    [MethodName('initWithUUID:')]
+    function initWithUUID(uuid: NSUUID): Pointer{instancetype}; cdecl; overload;
+    [MethodName('initWithUUID:major:')]
+    function initWithUUID(uuid: NSUUID; major: CLBeaconMajorValue): Pointer{instancetype}; cdecl; overload;
+    [MethodName('initWithUUID:major:minor:')]
+    function initWithUUID(uuid: NSUUID; major: CLBeaconMajorValue; minor: CLBeaconMinorValue): Pointer{instancetype}; cdecl; overload;
+  end;
+  TCLBeaconIdentityConstraint = class(TOCGenericImport<CLBeaconIdentityConstraintClass, CLBeaconIdentityConstraint>)  end;
+
   CLPlacemarkClass = interface(NSObjectClass)
     ['{A0539851-6F72-4A85-A6DF-5ACDAD4DC09E}']
   end;
@@ -190,6 +220,19 @@
   end;
   TCLRegion = class(TOCGenericImport<CLRegionClass, CLRegion>)  end;
 
+  // https://quality.embarcadero.com/browse/RSP-18621
+  CLVisitClass = interface(NSObjectClass)
+    ['{8526B69B-5AD8-4B4B-91DC-6C06474BE925}']
+  end;
+  CLVisit = interface(NSObject)
+    ['{BB121072-B081-4C90-BB85-6FCC24DF8223}']
+    function arrivalDate: NSDate; cdecl;
+    function departureDate: NSDate; cdecl;
+    function coordinate: CLLocationCoordinate2D; cdecl;
+    function horizontalAccuracy: CLLocationAccuracy; cdecl;
+  end;
+  TCLVisit = class(TOCGenericImport<CLVisitClass, CLVisit>)  end;
+
   CLLocationManagerClass = interface(NSObjectClass)
     ['{4422C248-523F-4237-8966-2A322F58A77C}']
     {class} function authorizationStatus: CLAuthorizationStatus; cdecl;
@@ -205,6 +248,8 @@
 
   CLLocationManager = interface(NSObject)
     ['{48C6C581-DA14-4444-A65D-896A0EF5E828}']
+    function authorizationStatus : CLAuthorizationStatus; cdecl; // https://quality.embarcadero.com/browse/RSP-41352
+    function accuracyAuthorization : CLAccuracyAuthorization; cdecl; // https://quality.embarcadero.com/browse/RSP-41352
     function activityType : CLActivityType; cdecl;
     procedure allowDeferredLocationUpdatesUntilTraveled(distance: CLLocationDistance; timeout: NSTimeInterval); cdecl;
     function delegate: Pointer; cdecl;
@@ -248,6 +293,8 @@
     procedure stopRangingBeaconsInRegion(region: CLBeaconRegion); cdecl;
     procedure stopUpdatingHeading; cdecl;
     procedure stopUpdatingLocation; cdecl;
+    procedure startMonitoringVisits; cdecl; // https://quality.embarcadero.com/browse/RSP-18621
+    procedure stopMonitoringVisits; cdecl; // https://quality.embarcadero.com/browse/RSP-18621
   end;
   TCLLocationManager = class(TOCGenericImport<CLLocationManagerClass, CLLocationManager>)  end;
 
@@ -348,7 +395,7 @@
 
   CLCircularRegion = interface(CLRegion)
     ['{FF4DCF91-376B-41BB-B60A-880BEBB5B4EE}']
-    function initWithCenter(center: CLLocationCoordinate2D; radius: CLLocationDistance; identifier: NSString): Pointer; cdecl;
+    function initWithCenter(center: CLLocationCoordinate2D; radius: CLLocationDistance; identifier: pointer): Pointer; cdecl; // https://quality.embarcadero.com/browse/RSP-15717
     function center: CLLocationCoordinate2D; cdecl;
     function radius: CLLocationDistance; cdecl;
     function containsCoordinate(coordinate: CLLocationCoordinate2D): Boolean; cdecl;
@@ -358,6 +405,15 @@
 function CLLocationCoordinate2DIsValid(coord: CLLocationCoordinate2D): Boolean; cdecl; external libCoreLocation name _PU + 'CLLocationCoordinate2DIsValid';
 function CLLocationCoordinate2DMake(latitude: CLLocationDegrees; longitude: CLLocationDegrees): CLLocationCoordinate2D; cdecl; external libCoreLocation name _PU + 'CLLocationCoordinate2DMake';
 
+//https://quality.embarcadero.com/browse/RSP-41388
+function kCLLocationAccuracyBestForNavigation: Double;
+function kCLLocationAccuracyBest: Double;
+function kCLLocationAccuracyNearestTenMeters: Double;
+function kCLLocationAccuracyHundredMeters: Double;
+function kCLLocationAccuracyKilometer: Double;
+function kCLLocationAccuracyThreeKilometers: Double;
+function kCLLocationAccuracyReduced: Double;
+
 implementation
 
 {$IF defined(IOS) and NOT defined(CPUARM)}
@@ -378,6 +434,48 @@
   Result := CocoaNSStringConst(libCoreLocation, 'kCLErrorDomain');
 end;
 
+//https://quality.embarcadero.com/browse/RSP-41388
+function kCLLocationAccuracyBestForNavigation: Double;
+begin
+  Result := PDouble(CocoaPointerConst(libCoreLocation, 'kCLLocationAccuracyBestForNavigation'))^;
+end;
+
+//https://quality.embarcadero.com/browse/RSP-41388
+function kCLLocationAccuracyBest: Double;
+begin
+  Result := PDouble(CocoaPointerConst(libCoreLocation, 'kCLLocationAccuracyBest'))^;
+end;
+
+//https://quality.embarcadero.com/browse/RSP-41388
+function kCLLocationAccuracyNearestTenMeters: Double;
+begin
+  Result := PDouble(CocoaPointerConst(libCoreLocation, 'kCLLocationAccuracyNearestTenMeters'))^;
+end;
+
+//https://quality.embarcadero.com/browse/RSP-41388
+function kCLLocationAccuracyHundredMeters: Double;
+begin
+  Result := PDouble(CocoaPointerConst(libCoreLocation, 'kCLLocationAccuracyHundredMeters'))^;
+end;
+
+//https://quality.embarcadero.com/browse/RSP-41388
+function kCLLocationAccuracyKilometer: Double;
+begin
+  Result := PDouble(CocoaPointerConst(libCoreLocation, 'kCLLocationAccuracyKilometer'))^;
+end;
+
+//https://quality.embarcadero.com/browse/RSP-41388
+function kCLLocationAccuracyThreeKilometers: Double;
+begin
+  Result := PDouble(CocoaPointerConst(libCoreLocation, 'kCLLocationAccuracyThreeKilometers'))^;
+end;
+
+//https://quality.embarcadero.com/browse/RSP-41388
+function kCLLocationAccuracyReduced: Double;
+begin
+  Result := PDouble(CocoaPointerConst(libCoreLocation, 'kCLLocationAccuracyReduced'))^;
+end;
+
 {$IF defined(IOS) and NOT defined(CPUARM)}
 initialization
   CLModule := dlopen(MarshaledAString(libCoreLocation), RTLD_LAZY);
Index: Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.Foundation.pas
===================================================================
diff --git a/Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.Foundation.pas b/Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.Foundation.pas
--- a/Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.Foundation.pas	(revision 1)
+++ b/Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.Foundation.pas	(working copy)
@@ -5566,8 +5566,28 @@
       downloadTask: NSURLSessionDownloadTask; didResumeAtOffset: Int64; expectedTotalBytes: Int64); cdecl;
   end;
 
+  //https://quality.embarcadero.com/browse/RSP-28096
+  NSPersonNameComponentsClass = interface(NSObjectClass)
+    ['{2EDFEAC4-A0B4-4BB2-BAD9-4581B92DA4C7}']
+  end;
+  NSPersonNameComponents = interface(NSObject)
+    ['{821B6CD5-BE9B-4708-928B-FD5CE5D12788}']
+    procedure setNamePrefix(namePrefix: NSString); cdecl;
+    function namePrefix : NSString; cdecl;
+    procedure setGivenName(givenName: NSString); cdecl;
+    function givenName : NSString; cdecl;
+    procedure setMiddleName(middleName: NSString); cdecl;
+    function middleName : NSString; cdecl;
+    procedure setFamilyName(familyName: NSString); cdecl;
+    function familyName : NSString; cdecl;
+    procedure setNameSuffix(nameSuffix: NSString); cdecl;
+    function nameSuffix : NSString; cdecl;
+    procedure setNickname(nickname: NSString); cdecl;
+    function nickname : NSString; cdecl;
+    procedure setPhoneticRepresentation(phoneticRepresentation: NSPersonNameComponents); cdecl;
+    function phoneticRepresentation : NSPersonNameComponents; cdecl;
+  end;
 
-
 // Convenience method for creating an NSString from a Delphi Unicode string
 function NSSTR(const Str: string): NSString; inline; deprecated 'use StrToNSStr instead';
 
Index: Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.Security.pas
===================================================================
diff --git a/Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.Security.pas b/Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.Security.pas
--- a/Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.Security.pas	(revision 1)
+++ b/Embarcadero/Alexandria/11_3/rtl/ios/iOSapi.Security.pas	(working copy)
@@ -622,6 +622,8 @@
 function kSecAttrKeyClassSymmetric: NSString;
 function kSecAttrKeyTypeRSA: NSString;
 function kSecAttrKeyTypeEC: NSString;
+function kSecValueRef: NSString; // https://quality.embarcadero.com/browse/RSP-20279
+function kSecValueData: NSString; // https://quality.embarcadero.com/browse/RSP-20279
 
 
 implementation
@@ -1252,6 +1254,18 @@
   result := CocoaNSStringConst(libSecurity, 'kSecAttrKeyTypeEC');
 end;
 
+// https://quality.embarcadero.com/browse/RSP-20279
+function kSecValueRef: NSString;
+begin
+  result := CocoaNSStringConst(libSecurity, 'kSecValueRef');
+end;
+
+// https://quality.embarcadero.com/browse/RSP-20279
+function kSecValueData: NSString;
+begin
+  result := CocoaNSStringConst(libSecurity, 'kSecValueData');
+end;
+
 {$IF defined(IOS) and NOT defined(CPUARM)}
 
 initialization
Index: Embarcadero/Alexandria/11_3/rtl/win/Winapi.Isapi2.pas
===================================================================
diff --git a/Embarcadero/Alexandria/11_3/rtl/win/Winapi.Isapi2.pas b/Embarcadero/Alexandria/11_3/rtl/win/Winapi.Isapi2.pas
--- a/Embarcadero/Alexandria/11_3/rtl/win/Winapi.Isapi2.pas	(revision 1)
+++ b/Embarcadero/Alexandria/11_3/rtl/win/Winapi.Isapi2.pas	(working copy)
@@ -397,7 +397,7 @@
     dwReserved: DWORD): Pointer; stdcall;
 
   TFilterServerSupportFunctionProc = function (var pfc{: THTTP_FILTER_CONTEXT};
-    sfReq: DWORD; pData: Pointer; ul1, ul2: DWORD): BOOL; stdcall;
+    sfReq: DWORD; pData: Pointer; ul1, ul2: ULONG_PTR): BOOL; stdcall; // https://quality.embarcadero.com/browse/RSP-33754
 
   PHTTP_FILTER_CONTEXT = ^THTTP_FILTER_CONTEXT;
   THTTP_FILTER_CONTEXT = record

Alcinoe
=======

<b>Alcinoe</b> is a comprehensive library of both visual and non-visual 
components for Delphi. These components are freely available 
for use in commercial, shareware, freeware, and open-source 
projects. <b>Alcinoe</b> is fully compatible with <b>Delphi Athens 12.2</b>. 
If you find this library helpful, please consider giving it a 
star on GitHub. It’s free and greatly supports the project’s 
visibility and growth.

<img src="https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/star.jpg?raw=true" />


Example of an App Built with Alcinoe
------------------------------------

<a href="https://www.youtube.com/watch?v=IJzEuZTSXDI&vq=hd2160">
  <img src="https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/youtubekiskis.jpg?raw=true"/>
</a>


Embarcadero Quality Reports
---------------------------

Please request the resolution of these quality reports. Due 
to the unresolved issues from Embarcadero, we have been 
forced to apply patches to the original Delphi source files:

* [Project option to define where to look/create the LaunchScreen.TemplateiOS directory](https://quality.embarcadero.com/browse/RSP-33503)
* [Support for the new Android Splash Screen standard](https://quality.embarcadero.com/browse/RSP-39331)
* [Their is no propagation of mouse event under Firemonkey](https://quality.embarcadero.com/browse/RSP-24397)
* [Performance Issue - Comparing Equality Between Two Strings](https://quality.embarcadero.com/browse/RSP-42011)
* [Introduce IsVisibleObject function for improved optimization on TScrollBox](https://quality.embarcadero.com/browse/RSP-42357)
* [The width and height of a TContext3D object must be defined as single-precision, not as integers](https://embt.atlassian.net/servicedesk/customer/portal/1/RSS-1723)
* [TTextLayout.PositionAtPoint / TTextLayoutD2D.DoPositionAtPoint totally broken in Alexandria](https://quality.embarcadero.com/browse/RSP-39734)
* [Regression in Alexandria: FMX.StrokeBuilder.pas Revamp Leads to TARC Drawing Issues](https://quality.embarcadero.com/browse/RSP-41618)
* [Multi-Threading for TBitmap, TCanvas, and TContext3D is not working !](https://quality.embarcadero.com/browse/RSP-19673)
* [Allow linking of Swift compatibility frameworks](https://quality.embarcadero.com/browse/RSP-38700)
* [Allow TTexture to Define a GL_TEXTURE_EXTERNAL_OES Target](https://embt.atlassian.net/servicedesk/customer/portal/1/RSS-1550)
* [Make CanvasHelper of TCanvasGpu public](https://quality.embarcadero.com/browse/RSP-18797)
* [Allow TTexture to Define a Material (GLSL Shader) to Use](https://embt.atlassian.net/servicedesk/customer/portal/1/RSS-1549)
* [dorealign implemented badly](https://quality.embarcadero.com/browse/RSP-15768)
* [On iOS we need to pass options: PNSDictionary with the message TApplicationEvent.FinishedLaunching](https://quality.embarcadero.com/browse/RSP-40351)
* [AVPlayerItem miss the function addOutput](https://quality.embarcadero.com/browse/RSP-16853)
* [CLVisit is missing from the implementation of CLLocationManager](https://quality.embarcadero.com/browse/RSP-18621)
* [Miss kCIInputImageKey in iOSapi.CoreImage.pas](https://quality.embarcadero.com/browse/RSP-19878)
* [Miss some definition in IOSapi.Security](https://quality.embarcadero.com/browse/RSP-20279)
* [Effect ProcessTexture is not working and function TFilter.InputTexture: TTexture do unecessary work](https://quality.embarcadero.com/browse/RSP-20825)
* [TVirtualKeyboardAndroid.GetVirtualKeyboardState not accurate](https://quality.embarcadero.com/browse/RSP-24737)
* [Add NSPersonNameComponents in iOSapi.Foundation.pas](https://quality.embarcadero.com/browse/RSP-28096)
* [Comparison of 2 interfaces result in bad behavior in TCommonCustomForm.SetHovered and similar](https://quality.embarcadero.com/browse/RSP-36612)
* [In android, TFormRender must use JChoreographer_FrameCallback not JRunnable](https://quality.embarcadero.com/browse/RSP-38660)
* [Need JNotificationClass.AUDIO_ATTRIBUTES_DEFAULT and JNotificationChannel.setSound](https://quality.embarcadero.com/browse/RSP-39511)
* [iOS/OSX: Declaration for CLRegion.initCircularRegionWithCenter is incorrect](https://quality.embarcadero.com/browse/RSP-15717)
* [Missing Declaration of maximumFramesPerSecond Function in UIScreen Interface](https://quality.embarcadero.com/browse/RSP-43458)
* [Resolve Circular Reference in JBitmapClass by Refactoring JHardwareBuffer Declaration](https://quality.embarcadero.com/browse/RSP-44100)    
* [Add Missing drawBitmap functions to JRecordingCanvas Interface](https://quality.embarcadero.com/browse/RSP-44102)
* [Miss kCIFormatRGBA8 and kCIFormatBGRA8 in iOSapi.CoreImage.pas](https://quality.embarcadero.com/browse/RSP-44130)
* [Miss UITraitCollection.displayGamut in iOSapi.UIKit.pas](https://quality.embarcadero.com/browse/RSP-44208)
* [Update Pressed Property Setter in TControl to Enhance State Change Tracking](https://embt.atlassian.net/servicedesk/customer/portal/1/RSS-1323)
* [Architectural Issues in FMX.Skia.Canvas.GL](https://embt.atlassian.net/servicedesk/customer/portal/1/RSS-1541)
* [Missing Declaration of CTFontManagerRegisterGraphicsFont in Macapi.CoreText.pas](https://embt.atlassian.net/servicedesk/customer/portal/1/RSS-1929)
* [Request to Add Interfaces and Methods in Macapi.AppKit.pas](https://embt.atlassian.net/servicedesk/customer/portal/1/RSS-1933)
* [Missing Functions in Macapi.CoreText.pas](https://embt.atlassian.net/servicedesk/customer/portal/1/RSS-1934)
* [Missing &string Method in NSAttributedString Interface in Macapi.Foundation.pas](https://embt.atlassian.net/servicedesk/customer/portal/1/RSS-1935)
* [Modify libImageIO Constant in Macapi.ImageIO.pas to Include iOS Support](https://embt.atlassian.net/servicedesk/customer/portal/1/RSS-1936)
* [Missing Functions in Macapi.QuartzCore.pas](https://embt.atlassian.net/servicedesk/customer/portal/1/RSS-1937)
* [Missing CoreText Constant Functions in iOSapi.CoreText.pas](https://embt.atlassian.net/servicedesk/customer/portal/1/RSS-1938)
* [Missing CVMetalTexture and CVMetalTextureCache Declarations in iOSapi.CoreVideo.pas](https://embt.atlassian.net/servicedesk/customer/portal/1/RSS-1939)
* [Missing Method Declarations in UITextView and UITextField Interfaces in iOSapi.UIKit.pas](https://embt.atlassian.net/servicedesk/customer/portal/1/RSS-1941)
* [Incorrect External Declarations in System.Skia.API for Android Linking in Athens 12.2](https://embt.atlassian.net/servicedesk/customer/portal/1/RSS-1997)


Install Alcinoe
---------------

To set up Alcinoe, start by running the [CompileAll.bat](https://github.com/MagicFoundation/Alcinoe/tree/master/CompileAll.bat)
script. This batch file performs a series of tasks, 
including retrieving and patching the original Delphi 
source code, downloading the necessary iOS/Android 
libraries, generating the Alcinoe JAR files, building 
the BPL (Borland Package Library), compiling the tools 
in the [{alcinoe}\Tools](https://github.com/MagicFoundation/Alcinoe/tree/master/Tools/) 
directory, and finally compiling all demos found in the 
[{alcinoe}\Demos](https://github.com/MagicFoundation/Alcinoe/tree/master/Demos/) 
directory. Please note that some demos require 
components from [devexpress](https://www.devexpress.com/).

If you only need to use Alcinoe's non-visual components, 
no further steps are necessary. Simply ensure that 
[{alcinoe}\Source](https://github.com/MagicFoundation/Alcinoe/tree/master/Source) 
is included in your project's search path.

To use Alcinoe's visual components at design time, you 
will need to install the BPL. Open Delphi, go to 
Component > Install Packages..., and select the BPL 
from [{alcinoe}\Libraries\bpl\Alcinoe\Win32\\{YourDelphiVersion}\Alcinoe{YourDelphiVersion}.bpl](https://github.com/MagicFoundation/Alcinoe/tree/master/Libraries/bpl/Alcinoe/Win32). 
Additionally, include both [{alcinoe}\Source](https://github.com/MagicFoundation/Alcinoe/tree/master/Source) 
and all subdirectories from [{alcinoe}\Embarcadero\\{YourDelphiVersion}](https://github.com/MagicFoundation/Alcinoe/tree/master/Embarcadero/) 
in your search path.


Update Alcinoe
--------------

From time to time, we may need to rename units, classes, 
and functions in Alcinoe. To help you automatically update 
these names in your project and stay aligned with the 
latest version of Alcinoe, we provide a tool called 
<b>CodeRenaming</b>. You can find this tool here: [CodeRenaming](https://github.com/MagicFoundation/Alcinoe/tree/master/Tools/CodeRenaming)


Propose a Change on GitHub
--------------------------

If you'd like to suggest changes to the Alcinoe directory, 
please follow these steps:

1. <b>Fork the Alcinoe Repository</b>: First, you'll need 
   to fork the repository. Forking creates a personal copy 
   of the Alcinoe source code that you can modify as needed..  
   
   ![Fork](https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/createfork.jpg?raw=true)

2. <b>Make Your Edits</b>: After forking, make the necessary 
   changes to the source code. Then, commit and push these 
   changes to your forked repository.

3. <b>Submit a Pull Request</b>: Once you're happy with your 
   changes, go to your forked repository, click on 'Contribute,' 
   and select 'Open a pull request' to submit your proposal.
   
   ![Contribute](https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/openpullrequest.jpg?raw=true)
<br/>


About Skia
==========

Skia is an open-source 2D graphics library that powers 
the graphics engine used by Flutter and the Android 
operating system. The implementation of Skia in Delphi 
marked a significant advancement for the FireMonkey 
framework, as it greatly surpasses the legacy Delphi 
TCanvasGPU graphics engine in nearly every aspect.

#### Key Advantages of Skia: ####

* <b>Solid Graphics Foundation</b>: Since Skia is the 
  same graphics engine used by Flutter, apps built 
  with Flutter or Delphi + Skia share the same 
  foundational graphics technology.
* <b>Performance</b>: The Skia algorithms are optimized 
  to the extent that they can often render directly 
  onto the form surface without requiring an 
  internal buffer.
* <b>Cross-Platform Consistency</b>: Skia offers a 
  consistent graphics engine across all platforms 
  (Windows, iOS, macOS, Android).
* <b>Rich Features</b>: Skia provides powerful capabilities 
  typical of a robust graphics engine, including 
  advanced text formatting and shadow rendering.

#### Drawbacks of Skia: ####

* <b>Increased Package Size</b>: Adding Skia increases 
  the package size by approximately 25 MB.
* <b>Dependency on Google</b>: Skia is a Google product, 
  and while Embarcadero has traditionally focused on 
  offering an independent product free from GAFA domination, 
  using Skia introduces a dependency on Google's technology.
* <b>OpenGL Limitations</b>: Under OpenGL, only raster 
  images (CPU) can be shared across different threads. 
  This means that GPU textures cannot be created in 
  background threads and later drawn on the main form 
  surface. Interestingly, there seems to be no noticeable 
  speed improvement when drawing GPU images compared to 
  raster images.
* <b>Image Rendering Performance</b>: While Skia excels 
  at drawing shapes directly on the form surface, it is 
  notably slower (4x more slower) than the legacy Delphi 
  canvas (TCanvasGPU) when rendering images onto the form.

#### Performance Challenges with Skia: ####

The slower image rendering is particularly problematic in 
scenarios where we paint everything first onto an internal 
buffer and then render that buffer to the form surface on 
each paint loop—a technique often used to avoid flickering 
and improve performance. Unfortunately, Skia can be up to 
4 times slower at drawing images onto the form surface 
compared to the legacy Delphi TCanvasGPU, which uses 
OpenGL textures.

For example, on a Google Pixel 7, I can render 2000 textures 
simultaneously at 90 FPS using TCanvasGPU. However, with 
Skia, I can only render 500 images at the same frame rate. 
You can verify this using the demo app located at 
[{alcinoe}/Demos/ALFmxGraphics](https://github.com/MagicFoundation/Alcinoe/tree/master/Demos/ALFmxGraphics).

#### The Chosen Approach: ####

Given these limitations, I’ve decided to use Skia as the 
backend graphics engine in Alcinoe while continuing to 
use the legacy Delphi canvas (TCanvasGPU) for rendering 
on the main form surface. The exception is on Windows, 
where we use Skia for both the backend and the main 
form surface.

#### Platform-Specific Considerations: ####

On Android and iOS, the operating systems already provide 
powerful graphics APIs, and in many cases, these native APIs 
outperform Skia—often by as much as 2x. While the performance 
of the OS graphics APIs is superior, Skia still offers the 
benefit of a unified graphics engine across all platforms, 
along with additional features like animated images.
<br/>
<br/>
  

Material 3 Controls for Delphi: A Modern UI Approach
====================================================

In recent years, Material Design has emerged as a guiding design 
language for developers creating modern, user-friendly, and 
visually appealing applications. With the release of Material You 
(Material Design 3), Google has taken a step further by allowing 
greater personalization and a more dynamic appearance. Developers 
using Delphi can now leverage Material 3 principles to create 
stunning, cohesive interfaces across platforms like Android, iOS, 
Windows, and macOS.

<img src="https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/material3design.jpg?raw=true" />

## Key Alcinoe Controls for Material 3 Design

### 1. **TALButton**
TALButton offers full customization for states such as Enabled, 
Pressed, and Disabled, allowing for modern Material 3 button 
styles. You can adjust properties like fill, border, shadow, and 
font to match Material 3’s bold, clear design principles. It 
supports HTML content, enabling you to easily include icons or 
rich text.

<img src="https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/material3button.png?raw=true" />

### 2. **TALCheckBox and TALRadioButton**
Both controls follow Material 3’s minimalistic and responsive 
design. They include customizable properties for checkmark, 
border, and shadow and utilize smooth transitions between states. 
Their highly customizable nature allows you to create checkbox 
and radio button components that align with Material 3’s aesthetic.

<img src="https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/material3checkbox.png?raw=true" width="600" style="width:600px;" />

### 4. **TALSwitch**
TALSwitch is designed for easy customization, allowing you to 
control the design of the switch in states such as **Enabled**, 
**Hovered**, **Focused**, **Pressed**, and **Disabled**. The 
control provides smooth, responsive transitions between on and 
off states, reflecting the fluid, adaptable nature of 
Material 3’s switches. The customizable design ensures that 
TALSwitch fits seamlessly into a modern, minimalistic interface, 
offering both visual appeal and optimized performance for 
Delphi applications.

<img src="https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/material3switch.gif?raw=true" />

### 3. **TALTrackBar and TALRangeTrackBar**
TALTrackBar allows for extensive customization of its appearance 
and behavior, making it an ideal choice for implementing Material 3’s 
clean and modern slider design. You can easily customize the track and 
thumb with properties such as **fill**, **stroke**, and **shadow** to 
achieve the sleek, minimalistic look that defines Material 3. The 
slider's interactions, including value indicators and stop indicators, 
are smooth, ensuring responsive feedback as the user interacts with the 
control. Its transitions between states like **Enabled**, **Focused**, 
and **Pressed** contribute to a polished, fluid user experience.

<img src="https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/material3trackbar.gif?raw=true" />

### 4. **TALEdit and TALMemo**
Alcinoe’s native TALEdit and TALMemo controls are designed to 
match Material 3’s input fields, offering customizable border, 
shadow, and font properties. These controls adapt across platforms 
while maintaining a consistent, clean interface for text input, 
with features like autosizing and prompt text.

<img src="https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/material3edit.webp?raw=true" />

## Why Alcinoe for Material 3?
While Material 3 focuses on responsive and adaptive design, 
performance is equally important. Alcinoe’s double-buffered 
rendering ensures that your controls are fast and fluid, 
even during complex UI interactions like scrolling. This 
performance boost aligns perfectly with Material 3’s goal 
of seamless, responsive user interfaces.

Incorporating Alcinoe in your Delphi projects allows you to 
create modern, high-performance apps with a polished 
Material 3 appearance, without compromising on speed or 
cross-platform compatibility.

Learn more at [{alcinoe}/Demos/ALFmxControls](https://github.com/MagicFoundation/Alcinoe/tree/master/Demos/ALFmxControls)
<br/>
<br/>
  

High-Performance Text Control with HTML Formatting and Interactive Capabilities
===============================================================================

TALText is a powerful component similar to TText, but with 
enhanced capabilities, such as support for basic HTML text 
formatting. Despite integrating HTML formatting, TALText 
offers significant performance improvements over TText. 
This is achieved through its use of a double-buffered engine, 
which renders the text on an internal buffer and then 
draws only this buffer onto the form during each paint cycle. 
This design makes TALText extremely fast and efficient. 
Additionally, TALText extends its functionality by 
supporting mouse event handling that can detect the 
specific HTML elements (e.g., span ID and bounds) under 
the mouse pointer. This feature allows for interactive 
text elements, making it perfect for applications requiring 
responsive, dynamic text behavior. Learn more at 
[{alcinoe}/Demos/ALFmxControls](https://github.com/MagicFoundation/Alcinoe/tree/master/Demos/ALFmxControls)

<img src="https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/htmltext.png?raw=true" />
<br/>
  
Video Player for FireMonkey
===========================

ALVideoPlayer renders video to a texture, which is 
important for integrating the video into a Delphi form and 
supporting Z-ORDER for placing controls on top of it. 
Official Delphi video players are just native video player 
windows on top of the form and do not support Z-ORDER.

For Android, Alcinoe uses ExoPlayer, which supports 
features such as dynamic adaptive streaming over 
HTTP (DASH), HLS, SmoothStreaming, and common encryption 
that are not supported by MediaPlayer. ExoPlayer is 
designed to be easy to customize and extend. For iOS, I use 
AVPlayer with support for HLS, similar to ExoPlayer.

<p align="left">
  <img src="https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/videoplayer1.jpg?raw=true" alt="video player for FireMonkey" width="270" style="width:270px;"/>
  <img src="https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/videoplayer1.jpg?raw=true" alt="video player for FireMonkey" width="270" style="width:270px;"/>
  <img src="https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/videoplayer1.jpg?raw=true" alt="video player for FireMonkey" width="270" style="width:270px;"/>
</p>

Learn more at [{alcinoe}/Source/Alcinoe.FMX.VideoPlayer.pas](https://github.com/MagicFoundation/Alcinoe/tree/master/Source/Alcinoe.FMX.VideoPlayer.pas) and you can also start exploring this feature 
with the demo located at [{alcinoe}/Demos/ALFmxControls](https://github.com/MagicFoundation/Alcinoe/tree/master/Demos/ALFmxControls) 
<br/>
<br/>


WebRTC Delphi Wrapper
=====================

WebRTC (Web Real-Time Communications) is a technology which 
enables Web applications and sites to capture and optionally 
stream audio and/or video media, as well as to exchange arbitrary 
data between browsers and mobile applications without requiring 
an intermediary. The set of standards that comprises WebRTC 
makes it possible to share data and perform teleconferencing 
peer-to-peer, without requiring that the user installs plug-ins 
or any other third-party software.

<p align="center">
  <img src="https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/webrtc.jpg?raw=true" alt="Delphi WebRTC wrapper" />
</p>

With the TALWebRTC component, you can easily incorporate video 
and audio chat into your applications, giving your users a more 
interactive and immersive experience! Learn more at 
[{alcinoe}/Demos/ALLiveVideoChat](https://github.com/MagicFoundation/Alcinoe/tree/master/Demos/ALLiveVideoChat)
<br/>
<br/>
  
  
Confetti Falling Animation
==========================

ALConfetti is a lightweight and highly efficient Delphi 
library designed to create a visually appealing, customizable 
confetti falling animation. Built for performance and 
flexibility, it allows developers to easily adjust parameters 
like speed, size, and color, ensuring seamless integration 
into any project. Whether for celebrations, notifications, 
or dynamic visual effects, ALConfetti delivers a smooth, 
high-performance animation experience. Learn more at 
[{alcinoe}/Demos/ALConfetti](https://github.com/MagicFoundation/Alcinoe/tree/master/Demos/ALConfetti)

<img src="https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/confetti.gif?raw=true" alt="confetti" width="564" style="width:564px;" />
<br/>
  
  
AndroidMerger: Integrate AAR SDK in FMX Android App
===================================================
                                 
<img src="https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/androidmerger.jpg?raw=true"/>

An Android library, also called as Android Archive, includes 
everything you need to build an app like source files, 
resource files, manifest etc. This is the reason why AARs are 
different from JARs. AARs can contain resource files as well 
other than compiled byte code. 

Adding such library to Delphi project is long and convoluted 
process consisting of extracting resources from library, 
manually adding them to Delphi deployment files, compiling 
R.Java class, checking dependancies, etc.

With AndroidMerger all of the above can now be done 
automatically in a single command line. In brief 
AndroidMerger will:
 
* Use graddle or internal implementation to list all dependencies.
* Download libraries and dependancies from local or central maven repository.
* Merge the resources of all AARs inside a single directory.
* Merge the AndroidManifest files of all AARs inside AndroidManifest.template.xml.
* Merge google-services.json in the resources of the project.
* Create the R.jar with all resource IDs using aapt or aapt2.
* Update the project file (.dproj) to include all resources.
* Generate the Delphi native bridge file from the Java libraries.

Learn more at [{alcinoe}/Tools/AndroidMerger](https://github.com/MagicFoundation/Alcinoe/tree/master/Tools/AndroidMerger)
<br/>
<br/>
  

DeployMan/DeployProjNormalizer/DProjNormalizer
==============================================
                                 
DeployMan, DeployProjNormalizer, and DProjNormalizer are essential tools 
for managing Delphi app deployments. DeployMan greatly simplifies the 
deployment of files and folders for iOS and Android apps, ideal for 
handling extensive files like 3rd party SDKs (learn more at [{alcinoe}/Tools/DeployMan](https://github.com/MagicFoundation/Alcinoe/tree/master/Tools/DeployMan)). 
DeployProjNormalizer allows you to create a new deployproj file from 
scratch using the dproj as a reference and normalizes it by ordering 
the nodes, facilitating the comparison of different revisions with diff 
tools (learn more at [{alcinoe}/Tools/DeployProjNormalizer](https://github.com/MagicFoundation/Alcinoe/tree/master/Tools/DeployProjNormalizer)). 
Lastly, DProjNormalizer orders the nodes in a DProj file to maintain consistency 
across commits, simplifying the task of comparing differences 
(learn more at [{alcinoe}/Tools/DProjNormalizer](https://github.com/MagicFoundation/Alcinoe/tree/master/Tools/DProjNormalizer). 
<br/>
<br/>
  

Interpolated Animation
======================

The TALAnimation component is a refined iteration of Delphi's foundational
TAnimation object, meticulously tailored for mobile platforms. By forgoing the
traditional Timer mechanism and instead adopting platform-specific technologies,
this component offers a vastly improved animation experience for mobile users.
On Android, animations are seamlessly integrated with the Choreographer,
ensuring they sync perfectly with the device's refresh rate. Meanwhile, on iOS,
the precision of DisplayLink is harnessed, leading to optimized and fluid
animation rendering. Beyond these foundational changes, one of the most notable
enhancements is the capability to support custom interpolation algorithms. This
offers developers the flexibility to design unique and intricate animation
patterns, moving beyond the traditional ease-in or ease-out sequences.

<p align="left">
  <img src="https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/interpolated1.gif?raw=true" alt="Interpolated Animation" width="320" style="width:320px;"/>
  &nbsp;&nbsp;&nbsp;
  <img src="https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/interpolated2.gif?raw=true" alt="Interpolated Animation" width="320" style="width:320px;"/>
</p>

Learn more at 
[{alcinoe}/Demos/ALAnimation](https://github.com/MagicFoundation/Alcinoe/tree/master/Demos/ALAnimation)
<br/>
<br/>
  
  
SpringForce Animation
=====================

<img src="https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/springforce.gif?raw=true" alt="SpringForce Animation" align="left" width="320" height="711" />
<img src="https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/empty.png?raw=true" align="left" width="1" height="711" />
  
Inspired by Android's SpringForce, the TALSpringForceAnimation Component brings
the intrigue of physics-based animations to the Delphi platform. This component
captures the real-world dynamism of objects influenced by spring mechanics. The
resulting animations are ones that stretch, bounce, and settle, mirroring
real-world behaviors and offering a tangible sense of realism to users.
Developers have the added advantage of being able to adjust various physical
properties of the spring, such as its stiffness and damping ratio. This ensures
that a broad spectrum of animation behaviors can be realized, catering to the
specific nuances of different applications.

Learn more at 
[{alcinoe}/Demos/ALAnimation](https://github.com/MagicFoundation/Alcinoe/tree/master/Demos/ALAnimation)

<br clear="left"/>
<br/>
  
  
Scrolling Engine
================

<img src="https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/scrollingengine.gif?raw=true" alt="Scrolling Engine" align="right" width="222" height="480" />
<img src="https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/empty.png?raw=true" align="right" width="32" height="480" />
  
TALOverScroller and TALVelocityTracker are essential components of the
TALScrollEngine, playing crucial roles in refining user interface interactions.
While TALOverScroller is designed to animate and manage actions like scrolling
and flinging, offering a decelerating animation as users scroll past a view's
edge to indicate the boundary, TALVelocityTracker measures the velocity of
touch events, helping to determine the speed and direction of user gestures.
Together within the TALScrollEngine, they elevate the overall user experience
by offering smooth animations and intuitive touch feedback.

Building a scrolling engine is a complex endeavor, requiring expertise in
various domains, including physics. Rather than starting from scratch and
potentially reinventing the wheel, we looked towards proven solutions. To this
end, we utilized the robust and well-tested code from Android's VelocityTracker
and OverScroller. By translating their Java and C++ codes into Delphi, we've
ensured that the resultant TALScrollEngine not only meets but exceeds the
standard for scrolling dynamics. Leveraging the reliability and efficiency of
Android's scrolling mechanisms, the TALScrollEngine offers Delphi developers a
top-notch scrolling experience, rooted in established and trusted technologies.

Learn more at 
[{alcinoe}/Demos/ALFmxControls](https://github.com/MagicFoundation/Alcinoe/tree/master/Demos/ALFmxControls)

<br clear="right"/>
<br/>
  

Firebase cloud messaging
========================

Delphi implementation of the latest version of Firebase 
cloud messaging (FCM) with HTTP V1 protocol that will 
permit you to send alert notifications with images in 
Android and iOS. Learn more at 
[{alcinoe}\Demos\ALNotificationService](https://github.com/MagicFoundation/Alcinoe/tree/master/Demos/ALNotificationService)
<br/>
<br/>


GeoPositioning for Android/iOS
==============================

The TALGeoPositionSensor component is a Delphi component that grants access to
location services on iOS and Android devices. It enables the retrieval of the
device's current location, and can provide location updates as the device's
location changes. It supports a range of location providers, including GPS,
cellular network triangulation, and Wi-Fi positioning.

Aside from granting access to location services, TALGeoPositionSensor also
automates the process of acquiring the user's permission to use the location
sensor on both iOS and Android devices. The component can handle situations
where the user has previously refused access to their location. The
TALGeoPositionSensor component provides a comprehensive solution for developers
seeking to integrate location-based functionality into their apps without
having to worry about low-level implementation details. Learn more at 
[{alcinoe}\Demos\ALGeoPositionSensor](https://github.com/MagicFoundation/Alcinoe/tree/master/Demos/ALGeoPositionSensor)
<br/>
<br/>
  

Google OAuth 2.0 Access Token
=============================

Google APIs use the OAuth 2.0 protocol for authentication 
and authorization. You can use the function 
ALGenerateGoogleOAuth2AccessToken to generate an OAuth 2.0 
Access Token. Learn more at 
[{alcinoe}/Source/Alcinoe.Cipher.pas](https://github.com/MagicFoundation/Alcinoe/tree/master/Source/Alcinoe.Cipher.pas) 
<br/>
<br/>
  

Android/iOS VKontakte/Facebook SDK login
========================================

The VKontakte/Facebook SDK for Android enables users to 
sign into your app using VKontakte/Facebook Login. Once 
logged in, users can grant permissions to your app, 
allowing you to retrieve information or perform actions on 
VKontakte/Facebook on their behalf. Learn more at 
[{alcinoe}\Demos\ALFacebookLogin](https://github.com/MagicFoundation/Alcinoe/tree/master/Demos/ALFacebookLogin)
<br/>
<br/>
  

Photo Editor Filters for Android/iOS
====================================

With TALColorAdjustEffect, you can apply gorgeous photo 
filters that enhance your images with just one tap. Make 
your photos beautiful and expressive in just minutes! 
Learn more at [{alcinoe}\Demos\ALFmxFilterEffects](https://github.com/MagicFoundation/Alcinoe/tree/master/Demos/ALFmxFilterEffects)

<p align="left">
  <img src="https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/imagefilter1.jpg?raw=true" width="320" style="width:320px;"/>
  &nbsp;&nbsp;&nbsp;
  <img src="https://raw.githubusercontent.com/MagicFoundation/Alcinoe/Skia/References/DocImages/imagefilter2.jpg?raw=true" width="320" style="width:320px;"/>
</p>
<br/>
  
  
Json Parser
===========

TALJSONDocument is a Delphi parser/writer for JSON/BSON 
data formats. It supports both DOM and SAX parsers. (Note 
that a better name for SAX could be SAJ for Simple API for 
JSON instead of Simple API for XML, but as the concept of 
SAX is well-known, I will keep this name.) TALJSONDocument 
also supports BSON format and uses a syntax similar to 
TALXMLDocument/TXMLDocument. Additionally, TALJSONDocument 
can export Json/Bson data to TALStringList.

Example :

```
    {
      _id: 1, // comments
      name: { first: "John", last: "Backus" },
      birth: new Date('1999-10-21T21:04:54.234Z'),
      contribs: [ "Fortran", "ALGOL", "Backus-Naur Form", "FP" ],
      awards: [
                { award: "National Medal of Science",
                  year: 1975,
                  by: "National Science Foundation" },
                { award: "Turing Award",
                  year: 1977,
                  by: "ACM" }
              ],
      spouse: "",
      address: {},
      phones: []
    }
```

To access the document nodes :

```
    MyJsonDoc.GetChildNodeValueInt32('_id', 0{default if node not exists});
    MyJsonDoc.GetChildNodeValueText(['name','first'], ''{default if node not exists});
    MyJsonDoc.GetChildNodeValueDateTime('birth', Now{default if node not exists});
```

Learn more at [{alcinoe}/Source/Alcinoe.JSONDoc.pas](https://github.com/MagicFoundation/Alcinoe/tree/master/Source/Alcinoe.JSONDoc.pas)
<br/>
<br/>
  

ImageMagick wrapper for Delphi
==============================

Use ImageMagick® to create, edit, compose, or convert bitmap 
images. It can read and write images in a variety of formats 
(over 200) including PNG, JPEG, GIF, HEIC, TIFF, DPX, EXR, 
WebP, Postscript, PDF, and SVG. Use ImageMagick to resize, 
flip, mirror, rotate, distort, shear and transform images, 
adjust image colors, apply various special effects, or draw 
text, lines, polygons, ellipses and Bézier curves.

Example :

```
    var LWand: PMagickWand;
    begin
    
      //Create the ImageMagick Library
      alCreateImageMagickLibrary({alcinoe} + '\Libraries\dll\imagemagick\win32\imagemagick', min(2, System.CPUCount){aThreadLimit});
      try
      
        //create the wand pointer
        LWand := ALImageMagickLib.NewMagickWand;
        try
      
          //load the image
          if ALImageMagickLib.MagickReadImage(LWand, pansiChar(aInputFilename)) <> MagickTrue then RaiseLastMagickWandError(LWand);
          
          //Set the compression quality
          if ALImageMagickLib.MagickSetImageCompressionQuality(LWand,80) <> MagickTrue then RaiseLastMagickWandError(LWand);
      
          //autorate the image
          if ALImageMagickLib.MagickAutoOrientImage(LWand) <> MagickTrue then RaiseLastMagickWandError(LWand);
      
          //Resize the image using the Lanczos filter
          if ALImageMagickLib.MagickResizeImage(LWand, 640, 480, LanczosFilter) <> MagickTrue then RaiseLastMagickWandError(LWand);
             
          //save the image
          ALImageMagickLib.MagickWriteImage(LWand, pansiChar(aOutputFilename));
      
        finally
          ALImageMagickLib.DestroyMagickWand(LWand);
        end;
    
      finally
        alFreeImageMagickLibrary;
      end;

    end;
```

Learn more at [{alcinoe}/Source/Alcinoe.ImageMagick.pas](https://github.com/MagicFoundation/Alcinoe/tree/master/Source/Alcinoe.ImageMagick.pas)
<br/>
<br/>
  

Streamlining Object Initialization with TALInit
===============================================

In the constant evolution of software development, we often find ourselves
seeking ways to reduce boilerplate code and enhance the maintainability of our
projects. One such instance where boilerplate can become cumbersome is in the
initialization of class fields. The traditional method involves explicitly
setting each field's value in the constructor, which can be tedious, especially
for classes with numerous fields. Enter TALInit—a feature that allows
automatic initialization of object fields based on their attributes.

#### The Traditional Way ####

In the typical approach, developers manually initialize object fields in the
constructor. Take the following class as an example:

```
    TAutoInitObject = class(TObject)
    public
      CharValue: Char;
      ChildObject: TChildObject;
    public
      constructor Create; virtual;
      destructor Destroy; override;
    End;
```

Here, each field is initialized in the Create constructor:

```
  constructor TAutoInitObject.create(const aOwner: Tform1; const AAutoInit: Boolean);
  begin
    CharValue := 'A';
    ChildObject := TChildObject.create;
    ChildObject.Name := 'AnObject';
    ChildObject.Value := 12.2;
  end;

  destructor TAutoInitObject.Destroy;
  begin
    ALFreeandNil(ChildObject);
    inherited;
  end;
```

While this method offers precise control, it can become tedious for large
classes with numerous fields.

#### The TALInit Way ####

Imagine having a mechanism that not only automates this but is also as fast as
the traditional way - yes, you read that right. TALInit achieves this
remarkable feat.

```
  TAutoInitObject = class(TObject)
  public
    [TALInit('A')]
    CharValue: Char;
    [TALInit('Name:AnObject;Value:12.2')]
    ChildObject: TChildObject;
  End;
```

By using custom attributes, every field within the object can be automatically
initialized based on its corresponding attribute. This eliminates the need for
manually setting each field within the constructor. The above snippet showcases
just how concise and readable object field initialization can become with
TALInit.

#### Performance - A Game Changer: ####

One of the strongest advantages of using TALInit is its performance. When
introducing automation, a natural concern is the overhead that might come with
it. However, TALInit is designed to be as efficient as the traditional way
of initializing fields. This means developers can enjoy the convenience
without having to worry about any hidden costs in execution time.

Learn more at [{alcinoe}/Alcinoe/tree/master/Demos/ALRTTI](https://github.com/MagicFoundation/Alcinoe/tree/master/Demos/ALRTTI)
<br/>
<br/>


MongoDb client
==============

This is a Delphi driver (with connection pooling) for 
accessing a MongoDB server. Connection pooling is a cache 
of database connections that are maintained so that they 
can be reused when future requests to the database are 
required. After a connection is created in connection 
pooling, it is placed in the pool and is used over again so 
that a new connection does not have to be established. If 
all the connections are being used, a new connection is 
made and added to the pool. Connection pooling also reduces 
the amount of time a user must wait to establish a 
connection to the database. Learn more at 
[{alcinoe}/Source/Alcinoe.MongoDB.Client.pas](https://github.com/MagicFoundation/Alcinoe/tree/master/Source/Alcinoe.MongoDB.Client.pas)
<br/>
<br/>
  

WebSocket client
================

The WebSocket client for Delphi is implemented on top of 
WinHTTP. WebSocket is a communication protocol that enables 
two-way interactive communication sessions between a user's 
browser and a server. This allows you to send messages to a 
server and receive event-driven responses without having to 
poll the server for a reply. Learn more at 
[{alcinoe}\Demos\ALWinHTTPWebSocketClient](https://github.com/MagicFoundation/Alcinoe/tree/master/Demos/ALWinHTTPWebSocketClient)
<br/>
<br/>
  

Fast TStringList
================

TALStringList works the same as Delphi's TStringList, 
except that it allows you to search for a name=value 
using a quicksort algorithm when the list is sorted. 
Additionally, TALStringList uses a locale-independent 
algorithm (based on the 8-bit ordinal value of each 
character) instead of the AnsiCompareText and 
AnsiCompareStr used by Delphi's TStringList. As a 
result, sorting in TALStringList is up to 10 times 
faster than in Delphi's TStringList. Furthermore, 
TALStringList is not a Unicode TStringList, but a 100% 
Ansi StringList. You can start exploring this feature 
with the demo located at 
[{alcinoe}\Demos\ALSortedListBenchmark](https://github.com/MagicFoundation/Alcinoe/tree/master/Demos/ALSortedListBenchmark)
<br/>
<br/>


PHP runner
==========

ALPHPRunnerEngine is a simple yet useful component that 
allows you to easily use PHP (any version) as a scripting 
language in Delphi applications. With ALPhpRunnerEngine, 
you can execute PHP scripts within the Delphi program 
without the need for a web server. The component uses 
the CGI/FastCGI interface (php-cgi.exe) of PHP to 
communicate with the PHP engine. Learn more at 
[{alcinoe}\Demos\ALPhpRunner](https://github.com/MagicFoundation/Alcinoe/tree/master/Demos/ALPhpRunner)
<br/>
<br/>
  

Memcached Client
================

What is Memcached? Free & open source, high-performance,
distributed memory object caching system, generic in
nature, but intended for use in speeding up dynamic web
applications by alleviating database load. Learn more at 
[{alcinoe}/Source/Alcinoe.MemCached.Client.pas](https://github.com/MagicFoundation/Alcinoe/tree/master/Source/Alcinoe.MemCached.Client.pas)
<br/>
<br/>
  

GSM component
=============

The TAlGSMComm component allows you to implement SMS text 
messaging using the text-mode interface defined in the GSM 
Technical Specification 07.05. Learn more at 
[{alcinoe}/Source/Alcinoe.GSMComm.pas](https://github.com/MagicFoundation/Alcinoe/tree/master/Source/Alcinoe.GSMComm.pas)
<br/>
<br/>
  

SQLite3 Client
==============

Query the SQLite3 database and get the results in XML format
or in JSON/BSON format. Learn more at 
[{alcinoe}/Source/Alcinoe.Sqlite3.Client.pas](https://github.com/MagicFoundation/Alcinoe/tree/master/Source/Alcinoe.Sqlite3.Client.pas)
<br/>
<br/>
  

And much more
=============

* CGI runner 
* Http Client (WinInet/WinHTTP)
* MySQL Client 
* NNTP Client
* POP3 Client
* SMTP Client
* Xml Parser 
* etc ...
<br/>
<br/>


DELPHI D2009+ (UNICODE)
=======================

No mistake, Unicode was necessary for a product like Delphi. 
However, the way Embarcadero decided to implement it is 
questionable. They chose to migrate from 8-bit strings to 
16-bit strings instead of implementing Unicode through 
8-bit strings (UTF-8). This made the migration of some 
Delphi applications prior to D2009 very difficult, especially 
for applications that assumed that strings were 8-bit. 
Here's a very good article about why you should avoid 
using UTF-16: [utf8everywhere.org](http://www.utf8everywhere.org/)

Starting with D2009, AnsiString now has a codepage, 
and some transliteration (OldCodePage => UTF-16 => 
NewCodePage) will occur when assigning one AnsiString 
with a different codepage to another AnsiString with 
a different codepage. To avoid this, it's important to 
always set the project option to the code page you want 
(e.g., 65001 for UTF-8) and also to call 
SetMultiByteConversionCodePage(CP_UTF8) at the beginning 
of the program. Additionally, it's crucial to avoid using 
two different string types (e.g., UTF8String and 
AnsiString) even if they have the same codepage because 
the compiler, at compile time, doesn't know that the 
codepage is the same and will do a transliteration 
(e.g., MyAnsiStringUTF8 := MyUTF8String will result in 
UTF-8 => UTF-16 => UTF-8). This is why we use only 
AnsiString in all our code instead of UTF8String (even 
when we assume that the string contains only UTF-8 
characters) to avoid these transliterations. Always follow 
the rule of using only AnsiString with 
SetMultiByteConversionCodePage(CP_UTF8).
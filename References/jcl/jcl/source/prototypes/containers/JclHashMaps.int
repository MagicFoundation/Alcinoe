(*$JPPDEFINEMACRO JCLHASHMAPTYPESINT(ENTRYTYPENAME, ENTRYARRAYTYPENAME, BUCKETTYPENAME, KEYTYPENAME, VALUETYPENAME)
ENTRYTYPENAME = record
  Key: KEYTYPENAME;
  Value: VALUETYPENAME;
end;

ENTRYARRAYTYPENAME = array of ENTRYTYPENAME;

BUCKETTYPENAME = class
public
  Size: Integer;
  Entries: ENTRYARRAYTYPENAME;
  {$JPPUNDEF GENERIC}{$JPPUNDEF REFCOUNTED}{$IFDEF KEYREFCOUNTED}{$JPPDEFINE REFCOUNTED}{$ENDIF}{$IFDEF VALUEREFCOUNTED}{$JPPDEFINE REFCOUNTED}{$ENDIF}{$IFDEF KEYZEROINIT}{$JPPDEFINE ZEROINIT}{$ENDIF}{$IFDEF VALUEZEROINIT}{$JPPDEFINE ZEROINIT}{$ENDIF}{$JPPEXPANDMACRO MOVEARRAYINT(MoveArray,ENTRYARRAYTYPENAME,)}
end;*)
(*$JPPDEFINEMACRO JCLHASHMAPINT(BUCKETTYPENAME, SELFCLASSNAME, ANCESTORNAME, MAPINTERFACENAME, KEYSETINTERFACENAME, KEYCOLLECTIONINTERFACENAME, VALUECOLLECTIONINTERFACENAME,
  INTERFACEADDITIONAL, SECTIONADDITIONAL, KEYOWNERSHIPDECLARATION, VALUEOWNERSHIPDECLARATION,
  KEYCONSTKEYWORD, KEYTYPENAME, VALUECONSTKEYWORD, VALUETYPENAME)
SELFCLASSNAME = class(ANCESTORNAME, {$IFDEF THREADSAFE} IJclLockable, {$ENDIF THREADSAFE}
  IJclIntfCloneable, IJclCloneable, IJclGrowable, IJclPackable, IJclBaseContainer,INTERFACEADDITIONAL
  MAPINTERFACENAME)SECTIONADDITIONAL
private
  FBuckets: array of BUCKETTYPENAME;
  FHashToRangeFunction: TJclHashToRangeFunction;
protected
  procedure AssignDataTo(Dest: TJclAbstractContainerBase); override;
  procedure AssignPropertiesTo(Dest: TJclAbstractContainerBase); override;
public
  constructor Create(ACapacity: IntegerVALUEOWNERSHIPDECLARATIONKEYOWNERSHIPDECLARATION);
  destructor Destroy; override;
  property HashToRangeFunction: TJclHashToRangeFunction read FHashToRangeFunction write FHashToRangeFunction;
  { IJclPackable }
  procedure Pack; override;
  procedure SetCapacity(Value: Integer); override;
  { MAPINTERFACENAME }
  procedure Clear;
  function ContainsKey(KEYCONSTKEYWORDKey: KEYTYPENAME): Boolean;
  function ContainsValue(VALUECONSTKEYWORDValue: VALUETYPENAME): Boolean;
  function Extract(KEYCONSTKEYWORDKey: KEYTYPENAME): VALUETYPENAME;
  function GetValue(KEYCONSTKEYWORDKey: KEYTYPENAME): VALUETYPENAME;
  function IsEmpty: Boolean;
  function KeyOfValue(VALUECONSTKEYWORDValue: VALUETYPENAME): KEYTYPENAME;
  function KeySet: KEYSETINTERFACENAME;
  function Keys: KEYCOLLECTIONINTERFACENAME;
  function MapEquals(const AMap: MAPINTERFACENAME): Boolean;
  procedure PutAll(const AMap: MAPINTERFACENAME);
  procedure PutValue(KEYCONSTKEYWORDKey: KEYTYPENAME; VALUECONSTKEYWORDValue: VALUETYPENAME);
  function Remove(KEYCONSTKEYWORDKey: KEYTYPENAME): VALUETYPENAME;
  function Size: Integer;
  function Values: VALUECOLLECTIONINTERFACENAME;
end;*)

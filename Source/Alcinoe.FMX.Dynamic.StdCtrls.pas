unit Alcinoe.FMX.Dynamic.StdCtrls;

interface

{$I Alcinoe.inc}

uses
  System.Classes,
  System.Types,
  System.UITypes,
  System.Math,
  System.Messaging,
  FMX.types,
  FMX.stdActns,
  FMX.Controls,
  FMX.Graphics,
  Alcinoe.Common,
  Alcinoe.FMX.CacheEngines,
  Alcinoe.FMX.BreakText,
  Alcinoe.FMX.Ani,
  Alcinoe.FMX.Common,
  Alcinoe.fmx.Controls,
  Alcinoe.fmx.Dynamic.Controls,
  Alcinoe.fmx.Dynamic.Common,
  Alcinoe.Fmx.Dynamic.Objects;

{$REGION 'Auto-generated by <ALCINOE>\Tools\CodeBuilder (1)'}

type

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  TALDynamicAniIndicator = class(TALDynamicExtendedControl)
  Public
    type
      // ---------
      // TMotionMode
      TMotionMode = (Frame, Rotate);
      // ----------
      // TAnimation
      TAnimation = class(TALFloatAnimation)
      private
        fOwner: TALDynamicAniIndicator;
        FEnabled: Boolean;
        procedure SetEnabled(const Value: Boolean);
        procedure repaint;
      protected
        procedure DoProcess; override;
        function GetDefaultDuration: Single; override;
        function GetDefaultLoop: Boolean; override;
        function GetDefaultStartValue: Single; override;
        function GetDefaultStopValue: Single; override;
      public
        constructor Create(const AOwner: TALDynamicAniIndicator); reintroduce; virtual;
        procedure Assign(Source: TPersistent); override;
        procedure Start; override;
      public
        property AutoReverse;
        property Delay;
        property Duration;
        property Enabled Read FEnabled write SetEnabled stored true default True;
        property Inverse;
        property Loop;
        property InterpolationType;
        property InterpolationMode;
        property InterpolationParams;
      end;
  private
    FAnimation: TAnimation; // 8 bytes
    FResourceName: String; // 8 bytes
    FTintColorKey: String; // 8 bytes
    FTintColor: TAlphaColor; // 4 bytes
    FFrameCount: Integer; // 4 bytes
    FRowCount: Integer; // 4 bytes
    FCacheIndex: Integer; // 4 bytes
    FCacheEngine: TALBufDrawableCacheEngine; // 8 bytes
    FMotionMode: TMotionMode; // 1 byte
    procedure SetTintColor(const Value: TAlphaColor);
    procedure setTintColorKey(const Value: String);
    procedure SetAnimation(const Value: TAnimation);
    procedure SetResourceName(const Value: String);
    procedure SetMotionMode(const Value: TMotionMode);
    procedure SetFrameCount(const Value: Integer);
    procedure SetRowCount(const Value: Integer);
    function IsTintColorStored: Boolean;
    function IsTintColorKeyStored: Boolean;
  protected
    FBufDrawable: TALDrawable;
    FBufDrawableRect: TRectF;
    procedure ApplyTintColorScheme; virtual;
    function GetCacheSubIndex: Integer; virtual;
    function GetDoubleBuffered: boolean; override;
    function GetDefaultSize: TSizeF; override;
    function GetDefaultTintColor: TAlphaColor; virtual;
    function GetDefaultTintColorKey: String; virtual;
    procedure Paint; override;
    procedure DoResized; override;
  public
    constructor Create(const AOwner: TObject); override;
    destructor Destroy; override;
    procedure BeforeDestruction; override;
    procedure Assign(Source: TALDynamicControl); override;
    procedure ApplyColorScheme; override;
    procedure MakeBufDrawable; override;
    procedure ClearBufDrawable; override;
    property DefaultTintColor: TAlphaColor read GetDefaultTintColor;
    property DefaultTintColorKey: String read GetDefaultTintColorKey;
    // CacheIndex and CacheEngine are primarily used in TALDynamicListBox to
    // prevent duplicate drawables across multiple identical controls.
    // CacheIndex specifies the slot in the cache engine where an existing
    // drawable can be retrieved.
    property CacheIndex: Integer read FCacheIndex write FCacheIndex;
    // CacheEngine is not owned by the current control.
    property CacheEngine: TALBufDrawableCacheEngine read FCacheEngine write FCacheEngine;
  public
    //property Action;
    property Align;
    property Animation: TAnimation read fAnimation write SetAnimation;
    //**property Anchors;
    //property AutoSize;
    //property CanFocus;
    //property CanParentFocus;
    //property DisableFocusEffect;
    property ClickSound;
    //property ClipChildren;
    //property ClipParent;
    property Cursor;
    //property DoubleBuffered;
    //**property DragMode;
    //**property EnableDragHighlight;
    property Enabled;
    property Height;
    //property Hint;
    //property ParentShowHint;
    //property ShowHint;
    property HitTest;
    //**property Locked;
    property Margins;
    property Opacity;
    property Padding;
    //**property PopupMenu;
    //**property Position;
    property ResourceName: String read FResourceName write SetResourceName;
    property MotionMode: TMotionMode read FMotionMode write SetMotionMode default TMotionMode.Rotate;
    property FrameCount: Integer read FFrameCount write SetFrameCount default 1;
    property RowCount: Integer read FRowCount write SetRowCount default 1;
    property RotationAngle;
    //property RotationCenter;
    property Pivot;
    property Scale;
    //**property Size;
    //property TabOrder;
    //property TabStop;
    property TintColor: TAlphaColor read FTintColor write SetTintColor stored IsTintColorStored;
    property TintColorKey: String read FTintColorKey write setTintColorKey Stored IsTintColorKeyStored;
    property TouchTargetExpansion;
    property Visible;
    property Width;
    //property OnCanFocus;
    //**property OnDragEnter;
    //**property OnDragLeave;
    //**property OnDragOver;
    //**property OnDragDrop;
    //**property OnDragEnd;
    //property OnEnter;
    //property OnExit;
    property OnMouseEnter;
    property OnMouseLeave;
    property OnMouseDown;
    property OnMouseUp;
    property OnMouseMove;
    //**property OnMouseWheel;
    property OnClick;
    property OnDblClick;
    //property OnKeyDown;
    //property OnKeyUp;
    property OnPainting;
    property OnPaint;
    //property OnResize;
    //**property OnResized;
  end;

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  TALDynamicBaseCheckBox = class(TALDynamicShape)
  public
    type
      // ---------------
      // TCheckMarkBrush
      TCheckMarkBrush = class(TALPersistentObserver)
      public
        Type
          TMargins = class(TALBounds)
          protected
            function GetDefaultValue: TRectF; override;
          end;
      private
        FColor: TAlphaColor;
        FColorKey: String;
        FResourceName: String;
        FWrapMode: TALImageWrapMode;
        FThickness: Single;
        FMargins: TALBounds;
        procedure SetColor(const Value: TAlphaColor);
        procedure SetColorKey(const Value: String);
        procedure SetResourceName(const Value: String);
        procedure SetWrapMode(const Value: TALImageWrapMode);
        procedure SetThickness(const Value: Single);
        procedure SetMargins(const Value: TALBounds);
        procedure MarginsChanged(Sender: TObject); virtual;
        function IsColorStored: Boolean;
        function IsColorKeyStored: Boolean;
        function IsResourceNameStored: Boolean;
        function IsWrapModeStored: Boolean;
        function IsThicknessStored: Boolean;
      protected
        function CreateMargins: TALBounds; virtual;
        function GetDefaultColor: TAlphaColor; virtual;
        function GetDefaultColorKey: String; virtual;
        function GetDefaultResourceName: String; virtual;
        function GetDefaultWrapMode: TALImageWrapMode; virtual;
        function GetDefaultThickness: Single; virtual;
      public
        constructor Create; override;
        destructor Destroy; override;
        procedure Assign(Source: TPersistent); override;
        procedure Reset; override;
        procedure AlignToPixel; virtual;
        procedure ApplyColorScheme; virtual;
        procedure Interpolate(const ATo: TCheckMarkBrush; const ANormalizedTime: Single; const AReverse: Boolean); virtual;
        procedure InterpolateNoChanges(const ATo: TCheckMarkBrush; const ANormalizedTime: Single; const AReverse: Boolean);
        function HasCheckMark: boolean;
        property DefaultColor: TAlphaColor read GetDefaultColor;
        property DefaultColorKey: String read GetDefaultColorKey;
        property DefaultResourceName: String read GetDefaultResourceName;
        property DefaultWrapMode: TALImageWrapMode read GetDefaultWrapMode;
        property DefaultThickness: Single read GetDefaultThickness;
      public
        property Color: TAlphaColor read FColor write SetColor stored IsColorStored;
        property ColorKey: String read FColorKey write SetColorKey stored IsColorKeyStored;
        property ResourceName: String read FResourceName write SetResourceName stored IsResourceNameStored nodefault;
        property WrapMode: TALImageWrapMode read FWrapMode write SetWrapMode stored IsWrapModeStored;
        property Thickness: Single read FThickness write SetThickness stored IsThicknessStored nodefault;
        property Margins: TALBounds read FMargins write SetMargins;
      end;
      // ----------------------
      // TInheritCheckMarkBrush
      TInheritCheckMarkBrush = class(TCheckMarkBrush)
      private
        FParent: TCheckMarkBrush;
        FInherit: Boolean;
        fSuperseded: Boolean;
        procedure SetInherit(const AValue: Boolean);
      protected
        function CreateSavedState: TALPersistentObserver; override;
        procedure DoSupersede; virtual;
      public
        constructor Create(const AParent: TCheckMarkBrush); reintroduce; virtual;
        procedure Assign(Source: TPersistent); override;
        procedure Reset; override;
        procedure Supersede(Const ASaveState: Boolean = False); virtual;
        procedure SupersedeNoChanges(Const ASaveState: Boolean = False);
        property Superseded: Boolean read FSuperseded;
        property Parent: TCheckMarkBrush read FParent;
      public
        property Inherit: Boolean read FInherit write SetInherit Default True;
      end;
      // ---------------
      // TBaseStateStyle
      TBaseStateStyle = class(TALDynamicBaseStateStyle)
      public
        type
          TStateLayer = class(TALStateLayer)
          public
            Type
              TMargins = class(TALBounds)
              protected
                function GetDefaultValue: TRectF; override;
              end;
          protected
            function CreateMargins: TALBounds; override;
            function GetDefaultXRadius: Single; override;
            function GetDefaultYRadius: Single; override;
          end;
      private
        FCheckMark: TInheritCheckMarkBrush;
        function GetStateStyleParent: TBaseStateStyle;
        function GetControlParent: TALDynamicBaseCheckBox;
        procedure SetCheckMark(const AValue: TInheritCheckMarkBrush);
        procedure CheckMarkChanged(ASender: TObject);
      protected
        function CreateStateLayer: TALStateLayer; override;
        function CreateCheckMark(const AParent: TCheckMarkBrush): TInheritCheckMarkBrush; virtual;
        function GetInherit: Boolean; override;
        procedure DoSupersede; override;
      public
        constructor Create(const AParent: TObject); override;
        destructor Destroy; override;
        procedure Assign(Source: TPersistent); override;
        procedure Reset; override;
        procedure AlignToPixel; override;
        procedure ApplyColorScheme; override;
        procedure Interpolate(const ATo: TALDynamicBaseStateStyle; const ANormalizedTime: Single; const AReverse: Boolean); override;
        property StateStyleParent: TBaseStateStyle read GetStateStyleParent;
        property ControlParent: TALDynamicBaseCheckBox read GetControlParent;
      public
        property CheckMark: TInheritCheckMarkBrush read FCheckMark write SetCheckMark;
        property Fill;
        property Shadow;
        property Stroke;
      end;
      // ------------------
      // TDefaultStateStyle
      TDefaultStateStyle = class(TBaseStateStyle)
      protected
        function GetCacheSubIndex: Integer; override;
      end;
      // -------------------
      // TDisabledStateStyle
      TDisabledStateStyle = class(TBaseStateStyle)
      private
        FOpacity: Single;
        procedure SetOpacity(const Value: Single);
        function IsOpacityStored: Boolean;
      protected
        function GetInherit: Boolean; override;
        function GetCacheSubIndex: Integer; override;
      public
        constructor Create(const AParent: TObject); override;
        procedure Assign(Source: TPersistent); override;
        procedure Reset; override;
      public
        property Opacity: Single read FOpacity write SetOpacity stored IsOpacityStored nodefault;
      end;
      // ------------------
      // THoveredStateStyle
      THoveredStateStyle = class(TBaseStateStyle)
      protected
        function GetCacheSubIndex: Integer; override;
      public
        property StateLayer;
        property Scale;
      end;
      // ------------------
      // TPressedStateStyle
      TPressedStateStyle = class(TBaseStateStyle)
      protected
        function GetCacheSubIndex: Integer; override;
      public
        property StateLayer;
        property Scale;
      end;
      // ------------------
      // TFocusedStateStyle
      TFocusedStateStyle = class(TBaseStateStyle)
      protected
        function GetCacheSubIndex: Integer; override;
      public
        property StateLayer;
        property Scale;
      end;
      // -----------------
      // TCheckStateStyles
      TCheckStateStyles = class(TALPersistentObserver)
      private
        FDefault: TDefaultStateStyle;
        FDisabled: TDisabledStateStyle;
        FHovered: THoveredStateStyle;
        FPressed: TPressedStateStyle;
        FFocused: TFocusedStateStyle;
        procedure SetDefault(const AValue: TDefaultStateStyle);
        procedure SetDisabled(const AValue: TDisabledStateStyle);
        procedure SetHovered(const AValue: THoveredStateStyle);
        procedure SetPressed(const AValue: TPressedStateStyle);
        procedure SetFocused(const AValue: TFocusedStateStyle);
        procedure DefaultChanged(ASender: TObject);
        procedure DisabledChanged(ASender: TObject);
        procedure HoveredChanged(ASender: TObject);
        procedure PressedChanged(ASender: TObject);
        procedure FocusedChanged(ASender: TObject);
      protected
        function CreateSavedState: TALPersistentObserver; override;
        function CreateDefaultStateStyle(const AParent: TObject): TDefaultStateStyle; virtual;
        function CreateDisabledStateStyle(const AParent: TObject): TDisabledStateStyle; virtual;
        function CreateHoveredStateStyle(const AParent: TObject): THoveredStateStyle; virtual;
        function CreatePressedStateStyle(const AParent: TObject): TPressedStateStyle; virtual;
        function CreateFocusedStateStyle(const AParent: TObject): TFocusedStateStyle; virtual;
      public
        constructor Create(const AParent: TALDynamicControl); reintroduce; virtual;
        destructor Destroy; override;
        procedure Assign(Source: TPersistent); override;
        procedure Reset; override;
        procedure AlignToPixel; virtual;
        procedure ApplyColorScheme; virtual;
        procedure ClearBufDrawable; virtual;
      public
        property &Default: TDefaultStateStyle read FDefault write SetDefault;
        property Disabled: TDisabledStateStyle read FDisabled write SetDisabled;
        property Hovered: THoveredStateStyle read FHovered write SetHovered;
        property Pressed: TPressedStateStyle read FPressed write SetPressed;
        property Focused: TFocusedStateStyle read FFocused write SetFocused;
      end;
      // ------------
      // TStateStyles
      TStateStyles = class(TALDynamicBaseStateStyles)
      public
        type
          // -----------
          // TTransition
          TTransition = class(TALDynamicBaseStateStyles.TTransition)
          public
            property FadeImage;
          end;
      private
        FChecked: TCheckStateStyles;
        FUnchecked: TCheckStateStyles;
        function GetParent: TALDynamicBaseCheckBox;
        function GetTransition: TStateStyles.TTransition;
        procedure SetTransition(const AValue: TStateStyles.TTransition);
        procedure SetChecked(const AValue: TCheckStateStyles);
        procedure SetUnchecked(const AValue: TCheckStateStyles);
        procedure CheckedChanged(ASender: TObject);
        procedure UncheckedChanged(ASender: TObject);
      protected
        function CreateTransition: TALDynamicBaseStateStyles.TTransition; override;
        function CreateCheckedStateStyles(const AParent: TALDynamicControl): TCheckStateStyles; virtual;
        function CreateUncheckedStateStyles(const AParent: TALDynamicControl): TCheckStateStyles; virtual;
      public
        constructor Create(const AParent: TALDynamicControl); override;
        destructor Destroy; override;
        procedure Assign(Source: TPersistent); override;
        procedure Reset; override;
        procedure AlignToPixel; override;
        procedure ApplyColorScheme; override;
        procedure ClearBufDrawable; override;
        function GetCurrentRawStyle: TALDynamicBaseStateStyle; override;
        Property Parent: TALDynamicBaseCheckBox read GetParent;
      public
        property Checked: TCheckStateStyles read FChecked write SetChecked;
        property Unchecked: TCheckStateStyles read FUnchecked write SetUnchecked;
        property Transition: TStateStyles.TTransition read GetTransition write SetTransition;
      end;
  private
    FStateStyles: TStateStyles;
    FCheckMark: TCheckMarkBrush;
    FChecked: Boolean;
    FDoubleBuffered: boolean;
    FXRadius: Single;
    FYRadius: Single;
    FCacheIndex: Integer; // 4 bytes
    FCacheEngine: TALBufDrawableCacheEngine; // 8 bytes
    {$IF NOT DEFINED(ALSkiaCanvas)}
    FRenderTargetSurface: TALSurface; // 8 bytes
    FRenderTargetCanvas: TALCanvas; // 8 bytes
    fRenderTargetDrawable: TALDrawable; // 8 bytes
    {$ENDIF}
    FOnChange: TNotifyEvent;
    procedure SetCheckMark(const Value: TCheckMarkBrush);
    procedure SetStateStyles(const AValue: TStateStyles);
    function IsXRadiusStored: Boolean;
    function IsYRadiusStored: Boolean;
  protected
    function CreateCheckMark: TCheckMarkBrush; virtual;
    function CreateStateStyles: TStateStyles; virtual;
    function GetCacheSubIndex: Integer; virtual;
    function GetDoubleBuffered: boolean; override;
    procedure SetDoubleBuffered(const AValue: Boolean); override;
    function GetDefaultXRadius: Single; virtual;
    function GetDefaultYRadius: Single; virtual;
    procedure SetXRadius(const Value: Single); virtual;
    procedure SetYRadius(const Value: Single); virtual;
    procedure CheckMarkChanged(Sender: TObject); virtual;
    procedure StateStylesChanged(Sender: TObject); virtual;
    procedure FillChanged(Sender: TObject); override;
    procedure StrokeChanged(Sender: TObject); override;
    procedure ShadowChanged(Sender: TObject); override;
    procedure IsMouseOverChanged; override;
    //**procedure IsFocusedChanged; override;
    procedure PressedChanged; override;
    function GetDefaultSize: TSizeF; override;
    function GetChecked: Boolean; virtual;
    procedure SetChecked(const Value: Boolean); virtual;
    //**procedure KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState); override;
    procedure DoClickSound; override;
    procedure Click; override;
    procedure DoChanged; virtual;
    procedure DoResized; override;
    procedure DrawCheckMark(
                const ACanvas: TALCanvas;
                const AScale: Single;
                const ADstRect: TrectF;
                const AOpacity: Single;
                const AChecked: Boolean;
                const ACheckMark: TCheckMarkBrush); virtual;
    Procedure CreateBufDrawable(
                var ABufDrawable: TALDrawable;
                out ABufDrawableRect: TRectF;
                const AScale: Single;
                const AFill: TALBrush;
                const AStateLayer: TALStateLayer;
                const AStroke: TALStrokeBrush;
                const ACheckMark: TCheckMarkBrush;
                const AShadow: TALShadow); virtual;
    {$IF NOT DEFINED(ALSkiaCanvas)}
    function GetRenderTargetRect(const ARect: TrectF): TRectF; virtual;
    procedure InitRenderTargets(var ARect: TrectF); virtual;
    procedure ClearRenderTargets; virtual;
    Property RenderTargetSurface: TALSurface read FRenderTargetSurface;
    Property RenderTargetCanvas: TALCanvas read FRenderTargetCanvas;
    Property RenderTargetDrawable: TALDrawable read fRenderTargetDrawable;
    {$ENDIF}
    procedure Paint; override;
    // CacheIndex and CacheEngine are primarily used in TALDynamicListBox to
    // prevent duplicate drawables across multiple identical controls.
    // CacheIndex specifies the slot in the cache engine where an existing
    // drawable can be retrieved.
    property CacheIndex: Integer read FCacheIndex write FCacheIndex;
    // CacheEngine is not owned by the current control.
    property CacheEngine: TALBufDrawableCacheEngine read FCacheEngine write FCacheEngine;
  public
    constructor Create(const AOwner: TObject); override;
    destructor Destroy; override;
    procedure Assign(Source: TALDynamicControl); override;
    procedure AlignToPixel; override;
    procedure ApplyColorScheme; override;
    procedure MakeBufDrawable; override;
    procedure ClearBufDrawable; override;
    //**property CanFocus default True;
    property Cursor default crHandPoint;
    property Checked: Boolean read GetChecked write SetChecked default False;
    property CheckMark: TCheckMarkBrush read FCheckMark write SetCheckMark;
    property DoubleBuffered default true;
    property StateStyles: TStateStyles read FStateStyles write SetStateStyles;
    property XRadius: Single read FXRadius write SetXRadius stored IsXRadiusStored nodefault;
    property YRadius: Single read FYRadius write SetYRadius stored IsYRadiusStored nodefault;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
    property DefaultXRadius: Single read GetDefaultXRadius;
    property DefaultYRadius: Single read GetDefaultYRadius;
  end;

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  TALDynamicCheckBox = class(TALDynamicBaseCheckBox)
  public
    type
      // ------------
      // TStateStyles
      TStateStyles = class(TALDynamicBaseCheckBox.TStateStyles)
      public
        property Transition;
      end;
  private
    function GetStateStyles: TStateStyles;
    procedure SetStateStyles(const AValue: TStateStyles);
  protected
    function CreateStateStyles: TALDynamicBaseCheckBox.TStateStyles; override;
  public
    property CacheEngine;
    property CacheIndex;
  public
    //property Action;
    property Align;
    //**property Anchors;
    //property AutoSize;
    //**property CanFocus;
    //property CanParentFocus;
    //property DisableFocusEffect;
    property CheckMark;
    property Checked;
    property ClickSound;
    //**property ClipChildren;
    //property ClipParent;
    property Cursor;
    property DoubleBuffered;
    //**property DragMode;
    //**property EnableDragHighlight;
    property Enabled;
    property Fill;
    property Height;
    //property Hint;
    //property ParentShowHint;
    //property ShowHint;
    property HitTest;
    //**property Locked;
    property Margins;
    property Opacity;
    property Padding;
    //**property PopupMenu;
    //**property Position;
    property RotationAngle;
    //property RotationCenter;
    property Pivot;
    property Scale;
    property Shadow;
    //**property Size;
    property StateStyles: TStateStyles read GetStateStyles write SetStateStyles;
    property Stroke;
    //**property TabOrder;
    //**property TabStop;
    property TouchTargetExpansion;
    property Visible;
    property Width;
    property XRadius;
    property YRadius;
    //**property OnCanFocus;
    property OnChange;
    //**property OnDragEnter;
    //**property OnDragLeave;
    //**property OnDragOver;
    //**property OnDragDrop;
    //**property OnDragEnd;
    //**property OnEnter;
    //**property OnExit;
    property OnMouseEnter;
    property OnMouseLeave;
    property OnMouseDown;
    property OnMouseUp;
    property OnMouseMove;
    //**property OnMouseWheel;
    property OnClick;
    property OnDblClick;
    //**property OnKeyDown;
    //**property OnKeyUp;
    property OnPainting;
    property OnPaint;
    //property OnResize;
    //**property OnResized;
  end;

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  TALDynamicRadioButton = class(TALDynamicCheckBox)
  public
    type
      // ---------------
      // TCheckMarkBrush
      TCheckMarkBrush = class(TALDynamicCheckBox.TCheckMarkBrush)
      public
        Type
          TMargins = class(TALDynamicCheckBox.TCheckMarkBrush.TMargins)
          protected
            function GetDefaultValue: TRectF; override;
          end;
      protected
        function CreateMargins: TALBounds; override;
      end;
      // ----------------------
      // TInheritCheckMarkBrush
      TInheritCheckMarkBrush = class(TALDynamicCheckBox.TInheritCheckMarkBrush)
      public
        Type
          TMargins = class(TALDynamicCheckBox.TInheritCheckMarkBrush.TMargins)
          protected
            function GetDefaultValue: TRectF; override;
          end;
      protected
        function CreateMargins: TALBounds; override;
      end;
      // ------------------
      // TDefaultStateStyle
      TDefaultStateStyle = class(TALDynamicCheckBox.TDefaultStateStyle)
      protected
        function CreateCheckMark(const AParent: TALDynamicBaseCheckBox.TCheckMarkBrush): TALDynamicBaseCheckBox.TInheritCheckMarkBrush; override;
      end;
      // -------------------
      // TDisabledStateStyle
      TDisabledStateStyle = class(TALDynamicCheckBox.TDisabledStateStyle)
      protected
        function CreateCheckMark(const AParent: TALDynamicBaseCheckBox.TCheckMarkBrush): TALDynamicBaseCheckBox.TInheritCheckMarkBrush; override;
      end;
      // ------------------
      // THoveredStateStyle
      THoveredStateStyle = class(TALDynamicCheckBox.THoveredStateStyle)
      protected
        function CreateCheckMark(const AParent: TALDynamicBaseCheckBox.TCheckMarkBrush): TALDynamicBaseCheckBox.TInheritCheckMarkBrush; override;
      end;
      // ------------------
      // TPressedStateStyle
      TPressedStateStyle = class(TALDynamicCheckBox.TPressedStateStyle)
      protected
        function CreateCheckMark(const AParent: TALDynamicBaseCheckBox.TCheckMarkBrush): TALDynamicBaseCheckBox.TInheritCheckMarkBrush; override;
      end;
      // ------------------
      // TFocusedStateStyle
      TFocusedStateStyle = class(TALDynamicCheckBox.TFocusedStateStyle)
      protected
        function CreateCheckMark(const AParent: TALDynamicBaseCheckBox.TCheckMarkBrush): TALDynamicBaseCheckBox.TInheritCheckMarkBrush; override;
      end;
      // -----------------
      // TCheckStateStyles
      TCheckStateStyles = class(TALDynamicCheckBox.TCheckStateStyles)
      protected
        function CreateDefaultStateStyle(const AParent: TObject): TALDynamicBaseCheckBox.TDefaultStateStyle; override;
        function CreateDisabledStateStyle(const AParent: TObject): TALDynamicBaseCheckBox.TDisabledStateStyle; override;
        function CreateHoveredStateStyle(const AParent: TObject): TALDynamicBaseCheckBox.THoveredStateStyle; override;
        function CreatePressedStateStyle(const AParent: TObject): TALDynamicBaseCheckBox.TPressedStateStyle; override;
        function CreateFocusedStateStyle(const AParent: TObject): TALDynamicBaseCheckBox.TFocusedStateStyle; override;
      end;
      // ------------
      // TStateStyles
      TStateStyles = class(TALDynamicCheckBox.TStateStyles)
      protected
        function CreateCheckedStateStyles(const AParent: TALDynamicControl): TALDynamicBaseCheckBox.TCheckStateStyles; override;
        function CreateUncheckedStateStyles(const AParent: TALDynamicControl): TALDynamicBaseCheckBox.TCheckStateStyles; override;
      end;
  private
    FGroupName: string;
    fMandatory: boolean;
    function GetGroupName: string;
    procedure SetGroupName(const Value: string);
    function GroupNameStored: Boolean;
    procedure GroupMessageCall(const Sender : TObject; const M : TMessage);
  protected
    function CreateCheckMark: TALDynamicBaseCheckBox.TCheckMarkBrush; override;
    function CreateStateStyles: TALDynamicBaseCheckBox.TStateStyles; override;
    procedure SetChecked(const Value: Boolean); override;
    function GetDefaultXRadius: Single; override;
    function GetDefaultYRadius: Single; override;
    function GetDefaultSize: TSizeF; override;
    procedure DrawCheckMark(
                const ACanvas: TALCanvas;
                const AScale: Single;
                const ADstRect: TrectF;
                const AOpacity: Single;
                const AChecked: Boolean;
                const ACheckMark: TALDynamicBaseCheckBox.TCheckMarkBrush); override;
  public
    constructor Create(const AOwner: TObject); override;
    procedure BeforeDestruction; override;
    procedure Assign(Source: TALDynamicControl); override;
  public
    property GroupName: string read GetGroupName write SetGroupName stored GroupNameStored nodefault;
    property Mandatory: Boolean read fMandatory write fMandatory default false;
  end;

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  TALDynamicSwitch = class(TALDynamicExtendedControl)
  public
    type
      // ------
      // TTrack
      TTrack = class(TALDynamicShape)
      public
        type
          // -----
          // TFill
          TFill = class(TALBrush)
          protected
            function GetDefaultColor: TAlphaColor; override;
          end;
          // -------
          // TStroke
          TStroke = class(TALStrokeBrush)
          protected
            function GetDefaultColor: TAlphaColor; override;
          end;
          // ---------------
          // TBaseStateStyle
          TBaseStateStyle = class(TALDynamicBaseStateStyle)
          public
            type
              TFill = class(TALInheritBrush)
              protected
                function GetDefaultColor: TAlphaColor; override;
              end;
              TStroke = class(TALInheritStrokeBrush)
              protected
                function GetDefaultColor: TAlphaColor; override;
              end;
              TStateLayer = class(TALStateLayer)
              protected
                function GetDefaultXRadius: Single; override;
                function GetDefaultYRadius: Single; override;
              end;
          protected
            function CreateFill(const AParent: TALBrush): TALInheritBrush; override;
            function CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush; override;
            function CreateStateLayer: TALStateLayer; override;
          public
            property Fill;
            property Shadow;
            property Stroke;
          end;
          // ------------------
          // TDefaultStateStyle
          TDefaultStateStyle = class(TBaseStateStyle)
          protected
            function GetCacheSubIndex: Integer; override;
          end;
          // -------------------
          // TDisabledStateStyle
          TDisabledStateStyle = class(TBaseStateStyle)
          private
            FOpacity: Single;
            procedure SetOpacity(const Value: Single);
            function IsOpacityStored: Boolean;
          protected
            function GetInherit: Boolean; override;
            function GetCacheSubIndex: Integer; override;
          public
            constructor Create(const AParent: TObject); override;
            procedure Assign(Source: TPersistent); override;
            procedure Reset; override;
          public
            property Opacity: Single read FOpacity write SetOpacity stored IsOpacityStored nodefault;
          end;
          // ------------------
          // THoveredStateStyle
          THoveredStateStyle = class(TBaseStateStyle)
          protected
            function GetCacheSubIndex: Integer; override;
          public
            property StateLayer;
            // When the track is scaled, the thumb is no longer aligned with the track.
            // Therefore, currently, scaling of the track is disabled.
            //property Scale;
          end;
          // ------------------
          // TPressedStateStyle
          TPressedStateStyle = class(TBaseStateStyle)
          protected
            function GetCacheSubIndex: Integer; override;
          public
            property StateLayer;
            // When the track is scaled, the thumb is no longer aligned with the track.
            // Therefore, currently, scaling of the track is disabled.
            //property Scale;
          end;
          // ------------------
          // TFocusedStateStyle
          TFocusedStateStyle = class(TBaseStateStyle)
          protected
            function GetCacheSubIndex: Integer; override;
          public
            property StateLayer;
            // When the track is scaled, the thumb is no longer aligned with the track.
            // Therefore, currently, scaling of the track is disabled.
            //property Scale;
          end;
          // -----------------
          // TCheckStateStyles
          TCheckStateStyles = class(TALPersistentObserver)
          private
            FDefault: TDefaultStateStyle;
            FDisabled: TDisabledStateStyle;
            FHovered: THoveredStateStyle;
            FPressed: TPressedStateStyle;
            FFocused: TFocusedStateStyle;
            procedure SetDefault(const AValue: TDefaultStateStyle);
            procedure SetDisabled(const AValue: TDisabledStateStyle);
            procedure SetHovered(const AValue: THoveredStateStyle);
            procedure SetPressed(const AValue: TPressedStateStyle);
            procedure SetFocused(const AValue: TFocusedStateStyle);
            procedure DefaultChanged(ASender: TObject);
            procedure DisabledChanged(ASender: TObject);
            procedure HoveredChanged(ASender: TObject);
            procedure PressedChanged(ASender: TObject);
            procedure FocusedChanged(ASender: TObject);
          protected
            function CreateSavedState: TALPersistentObserver; override;
            function CreateDefaultStateStyle(const AParent: TObject): TDefaultStateStyle; virtual;
            function CreateDisabledStateStyle(const AParent: TObject): TDisabledStateStyle; virtual;
            function CreateHoveredStateStyle(const AParent: TObject): THoveredStateStyle; virtual;
            function CreatePressedStateStyle(const AParent: TObject): TPressedStateStyle; virtual;
            function CreateFocusedStateStyle(const AParent: TObject): TFocusedStateStyle; virtual;
          public
            constructor Create(const AParent: TALDynamicControl); reintroduce; virtual;
            destructor Destroy; override;
            procedure Assign(Source: TPersistent); override;
            procedure Reset; override;
            procedure AlignToPixel; virtual;
            procedure ApplyColorScheme; virtual;
            procedure ClearBufDrawable; virtual;
          public
            property &Default: TDefaultStateStyle read FDefault write SetDefault;
            property Disabled: TDisabledStateStyle read FDisabled write SetDisabled;
            property Hovered: THoveredStateStyle read FHovered write SetHovered;
            property Pressed: TPressedStateStyle read FPressed write SetPressed;
            property Focused: TFocusedStateStyle read FFocused write SetFocused;
          end;
          // ------------
          // TStateStyles
          TStateStyles = class(TALDynamicBaseStateStyles)
          private
            FChecked: TCheckStateStyles;
            FUnchecked: TCheckStateStyles;
            function GetParent: TTrack;
            procedure SetChecked(const AValue: TCheckStateStyles);
            procedure SetUnchecked(const AValue: TCheckStateStyles);
            procedure CheckedChanged(ASender: TObject);
            procedure UncheckedChanged(ASender: TObject);
          protected
            function CreateCheckedStateStyles(const AParent: TALDynamicControl): TCheckStateStyles; virtual;
            function CreateUncheckedStateStyles(const AParent: TALDynamicControl): TCheckStateStyles; virtual;
          public
            constructor Create(const AParent: TALDynamicControl); override;
            destructor Destroy; override;
            procedure Assign(Source: TPersistent); override;
            procedure Reset; override;
            procedure AlignToPixel; override;
            procedure ApplyColorScheme; override;
            procedure ClearBufDrawable; override;
            function GetCurrentRawStyle: TALDynamicBaseStateStyle; override;
            Property Parent: TTrack read GetParent;
          public
            property Checked: TCheckStateStyles read FChecked write SetChecked;
            property Unchecked: TCheckStateStyles read FUnchecked write SetUnchecked;
          end;
      private
        FStateStyles: TStateStyles;
        FChecked: Boolean;
        FDoubleBuffered: boolean;
        FXRadius: Single;
        FYRadius: Single;
        FCacheIndex: Integer; // 4 bytes
        FCacheEngine: TALBufDrawableCacheEngine; // 8 bytes
        {$IF NOT DEFINED(ALSkiaCanvas)}
        FRenderTargetSurface: TALSurface; // 8 bytes
        FRenderTargetCanvas: TALCanvas; // 8 bytes
        fRenderTargetDrawable: TALDrawable; // 8 bytes
        {$ENDIF}
        procedure SetStateStyles(const AValue: TStateStyles);
        function IsXRadiusStored: Boolean;
        function IsYRadiusStored: Boolean;
      protected
        function CreateFill: TALBrush; override;
        function CreateStroke: TALStrokeBrush; override;
        function CreateStateStyles: TStateStyles; virtual;
        function GetDefaultSize: TSizeF; override;
        function GetCacheSubIndex: Integer; virtual;
        function GetDoubleBuffered: boolean; override;
        procedure SetDoubleBuffered(const AValue: Boolean); override;
        function GetDefaultXRadius: Single; virtual;
        function GetDefaultYRadius: Single; virtual;
        procedure SetXRadius(const Value: Single); virtual;
        procedure SetYRadius(const Value: Single); virtual;
        procedure StateStylesChanged(Sender: TObject); virtual;
        procedure FillChanged(Sender: TObject); override;
        procedure StrokeChanged(Sender: TObject); override;
        procedure ShadowChanged(Sender: TObject); override;
        procedure IsMouseOverChanged; override;
        //**procedure IsFocusedChanged; override;
        procedure PressedChanged; override;
        function GetChecked: Boolean; virtual;
        procedure SetChecked(const Value: Boolean); virtual;
        procedure DoChanged; virtual;
        procedure DoResized; override;
        Procedure CreateBufDrawable(
                    var ABufDrawable: TALDrawable;
                    out ABufDrawableRect: TRectF;
                    const AScale: Single;
                    const AFill: TALBrush;
                    const AStateLayer: TALStateLayer;
                    const AStroke: TALStrokeBrush;
                    const AShadow: TALShadow); virtual;
        {$IF NOT DEFINED(ALSkiaCanvas)}
        function GetRenderTargetRect(const ARect: TrectF): TRectF; virtual;
        procedure InitRenderTargets(var ARect: TrectF); virtual;
        procedure ClearRenderTargets; virtual;
        Property RenderTargetSurface: TALSurface read FRenderTargetSurface;
        Property RenderTargetCanvas: TALCanvas read FRenderTargetCanvas;
        Property RenderTargetDrawable: TALDrawable read fRenderTargetDrawable;
        {$ENDIF}
        procedure Paint; override;
        property Checked: Boolean read GetChecked write SetChecked default False;
        property CacheIndex: Integer read FCacheIndex write FCacheIndex;
        property CacheEngine: TALBufDrawableCacheEngine read FCacheEngine write FCacheEngine;
      public
        constructor Create(const AOwner: TObject); override;
        destructor Destroy; override;
        procedure AlignToPixel; override;
        procedure ApplyColorScheme; override;
        procedure MakeBufDrawable; override;
        procedure ClearBufDrawable; override;
        property DefaultXRadius: Single read GetDefaultXRadius;
        property DefaultYRadius: Single read GetDefaultYRadius;
        property DoubleBuffered default true;
        //**property Position stored false;
      public
        //property Action;
        //property Align;
        //property Anchors;
        //property AutoSize;
        //property CanFocus default False;
        //property CanParentFocus;
        //property DisableFocusEffect;
        property ClickSound;
        //property ClipChildren;
        //property ClipParent;
        //property Cursor;
        //property DoubleBuffered;
        //property DragMode;
        //property EnableDragHighlight;
        //property Enabled;
        property Fill;
        //property Height;
        //property Hint;
        //property ParentShowHint;
        //property ShowHint;
        //property HitTest default False;
        //property Locked default True;
        property Margins;
        property Opacity;
        property Padding;
        //property PopupMenu;
        //property Position;
        //property RotationAngle;
        //property RotationCenter;
        //property Pivot;
        //property Scale;
        property Shadow;
        //property Size;
        property StateStyles: TStateStyles read FStateStyles write SetStateStyles;
        property Stroke;
        //property TabOrder;
        //property TabStop;
        //property TouchTargetExpansion;
        //property Visible;
        //property Width;
        property XRadius: Single read FXRadius write SetXRadius stored IsXRadiusStored nodefault;
        property YRadius: Single read FYRadius write SetYRadius stored IsYRadiusStored nodefault;
        //property OnCanFocus;
        //property OnDragEnter;
        //property OnDragLeave;
        //property OnDragOver;
        //property OnDragDrop;
        //property OnDragEnd;
        //property OnEnter;
        //property OnExit;
        //property OnMouseEnter;
        //property OnMouseLeave;
        //property OnMouseDown;
        //property OnMouseUp;
        //property OnMouseMove;
        //property OnMouseWheel;
        //property OnClick;
        //property OnDblClick;
        //property OnKeyDown;
        //property OnKeyUp;
        property OnPainting;
        property OnPaint;
        //property OnResize;
        //property OnResized;
      end;
      // ------
      // TThumb
      TThumb = class(TALDynamicBaseCheckBox)
      public
        Type
          TMargins = class(TALBounds)
          protected
            function GetDefaultValue: TRectF; override;
          end;
      protected
        function CreateMargins: TALBounds; override;
      public
        type
          // -------
          // TStroke
          TStroke = class(TALStrokeBrush)
          protected
            function GetDefaultColor: TAlphaColor; override;
          end;
          // --------------------
          // TCheckMarkBrush
          TCheckMarkBrush = class(TALDynamicBaseCheckBox.TCheckMarkBrush)
          public
            Type
              TMargins = class(TALDynamicBaseCheckBox.TCheckMarkBrush.TMargins)
              protected
                function GetDefaultValue: TRectF; override;
              end;
          protected
            function CreateMargins: TALBounds; override;
          end;
          // ----------------------
          // TInheritCheckMarkBrush
          TInheritCheckMarkBrush = class(TALDynamicBaseCheckBox.TInheritCheckMarkBrush)
          public
            Type
              TMargins = class(TALDynamicBaseCheckBox.TInheritCheckMarkBrush.TMargins)
              protected
                function GetDefaultValue: TRectF; override;
              end;
          protected
            function CreateMargins: TALBounds; override;
          end;
          // ------------------
          // TDefaultStateStyle
          TDefaultStateStyle = class(TALDynamicBaseCheckBox.TDefaultStateStyle)
          public
            type
              TStroke = class(TALInheritStrokeBrush)
              protected
                function GetDefaultColor: TAlphaColor; override;
              end;
          protected
            function CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush; override;
            function CreateCheckMark(const AParent: TALDynamicBaseCheckBox.TCheckMarkBrush): TALDynamicBaseCheckBox.TInheritCheckMarkBrush; override;
          end;
          // -------------------
          // TDisabledStateStyle
          TDisabledStateStyle = class(TALDynamicBaseCheckBox.TDisabledStateStyle)
          public
            type
              TStroke = class(TALInheritStrokeBrush)
              protected
                function GetDefaultColor: TAlphaColor; override;
              end;
          protected
            function CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush; override;
            function CreateCheckMark(const AParent: TALDynamicBaseCheckBox.TCheckMarkBrush): TALDynamicBaseCheckBox.TInheritCheckMarkBrush; override;
          end;
          // ------------------
          // THoveredStateStyle
          THoveredStateStyle = class(TALDynamicBaseCheckBox.THoveredStateStyle)
          public
            type
              TStroke = class(TALInheritStrokeBrush)
              protected
                function GetDefaultColor: TAlphaColor; override;
              end;
          protected
            function CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush; override;
            function CreateCheckMark(const AParent: TALDynamicBaseCheckBox.TCheckMarkBrush): TALDynamicBaseCheckBox.TInheritCheckMarkBrush; override;
          end;
          // ------------------
          // TPressedStateStyle
          TPressedStateStyle = class(TALDynamicBaseCheckBox.TPressedStateStyle)
          public
            type
              TStroke = class(TALInheritStrokeBrush)
              protected
                function GetDefaultColor: TAlphaColor; override;
              end;
          protected
            function CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush; override;
            function CreateCheckMark(const AParent: TALDynamicBaseCheckBox.TCheckMarkBrush): TALDynamicBaseCheckBox.TInheritCheckMarkBrush; override;
          end;
          // ------------------
          // TFocusedStateStyle
          TFocusedStateStyle = class(TALDynamicBaseCheckBox.TFocusedStateStyle)
          public
            type
              TStroke = class(TALInheritStrokeBrush)
              protected
                function GetDefaultColor: TAlphaColor; override;
              end;
          protected
            function CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush; override;
            function CreateCheckMark(const AParent: TALDynamicBaseCheckBox.TCheckMarkBrush): TALDynamicBaseCheckBox.TInheritCheckMarkBrush; override;
          end;
          // -----------------
          // TCheckStateStyles
          TCheckStateStyles = class(TALDynamicBaseCheckBox.TCheckStateStyles)
          protected
            function CreateDefaultStateStyle(const AParent: TObject): TALDynamicBaseCheckBox.TDefaultStateStyle; override;
            function CreateDisabledStateStyle(const AParent: TObject): TALDynamicBaseCheckBox.TDisabledStateStyle; override;
            function CreateHoveredStateStyle(const AParent: TObject): TALDynamicBaseCheckBox.THoveredStateStyle; override;
            function CreatePressedStateStyle(const AParent: TObject): TALDynamicBaseCheckBox.TPressedStateStyle; override;
            function CreateFocusedStateStyle(const AParent: TObject): TALDynamicBaseCheckBox.TFocusedStateStyle; override;
          end;
          // ------------
          // TStateStyles
          TStateStyles = class(TALDynamicBaseCheckBox.TStateStyles)
          public
            type
              // -----------
              // TTransition
              TTransition = class(TALDynamicBaseStateStyles.TTransition)
              private
                FStartPositionX: Single;
              protected
                procedure DoProcess; override;
                procedure DoFinish; override;
              public
                procedure Start; override;
              end;
          protected
            function CreateTransition: TALDynamicBaseStateStyles.TTransition; override;
            function CreateCheckedStateStyles(const AParent: TALDynamicControl): TALDynamicBaseCheckBox.TCheckStateStyles; override;
            function CreateUncheckedStateStyles(const AParent: TALDynamicControl): TALDynamicBaseCheckBox.TCheckStateStyles; override;
          end;
      protected
        function CreateStroke: TALStrokeBrush; override;
        function CreateCheckMark: TALDynamicBaseCheckBox.TCheckMarkBrush; override;
        function CreateStateStyles: TALDynamicBaseCheckBox.TStateStyles; override;
        function GetDefaultXRadius: Single; override;
        function GetDefaultYRadius: Single; override;
        function GetDefaultSize: TSizeF; override;
        procedure Click; override;
      public
        constructor Create(const AOwner: TObject); override;
        //**property Position stored false;
      public
        //property Action;
        //property Align;
        //property Anchors;
        //property AutoSize;
        //property CanFocus default False;
        //property CanParentFocus;
        //property DisableFocusEffect;
        property CheckMark;
        //property Checked;
        property ClickSound;
        //property ClipChildren;
        //property ClipParent;
        //property Cursor;
        //property DoubleBuffered;
        //property DragMode;
        //property EnableDragHighlight;
        //property Enabled;
        property Fill;
        //property Height;
        //property Hint;
        //property ParentShowHint;
        //property ShowHint;
        //property HitTest default False;
        //property Locked default True;
        property Margins;
        property Opacity;
        property Padding;
        //property PopupMenu;
        //property Position;
        //property RotationAngle;
        //property RotationCenter;
        //property Pivot;
        //property Scale;
        property Shadow;
        //**property Size;
        property StateStyles;
        property Stroke;
        //property TabOrder;
        //property TabStop;
        //property TouchTargetExpansion;
        //property Visible;
        property Width;
        property XRadius;
        property YRadius;
        //property OnCanFocus;
        //property OnChange;
        //property OnDragEnter;
        //property OnDragLeave;
        //property OnDragOver;
        //property OnDragDrop;
        //property OnDragEnd;
        //property OnEnter;
        //property OnExit;
        //property OnMouseEnter;
        //property OnMouseLeave;
        //property OnMouseDown;
        //property OnMouseUp;
        //property OnMouseMove;
        //property OnMouseWheel;
        //property OnClick;
        //property OnDblClick;
        //property OnKeyDown;
        //property OnKeyUp;
        property OnPainting;
        property OnPaint;
        //property OnResize;
        //property OnResized;
      end;
      // -----------
      // TTransition
      TTransition = class(TPersistent)
      public
        type
          TInterpolationParams = class(TPersistent)
          private
            FOwner: TTransition;
            function GetBezierX1: Single;
            function GetBezierY1: Single;
            function GetBezierX2: Single;
            function GetBezierY2: Single;
            procedure SetBezierX1(const AValue: Single);
            procedure SetBezierY1(const AValue: Single);
            procedure SetBezierX2(const AValue: Single);
            procedure SetBezierY2(const AValue: Single);
            function GetOvershoot: Single;
            procedure SetOvershoot(const AValue: Single);
          public
            constructor Create(Const AOwner: TTransition); reintroduce; virtual;
          public
            property BezierX1: Single read GetBezierX1 write SetBezierX1;
            property BezierY1: Single read GetBezierY1 write SetBezierY1;
            property BezierX2: Single read GetBezierX2 write SetBezierX2;
            property BezierY2: Single read GetBezierY2 write SetBezierY2;
            property Overshoot: Single read GetOvershoot write SetOvershoot;
          end;
      private
        FOwner: TALDynamicSwitch;
        FInterpolationParams: TInterpolationParams;
        function GetDuration: Single;
        procedure SetDuration(const AValue: Single);
        function GetDelayClick: Boolean;
        procedure SetDelayClick(const AValue: Boolean);
        function GetInterpolationType: TALInterpolationType;
        procedure SetInterpolationType(const AValue: TALInterpolationType);
        function GetInterpolationMode: TALInterpolationMode;
        procedure SetInterpolationMode(const AValue: TALInterpolationMode);
        procedure SetInterpolationParams(const AValue: TInterpolationParams);
        Function IsDurationStored: Boolean;
        Function IsDelayClickStored: Boolean;
        Function IsInterpolationTypeStored: Boolean;
        Function IsInterpolationModeStored: Boolean;
      public
        constructor Create(Const AOwner: TALDynamicSwitch); reintroduce; virtual;
        destructor Destroy; override;
        procedure Start;
      public
        property Duration: Single read GetDuration write SetDuration stored IsDurationStored nodefault;
        property InterpolationType: TALInterpolationType read GetInterpolationType write SetInterpolationType stored IsInterpolationTypeStored;
        property InterpolationMode: TALInterpolationMode read GetInterpolationMode write SetInterpolationMode stored IsInterpolationModeStored;
        property InterpolationParams: TInterpolationParams read FInterpolationParams write SetInterpolationParams;
        property DelayClick: Boolean read GetDelayClick write SetDelayClick stored IsDelayClickStored;
      end;
  private
    FThumb: TThumb;
    FTrack: TTrack;
    FTransition: TTransition;
    FPressedThumbPos: TPointF;
    FOnChange: TNotifyEvent;
    fScrollCapturedByMe: boolean;
    procedure ScrollCapturedByOtherHandler(const Sender: TObject; const M: TMessage);
    procedure SetTransition(const Value: TTransition);
    function GetCacheIndex: integer;
    procedure SetCacheIndex(const AValue: Integer);
    function GetCacheEngine: TALBufDrawableCacheEngine;
    procedure SetCacheEngine(const AValue: TALBufDrawableCacheEngine);
    function GetMinThumbPos: Single;
    function GetMaxThumbPos: Single;
    procedure AlignThumb;
  protected
    function CreateTrack: TTrack; virtual;
    function CreateThumb: TThumb; virtual;
    function GetDefaultSize: TSizeF; override;
    function GetDoubleBuffered: boolean; override;
    procedure SetDoubleBuffered(const AValue: Boolean); override;
    procedure IsMouseOverChanged; override;
    //**procedure IsFocusedChanged; override;
    procedure PressedChanged; override;
    procedure EnabledChanged; override;
    procedure DoChange;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Single); override;
    procedure MouseMove(Shift: TShiftState; X, Y: Single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Single); override;
    procedure MouseLeave; override;
    procedure DoClickSound; override;
    procedure Click; override;
    function GetChecked: boolean; virtual;
    procedure SetChecked(const Value: Boolean); virtual;
    //**procedure Loaded; override;
  public
    constructor Create(const AOwner: TObject); override;
    destructor Destroy; override;
    procedure BeforeDestruction; override;
    procedure AfterConstruction; override;
    procedure AlignToPixel; override;
    procedure ApplyColorScheme; override;
    procedure MakeBufDrawable; override;
    procedure ClearBufDrawable; override;
    // CacheIndex and CacheEngine are primarily used in TALDynamicListBox to
    // prevent duplicate drawables across multiple identical controls.
    // CacheIndex specifies the slot in the cache engine where an existing
    // drawable can be retrieved.
    property CacheIndex: Integer read GetCacheIndex write SetCacheIndex;
    // CacheEngine is not owned by the current control.
    property CacheEngine: TALBufDrawableCacheEngine read GetCacheEngine write SetCacheEngine;
  public
    //property Action;
    property Align;
    //**property Anchors;
    //property AutoSize;
    //**property CanFocus default true;
    //property CanParentFocus;
    //property DisableFocusEffect;
    property DoubleBuffered default true;
    property Checked: Boolean read GetChecked write SetChecked default false;
    property ClickSound;
    //**property ClipChildren;
    //property ClipParent;
    property Cursor default crHandPoint;
    //property DoubleBuffered;
    //**property DragMode;
    //**property EnableDragHighlight;
    property Enabled;
    property Height;
    //property Hint;
    //property ParentShowHint;
    //property ShowHint;
    property HitTest;
    //**property Locked;
    property Margins;
    property Opacity;
    property Padding;
    //**property PopupMenu;
    //**property Position;
    property RotationAngle;
    //property RotationCenter;
    property Pivot;
    property Scale;
    //**property Size;
    //**property TabOrder;
    //**property TabStop;
    property Thumb: TThumb read FThumb;
    property TouchTargetExpansion;
    property Track: TTrack read FTrack;
    property Transition: TTransition read FTransition write SetTransition;
    property Visible;
    property Width;
    //**property OnCanFocus;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
    //**property OnDragEnter;
    //**property OnDragLeave;
    //**property OnDragOver;
    //**property OnDragDrop;
    //**property OnDragEnd;
    //**property OnEnter;
    //**property OnExit;
    property OnMouseEnter;
    property OnMouseLeave;
    property OnMouseDown;
    property OnMouseUp;
    property OnMouseMove;
    //**property OnMouseWheel;
    property OnClick;
    property OnDblClick;
    //**property OnKeyDown;
    //**property OnKeyUp;
    property OnPainting;
    property OnPaint;
    //property OnResize;
    //**property OnResized;
  end;

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  TALDynamicButton = class(TALDynamicBaseText)
  public
    Type
      TPadding = class(TALBounds)
      protected
        function GetDefaultValue: TRectF; override;
      end;
  protected
    function CreatePadding: TALBounds; override;
  public
    type
      // -----
      // TFill
      TFill = class(TALDynamicBaseText.TFill)
      protected
        function GetDefaultColor: TAlphaColor; override;
      end;
      // -------
      // TStroke
      TStroke = class(TALDynamicBaseText.TStroke)
      protected
        function GetDefaultColor: TAlphaColor; override;
      end;
      // -------------
      // TTextSettings
      TTextSettings = class(TALBaseTextSettings)
      public
        Type
          TFont = Class(TALFont)
          protected
            function GetDefaultWeight: TFontWeight; override;
          End;
      protected
        function CreateFont: TALFont; override;
        function GetDefaultHorzAlign: TALTextHorzAlign; override;
      public
        property Font;
        property Decoration;
        property Ellipsis;
        property MaxLines;
        property IsHtml;
        property HorzAlign;
        property VertAlign;
        property LineHeightMultiplier;
        property LetterSpacing;
      end;
      // ---------------
      // TBaseStateStyle
      TBaseStateStyle = class(TALDynamicBaseStateStyle)
      public
        type
          TFill = class(TALInheritBrush)
          protected
            function GetDefaultColor: TAlphaColor; override;
          end;
          TStroke = class(TALInheritStrokeBrush)
          protected
            function GetDefaultColor: TAlphaColor; override;
          end;
          TTextSettings = class(TALInheritBaseTextSettings)
          public
            Type
              TFont = Class(TALFont)
              protected
                function GetDefaultWeight: TFontWeight; override;
              End;
          protected
            function CreateFont: TALFont; override;
          public
            property Font;
            property Decoration;
          end;
      private
        FText: String;
        FTextSettings: TBaseStateStyle.TTextSettings;
        FXRadius: Single;
        FYRadius: Single;
        function GetStateStyleParent: TBaseStateStyle;
        function GetControlParent: TALDynamicButton;
        procedure SetText(const Value: string);
        procedure SetTextSettings(const AValue: TBaseStateStyle.TTextSettings);
        procedure SetXRadius(const Value: Single); virtual;
        procedure SetYRadius(const Value: Single); virtual;
        procedure TextSettingsChanged(ASender: TObject);
        function IsTextStored: Boolean;
        function IsXRadiusStored: Boolean;
        function IsYRadiusStored: Boolean;
      protected
        function CreateFill(const AParent: TALBrush): TALInheritBrush; override;
        function CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush; override;
        function CreateTextSettings(const AParent: TALBaseTextSettings): TBaseStateStyle.TTextSettings; virtual;
        function GetDefaultText: String; virtual;
        function GetDefaultXRadius: Single; virtual;
        function GetDefaultYRadius: Single; virtual;
        function GetInherit: Boolean; override;
        procedure DoSupersede; override;
      public
        constructor Create(const AParent: TObject); override;
        destructor Destroy; override;
        procedure Assign(Source: TPersistent); override;
        procedure Reset; override;
        procedure AlignToPixel; override;
        procedure ApplyColorScheme; override;
        procedure Interpolate(const ATo: TALDynamicBaseStateStyle; const ANormalizedTime: Single; const AReverse: Boolean); override;
        property StateStyleParent: TBaseStateStyle read GetStateStyleParent;
        property ControlParent: TALDynamicButton read GetControlParent;
        property DefaultText: String read GetDefaultText;
        property DefaultXRadius: Single read GetDefaultXRadius;
        property DefaultYRadius: Single read GetDefaultYRadius;
      public
        property Fill;
        property Shadow;
        property Stroke;
        property Text: string read FText write SetText stored IsTextStored nodefault;
        property TextSettings: TBaseStateStyle.TTextSettings read fTextSettings write SetTextSettings;
        property XRadius: Single read FXRadius write SetXRadius stored IsXRadiusStored nodefault;
        property YRadius: Single read FYRadius write SetYRadius stored IsYRadiusStored nodefault;
      end;
      // -------------------
      // TDisabledStateStyle
      TDisabledStateStyle = class(TBaseStateStyle)
      private
        FOpacity: Single;
        procedure SetOpacity(const Value: Single);
        function IsOpacityStored: Boolean;
      protected
        function GetInherit: Boolean; override;
        function GetCacheSubIndex: Integer; override;
      public
        constructor Create(const AParent: TObject); override;
        procedure Assign(Source: TPersistent); override;
        procedure Reset; override;
      public
        property Opacity: Single read FOpacity write SetOpacity stored IsOpacityStored nodefault;
      end;
      // ------------------
      // THoveredStateStyle
      THoveredStateStyle = class(TBaseStateStyle)
      protected
        function GetCacheSubIndex: Integer; override;
      public
        property StateLayer;
        property Scale;
      end;
      // ------------------
      // TPressedStateStyle
      TPressedStateStyle = class(TBaseStateStyle)
      protected
        function GetCacheSubIndex: Integer; override;
      public
        property StateLayer;
        property Scale;
      end;
      // ------------------
      // TFocusedStateStyle
      TFocusedStateStyle = class(TBaseStateStyle)
      protected
        function GetCacheSubIndex: Integer; override;
      public
        property StateLayer;
        property Scale;
      end;
      // ------------
      // TStateStyles
      TStateStyles = class(TALDynamicBaseStateStyles)
      private
        FDisabled: TDisabledStateStyle;
        FHovered: THoveredStateStyle;
        FPressed: TPressedStateStyle;
        FFocused: TFocusedStateStyle;
        function GetParent: TALDynamicButton;
        procedure SetDisabled(const AValue: TDisabledStateStyle);
        procedure SetHovered(const AValue: THoveredStateStyle);
        procedure SetPressed(const AValue: TPressedStateStyle);
        procedure SetFocused(const AValue: TFocusedStateStyle);
        procedure DisabledChanged(ASender: TObject);
        procedure HoveredChanged(ASender: TObject);
        procedure PressedChanged(ASender: TObject);
        procedure FocusedChanged(ASender: TObject);
      protected
        function CreateDisabledStateStyle(const AParent: TObject): TDisabledStateStyle; virtual;
        function CreateHoveredStateStyle(const AParent: TObject): THoveredStateStyle; virtual;
        function CreatePressedStateStyle(const AParent: TObject): TPressedStateStyle; virtual;
        function CreateFocusedStateStyle(const AParent: TObject): TFocusedStateStyle; virtual;
      public
        constructor Create(const AParent: TALDynamicControl); override;
        destructor Destroy; override;
        procedure Assign(Source: TPersistent); override;
        procedure Reset; override;
        procedure AlignToPixel; override;
        procedure ApplyColorScheme; override;
        procedure ClearBufDrawable; override;
        function GetCurrentRawStyle: TALDynamicBaseStateStyle; override;
        Property Parent: TALDynamicButton read GetParent;
      public
        property Disabled: TDisabledStateStyle read FDisabled write SetDisabled;
        property Hovered: THoveredStateStyle read FHovered write SetHovered;
        property Pressed: TPressedStateStyle read FPressed write SetPressed;
        property Focused: TFocusedStateStyle read FFocused write SetFocused;
        property Transition;
      end;
      // -----------------
      // TLoadingIndicator
      TLoadingIndicator = class(TALDynamicAnimatedImage)
      public
        type
          TTransitionPhase = (Idle, ButtonIn, ButtonOut, LoadingIndicatorIn, LoadingIndicatorOut);
          TTransitionKind = (CollapseWidth, CollapseHeight, CollapseBoth);
      private
        FTransitionAnimation: TALFloatAnimation;
        FTransitionPhase: TTransitionPhase;
        FTransitionKind: TTransitionKind;
        procedure TransitionAnimationProcess(Sender: TObject);
        procedure TransitionAnimationFinish(Sender: TObject);
      protected
        property TransitionAnimation: TALFloatAnimation read FTransitionAnimation;
        property TransitionPhase: TTransitionPhase read FTransitionPhase write FTransitionPhase;
        property TransitionKind: TTransitionKind read FTransitionKind write FTransitionKind;
      public
        constructor Create(const AOwner: TObject); override;
        destructor Destroy; override;
        procedure BeforeDestruction; override;
      end;
  private
    {$IF defined(ALDPK)}
    FPrevStateStyles: TStateStyles;
    {$ENDIF}
    FStateStyles: TStateStyles;
    FLoadingIndicator: TLoadingIndicator;
    function GetTextSettings: TTextSettings;
    procedure SetStateStyles(const AValue: TStateStyles);
  protected
    function CreateFill: TALBrush; override;
    function CreateStroke: TALStrokeBrush; override;
    function CreateTextSettings: TALBaseTextSettings; override;
    function CreateStateStyles: TStateStyles; virtual;
    procedure SetTextSettings(const Value: TTextSettings); reintroduce;
    //**procedure SetName(const Value: TComponentName); override;
    procedure TextSettingsChanged(Sender: TObject); override;
    procedure StateStylesChanged(Sender: TObject); virtual;
    procedure IsMouseOverChanged; override;
    //**procedure IsFocusedChanged; override;
    procedure PressedChanged; override;
    procedure Click; override;
    Procedure DrawMultilineTextAdjustRect(const ACanvas: TALCanvas; const AOptions: TALMultiLineTextOptions; var ARect: TrectF; var ASurfaceSize: TSizeF); override;
    {$IF NOT DEFINED(ALSkiaCanvas)}
    function GetRenderTargetRect(const ARect: TrectF): TRectF; override;
    {$ENDIF}
    procedure Paint; override;
  public
    constructor Create(const AOwner: TObject); override;
    destructor Destroy; override;
    procedure Assign(Source: TALDynamicControl); override;
    procedure AlignToPixel; override;
    procedure ApplyColorScheme; override;
    procedure MakeBufDrawable; override;
    procedure ClearBufDrawable; override;
    procedure ShowLoadingIndicator(
                const AResourceName: String = 'alcinoe_loading_indicator';
                const ATintColor: TAlphaColor = TalphaColors.Null;
                const ATransitionKind: TLoadingIndicator.TTransitionKind = TLoadingIndicator.TTransitionKind.CollapseWidth); virtual;
    procedure HideLoadingIndicator; virtual;
    Property LoadingIndicator: TLoadingIndicator read FLoadingIndicator;
    property CacheEngine;
    property CacheIndex;
  public
    //property Action;
    property Align;
    //**property Anchors;
    property AutoSize default TALAutoSizeMode.Both;
    property AutoTranslate;
    //**property CanFocus default true;
    //property CanParentFocus;
    //property DisableFocusEffect;
    property ClickSound;
    //**property ClipChildren;
    //property ClipParent;
    property Corners;
    property Cursor default crHandPoint;
    property DoubleBuffered;
    //**property DragMode;
    //**property EnableDragHighlight;
    property Enabled;
    property Fill;
    property Height;
    //property Hint;
    //property ParentShowHint;
    //property ShowHint;
    property HitTest default True;
    //**property Locked;
    property Margins;
    property MaxWidth;
    property MaxHeight;
    property Opacity;
    property Padding;
    //**property PopupMenu;
    //**property Position;
    property RotationAngle;
    //property RotationCenter;
    property Pivot;
    property Scale;
    property Shadow;
    property Sides;
    //**property Size;
    property StateStyles: TStateStyles read FStateStyles write SetStateStyles;
    property Stroke;
    //**property TabOrder;
    //**property TabStop;
    property Text;
    property TextSettings: TTextSettings read GetTextSettings write SetTextSettings;
    property TouchTargetExpansion;
    property Visible;
    property Width;
    property XRadius;
    property YRadius;
    //property OnCanFocus;
    //**property OnDragEnter;
    //**property OnDragLeave;
    //**property OnDragOver;
    //**property OnDragDrop;
    //**property OnDragEnd;
    //property OnEnter;
    //property OnExit;
    property OnMouseEnter;
    property OnMouseLeave;
    property OnMouseDown;
    property OnMouseUp;
    property OnMouseMove;
    //**property OnMouseWheel;
    property OnClick;
    property OnDblClick;
    //property OnKeyDown;
    //property OnKeyUp;
    property OnPainting;
    property OnPaint;
    //property OnResize;
    //**property OnResized;
  end;

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  TALDynamicToggleButton = class(TALDynamicBaseText)
  public
    Type
      TPadding = class(TALBounds)
      protected
        function GetDefaultValue: TRectF; override;
      end;
  protected
    function CreatePadding: TALBounds; override;
  public
    type
      // -------------
      // TGroupMessage
      TGroupMessage = class(TMessage)
      private
        FGroupName: string;
      public
        constructor Create(const AGroupName: string);
        property GroupName: string read FGroupName;
      end;
      // -----
      // TFill
      TFill = class(TALDynamicBaseText.TFill)
      protected
        function GetDefaultColor: TAlphaColor; override;
      end;
      // -------
      // TStroke
      TStroke = class(TALDynamicBaseText.TStroke)
      protected
        function GetDefaultColor: TAlphaColor; override;
      end;
      // -------------
      // TTextSettings
      TTextSettings = class(TALBaseTextSettings)
      public
        Type
          TFont = Class(TALFont)
          protected
            function GetDefaultWeight: TFontWeight; override;
          End;
      protected
        function CreateFont: TALFont; override;
        function GetDefaultHorzAlign: TALTextHorzAlign; override;
      public
        property Font;
        property Decoration;
        property Ellipsis;
        property MaxLines;
        property IsHtml;
        property HorzAlign;
        property VertAlign;
        property LineHeightMultiplier;
        property LetterSpacing;
      end;
      // ---------------
      // TBaseStateStyle
      TBaseStateStyle = class(TALDynamicBaseStateStyle)
      public
        type
          TFill = class(TALInheritBrush)
          protected
            function GetDefaultColor: TAlphaColor; override;
          end;
          TStroke = class(TALInheritStrokeBrush)
          protected
            function GetDefaultColor: TAlphaColor; override;
          end;
          TTextSettings = class(TALInheritBaseTextSettings)
          public
            Type
              TFont = Class(TALFont)
              protected
                function GetDefaultWeight: TFontWeight; override;
              End;
          protected
            function CreateFont: TALFont; override;
          public
            property Font;
            property Decoration;
          end;
      private
        FText: String;
        FTextSettings: TBaseStateStyle.TTextSettings;
        FXRadius: Single;
        FYRadius: Single;
        function GetStateStyleParent: TBaseStateStyle;
        function GetControlParent: TALDynamicToggleButton;
        procedure SetText(const Value: string);
        procedure SetTextSettings(const AValue: TBaseStateStyle.TTextSettings);
        procedure SetXRadius(const Value: Single); virtual;
        procedure SetYRadius(const Value: Single); virtual;
        procedure TextSettingsChanged(ASender: TObject);
        function IsTextStored: Boolean;
        function IsXRadiusStored: Boolean;
        function IsYRadiusStored: Boolean;
      protected
        function CreateFill(const AParent: TALBrush): TALInheritBrush; override;
        function CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush; override;
        function CreateTextSettings(const AParent: TALBaseTextSettings): TBaseStateStyle.TTextSettings; virtual;
        function GetDefaultText: String; virtual;
        function GetDefaultXRadius: Single; virtual;
        function GetDefaultYRadius: Single; virtual;
        function GetInherit: Boolean; override;
        procedure DoSupersede; override;
      public
        constructor Create(const AParent: TObject); override;
        destructor Destroy; override;
        procedure Assign(Source: TPersistent); override;
        procedure Reset; override;
        procedure AlignToPixel; override;
        procedure ApplyColorScheme; override;
        procedure Interpolate(const ATo: TALDynamicBaseStateStyle; const ANormalizedTime: Single; const AReverse: Boolean); override;
        property StateStyleParent: TBaseStateStyle read GetStateStyleParent;
        property ControlParent: TALDynamicToggleButton read GetControlParent;
        property DefaultText: String read GetDefaultText;
        property DefaultXRadius: Single read GetDefaultXRadius;
        property DefaultYRadius: Single read GetDefaultYRadius;
      public
        property Fill;
        property Shadow;
        property Stroke;
        property Text: string read FText write SetText stored IsTextStored nodefault;
        property TextSettings: TBaseStateStyle.TTextSettings read fTextSettings write SetTextSettings;
        property XRadius: Single read FXRadius write SetXRadius stored IsXRadiusStored nodefault;
        property YRadius: Single read FYRadius write SetYRadius stored IsYRadiusStored nodefault;
      end;
      // ------------------
      // TDefaultStateStyle
      TDefaultStateStyle = class(TBaseStateStyle)
      protected
        function GetCacheSubIndex: Integer; override;
      end;
      // -------------------
      // TDisabledStateStyle
      TDisabledStateStyle = class(TBaseStateStyle)
      private
        FOpacity: Single;
        procedure SetOpacity(const Value: Single);
        function IsOpacityStored: Boolean;
      protected
        function GetInherit: Boolean; override;
        function GetCacheSubIndex: Integer; override;
      public
        constructor Create(const AParent: TObject); override;
        procedure Assign(Source: TPersistent); override;
        procedure Reset; override;
      public
        property Opacity: Single read FOpacity write SetOpacity stored IsOpacityStored nodefault;
      end;
      // ------------------
      // THoveredStateStyle
      THoveredStateStyle = class(TBaseStateStyle)
      protected
        function GetCacheSubIndex: Integer; override;
      public
        property StateLayer;
        property Scale;
      end;
      // ------------------
      // TPressedStateStyle
      TPressedStateStyle = class(TBaseStateStyle)
      protected
        function GetCacheSubIndex: Integer; override;
      public
        property StateLayer;
        property Scale;
      end;
      // ------------------
      // TFocusedStateStyle
      TFocusedStateStyle = class(TBaseStateStyle)
      protected
        function GetCacheSubIndex: Integer; override;
      public
        property StateLayer;
        property Scale;
      end;
      // -----------------
      // TCheckStateStyles
      TCheckStateStyles = class(TALPersistentObserver)
      private
        FDefault: TDefaultStateStyle;
        FDisabled: TDisabledStateStyle;
        FHovered: THoveredStateStyle;
        FPressed: TPressedStateStyle;
        FFocused: TFocusedStateStyle;
        procedure SetDefault(const AValue: TDefaultStateStyle);
        procedure SetDisabled(const AValue: TDisabledStateStyle);
        procedure SetHovered(const AValue: THoveredStateStyle);
        procedure SetPressed(const AValue: TPressedStateStyle);
        procedure SetFocused(const AValue: TFocusedStateStyle);
        procedure DefaultChanged(ASender: TObject);
        procedure DisabledChanged(ASender: TObject);
        procedure HoveredChanged(ASender: TObject);
        procedure PressedChanged(ASender: TObject);
        procedure FocusedChanged(ASender: TObject);
      protected
        function CreateSavedState: TALPersistentObserver; override;
        function CreateDefaultStateStyle(const AParent: TObject): TDefaultStateStyle; virtual;
        function CreateDisabledStateStyle(const AParent: TObject): TDisabledStateStyle; virtual;
        function CreateHoveredStateStyle(const AParent: TObject): THoveredStateStyle; virtual;
        function CreatePressedStateStyle(const AParent: TObject): TPressedStateStyle; virtual;
        function CreateFocusedStateStyle(const AParent: TObject): TFocusedStateStyle; virtual;
      public
        constructor Create(const AParent: TALDynamicControl); reintroduce; virtual;
        destructor Destroy; override;
        procedure Assign(Source: TPersistent); override;
        procedure Reset; override;
        procedure AlignToPixel; virtual;
        procedure ApplyColorScheme; virtual;
        procedure ClearBufDrawable; virtual;
      public
        property &Default: TDefaultStateStyle read FDefault write SetDefault;
        property Disabled: TDisabledStateStyle read FDisabled write SetDisabled;
        property Hovered: THoveredStateStyle read FHovered write SetHovered;
        property Pressed: TPressedStateStyle read FPressed write SetPressed;
        property Focused: TFocusedStateStyle read FFocused write SetFocused;
      end;
      // ------------
      // TStateStyles
      TStateStyles = class(TALDynamicBaseStateStyles)
      public
        type
          // -----------
          // TTransition
          TTransition = class(TALDynamicBaseStateStyles.TTransition)
          public
            property FadeImage;
          end;
      private
        FChecked: TCheckStateStyles;
        FUnchecked: TCheckStateStyles;
        function GetParent: TALDynamicToggleButton;
        function GetTransition: TStateStyles.TTransition;
        procedure SetTransition(const AValue: TStateStyles.TTransition);
        procedure SetChecked(const AValue: TCheckStateStyles);
        procedure SetUnchecked(const AValue: TCheckStateStyles);
        procedure CheckedChanged(ASender: TObject);
        procedure UncheckedChanged(ASender: TObject);
      protected
        function CreateTransition: TALDynamicBaseStateStyles.TTransition; override;
        function CreateCheckedStateStyles(const AParent: TALDynamicControl): TCheckStateStyles; virtual;
        function CreateUncheckedStateStyles(const AParent: TALDynamicControl): TCheckStateStyles; virtual;
      public
        constructor Create(const AParent: TALDynamicControl); override;
        destructor Destroy; override;
        procedure Assign(Source: TPersistent); override;
        procedure Reset; override;
        procedure AlignToPixel; override;
        procedure ApplyColorScheme; override;
        procedure ClearBufDrawable; override;
        function GetCurrentRawStyle: TALDynamicBaseStateStyle; override;
        Property Parent: TALDynamicToggleButton read GetParent;
      public
        property Checked: TCheckStateStyles read FChecked write SetChecked;
        property Unchecked: TCheckStateStyles read FUnchecked write SetUnchecked;
        property Transition: TStateStyles.TTransition read GetTransition write SetTransition;
      end;
  private
    {$IF defined(ALDPK)}
    FPrevStateStyles: TStateStyles;
    {$ENDIF}
    FStateStyles: TStateStyles;
    FGroupName: string;
    fMandatory: boolean;
    FChecked: Boolean;
    FOnChange: TNotifyEvent;
    function GetTextSettings: TTextSettings;
    procedure SetStateStyles(const AValue: TStateStyles);
    function GetGroupName: string;
    procedure SetGroupName(const Value: string);
    function GroupNameStored: Boolean;
    procedure GroupMessageCall(const Sender : TObject; const M : TMessage);
  protected
    function CreateFill: TALBrush; override;
    function CreateStroke: TALStrokeBrush; override;
    function CreateTextSettings: TALBaseTextSettings; override;
    function CreateStateStyles: TStateStyles; virtual;
    procedure SetTextSettings(const Value: TTextSettings); reintroduce;
    //**procedure SetName(const Value: TComponentName); override;
    procedure TextSettingsChanged(Sender: TObject); override;
    procedure StateStylesChanged(Sender: TObject); virtual;
    procedure IsMouseOverChanged; override;
    //**procedure IsFocusedChanged; override;
    procedure PressedChanged; override;
    function GetChecked: Boolean; virtual;
    procedure SetChecked(const Value: Boolean); virtual;
    //**procedure KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState); override;
    procedure DoClickSound; override;
    procedure Click; override;
    procedure DoChanged; virtual;
    procedure AdjustSize; override;
    Procedure DrawMultilineTextAdjustRect(const ACanvas: TALCanvas; const AOptions: TALMultiLineTextOptions; var ARect: TrectF; var ASurfaceSize: TSizeF); override;
    {$IF NOT DEFINED(ALSkiaCanvas)}
    function GetRenderTargetRect(const ARect: TrectF): TRectF; override;
    {$ENDIF}
    procedure Paint; override;
  public
    constructor Create(const AOwner: TObject); override;
    destructor Destroy; override;
    procedure BeforeDestruction; override;
    procedure Assign(Source: TALDynamicControl); override;
    procedure AlignToPixel; override;
    procedure ApplyColorScheme; override;
    procedure MakeBufDrawable; override;
    procedure ClearBufDrawable; override;
    property CacheEngine;
    property CacheIndex;
  public
    //property Action;
    property Align;
    //**property Anchors;
    property AutoSize default TALAutoSizeMode.Both;
    property AutoTranslate;
    //**property CanFocus default true;
    //property CanParentFocus;
    //property DisableFocusEffect;
    property Checked: Boolean read GetChecked write SetChecked default False;
    property ClickSound;
    //**property ClipChildren;
    //property ClipParent;
    property Corners;
    property Cursor default crHandPoint;
    property DoubleBuffered;
    //**property DragMode;
    //**property EnableDragHighlight;
    property Enabled;
    property Fill;
    property GroupName: string read GetGroupName write SetGroupName stored GroupNameStored nodefault;
    property Mandatory: Boolean read fMandatory write fMandatory default false;
    property Height;
    //property Hint;
    //property ParentShowHint;
    //property ShowHint;
    property HitTest default True;
    //**property Locked;
    property Margins;
    property MaxWidth;
    property MaxHeight;
    property Opacity;
    property Padding;
    //**property PopupMenu;
    //**property Position;
    property RotationAngle;
    //property RotationCenter;
    property Pivot;
    property Scale;
    property Shadow;
    property Sides;
    //**property Size;
    property StateStyles: TStateStyles read FStateStyles write SetStateStyles;
    property Stroke;
    //**property TabOrder;
    //**property TabStop;
    property Text;
    property TextSettings: TTextSettings read GetTextSettings write SetTextSettings;
    property TouchTargetExpansion;
    property Visible;
    property Width;
    property XRadius;
    property YRadius;
    //property OnCanFocus;
    //**property OnDragEnter;
    //**property OnDragLeave;
    //**property OnDragOver;
    //**property OnDragDrop;
    //**property OnDragEnd;
    //property OnEnter;
    //property OnExit;
    property OnMouseEnter;
    property OnMouseLeave;
    property OnMouseDown;
    property OnMouseUp;
    property OnMouseMove;
    //**property OnMouseWheel;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
    property OnClick;
    property OnDblClick;
    //property OnKeyDown;
    //property OnKeyUp;
    property OnPainting;
    property OnPaint;
    //property OnResize;
    //**property OnResized;
  end;

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  TALDynamicCustomTrack = class(TALDynamicExtendedControl)
  public
    type
      // ------
      // TTrack
      TTrack = class(TALDynamicBaseRectangle)
      public
        Type
          TMargins = class(TALBounds)
          protected
            function GetDefaultValue: TRectF; override;
          end;
      protected
        function CreateMargins: TALBounds; override;
      public
        type
          // -----
          // TFill
          TFill = class(TALBrush)
          protected
            function GetDefaultColor: TAlphaColor; override;
          end;
          // -------
          // TStroke
          TStroke = class(TALStrokeBrush)
          protected
            function GetDefaultColor: TAlphaColor; override;
          end;
          // -------------------
          // TStopIndicatorBrush
          TStopIndicatorBrush = class(TALPersistentObserver)
          private
            FColor: TAlphaColor;
            FColorKey: String;
            FResourceName: String;
            FWrapMode: TALImageWrapMode;
            FSize: Single;
            procedure SetColor(const Value: TAlphaColor);
            procedure SetColorKey(const Value: String);
            procedure SetResourceName(const Value: String);
            procedure SetWrapMode(const Value: TALImageWrapMode);
            procedure SetSize(const Value: Single);
            function IsColorStored: Boolean;
            function IsColorKeyStored: Boolean;
            function IsResourceNameStored: Boolean;
            function IsWrapModeStored: Boolean;
            function IsSizeStored: Boolean;
          protected
            function GetDefaultColor: TAlphaColor; virtual;
            function GetDefaultColorKey: String; virtual;
            function GetDefaultResourceName: String; virtual;
            function GetDefaultWrapMode: TALImageWrapMode; virtual;
            function GetDefaultSize: Single; virtual;
          public
            constructor Create; override;
            procedure Assign(Source: TPersistent); override;
            procedure Reset; override;
            procedure AlignToPixel; virtual;
            procedure ApplyColorScheme; virtual;
            procedure Interpolate(const ATo: TStopIndicatorBrush; const ANormalizedTime: Single; const AReverse: Boolean); virtual;
            procedure InterpolateNoChanges(const ATo: TStopIndicatorBrush; const ANormalizedTime: Single; const AReverse: Boolean);
            function hasStopIndicator: Boolean;
            property DefaultColor: TAlphaColor read GetDefaultColor;
            property DefaultColorKey: String read GetDefaultColorKey;
            property DefaultResourceName: String read GetDefaultResourceName;
            property DefaultWrapMode: TALImageWrapMode read GetDefaultWrapMode;
            property DefaultSize: Single read GetDefaultSize;
          public
            property Color: TAlphaColor read FColor write SetColor stored IsColorStored;
            property ColorKey: String read FColorKey write SetColorKey stored IsColorKeyStored;
            property ResourceName: String read FResourceName write SetResourceName stored IsResourceNameStored nodefault;
            property WrapMode: TALImageWrapMode read FWrapMode write SetWrapMode stored IsWrapModeStored;
            property Size: Single read FSize write SetSize stored IsSizeStored nodefault;
          end;
          // --------------------------
          // TInheritStopIndicatorBrush
          TInheritStopIndicatorBrush = class(TStopIndicatorBrush)
          private
            FParent: TStopIndicatorBrush;
            FInherit: Boolean;
            fSuperseded: Boolean;
            procedure SetInherit(const AValue: Boolean);
          protected
            function CreateSavedState: TALPersistentObserver; override;
            procedure DoSupersede; virtual;
          public
            constructor Create(const AParent: TStopIndicatorBrush); reintroduce; virtual;
            procedure Assign(Source: TPersistent); override;
            procedure Reset; override;
            procedure Supersede(Const ASaveState: Boolean = False); virtual;
            procedure SupersedeNoChanges(Const ASaveState: Boolean = False);
            property Superseded: Boolean read FSuperseded;
            property Parent: TStopIndicatorBrush read FParent;
          public
            property Inherit: Boolean read FInherit write SetInherit Default True;
          end;
          // ---------------
          // TBaseStateStyle
          TBaseStateStyle = class(TALDynamicBaseStateStyle)
          public
            type
              TFill = class(TALInheritBrush)
              protected
                function GetDefaultColor: TAlphaColor; override;
              end;
              TStroke = class(TALInheritStrokeBrush)
              protected
                function GetDefaultColor: TAlphaColor; override;
              end;
              TStateLayer = class(TALStateLayer)
              protected
                function GetDefaultXRadius: Single; override;
                function GetDefaultYRadius: Single; override;
              end;
          private
            FStopIndicator: TInheritStopIndicatorBrush;
            function GetControlParent: TTrack;
            procedure SetStopIndicator(const AValue: TInheritStopIndicatorBrush);
            procedure StopIndicatorChanged(ASender: TObject);
          protected
            function CreateFill(const AParent: TALBrush): TALInheritBrush; override;
            function CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush; override;
            function CreateStateLayer: TALStateLayer; override;
            function CreateStopIndicator(const AParent: TStopIndicatorBrush): TInheritStopIndicatorBrush; virtual;
            procedure DoSupersede; override;
            function GetInherit: Boolean; override;
          public
            constructor Create(const AParent: TObject); override;
            destructor Destroy; override;
            procedure Assign(Source: TPersistent); override;
            procedure Reset; override;
            procedure AlignToPixel; override;
            procedure ApplyColorScheme; override;
            procedure Interpolate(const ATo: TALDynamicBaseStateStyle; const ANormalizedTime: Single; const AReverse: Boolean); override;
            property ControlParent: TTrack read GetControlParent;
          public
            property Fill;
            property StopIndicator: TInheritStopIndicatorBrush read FStopIndicator write SetStopIndicator;
            property Stroke;
          end;
          // -------------------
          // TDisabledStateStyle
          TDisabledStateStyle = class(TBaseStateStyle)
          private
            FOpacity: Single;
            procedure SetOpacity(const Value: Single);
            function IsOpacityStored: Boolean;
          protected
            function GetInherit: Boolean; override;
          public
            constructor Create(const AParent: TObject); override;
            procedure Assign(Source: TPersistent); override;
            procedure Reset; override;
          public
            property Opacity: Single read FOpacity write SetOpacity stored IsOpacityStored nodefault;
          end;
          // ------------
          // TStateStyles
          TStateStyles = class(TALDynamicBaseStateStyles)
          private
            FDisabled: TDisabledStateStyle;
            function GetParent: TTrack;
            procedure SetDisabled(const AValue: TDisabledStateStyle);
            procedure DisabledChanged(ASender: TObject);
          protected
            function CreateDisabledStateStyle(const AParent: TObject): TDisabledStateStyle; virtual;
          public
            constructor Create(const AParent: TALDynamicControl); override;
            destructor Destroy; override;
            procedure Assign(Source: TPersistent); override;
            procedure Reset; override;
            procedure AlignToPixel; override;
            procedure ApplyColorScheme; override;
            procedure ClearBufDrawable; override;
            function GetCurrentRawStyle: TALDynamicBaseStateStyle; override;
            Property Parent: TTrack read GetParent;
          public
            property Disabled: TDisabledStateStyle read FDisabled write SetDisabled;
          end;
      private
        FStateStyles: TStateStyles;
        FCustomTrack: TALDynamicCustomTrack;
        FStopIndicator: TStopIndicatorBrush;
        procedure SetStateStyles(const AValue: TStateStyles);
        procedure SetStopIndicator(const Value: TStopIndicatorBrush);
      protected
        function CreateFill: TALBrush; override;
        function CreateStroke: TALStrokeBrush; override;
        function CreateStopIndicator: TStopIndicatorBrush; virtual;
        function CreateStateStyles: TStateStyles; virtual;
        procedure StateStylesChanged(Sender: TObject); virtual;
        procedure StopIndicatorChanged(Sender: TObject); virtual;
        procedure PaddingChanged; override;
        function HasCustomDraw: Boolean; override;
        Procedure CreateBufDrawable(
                    var ABufDrawable: TALDrawable;
                    out ABufDrawableRect: TRectF;
                    const AScale: Single;
                    const AFill: TALBrush;
                    const AStateLayer: TALStateLayer;
                    const AStateLayerContentColor: TAlphaColor;
                    const ADrawStateLayerOnTop: Boolean;
                    const AStroke: TALStrokeBrush;
                    const AShadow: TALShadow); overload; override;
        Procedure CreateBufDrawable(
                    var ABufDrawable: TALDrawable;
                    out ABufDrawableRect: TRectF;
                    const AScale: Single;
                    const AFill: TALBrush;
                    const AStateLayer: TALStateLayer;
                    const AStateLayerContentColor: TAlphaColor;
                    const ADrawStateLayerOnTop: Boolean;
                    const AStroke: TALStrokeBrush;
                    const AShadow: TALShadow;
                    const AStopIndicator: TStopIndicatorBrush); reintroduce; overload; virtual;
        function GetBufDrawableSrcRect: TRectF; virtual; abstract;
        procedure Paint; override;
      public
        constructor Create(const ACustomTrack: TALDynamicCustomTrack); reintroduce; virtual;
        destructor Destroy; override;
        procedure Assign(Source: TALDynamicControl); override;
        procedure AlignToPixel; override;
        procedure ApplyColorScheme; override;
        procedure MakeBufDrawable; override;
        procedure ClearBufDrawable; override;
        property HitTest default false;
        //**property Locked default True;
        //**property Position stored false;
      public
        //property Action;
        //property Align;
        //property Anchors;
        //property AutoSize;
        //property CanFocus;
        //property CanParentFocus;
        //property DisableFocusEffect;
        property ClickSound;
        //property ClipChildren;
        //property ClipParent;
        property Corners;
        //property Cursor;
        //property DoubleBuffered;
        //property DragMode;
        //property EnableDragHighlight;
        //property Enabled;
        property Fill;
        //property Height;
        //property Hint;
        //property ParentShowHint;
        //property ShowHint;
        //property HitTest;
        //property Locked;
        property Margins;
        property Opacity;
        property Padding;
        //property PopupMenu;
        //property Position;
        //property RotationAngle;
        //property RotationCenter;
        //property Pivot;
        //property Scale;
        //property Shadow;
        //property Sides;
        //property Size;
        property StateStyles: TStateStyles read FStateStyles write SetStateStyles;
        property StopIndicator: TStopIndicatorBrush read FStopIndicator write SetStopIndicator;
        property Stroke;
        //property TabOrder;
        //property TabStop;
        //property TouchTargetExpansion;
        //property Visible;
        //property Width;
        property XRadius;
        property YRadius;
        //property OnCanFocus;
        //property OnDragEnter;
        //property OnDragLeave;
        //property OnDragOver;
        //property OnDragDrop;
        //property OnDragEnd;
        //property OnEnter;
        //property OnExit;
        //property OnMouseEnter;
        //property OnMouseLeave;
        //property OnMouseDown;
        //property OnMouseUp;
        //property OnMouseMove;
        //property OnMouseWheel;
        //property OnClick;
        //property OnDblClick;
        //property OnKeyDown;
        //property OnKeyUp;
        property OnPainting;
        property OnPaint;
        //property OnResize;
        //property OnResized;
      end;
      // --------------
      // TInactiveTrack
      TInactiveTrack = class(TTrack)
      protected
        function GetBufDrawableSrcRect: TRectF; override;
      end;
      // ------------
      // TActiveTrack
      TActiveTrack = class(TTrack)
      public
        type
          // -----
          // TFill
          TFill = class(TTrack.TFill)
          protected
            function GetDefaultColor: TAlphaColor; override;
          end;
          // -------------------
          // TDisabledStateStyle
          TDisabledStateStyle = class(TTrack.TDisabledStateStyle)
          public
            type
              TFill = class(TTrack.TDisabledStateStyle.TFill)
              protected
                function GetDefaultColor: TAlphaColor; override;
              end;
          protected
            function CreateFill(const AParent: TALBrush): TALInheritBrush; override;
          end;
          // ------------
          // TStateStyles
          TStateStyles = class(TTrack.TStateStyles)
          protected
            function CreateDisabledStateStyle(const AParent: TObject): TTrack.TDisabledStateStyle; override;
          end;
      protected
        function CreateFill: TALBrush; override;
        function CreateStateStyles: TTrack.TStateStyles; override;
        function GetBufDrawableSrcRect: TRectF; override;
      end;
      // ------
      // TThumb
      TThumb = class(TALDynamicBaseRectangle)
      public
        type
          // -------
          // TStroke
          TStroke = class(TALStrokeBrush)
          protected
            function GetDefaultColor: TAlphaColor; override;
          end;
          // ---------------
          // TBaseStateStyle
          TBaseStateStyle = class(TALDynamicBaseStateStyle)
          public
            type
              TStroke = class(TALInheritStrokeBrush)
              protected
                function GetDefaultColor: TAlphaColor; override;
              end;
              TStateLayer = class(TALStateLayer)
              protected
                function GetDefaultXRadius: Single; override;
                function GetDefaultYRadius: Single; override;
              end;
          protected
            function CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush; override;
            function CreateStateLayer: TALStateLayer; override;
          public
            property Fill;
            property Shadow;
            property Stroke;
          end;
          // -------------------
          // TDisabledStateStyle
          TDisabledStateStyle = class(TBaseStateStyle)
          private
            FOpacity: Single;
            procedure SetOpacity(const Value: Single);
            function IsOpacityStored: Boolean;
          protected
            function GetInherit: Boolean; override;
          public
            constructor Create(const AParent: TObject); override;
            procedure Assign(Source: TPersistent); override;
            procedure Reset; override;
          public
            property Opacity: Single read FOpacity write SetOpacity stored IsOpacityStored nodefault;
          end;
          // ------------------
          // THoveredStateStyle
          THoveredStateStyle = class(TBaseStateStyle)
          public
            property StateLayer;
            property Scale;
          end;
          // ------------------
          // TPressedStateStyle
          TPressedStateStyle = class(TBaseStateStyle)
          public
            property StateLayer;
            property Scale;
          end;
          // ------------------
          // TFocusedStateStyle
          TFocusedStateStyle = class(TBaseStateStyle)
          public
            property StateLayer;
            property Scale;
          end;
          // ------------
          // TStateStyles
          TStateStyles = class(TALDynamicBaseStateStyles)
          private
            FDisabled: TDisabledStateStyle;
            FHovered: THoveredStateStyle;
            FPressed: TPressedStateStyle;
            FFocused: TFocusedStateStyle;
            function GetParent: TThumb;
            procedure SetDisabled(const AValue: TDisabledStateStyle);
            procedure SetHovered(const AValue: THoveredStateStyle);
            procedure SetPressed(const AValue: TPressedStateStyle);
            procedure SetFocused(const AValue: TFocusedStateStyle);
            procedure DisabledChanged(ASender: TObject);
            procedure HoveredChanged(ASender: TObject);
            procedure PressedChanged(ASender: TObject);
            procedure FocusedChanged(ASender: TObject);
          protected
            function CreateDisabledStateStyle(const AParent: TObject): TDisabledStateStyle; virtual;
            function CreateHoveredStateStyle(const AParent: TObject): THoveredStateStyle; virtual;
            function CreatePressedStateStyle(const AParent: TObject): TPressedStateStyle; virtual;
            function CreateFocusedStateStyle(const AParent: TObject): TFocusedStateStyle; virtual;
          public
            constructor Create(const AParent: TALDynamicControl); override;
            destructor Destroy; override;
            procedure Assign(Source: TPersistent); override;
            procedure Reset; override;
            procedure AlignToPixel; override;
            procedure ApplyColorScheme; override;
            procedure ClearBufDrawable; override;
            function GetCurrentRawStyle: TALDynamicBaseStateStyle; override;
            Property Parent: TThumb read GetParent;
          public
            property Disabled: TDisabledStateStyle read FDisabled write SetDisabled;
            property Hovered: THoveredStateStyle read FHovered write SetHovered;
            property Pressed: TPressedStateStyle read FPressed write SetPressed;
            property Focused: TFocusedStateStyle read FFocused write SetFocused;
            property Transition;
          end;
      private
        FStateStyles: TStateStyles;
        fValueRange: TValueRange;
        FCustomTrack: TALDynamicCustomTrack;
        fCustomTrackMouseDownPos: TPointF;
        fScrollCapturedByMe: boolean;
        procedure SetStateStyles(const AValue: TStateStyles);
        procedure ScrollCapturedByOtherHandler(const Sender: TObject; const M: TMessage);
      protected
        function CreateStroke: TALStrokeBrush; override;
        function CreateStateStyles: TStateStyles; virtual;
        procedure DoBeginUpdate; override;
        procedure DoEndUpdate; override;
        function GetDefaultXRadius: Single; override;
        function GetDefaultYRadius: Single; override;
        procedure StateStylesChanged(Sender: TObject); virtual;
        procedure IsMouseOverChanged; override;
        //**procedure IsFocusedChanged; override;
        procedure PressedChanged; override;
        procedure ValueRangeChanged(Sender: TObject); Virtual;
        //**procedure KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState); override;
        {$IF NOT DEFINED(ALSkiaCanvas)}
        function GetRenderTargetRect(const ARect: TrectF): TRectF; override;
        {$ENDIF}
        procedure Paint; override;
      public
        constructor Create(const ACustomTrack: TALDynamicCustomTrack); reintroduce; virtual;
        destructor Destroy; override;
        procedure BeforeDestruction; override;
        procedure Assign(Source: TALDynamicControl); override;
        procedure AlignToPixel; override;
        procedure ApplyColorScheme; override;
        function GetValue: Double;
        procedure MakeBufDrawable; override;
        procedure ClearBufDrawable; override;
        procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Single); override;
        procedure MouseMove(Shift: TShiftState; X, Y: Single); override;
        procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Single); override;
        procedure MouseLeave; override;
        //**property Locked default True;
        //**property Position stored false;
        //**property CanFocus default true;
      public
        //property Action;
        //property Align;
        //property Anchors;
        //property AutoSize;
        //property CanFocus default true;
        //property CanParentFocus;
        //property DisableFocusEffect;
        property ClickSound;
        //property ClipChildren;
        //property ClipParent;
        property Corners;
        property Cursor default crHandPoint;
        //property DoubleBuffered;
        //property DragMode;
        //property EnableDragHighlight;
        //property Enabled;
        property Fill;
        property Height;
        //property Hint;
        //property ParentShowHint;
        //property ShowHint;
        //property HitTest;
        //property Locked;
        property Margins;
        property Opacity;
        property Padding;
        //property PopupMenu;
        //property Position;
        //property RotationAngle;
        //property RotationCenter;
        //property Pivot;
        //property Scale;
        property Shadow;
        //property Sides;
        //**property Size;
        property StateStyles: TStateStyles read FStateStyles write SetStateStyles;
        property Stroke;
        //property TabOrder;
        //property TabStop;
        property TouchTargetExpansion;
        //property Visible;
        property Width;
        property XRadius;
        property YRadius;
        //property OnCanFocus;
        //property OnDragEnter;
        //property OnDragLeave;
        //property OnDragOver;
        //property OnDragDrop;
        //property OnDragEnd;
        //property OnEnter;
        //property OnExit;
        //property OnMouseEnter;
        //property OnMouseLeave;
        //property OnMouseDown;
        //property OnMouseUp;
        //property OnMouseMove;
        //property OnMouseWheel;
        //property OnClick;
        //property OnDblClick;
        //property OnKeyDown;
        //property OnKeyUp;
        property OnPainting;
        property OnPaint;
        //property OnResize;
        //property OnResized;
      end;
      // ---------------
      // TValueIndicator
      TValueIndicator = class(TALDynamicBaseText)
      public
        Type
          TPadding = class(TALBounds)
          protected
            function GetDefaultValue: TRectF; override;
          end;
      protected
        function CreatePadding: TALBounds; override;
      public
        Type
          TMargins = class(TALBounds)
          protected
            function GetDefaultValue: TRectF; override;
          end;
      protected
        function CreateMargins: TALBounds; override;
      public
        class var Format0: String;
      public
        type
          // -----
          // TFill
          TFill = class(TALDynamicBaseText.TFill)
          protected
            function GetDefaultColor: TAlphaColor; override;
          end;
          // -------------
          // TTextSettings
          TTextSettings = Class(TALTextSettings)
          public
            Type
              TFont = Class(TALFont)
              protected
                function GetDefaultWeight: TFontWeight; override;
                function GetDefaultColor: TAlphaColor; override;
              End;
          protected
            function CreateFont: TALFont; override;
            function GetDefaultHorzAlign: TALTextHorzAlign; override;
          End;
          // ----------
          // TAnimation
          TAnimation = (None, ScaleInOut, Opacity);
          // ------------------
          // TCustomFormatEvent
          TCustomFormatEvent = procedure(ASender: TObject; const AValue: Double; Var AText: String) of object;
      private
        FCustomTrack: TALDynamicCustomTrack;
        FFormat: String;
        FOnCustomFormat: TCustomFormatEvent;
        FFloatAnimation: TALFloatAnimation;
        FAnimation: TAnimation;
        FShowOnInteraction: Boolean;
        function GetTextSettings: TALTextSettings;
        procedure SetFormat(const Value: string);
        function IsFormatStored: Boolean;
        procedure AnimationProcess(Sender: TObject);
        procedure AnimationFinish(Sender: TObject);
        procedure AdjustPosition(const AThumb: TThumb);
      protected
        function CreateFill: TALBrush; override;
        function CreateTextSettings: TALBaseTextSettings; override;
        procedure SetTextSettings(const Value: TALTextSettings); reintroduce;
        function GetDefaultXRadius: Single; override;
        function GetDefaultYRadius: Single; override;
        function GetDefaultFormat: String; virtual;
      public
        constructor Create(const ACustomTrack: TALDynamicCustomTrack); reintroduce; virtual;
        destructor Destroy; override;
        procedure Assign(Source: TALDynamicControl); override;
        procedure Refresh(const AThumb: TThumb);
        property DefaultFormat: String read GetDefaultFormat;
        property Visible default false;
      public
        //property Action;
        //property Align;
        //property Anchors;
        property Animation: TAnimation read FAnimation write FAnimation default TAnimation.ScaleInOut;
        property AutoSize default TALAutoSizeMode.Both;
        //property AutoTranslate;
        //property CanFocus;
        //property CanParentFocus;
        //property DisableFocusEffect;
        property ClickSound;
        //property ClipChildren;
        //property ClipParent;
        property Corners;
        //property Cursor;
        //property DoubleBuffered;
        //property DragMode;
        //property EnableDragHighlight;
        //property Enabled;
        property Fill;
        property Format: string read FFormat write SetFormat stored IsFormatStored;
        property Height;
        //property Hint;
        //property ParentShowHint;
        //property ShowHint;
        //property HitTest;
        //property Locked;
        property Margins;
        //property MaxWidth;
        //property MaxHeight;
        property Opacity;
        property Padding;
        //property PopupMenu;
        //property Position;
        //property RotationAngle;
        //property RotationCenter;
        //property Pivot;
        //property Scale;
        property Shadow;
        property ShowOnInteraction: Boolean read FShowOnInteraction write FShowOnInteraction default false;
        property Sides;
        //**property Size;
        property Stroke;
        //property TabOrder;
        //property TabStop;
        //property Text;
        property TextSettings: TALTextSettings read GetTextSettings write SetTextSettings;
        //property TouchTargetExpansion;
        //property Visible default false;
        property Width;
        property XRadius;
        property YRadius;
        //property OnCanFocus;
        property OnCustomFormat: TCustomFormatEvent read FOnCustomFormat write FOnCustomFormat;
        //property OnDragEnter;
        //property OnDragLeave;
        //property OnDragOver;
        //property OnDragDrop;
        //property OnDragEnd;
        //property OnElementClick;
        //property OnElementDblClick;
        //property OnElementMouseDown;
        //property OnElementMouseMove;
        //property OnElementMouseUp;
        //property OnElementMouseEnter;
        //property OnElementMouseLeave;
        //property OnEnter;
        //property OnExit;
        //property OnMouseEnter;
        //property OnMouseLeave;
        //property OnMouseDown;
        //property OnMouseUp;
        //property OnMouseMove;
        //property OnMouseWheel;
        //property OnClick;
        //property OnDblClick;
        //property OnKeyDown;
        //property OnKeyUp;
        property OnPainting;
        property OnPaint;
        //property OnResize;
        //property OnResized;
      end;
  private
    FTabStop: Boolean;
    FIsAligningTracks: Boolean;
    function FrequencyStored: Boolean;
    function MaxStored: Boolean;
    function MinStored: Boolean;
    function ViewportSizeStored: Boolean;
  protected
    type
      TInactiveTrackClass = Class of TInactiveTrack;
      TActiveTrackClass = Class of TActiveTrack;
      TThumbClass = Class of TThumb;
      TValueIndicatorClass = Class of TValueIndicator;
  protected
    FInactiveTrack: TInactiveTrack;
    FActiveTrack: TActiveTrack;
    FThumb: TThumb;
    FValueIndicator: TValueIndicator;
    FOrientation: TOrientation;
    FOnChange: TNotifyEvent;
    function GetLeadingTrack: TTrack; virtual;
    function GetTrailingTrack: TTrack; virtual;
    function GetLeadingTrackStartPadding: Single;
    function GetTrailingTrackEndPadding: Single;
    /// <summary>
    ///   Return the precise size of the track where the center
    ///   of the thumb can be positioned
    /// </summary>
    function GetTrackSize(Const AIncludeTrackPadding: Boolean = False): Single; virtual;
    function GetDoubleBuffered: boolean; override;
    procedure SetDoubleBuffered(const AValue: Boolean); override;
    //**function _GetCanFocus: Boolean; virtual; virtual;
    //**procedure _SetCanFocus(const Value: Boolean); virtual; virtual;
    //**procedure _SetTabStop(const Value: Boolean); virtual; virtual;
    procedure SetViewportSize(const Value: Double); virtual;
    function GetViewportSize: Double; virtual;
    function GetFrequency: Double; virtual;
    procedure SetFrequency(const Value: Double); virtual;
    function GetMax: Double; virtual;
    procedure SetMax(const Value: Double); virtual;
    function GetMin: Double; virtual;
    procedure SetMin(const Value: Double); virtual;
    function GetValue: Double; virtual;
    procedure SetValue(Value: Double); virtual;
    function ValueStored: Boolean; virtual;
    procedure SetOrientation(const Value: TOrientation); virtual;
    /// <summary>
    ///   Return the center position of the thumb corresponding to AValue
    /// </summary>
    function GetThumbPos(const AValue: single): Single; virtual;
    procedure DoResized; override;
    procedure DoRealign; override;
    //**procedure Loaded; override;
    procedure DoChanged; virtual;
    procedure EnabledChanged; override;
    property Value: Double read GetValue write SetValue stored ValueStored nodefault;
    property InactiveTrack: TInactiveTrack read FInactiveTrack;
    property ActiveTrack: TActiveTrack read FActiveTrack;
    property Thumb: TThumb read FThumb;
    property ValueIndicator: TValueIndicator read FValueIndicator;
    function CreateInactiveTrack(const AInactiveTrackClass: TInactiveTrackClass = nil; Const AName: String = 'InactiveTrack'): TInactiveTrack; virtual;
    function CreateActiveTrack(const AActiveTrackClass: TActiveTrackClass = nil; Const AName: String = 'ActiveTrack'): TActiveTrack; virtual;
    function CreateThumb(const AThumbClass: TThumbClass = nil; Const AName: String = 'Thumb'): TThumb; virtual;
    function CreateValueIndicator(const AValueIndicatorClass: TValueIndicatorClass = nil; Const AName: String = 'ValueIndicator'): TValueIndicator; virtual;
    procedure AlignThumb; virtual;
    procedure AlignTracks; virtual;
  public
    constructor Create(const AOwner: TObject); override;
    procedure AfterConstruction; override;
    procedure Assign(Source: TALDynamicControl); override;
    procedure AlignToPixel; override;
    procedure ApplyColorScheme; override;
    procedure MakeBufDrawable; override;
    procedure ClearBufDrawable; override;
    property DoubleBuffered default true;
    //**property CanFocus: Boolean read _GetCanFocus write _SetCanFocus default True;
    //**property TabStop: Boolean read FTabStop write _SetTabStop default True;
    property Min: Double read GetMin write SetMin stored MinStored nodefault;
    property Max: Double read GetMax write SetMax stored MaxStored nodefault;
    property Frequency: Double read GetFrequency write SetFrequency stored FrequencyStored nodefault;
    property ViewportSize: Double read GetViewportSize write SetViewportSize stored ViewportSizeStored nodefault;
    property Orientation: TOrientation read FOrientation write SetOrientation default TOrientation.Horizontal;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  TALDynamicTrackBar = class(TALDynamicCustomTrack)
  protected
    function GetDefaultSize: TSizeF; override;
  public
    //property Action;
    property ActiveTrack;
    property Align;
    //**property Anchors;
    //property AutoSize;
    //**property CanFocus;
    //property CanParentFocus;
    //property DisableFocusEffect;
    property DoubleBuffered;
    property ClickSound;
    //**property ClipChildren;
    //property ClipParent;
    property Cursor;
    //property DoubleBuffered;
    //**property DragMode;
    //**property EnableDragHighlight;
    property Enabled;
    property Frequency;
    property Height;
    //property Hint;
    //property ParentShowHint;
    //property ShowHint;
    property HitTest;
    property InactiveTrack;
    //**property Locked;
    property Margins;
    property Min;
    property Max;
    property Opacity;
    property Orientation;
    property Padding;
    //**property PopupMenu;
    //**property Position;
    property RotationAngle;
    //property RotationCenter;
    property Pivot;
    property Scale;
    //**property Size;
    //**property TabOrder;
    //**property TabStop;
    property Thumb;
    property TouchTargetExpansion;
    property Value;
    property ValueIndicator;
    property Visible;
    property Width;
    //**property OnCanFocus;
    property OnChange;
    //**property OnDragEnter;
    //**property OnDragLeave;
    //**property OnDragOver;
    //**property OnDragDrop;
    //**property OnDragEnd;
    //**property OnEnter;
    //**property OnExit;
    property OnMouseEnter;
    property OnMouseLeave;
    property OnMouseDown;
    property OnMouseUp;
    property OnMouseMove;
    //**property OnMouseWheel;
    property OnClick;
    property OnDblClick;
    //**property OnKeyDown;
    //**property OnKeyUp;
    property OnPainting;
    property OnPaint;
    //property OnResize;
    //**property OnResized;
  end;

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  TALDynamicRangeTrackBar = class(TALDynamicCustomTrack)
  public
    Type
      // -----------------
      // TMinInactiveTrack
      TMinInactiveTrack = class(TALDynamicCustomTrack.TInactiveTrack)
      private
        function _GetOpacity: Single;
        procedure _SetOpacity(const AValue: Single);
        function _IsOpacityStored: boolean;
      protected
        procedure SetXRadius(const Value: Single); override;
        procedure SetYRadius(const Value: Single); override;
        procedure SetCorners(const Value: TCorners); override;
        procedure MarginsChanged; override;
        procedure PaddingChanged; override;
        procedure StopIndicatorChanged(Sender: TObject); override;
        procedure FillChanged(Sender: TObject); override;
        procedure StrokeChanged(Sender: TObject); override;
        function GetBufDrawableSrcRect: TRectF; override;
      public
        property Opacity: Single read _GetOpacity write _SetOpacity stored _IsOpacityStored nodefault;
      end;
      // -----------------
      // TMaxInactiveTrack
      TMaxInactiveTrack = class(TALDynamicCustomTrack.TInactiveTrack)
      protected
        function GetBufDrawableSrcRect: TRectF; override;
      end;
      // ------------
      // TActiveTrack
      TActiveTrack = class(TALDynamicCustomTrack.TActiveTrack)
      protected
        function GetBufDrawableSrcRect: TRectF; override;
      end;
      // ---------
      // TMinThumb
      TMinThumb = class(TALDynamicCustomTrack.TThumb)
      private
        //**FFormerTouchTargetExpansionChangedHandler: TNotifyEvent;
        function _GetOpacity: Single;
        procedure _SetOpacity(const AValue: Single);
        function _GetCursor: TCursor;
        procedure _SetCursor(const AValue: TCursor);
        function _IsOpacityStored: boolean;
      protected
        procedure SetXRadius(const Value: Single); override;
        procedure SetYRadius(const Value: Single); override;
        procedure SetCorners(const Value: TCorners); override;
        procedure MarginsChanged; override;
        procedure PaddingChanged; override;
        procedure FillChanged(Sender: TObject); override;
        procedure StrokeChanged(Sender: TObject); override;
        procedure ShadowChanged(Sender: TObject); override;
        procedure StateStylesChanged(Sender: TObject); override;
        procedure SetTouchTargetExpansion(const AValue: TRectF); override;
        procedure DoResized; override;
     public
       constructor Create(const ACustomTrack: TALDynamicCustomTrack); override;
     public
        property Opacity: Single read _GetOpacity write _SetOpacity stored _IsOpacityStored nodefault;
        property Cursor: TCursor read _GetCursor write _SetCursor default crHandPoint;
      end;
      // ---------
      // TMaxThumb
      TMaxThumb = class(TALDynamicCustomTrack.TThumb)
      public
        constructor Create(const ACustomTrack: TALDynamicCustomTrack); override;
      end;
  protected
    FMaxInactiveTrack: TALDynamicCustomTrack.TInactiveTrack;
    FMaxThumb: TALDynamicCustomTrack.TThumb;
    function GetLeadingTrack: TALDynamicCustomTrack.TTrack; override;
    function GetTrailingTrack: TALDynamicCustomTrack.TTrack; override;
    procedure SetDoubleBuffered(const AValue: Boolean); override;
    //**procedure _SetCanFocus(const Value: Boolean); virtual; override;
    //**procedure _SetTabStop(const Value: Boolean); virtual; override;
    procedure SetViewportSize(const Value: Double); override;
    procedure SetFrequency(const Value: Double); override;
    procedure SetMax(const Value: Double); override;
    procedure SetMin(const Value: Double); override;
    function MaxValueStored: Boolean; virtual;
    function GetDefaultSize: TSizeF; override;
    procedure SetValue(Value: Double); override;
    function GetMaxValue: Double; virtual;
    procedure SetMaxValue(Value: Double); virtual;
    procedure SetOrientation(const Value: TOrientation); override;
    procedure EnabledChanged; override;
    //**procedure Loaded; override;
    function CreateInactiveTrack(const AInactiveTrackClass: TALDynamicCustomTrack.TInactiveTrackClass = nil; Const AName: String = 'InactiveTrack'): TALDynamicCustomTrack.TInactiveTrack; override;
    function CreateActiveTrack(const AActiveTrackClass: TALDynamicCustomTrack.TActiveTrackClass = nil; Const AName: String = 'ActiveTrack'): TALDynamicCustomTrack.TActiveTrack; override;
    function CreateThumb(const AThumbClass: TALDynamicCustomTrack.TThumbClass = nil; Const AName: String = 'Thumb'): TALDynamicCustomTrack.TThumb; override;
    procedure DoResized; override;
    procedure DoRealign; override;
    procedure AlignThumb; override;
    procedure AlignTracks; override;
  public
    constructor Create(const AOwner: TObject); override;
    procedure AlignToPixel; override;
    procedure ApplyColorScheme; override;
    procedure MakeBufDrawable; override;
    procedure ClearBufDrawable; override;
  public
    //property Action;
    property ActiveTrack;
    property Align;
    //**property Anchors;
    //property AutoSize;
    //**property CanFocus;
    //property CanParentFocus;
    //property DisableFocusEffect;
    property DoubleBuffered;
    property ClickSound;
    //**property ClipChildren;
    //property ClipParent;
    property Cursor;
    //property DoubleBuffered;
    //**property DragMode;
    //**property EnableDragHighlight;
    property Enabled;
    property Frequency;
    property Height;
    //property Hint;
    //property ParentShowHint;
    //property ShowHint;
    property HitTest;
    property InactiveTrack;
    //**property Locked;
    property Margins;
    property Min;
    property Max;
    property MinValue: Double read GetValue write SetValue stored ValueStored nodefault;
    property MaxValue: Double read GetMaxValue write SetMaxValue stored MaxValueStored nodefault;
    property Thumb;
    property Opacity;
    property Orientation;
    property Padding;
    //**property PopupMenu;
    //**property Position;
    property RotationAngle;
    //property RotationCenter;
    property Pivot;
    property Scale;
    //**property Size;
    //**property TabOrder;
    //**property TabStop;
    property TouchTargetExpansion;
    property Value;
    property ValueIndicator;
    property Visible;
    property Width;
    //**property OnCanFocus;
    property OnChange;
    //**property OnDragEnter;
    //**property OnDragLeave;
    //**property OnDragOver;
    //**property OnDragDrop;
    //**property OnDragEnd;
    //**property OnEnter;
    //**property OnExit;
    property OnMouseEnter;
    property OnMouseLeave;
    property OnMouseDown;
    property OnMouseUp;
    property OnMouseMove;
    //**property OnMouseWheel;
    property OnClick;
    property OnDblClick;
    //**property OnKeyDown;
    //**property OnKeyUp;
    property OnPainting;
    property OnPaint;
    //property OnResize;
    //**property OnResized;
  end;

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  TALDynamicCustomScrollBar = class(TALDynamicCustomTrack)
  public
    type
      // ------
      // TThumb
      TThumb = class(TALDynamicCustomTrack.TThumb)
      public
        type
          // -----
          // TFill
          TFill = class(TALBrush)
          protected
            function GetDefaultColor: TAlphaColor; override;
          end;
          // -------
          // TStroke
          TStroke = class(TALDynamicCustomTrack.TThumb.TStroke)
          protected
            function GetDefaultColor: TAlphaColor; override;
          end;
          // -------------------
          // TDisabledStateStyle
          TDisabledStateStyle = class(TALDynamicCustomTrack.TThumb.TDisabledStateStyle)
          public
            type
              TFill = class(TALInheritBrush)
              protected
                function GetDefaultColor: TAlphaColor; override;
              end;
              TStroke = class(TALDynamicCustomTrack.TThumb.TDisabledStateStyle.TStroke)
              protected
                function GetDefaultColor: TAlphaColor; override;
              end;
              TStateLayer = class(TALDynamicCustomTrack.TThumb.TDisabledStateStyle.TStateLayer)
              protected
                function GetDefaultXRadius: Single; override;
                function GetDefaultYRadius: Single; override;
              end;
          protected
            function CreateFill(const AParent: TALBrush): TALInheritBrush; override;
            function CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush; override;
            function CreateStateLayer: TALStateLayer; override;
          end;
          // ------------------
          // THoveredStateStyle
          THoveredStateStyle = class(TALDynamicCustomTrack.TThumb.THoveredStateStyle)
          public
            type
              TFill = class(TALInheritBrush)
              protected
                function GetDefaultColor: TAlphaColor; override;
              end;
              TStroke = class(TALDynamicCustomTrack.TThumb.THoveredStateStyle.TStroke)
              protected
                function GetDefaultColor: TAlphaColor; override;
              end;
              TStateLayer = class(TALDynamicCustomTrack.TThumb.THoveredStateStyle.TStateLayer)
              protected
                function GetDefaultXRadius: Single; override;
                function GetDefaultYRadius: Single; override;
              end;
          protected
            function CreateFill(const AParent: TALBrush): TALInheritBrush; override;
            function CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush; override;
            function CreateStateLayer: TALStateLayer; override;
          end;
          // ------------------
          // TPressedStateStyle
          TPressedStateStyle = class(TALDynamicCustomTrack.TThumb.TPressedStateStyle)
          public
            type
              TFill = class(TALInheritBrush)
              protected
                function GetDefaultColor: TAlphaColor; override;
              end;
              TStroke = class(TALDynamicCustomTrack.TThumb.TPressedStateStyle.TStroke)
              protected
                function GetDefaultColor: TAlphaColor; override;
              end;
              TStateLayer = class(TALDynamicCustomTrack.TThumb.TPressedStateStyle.TStateLayer)
              protected
                function GetDefaultXRadius: Single; override;
                function GetDefaultYRadius: Single; override;
              end;
          protected
            function CreateFill(const AParent: TALBrush): TALInheritBrush; override;
            function CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush; override;
            function CreateStateLayer: TALStateLayer; override;
          end;
          // ------------------
          // TFocusedStateStyle
          TFocusedStateStyle = class(TALDynamicCustomTrack.TThumb.TFocusedStateStyle)
          public
            type
              TFill = class(TALInheritBrush)
              protected
                function GetDefaultColor: TAlphaColor; override;
              end;
              TStroke = class(TALDynamicCustomTrack.TThumb.TFocusedStateStyle.TStroke)
              protected
                function GetDefaultColor: TAlphaColor; override;
              end;
              TStateLayer = class(TALDynamicCustomTrack.TThumb.TFocusedStateStyle.TStateLayer)
              protected
                function GetDefaultXRadius: Single; override;
                function GetDefaultYRadius: Single; override;
              end;
          protected
            function CreateFill(const AParent: TALBrush): TALInheritBrush; override;
            function CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush; override;
            function CreateStateLayer: TALStateLayer; override;
          end;
          // ------------
          // TStateStyles
          TStateStyles = class(TALDynamicCustomTrack.TThumb.TStateStyles)
          protected
            function CreateDisabledStateStyle(const AParent: TObject): TALDynamicCustomTrack.TThumb.TDisabledStateStyle; override;
            function CreateHoveredStateStyle(const AParent: TObject): TALDynamicCustomTrack.TThumb.THoveredStateStyle; override;
            function CreatePressedStateStyle(const AParent: TObject): TALDynamicCustomTrack.TThumb.TPressedStateStyle; override;
            function CreateFocusedStateStyle(const AParent: TObject): TALDynamicCustomTrack.TThumb.TFocusedStateStyle; override;
          end;
      protected
        function CreateFill: TALBrush; override;
        function CreateStroke: TALStrokeBrush; override;
        function CreateStateStyles: TALDynamicCustomTrack.TThumb.TStateStyles; override;
        function GetDefaultXRadius: Single; override;
        function GetDefaultYRadius: Single; override;
      end;
  protected
    function GetDefaultSize: TSizeF; override;
    procedure AlignThumb; override;
    function CreateInactiveTrack(const AInactiveTrackClass: TALDynamicCustomTrack.TInactiveTrackClass = nil; Const AName: String = 'InactiveTrack'): TALDynamicCustomTrack.TInactiveTrack; override;
    function CreateActiveTrack(const AActiveTrackClass: TALDynamicCustomTrack.TActiveTrackClass = nil; Const AName: String = 'ActiveTrack'): TALDynamicCustomTrack.TActiveTrack; override;
    function CreateValueIndicator(const AValueIndicatorClass: TALDynamicCustomTrack.TValueIndicatorClass = nil; Const AName: String = 'ValueIndicator'): TALDynamicCustomTrack.TValueIndicator; override;
    function CreateThumb(const AThumbClass: TALDynamicCustomTrack.TThumbClass = nil; Const AName: String = 'Thumb'): TALDynamicCustomTrack.TThumb; override;
  public
    constructor Create(const AOwner: TObject); override;
    //**property CanFocus default False;
  end;

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  TALDynamicScrollBar = class(TALDynamicCustomScrollBar)
  public
    //property Action;
    property Align;
    //**property Anchors;
    //property AutoSize;
    //**property CanFocus;
    //property CanParentFocus;
    //property DisableFocusEffect;
    property DoubleBuffered;
    property ClickSound;
    //**property ClipChildren;
    //property ClipParent;
    property Cursor;
    //property DoubleBuffered;
    //**property DragMode;
    //**property EnableDragHighlight;
    property Enabled;
    property Height;
    //property Hint;
    //property ParentShowHint;
    //property ShowHint;
    property HitTest;
    //**property Locked;
    property Margins;
    property Min;
    property Max;
    property Opacity;
    property Orientation;
    property Padding;
    //**property PopupMenu;
    //**property Position;
    property RotationAngle;
    //property RotationCenter;
    property Pivot;
    property Scale;
    //**property Size;
    //**property TabOrder;
    //**property TabStop;
    property Thumb;
    property TouchTargetExpansion;
    property Value;
    property ViewportSize;
    property Visible;
    property Width;
    //**property OnCanFocus;
    property OnChange;
    //**property OnDragEnter;
    //**property OnDragLeave;
    //**property OnDragOver;
    //**property OnDragDrop;
    //**property OnDragEnd;
    //**property OnEnter;
    //**property OnExit;
    property OnMouseEnter;
    property OnMouseLeave;
    property OnMouseDown;
    property OnMouseUp;
    property OnMouseMove;
    //**property OnMouseWheel;
    property OnClick;
    property OnDblClick;
    //**property OnKeyDown;
    //**property OnKeyUp;
    property OnPainting;
    property OnPaint;
    //property OnResize;
    //**property OnResized;
  end;

{$ENDREGION 'Auto-generated by <ALCINOE>\Tools\CodeBuilder (1)'}

implementation

uses
  System.SysUtils,
  system.Math.Vectors,
  {$IF defined(ALSkiaEngine)}
  System.Skia.API,
  FMX.Skia.Canvas,
  {$ENDIF}
  {$IF DEFINED(ANDROID)}
  Androidapi.JNI.GraphicsContentViewText,
  FMX.types3D,
  {$ENDIF}
  {$IF DEFINED(IOS)}
  iOSapi.CoreGraphics,
  FMX.types3D,
  {$ENDIF}
  {$IF DEFINED(ALMacOS)}
  Macapi.CoreGraphics,
  {$ENDIF}
  fmx.utils,
  FMX.StdCtrls,
  Alcinoe.FMX.Graphics,
  Alcinoe.FMX.ScrollEngine,
  Alcinoe.Localization,
  Alcinoe.StringUtils,
  Alcinoe.FMX.Styles;

{*}
var
  _ALDummyComponent: TComponent;

{**}
Type
  _TALDynamicControlProtectedAccess = class(TALDynamicControl);
  _TALDynamicBaseStateStyleProtectedAccess = class(TALDynamicBaseStateStyle);

{$REGION 'Auto-generated by <ALCINOE>\Tools\CodeBuilder (2)'}

{*****************************************************************************************}
constructor TALDynamicAniIndicator.TAnimation.Create(const AOwner: TALDynamicAniIndicator);
begin
  inherited Create;
  FOwner := AOwner;
  FEnabled := True;
end;

{**********************************************************************}
procedure TALDynamicAniIndicator.TAnimation.Assign(Source: TPersistent);
begin
  if Source is TALDynamicAniIndicator.TAnimation then begin
    inherited Assign(Source);
    Enabled := TALDynamicAniIndicator.TAnimation(Source).Enabled;
  end
  else
    ALAssignError(Source{ASource}, Self{ADest});
end;

{************************************************}
procedure TALDynamicAniIndicator.TAnimation.Start;
begin
  if (Running) then
    Exit;
  FEnabled := True;
  inherited Start;
end;

{****************************************************}
procedure TALDynamicAniIndicator.TAnimation.DoProcess;
begin
  inherited;
  if Enabled then Repaint;
end;

{**************************************************}
procedure TALDynamicAniIndicator.TAnimation.repaint;
begin
  if Fowner.IsDisplayed then
    Fowner.Repaint
  else if Loop then
    Pause;
end;

{********************************************************************}
function TALDynamicAniIndicator.TAnimation.GetDefaultDuration: Single;
begin
  Result := 1.0;
end;

{*****************************************************************}
function TALDynamicAniIndicator.TAnimation.GetDefaultLoop: Boolean;
begin
  Result := True;
end;

{**********************************************************************}
function TALDynamicAniIndicator.TAnimation.GetDefaultStartValue: Single;
begin
  Result := 0.0;
end;

{*********************************************************************}
function TALDynamicAniIndicator.TAnimation.GetDefaultStopValue: Single;
begin
  Result := 1.0;
end;

{***************************************************************************}
procedure TALDynamicAniIndicator.TAnimation.SetEnabled(const Value: Boolean);
begin
  if Value <> FEnabled then begin
    FEnabled := Value;
    if not FEnabled then
      inherited Enabled := False;
  end;
end;

{***************************************************************}
constructor TALDynamicAniIndicator.Create(const AOwner: TObject);
begin
  inherited Create(AOwner);
  FAnimation := TAnimation.Create(Self);
  FResourceName := '';
  FTintColor := DefaultTintColor;
  FTintColorKey := DefaultTintColorKey;
  FFrameCount := 1;
  FRowCount := 1;
  FCacheIndex := 0;
  FCacheEngine := nil;
  FMotionMode := TMotionMode.Rotate;
  FBufDrawable := ALNullDrawable;
  //**SetAcceptsControls(False);
end;

{****************************************}
destructor TALDynamicAniIndicator.Destroy;
begin
  ALFreeAndNil(FAnimation);
  inherited;
end;

{*************************************************}
procedure TALDynamicAniIndicator.BeforeDestruction;
begin
  if BeforeDestructionExecuted then exit;
  // Necessary if the control is destroyed using
  // AlFreeAndNil with the delayed flag
  FAnimation.Enabled := False;
  inherited;
end;

{*****************************************************************}
procedure TALDynamicAniIndicator.Assign(Source: TALDynamicControl);
begin
  BeginUpdate;
  Try
    if Source is TALDynamicAniIndicator then begin
      Animation.Assign(TALDynamicAniIndicator(Source).Animation);
      ResourceName := TALDynamicAniIndicator(Source).ResourceName;
      TintColorKey := TALDynamicAniIndicator(Source).TintColorKey;
      TintColor := TALDynamicAniIndicator(Source).TintColor;
      FrameCount := TALDynamicAniIndicator(Source).FrameCount;
      RowCount := TALDynamicAniIndicator(Source).RowCount;
      CacheIndex := TALDynamicAniIndicator(Source).CacheIndex;
      CacheEngine := TALDynamicAniIndicator(Source).CacheEngine;
      MotionMode := TALDynamicAniIndicator(Source).MotionMode;
    end
    else
      ALAssignError(Source{ASource}, Self{ADest});
    inherited Assign(Source);
  Finally
    EndUpdate;
  End;
end;

{****************************************************}
procedure TALDynamicAniIndicator.ApplyTintColorScheme;
begin
  if FTintColorKey <> '' then begin
    var LTintColor := TALStyleManager.Instance.GetColor(FTintColorKey);
    if FTintColor <> LTintColor then begin
      FTintColor := LTintColor;
      ClearBufDrawable;
      Repaint;
    end;
  end;
end;

{************************************************}
procedure TALDynamicAniIndicator.ApplyColorScheme;
begin
  beginUpdate;
  try
    inherited;
    ApplyTintColorScheme;
  finally
    EndUpdate;
  end;
end;

{*****************************************************}
function TALDynamicAniIndicator.GetDefaultSize: TSizeF;
begin
  Result := TSizeF.Create(36, 36);
end;

{***************************************************************}
function TALDynamicAniIndicator.GetDefaultTintColor: TAlphaColor;
begin
  Result := TAlphaColors.null;
end;

{*************************************************************}
function TALDynamicAniIndicator.GetDefaulttintColorKey: String;
begin
  Result := '';
end;

{*****************************************}
procedure TALDynamicAniIndicator.DoResized;
begin
  ClearBufDrawable;
  inherited;
end;

{************************************************}
procedure TALDynamicAniIndicator.ClearBufDrawable;
begin
  {$IFDEF debug}
  if (not IsDestroying) and
     (not ALIsDrawableNull(FBufDrawable)) then
    ALLog(Classname + '.ClearBufDrawable', 'BufDrawable has been cleared | Name: ' + Name, TalLogType.warn);
  {$endif}
  ALFreeAndNilDrawable(FBufDrawable);
end;

{***********************************************}
procedure TALDynamicAniIndicator.MakeBufDrawable;
begin

  if //--- Do not create BufDrawable if the size is 0
     (BoundsRect.IsEmpty) or
     //--- Do not create BufDrawable if fResourceName is empty
     (FResourceName = '')
  then begin
    ClearBufDrawable;
    exit;
  end;

  if (not ALIsDrawableNull(FBufDrawable)) then exit;

  if (CacheIndex > 0) and
     (CacheEngine <> nil) and
     (CacheEngine.HasEntry(CacheIndex{AIndex}, GetCacheSubIndex{ASubIndex})) then Exit;

  {$IFDEF debug}
  ALLog(Classname + '.MakeBufDrawable', 'Name: ' + Name + ' | Width: ' + ALFloatToStrW(Width)+ ' | Height: ' + ALFloatToStrW(Height));
  {$endif}

  FBufDrawableRect := LocalRect.ReducePrecision;
  {$IFDEF ALDPK}
  if ALGetResourceFilename(FResourceName) = '' then
    fBufDrawable := ALNullDrawable
  else
  try
  {$ENDIF}
    fBufDrawable := ALCreateDrawableFromResource(
                      FResourceName, // const AResourceName: String;
                      nil, // const AResourceStream: TStream;
                      '', // const AMaskResourceName: String;
                      1, // const AScale: Single;
                      Width * (fframeCount div fRowCount) * ALGetScreenScale,
                      Height * fRowCount * ALGetScreenScale, // const W, H: single;
                      TALImageWrapMode.Fit, // const AWrapMode: TALImageWrapMode;
                      TpointF.Create(-50,-50), // const ACropCenter: TpointF;
                      FTintColor, // const ATintColor: TalphaColor;
                      0, // const ABlurRadius: single;
                      0, // const AXRadius: Single;
                      0); // const AYRadius: Single);
  {$IFDEF ALDPK}
  except
    fBufDrawable := ALNullDrawable;
  end;
  {$ENDIF}

end;

{*************************************}
procedure TALDynamicAniIndicator.Paint;
begin

  if FAnimation.Enabled then begin
    if not TALFloatAnimation(FAnimation).Enabled then
      TALFloatAnimation(FAnimation).Enabled := True
    else
      FAnimation.Resume;
  end;

  //**if (csDesigning in ComponentState) and not Locked and not FInPaintTo then
  //**begin
  //**  var R := LocalRect.ReducePrecision;
  //**  InflateRect(R, -0.5, -0.5);
  //**  Canvas.DrawDashRect(R, 0, 0, AllCorners, AbsoluteOpacity, $A0909090);
  //**end;

  var LDrawable: TALDrawable;
  var LDrawableRect: TRectF;
  if (CacheIndex <= 0) or
     (CacheEngine = nil) or
     (not CacheEngine.TryGetEntry(CacheIndex{AIndex}, GetCacheSubIndex{ASubIndex}, LDrawable{ADrawable}, LDrawableRect{ARect})) then begin
    MakeBufDrawable;
    if (CacheIndex > 0) and (CacheEngine <> nil) and (not ALIsDrawableNull(fBufDrawable)) then begin
      if not CacheEngine.TrySetEntry(CacheIndex{AIndex}, GetCacheSubIndex{ASubIndex}, fBufDrawable{ADrawable}, fBufDrawableRect{ARect}) then ALFreeAndNilDrawable(fBufDrawable)
      else fBufDrawable := ALNullDrawable;
      if not CacheEngine.TryGetEntry(CacheIndex{AIndex}, GetCacheSubIndex{ASubIndex}, LDrawable{ADrawable}, LDrawableRect{ARect}) then
        raise Exception.Create('Error BB5ACD27-7CF2-44D3-AEB1-22C8BB492762');
    end
    else begin
      LDrawable := FBufDrawable;
      LDrawableRect := FBufDrawableRect;
    end;
  end;

  if FMotionMode = TMotionMode.Frame then begin

    var LFrameFlatIndex := Round(FAnimation.CurrentValue * FrameCount) mod FrameCount;
    var LTotalFramesPerRow := FrameCount div RowCount;
    var LFrameIndex: TSmallPoint;
    LFrameIndex.X := LFrameFlatIndex mod LTotalFramesPerRow;
    LFrameIndex.Y := LFrameFlatIndex div LTotalFramesPerRow;

    ALDrawDrawable(
      Canvas, // const ACanvas: Tcanvas;
      LDrawable, // const ADrawable: TALDrawable;
      TRectF.Create(
        TPointF.Create(
          LFrameIndex.x * Width * ALGetScreenScale,
          LFrameIndex.Y * Height * ALGetScreenScale),
        Width * ALGetScreenScale,
        Height * ALGetScreenScale), // const ASrcRect: TrectF; // IN REAL PIXEL !
      LDrawableRect, // const ADestRect: TrectF; // IN virtual pixels !
      AbsoluteOpacity); // const AOpacity: Single);

  end
  else begin

    var LSavedMatrix := Canvas.Matrix;
    var LMatrixRotationCenter: TpointF;
    LMatrixRotationCenter.X := (Width / 2) + Canvas.Matrix.m31;
    LMatrixRotationCenter.Y := (Height / 2) + Canvas.Matrix.m32;
    var LMatrix := Canvas.Matrix;
    LMatrix := LMatrix * TMatrix.CreateTranslation(-LMatrixRotationCenter.X,-LMatrixRotationCenter.Y);
    LMatrix := LMatrix * TMatrix.CreateRotation(DegToRad(Fanimation.CurrentValue * 360));
    LMatrix := LMatrix * TMatrix.CreateTranslation(LMatrixRotationCenter.X,LMatrixRotationCenter.Y);
    Canvas.SetMatrix(LMatrix);
    try

      ALDrawDrawable(
        Canvas, // const ACanvas: Tcanvas;
        LDrawable, // const ADrawable: TALDrawable;
        LDrawableRect.TopLeft, // const ADstTopLeft: TpointF;
        AbsoluteOpacity); // const AOpacity: Single);

    finally
      Canvas.SetMatrix(LSavedMatrix);
    end;

  end;

end;

{********************************************************}
function TALDynamicAniIndicator.GetCacheSubIndex: Integer;
begin
  Result := 0;
end;

{*********************************************************}
function TALDynamicAniIndicator.GetDoubleBuffered: boolean;
begin
  result := True;
end;

{**********************************************************************}
procedure TALDynamicAniIndicator.setTintColor(const Value: TAlphaColor);
begin
  if FTintColor <> Value then begin
    FTintColor := Value;
    FTintColorKey := '';
    ClearBufDrawable;
    Repaint;
  end;
end;

{********************************************************************}
procedure TALDynamicAniIndicator.setTintColorKey(const Value: String);
begin
  if FTintColorKey <> Value then begin
    FTintColorKey := Value;
    ApplyTintColorScheme;
  end;
end;

{*********************************************************************}
procedure TALDynamicAniIndicator.SetAnimation(const Value: TAnimation);
begin
  FAnimation.Assign(Value);
end;

{********************************************************************}
procedure TALDynamicAniIndicator.setResourceName(const Value: String);
begin
  if FResourceName <> Value then begin
    ClearBufDrawable;
    FResourceName := Value;
    Repaint;
  end;
end;

{***********************************************************************}
procedure TALDynamicAniIndicator.SetMotionMode(const Value: TMotionMode);
begin
  if FMotionMode <> Value then begin
    FMotionMode := Value;
    Repaint;
  end;
end;

{*******************************************************************}
procedure TALDynamicAniIndicator.SetFrameCount(const Value: Integer);
begin
  if FFrameCount <> Value then begin
    ClearBufDrawable;
    FFrameCount := Value;
    Repaint;
  end;
end;

{*****************************************************************}
procedure TALDynamicAniIndicator.SetRowCount(const Value: Integer);
begin
  if FRowCount <> Value then begin
    ClearBufDrawable;
    FRowCount := Value;
    Repaint;
  end;
end;

{*********************************************************}
function TALDynamicAniIndicator.IsTintColorStored: Boolean;
begin
  Result := FTintColor <> DefaultTintColor;
end;

{************************************************************}
function TALDynamicAniIndicator.IsTintColorKeyStored: Boolean;
begin
  Result := FTintColorKey <> DefaultTintColorKey;
end;

{*******************************************************************************}
function TALDynamicBaseCheckBox.TCheckMarkBrush.TMargins.GetDefaultValue: TRectF;
begin
  Result := TRectF.Create(3,3,3,3);
end;

{********************************************************}
constructor TALDynamicBaseCheckBox.TCheckMarkBrush.Create;
begin
  inherited Create;
  //--
  FColor := DefaultColor;
  FColorKey := DefaultColorKey;
  FResourceName := DefaultResourceName;
  FWrapMode := DefaultWrapMode;
  FThickness := DefaultThickness;
  //--
  FMargins := CreateMargins;
  FMargins.OnChanged := MarginsChanged;
end;

{********************************************************}
destructor TALDynamicBaseCheckBox.TCheckMarkBrush.Destroy;
begin
  ALFreeAndNil(FMargins);
  inherited;
end;

{***********************************************************************}
function TALDynamicBaseCheckBox.TCheckMarkBrush.CreateMargins: TALBounds;
begin
  Result := TMargins.Create;
end;

{***************************************************************************}
function TALDynamicBaseCheckBox.TCheckMarkBrush.GetDefaultColor: TAlphaColor;
begin
  Result := TAlphaColors.Black;
end;

{*************************************************************************}
function TALDynamicBaseCheckBox.TCheckMarkBrush.GetDefaultColorKey: String;
begin
  Result := '';
end;

{*****************************************************************************}
function TALDynamicBaseCheckBox.TCheckMarkBrush.GetDefaultResourceName: String;
begin
  Result := '';
end;

{***********************************************************************************}
function TALDynamicBaseCheckBox.TCheckMarkBrush.GetDefaultWrapMode: TALImageWrapMode;
begin
  Result := TALImageWrapMode.Fit;
end;

{**************************************************************************}
function TALDynamicBaseCheckBox.TCheckMarkBrush.GetDefaultThickness: Single;
begin
  Result := 2;
end;

{***************************************************************************}
procedure TALDynamicBaseCheckBox.TCheckMarkBrush.Assign(Source: TPersistent);
begin
  if Source is TCheckMarkBrush then begin
    BeginUpdate;
    Try
      Color := TCheckMarkBrush(Source).Color;
      ColorKey := TCheckMarkBrush(Source).ColorKey;
      ResourceName := TCheckMarkBrush(Source).ResourceName;
      WrapMode := TCheckMarkBrush(Source).WrapMode;
      Thickness := TCheckMarkBrush(Source).Thickness;
      Margins.Assign(TCheckMarkBrush(Source).Margins);
    Finally
      EndUpdate;
    End;
  end
  else
    ALAssignError(Source{ASource}, Self{ADest});
end;

{*****************************************************}
procedure TALDynamicBaseCheckBox.TCheckMarkBrush.Reset;
begin
  BeginUpdate;
  Try
    inherited;
    Color := DefaultColor;
    ColorKey := DefaultColorKey;
    ResourceName := DefaultResourceName;
    WrapMode := DefaultWrapMode;
    Thickness := DefaultThickness;
    Margins.Rect := Margins.DefaultValue;
  finally
    EndUpdate;
  end;
end;

{************************************************************}
procedure TALDynamicBaseCheckBox.TCheckMarkBrush.AlignToPixel;
begin
  BeginUpdate;
  Try
    Thickness := ALAlignDimensionToPixelRound(Thickness, ALGetScreenScale, Tepsilon.vector);
    Margins.Rect := ALAlignEdgesToPixelRound(Margins.Rect, ALGetScreenScale, TEpsilon.Position);
  finally
    EndUpdate;
  end;
end;

{****************************************************************}
procedure TALDynamicBaseCheckBox.TCheckMarkBrush.ApplyColorScheme;
begin
  if FColorKey <> '' then begin
    var LColor := TALStyleManager.Instance.GetColor(FColorKey);
    if FColor <> LColor then begin
      FColor := LColor;
      Change;
    end;
  end;
end;

{***********************************************************************************************************************************************}
procedure TALDynamicBaseCheckBox.TCheckMarkBrush.Interpolate(const ATo: TCheckMarkBrush; const ANormalizedTime: Single; const AReverse: Boolean);
begin
  BeginUpdate;
  Try
    var LPrevColorKey := FColorKey;
    if ATo <> nil then begin
      Color := ALInterpolateColor(Color{Start}, ATo.Color{Stop}, ANormalizedTime);
      if not AReverse then ResourceName := ATo.ResourceName;
      if not AReverse then WrapMode := ATo.WrapMode;
      Thickness := InterpolateSingle(Thickness{Start}, ATo.Thickness{Stop}, ANormalizedTime);
      Margins.Left := InterpolateSingle(Margins.Left{Start}, ATo.Margins.Left{Stop}, ANormalizedTime);
      Margins.Right := InterpolateSingle(Margins.Right{Start}, ATo.Margins.Right{Stop}, ANormalizedTime);
      Margins.Top := InterpolateSingle(Margins.Top{Start}, ATo.Margins.Top{Stop}, ANormalizedTime);
      Margins.Bottom := InterpolateSingle(Margins.Bottom{Start}, ATo.Margins.Bottom{Stop}, ANormalizedTime);
    end
    else begin
      Color := ALInterpolateColor(Color{Start}, DefaultColor{Stop}, ANormalizedTime);
      if not AReverse then ResourceName := DefaultResourceName;
      if not AReverse then WrapMode := DefaultWrapMode;
      Thickness := InterpolateSingle(Thickness{Start}, DefaultThickness{Stop}, ANormalizedTime);
      Margins.Left := InterpolateSingle(Margins.Left{Start}, Margins.DefaultValue.Left{Stop}, ANormalizedTime);
      Margins.Right := InterpolateSingle(Margins.Right{Start}, Margins.DefaultValue.Right{Stop}, ANormalizedTime);
      Margins.Top := InterpolateSingle(Margins.Top{Start}, Margins.DefaultValue.Top{Stop}, ANormalizedTime);
      Margins.Bottom := InterpolateSingle(Margins.Bottom{Start}, Margins.DefaultValue.Bottom{Stop}, ANormalizedTime);
    end;
    FColorKey := LPrevColorKey;
  finally
    EndUpdate;
  end;
end;

{********************************************************************************************************************************************************}
procedure TALDynamicBaseCheckBox.TCheckMarkBrush.InterpolateNoChanges(const ATo: TCheckMarkBrush; const ANormalizedTime: Single; const AReverse: Boolean);
begin
  BeginUpdate;
  Try
    Interpolate(ATo, ANormalizedTime, AReverse);
  Finally
    EndUpdateNoChanges;
  end;
end;

{********************************************************************}
function TALDynamicBaseCheckBox.TCheckMarkBrush.HasCheckMark: boolean;
begin
  result := ((Color <> TalphaColors.Null) and
             (CompareValue(FThickness, 0, TEpsilon.Vector) > 0)) or
            (ResourceName <> '');
end;

{*********************************************************************}
function TALDynamicBaseCheckBox.TCheckMarkBrush.IsColorStored: Boolean;
begin
  result := FColor <> DefaultColor;
end;

{************************************************************************}
function TALDynamicBaseCheckBox.TCheckMarkBrush.IsColorKeyStored: Boolean;
begin
  result := FColorKey <> DefaultColorKey;
end;

{****************************************************************************}
function TALDynamicBaseCheckBox.TCheckMarkBrush.IsResourceNameStored: Boolean;
begin
  result := FResourceName <> DefaultResourceName;
end;

{************************************************************************}
function TALDynamicBaseCheckBox.TCheckMarkBrush.IsWrapModeStored: Boolean;
begin
  result := FWrapMode <> DefaultWrapMode;
end;

{*************************************************************************}
function TALDynamicBaseCheckBox.TCheckMarkBrush.IsThicknessStored: Boolean;
begin
  result := not SameValue(FThickness, DefaultThickness, TEpsilon.Vector);
end;

{**********************************************************************************}
procedure TALDynamicBaseCheckBox.TCheckMarkBrush.SetColor(const Value: TAlphaColor);
begin
  if fColor <> Value then begin
    fColor := Value;
    FColorKey := '';
    Change;
  end;
end;

{********************************************************************************}
procedure TALDynamicBaseCheckBox.TCheckMarkBrush.SetColorKey(const Value: String);
begin
  if FColorKey <> Value then begin
    FColorKey := Value;
    ApplyColorScheme;
  end;
end;

{************************************************************************************}
procedure TALDynamicBaseCheckBox.TCheckMarkBrush.SetResourceName(const Value: String);
begin
  if fResourceName <> Value then begin
    fResourceName := Value;
    Change;
  end;
end;

{******************************************************************************************}
procedure TALDynamicBaseCheckBox.TCheckMarkBrush.SetWrapMode(const Value: TALImageWrapMode);
begin
  if fWrapMode <> Value then begin
    fWrapMode := Value;
    Change;
  end;
end;

{*********************************************************************************}
procedure TALDynamicBaseCheckBox.TCheckMarkBrush.SetThickness(const Value: Single);
begin
  if not SameValue(Value, FThickness, TEpsilon.Vector) then begin
    fThickness := Value;
    Change;
  end;
end;

{**********************************************************************************}
procedure TALDynamicBaseCheckBox.TCheckMarkBrush.SetMargins(const Value: TALBounds);
begin
  FMargins.Assign(Value);
end;

{*******************************************************************************}
procedure TALDynamicBaseCheckBox.TCheckMarkBrush.MarginsChanged(Sender: TObject);
begin
  change;
end;

{***********************************************************************************************}
constructor TALDynamicBaseCheckBox.TInheritCheckMarkBrush.Create(const AParent: TCheckMarkBrush);
begin
  inherited create;
  FParent := AParent;
  FInherit := True;
  fSuperseded := False;
end;

{*********************************************************************************************}
function TALDynamicBaseCheckBox.TInheritCheckMarkBrush.CreateSavedState: TALPersistentObserver;
type
  TInheritCheckMarkBrushClass = class of TInheritCheckMarkBrush;
begin
  result := TInheritCheckMarkBrushClass(classtype).Create(nil{AParent});
end;

{****************************************************************************************}
procedure TALDynamicBaseCheckBox.TInheritCheckMarkBrush.SetInherit(const AValue: Boolean);
begin
  If FInherit <> AValue then begin
    FInherit := AValue;
    Change;
  end;
end;

{**********************************************************************************}
procedure TALDynamicBaseCheckBox.TInheritCheckMarkBrush.Assign(Source: TPersistent);
begin
  BeginUpdate;
  Try
    if Source is TInheritCheckMarkBrush then begin
      Inherit := TInheritCheckMarkBrush(Source).Inherit;
      fSuperseded := TInheritCheckMarkBrush(Source).fSuperseded;
    end
    else begin
      Inherit := False;
      fSuperseded := False;
    end;
    inherited Assign(Source);
  Finally
    EndUpdate;
  End;
end;

{************************************************************}
procedure TALDynamicBaseCheckBox.TInheritCheckMarkBrush.Reset;
begin
  BeginUpdate;
  Try
    inherited;
    Inherit := True;
    fSuperseded := False;
  finally
    EndUpdate;
  end;
end;

{******************************************************************}
procedure TALDynamicBaseCheckBox.TInheritCheckMarkBrush.DoSupersede;
begin
  Assign(FParent);
end;

{***************************************************************************************************}
procedure TALDynamicBaseCheckBox.TInheritCheckMarkBrush.Supersede(Const ASaveState: Boolean = False);
begin
  if ASaveState then SaveState;
  if (FSuperseded) or
     (not inherit) or
     (FParent = nil) then exit;
  BeginUpdate;
  try
    var LParentSuperseded := False;
    if FParent is TInheritCheckMarkBrush then begin
      TInheritCheckMarkBrush(FParent).SupersedeNoChanges(true{ASaveState});
      LParentSuperseded := True;
    end;
    try
      DoSupersede;
    finally
      if LParentSuperseded then
        TInheritCheckMarkBrush(FParent).restoreStateNoChanges;
    end;
    Inherit := False;
    FSuperseded := True;
  finally
    EndUpdate;
  end;
end;

{************************************************************************************************************}
procedure TALDynamicBaseCheckBox.TInheritCheckMarkBrush.SupersedeNoChanges(Const ASaveState: Boolean = False);
begin
  BeginUpdate;
  try
    Supersede(ASaveState);
  finally
    EndUpdateNoChanges;
  end;
end;

{*******************************************************************************************}
function TALDynamicBaseCheckBox.TBaseStateStyle.TStateLayer.TMargins.GetDefaultValue: TRectF;
begin
  Result := TRectF.Create(-12,-12,-12,-12);
end;

{***********************************************************************************}
function TALDynamicBaseCheckBox.TBaseStateStyle.TStateLayer.CreateMargins: TALBounds;
begin
  Result := TMargins.Create;
end;

{************************************************************************************}
function TALDynamicBaseCheckBox.TBaseStateStyle.TStateLayer.GetDefaultXRadius: Single;
begin
  Result := -50;
end;

{************************************************************************************}
function TALDynamicBaseCheckBox.TBaseStateStyle.TStateLayer.GetDefaultYRadius: Single;
begin
  Result := -50;
end;

{********************************************************************************}
constructor TALDynamicBaseCheckBox.TBaseStateStyle.Create(const AParent: TObject);
begin
  inherited Create(AParent);
  if StateStyleParent <> nil then FCheckMark := CreateCheckMark(StateStyleParent.CheckMark)
  else if ControlParent <> nil then FCheckMark := CreateCheckMark(ControlParent.CheckMark)
  else FCheckMark := CreateCheckMark(nil);
  FCheckMark.OnChanged := CheckMarkChanged;
end;

{********************************************************}
destructor TALDynamicBaseCheckBox.TBaseStateStyle.Destroy;
begin
  ALFreeAndNil(FCheckMark);
  inherited Destroy;
end;

{******************************************************************************}
function TALDynamicBaseCheckBox.TBaseStateStyle.CreateStateLayer: TALStateLayer;
begin
  Result := TStateLayer.Create;
end;

{**********************************************************************************************************************}
function TALDynamicBaseCheckBox.TBaseStateStyle.CreateCheckMark(const AParent: TCheckMarkBrush): TInheritCheckMarkBrush;
begin
  Result := TInheritCheckMarkBrush.Create(AParent);
end;

{***************************************************************************}
procedure TALDynamicBaseCheckBox.TBaseStateStyle.Assign(Source: TPersistent);
begin
  if Source is TBaseStateStyle then begin
    BeginUpdate;
    Try
      CheckMark.Assign(TBaseStateStyle(Source).CheckMark);
      inherited Assign(Source);
    Finally
      EndUpdate;
    End;
  end
  else
    ALAssignError(Source{ASource}, Self{ADest});
end;

{*****************************************************}
procedure TALDynamicBaseCheckBox.TBaseStateStyle.Reset;
begin
  BeginUpdate;
  Try
    inherited;
    CheckMark.Reset;
  finally
    EndUpdate;
  end;
end;

{************************************************************}
procedure TALDynamicBaseCheckBox.TBaseStateStyle.AlignToPixel;
begin
  BeginUpdate;
  Try
    inherited;
    CheckMark.AlignToPixel;
  finally
    EndUpdate;
  end;
end;

{****************************************************************}
procedure TALDynamicBaseCheckBox.TBaseStateStyle.ApplyColorScheme;
begin
  BeginUpdate;
  Try
    Inherited;
    CheckMark.ApplyColorScheme;
  finally
    EndUpdate;
  End;
end;

{********************************************************************************************************************************************************}
procedure TALDynamicBaseCheckBox.TBaseStateStyle.Interpolate(const ATo: TALDynamicBaseStateStyle; const ANormalizedTime: Single; const AReverse: Boolean);
begin
  {$IF defined(debug)}
  if (ATo <> nil) and (not (ATo is TBaseStateStyle)) then
    Raise Exception.Create('Error F3C72244-894F-4B67-AD86-F24DF5039927');
  {$ENDIF}
  BeginUpdate;
  Try
    inherited Interpolate(ATo, ANormalizedTime, AReverse);
    if ATo <> nil then CheckMark.Interpolate(TBaseStateStyle(ATo).CheckMark, ANormalizedTime, AReverse)
    else if StateStyleParent <> nil then begin
      StateStyleParent.SupersedeNoChanges(true{ASaveState});
      try
        CheckMark.Interpolate(StateStyleParent.CheckMark, ANormalizedTime, AReverse)
      finally
        StateStyleParent.RestoreStateNoChanges;
      end;
    end
    else if ControlParent <> nil then CheckMark.Interpolate(ControlParent.CheckMark, ANormalizedTime, AReverse)
    else CheckMark.Interpolate(nil, ANormalizedTime, AReverse);
  Finally
    EndUpdate;
  End;
end;

{***********************************************************}
procedure TALDynamicBaseCheckBox.TBaseStateStyle.DoSupersede;
begin
  inherited;
  CheckMark.Supersede;
end;

{***********************************************************************************}
function TALDynamicBaseCheckBox.TBaseStateStyle.GetStateStyleParent: TBaseStateStyle;
begin
  {$IF defined(debug)}
  if (inherited StateStyleParent <> nil) and
     (not (inherited StateStyleParent is TBaseStateStyle)) then
    raise Exception.Create('StateStyleParent must be of type TBaseStateStyle');
  {$ENDIF}
  result := TBaseStateStyle(inherited StateStyleParent);
end;

{***************************************************************************************}
function TALDynamicBaseCheckBox.TBaseStateStyle.GetControlParent: TALDynamicBaseCheckBox;
begin
  {$IF defined(debug)}
  if (inherited ControlParent <> nil) and
     (not (inherited ControlParent is TALDynamicBaseCheckBox)) then
    raise Exception.Create('ControlParent must be of type TALDynamicBaseCheckBox');
  {$ENDIF}
  result := TALDynamicBaseCheckBox(inherited ControlParent);
end;

{**************************************************************************************************}
procedure TALDynamicBaseCheckBox.TBaseStateStyle.SetCheckMark(const AValue: TInheritCheckMarkBrush);
begin
  FCheckMark.Assign(AValue);
end;

{******************************************************************}
function TALDynamicBaseCheckBox.TBaseStateStyle.GetInherit: Boolean;
begin
  Result := inherited GetInherit and
            CheckMark.Inherit;
end;

{**********************************************************************************}
procedure TALDynamicBaseCheckBox.TBaseStateStyle.CheckMarkChanged(ASender: TObject);
begin
  Change;
end;

{***************************************************************************}
function TALDynamicBaseCheckBox.TDefaultStateStyle.GetCacheSubIndex: Integer;
begin
  Result := 1;
end;

{***************************************************************************}
function TALDynamicBaseCheckBox.TDisabledStateStyle.IsOpacityStored: Boolean;
begin
  Result := not SameValue(FOpacity, TControl.DefaultDisabledOpacity, TEpsilon.Scale);
end;

{***********************************************************************************}
procedure TALDynamicBaseCheckBox.TDisabledStateStyle.SetOpacity(const Value: Single);
begin
  if not SameValue(FOpacity, Value, TEpsilon.Scale) then begin
    FOpacity := Value;
    Change;
  end;
end;

{************************************************************************************}
constructor TALDynamicBaseCheckBox.TDisabledStateStyle.Create(const AParent: TObject);
begin
  inherited Create(AParent);
  FOpacity := TControl.DefaultDisabledOpacity;
end;

{*******************************************************************************}
procedure TALDynamicBaseCheckBox.TDisabledStateStyle.Assign(Source: TPersistent);
begin
  BeginUpdate;
  Try
    if Source is TDisabledStateStyle then
      Opacity := TDisabledStateStyle(Source).Opacity
    else
      Opacity := TControl.DefaultDisabledOpacity;
    inherited Assign(Source);
  Finally
    EndUpdate;
  End;
end;

{*********************************************************}
procedure TALDynamicBaseCheckBox.TDisabledStateStyle.Reset;
begin
  BeginUpdate;
  Try
    inherited;
    Opacity := TControl.DefaultDisabledOpacity;
  finally
    EndUpdate;
  end;
end;

{**********************************************************************}
function TALDynamicBaseCheckBox.TDisabledStateStyle.GetInherit: Boolean;
begin
  // Opacity is not part of the GetInherit function because it updates the
  // disabledOpacity of the base control immediately every time it changes.
  // Essentially, it acts merely as a link to the disabledOpacity of the base control.
  Result := inherited GetInherit;
end;

{****************************************************************************}
function TALDynamicBaseCheckBox.TDisabledStateStyle.GetCacheSubIndex: Integer;
begin
  Result := 2;
end;

{***************************************************************************}
function TALDynamicBaseCheckBox.THoveredStateStyle.GetCacheSubIndex: Integer;
begin
  Result := 3;
end;

{***************************************************************************}
function TALDynamicBaseCheckBox.TPressedStateStyle.GetCacheSubIndex: Integer;
begin
  Result := 4;
end;

{***************************************************************************}
function TALDynamicBaseCheckBox.TFocusedStateStyle.GetCacheSubIndex: Integer;
begin
  Result := 5;
end;

{********************************************************************************************}
constructor TALDynamicBaseCheckBox.TCheckStateStyles.Create(const AParent: TALDynamicControl);
begin
  inherited Create;
  //--
  FDefault := CreateDefaultStateStyle(AParent);
  FDefault.OnChanged := DefaultChanged;
  //--
  FDisabled := CreateDisabledStateStyle(FDefault);
  FDisabled.OnChanged := DisabledChanged;
  //--
  FHovered := CreateHoveredStateStyle(FDefault);
  FHovered.OnChanged := HoveredChanged;
  //--
  FPressed := CreatePressedStateStyle(FDefault);
  FPressed.OnChanged := PressedChanged;
  //--
  FFocused := CreateFocusedStateStyle(FDefault);
  FFocused.OnChanged := FocusedChanged;
end;

{**********************************************************}
destructor TALDynamicBaseCheckBox.TCheckStateStyles.Destroy;
begin
  ALFreeAndNil(FDefault);
  ALFreeAndNil(FDisabled);
  ALFreeAndNil(FHovered);
  ALFreeAndNil(FPressed);
  ALFreeAndNil(FFocused);
  inherited Destroy;
end;

{****************************************************************************************}
function TALDynamicBaseCheckBox.TCheckStateStyles.CreateSavedState: TALPersistentObserver;
type
  TCheckStateStylesClass = class of TCheckStateStyles;
begin
  result := TCheckStateStylesClass(classtype).Create(nil{AParent});
end;

{********************************************************************************************************************}
function TALDynamicBaseCheckBox.TCheckStateStyles.CreateDefaultStateStyle(const AParent: TObject): TDefaultStateStyle;
begin
  Result := TDefaultStateStyle.Create(AParent);
end;

{**********************************************************************************************************************}
function TALDynamicBaseCheckBox.TCheckStateStyles.CreateDisabledStateStyle(const AParent: TObject): TDisabledStateStyle;
begin
  Result := TDisabledStateStyle.Create(AParent);
end;

{********************************************************************************************************************}
function TALDynamicBaseCheckBox.TCheckStateStyles.CreateHoveredStateStyle(const AParent: TObject): THoveredStateStyle;
begin
  Result := THoveredStateStyle.Create(AParent);
end;

{********************************************************************************************************************}
function TALDynamicBaseCheckBox.TCheckStateStyles.CreatePressedStateStyle(const AParent: TObject): TPressedStateStyle;
begin
  Result := TPressedStateStyle.Create(AParent);
end;

{********************************************************************************************************************}
function TALDynamicBaseCheckBox.TCheckStateStyles.CreateFocusedStateStyle(const AParent: TObject): TFocusedStateStyle;
begin
  Result := TFocusedStateStyle.Create(AParent);
end;

{*****************************************************************************}
procedure TALDynamicBaseCheckBox.TCheckStateStyles.Assign(Source: TPersistent);
begin
  if Source is TCheckStateStyles then begin
    BeginUpdate;
    Try
      Default.Assign(TCheckStateStyles(Source).Default);
      Disabled.Assign(TCheckStateStyles(Source).Disabled);
      Hovered.Assign(TCheckStateStyles(Source).Hovered);
      Pressed.Assign(TCheckStateStyles(Source).Pressed);
      Focused.Assign(TCheckStateStyles(Source).Focused);
    Finally
      EndUpdate;
    End;
  end
  else
    ALAssignError(Source{ASource}, Self{ADest});
end;

{*******************************************************}
procedure TALDynamicBaseCheckBox.TCheckStateStyles.Reset;
begin
  BeginUpdate;
  Try
    inherited;
    Default.Reset;
    Disabled.Reset;
    Hovered.Reset;
    Pressed.Reset;
    Focused.Reset;
  finally
    EndUpdate;
  end;
end;

{**************************************************************}
procedure TALDynamicBaseCheckBox.TCheckStateStyles.AlignToPixel;
begin
  BeginUpdate;
  Try
    Default.AlignToPixel;
    Disabled.AlignToPixel;
    Hovered.AlignToPixel;
    Pressed.AlignToPixel;
    Focused.AlignToPixel;
  finally
    EndUpdate;
  end;
end;

{******************************************************************}
procedure TALDynamicBaseCheckBox.TCheckStateStyles.ApplyColorScheme;
begin
  BeginUpdate;
  Try
    Default.ApplyColorScheme;
    Disabled.ApplyColorScheme;
    Hovered.ApplyColorScheme;
    Pressed.ApplyColorScheme;
    Focused.ApplyColorScheme;
  finally
    EndUpdate;
  end;
end;

{******************************************************************}
procedure TALDynamicBaseCheckBox.TCheckStateStyles.ClearBufDrawable;
begin
  Default.ClearBufDrawable;
  Disabled.ClearBufDrawable;
  Hovered.ClearBufDrawable;
  Pressed.ClearBufDrawable;
  Focused.ClearBufDrawable;
end;

{**********************************************************************************************}
procedure TALDynamicBaseCheckBox.TCheckStateStyles.SetDefault(const AValue: TDefaultStateStyle);
begin
  FDefault.Assign(AValue);
end;

{************************************************************************************************}
procedure TALDynamicBaseCheckBox.TCheckStateStyles.SetDisabled(const AValue: TDisabledStateStyle);
begin
  FDisabled.Assign(AValue);
end;

{**********************************************************************************************}
procedure TALDynamicBaseCheckBox.TCheckStateStyles.SetHovered(const AValue: THoveredStateStyle);
begin
  FHovered.Assign(AValue);
end;

{**********************************************************************************************}
procedure TALDynamicBaseCheckBox.TCheckStateStyles.SetPressed(const AValue: TPressedStateStyle);
begin
  FPressed.Assign(AValue);
end;

{**********************************************************************************************}
procedure TALDynamicBaseCheckBox.TCheckStateStyles.SetFocused(const AValue: TFocusedStateStyle);
begin
  FFocused.Assign(AValue);
end;

{**********************************************************************************}
procedure TALDynamicBaseCheckBox.TCheckStateStyles.DefaultChanged(ASender: TObject);
begin
  Change;
end;

{***********************************************************************************}
procedure TALDynamicBaseCheckBox.TCheckStateStyles.DisabledChanged(ASender: TObject);
begin
  Change;
end;

{**********************************************************************************}
procedure TALDynamicBaseCheckBox.TCheckStateStyles.HoveredChanged(ASender: TObject);
begin
  Change;
end;

{**********************************************************************************}
procedure TALDynamicBaseCheckBox.TCheckStateStyles.PressedChanged(ASender: TObject);
begin
  Change;
end;

{**********************************************************************************}
procedure TALDynamicBaseCheckBox.TCheckStateStyles.FocusedChanged(ASender: TObject);
begin
  Change;
end;

{***************************************************************************************}
constructor TALDynamicBaseCheckBox.TStateStyles.Create(const AParent: TALDynamicControl);
begin
  inherited Create(AParent);
  //--
  FChecked := CreateCheckedStateStyles(AParent);
  FChecked.OnChanged := CheckedChanged;
  //--
  FUnchecked := CreateUnCheckedStateStyles(AParent);
  FUnchecked.OnChanged := UncheckedChanged;
end;

{*****************************************************}
destructor TALDynamicBaseCheckBox.TStateStyles.Destroy;
begin
  ALFreeAndNil(FChecked);
  ALFreeAndNil(FUnchecked);
  inherited Destroy;
end;

{***************************************************************************************************}
function TALDynamicBaseCheckBox.TStateStyles.CreateTransition: TALDynamicBaseStateStyles.TTransition;
begin
  result := TTransition.Create(Self);
end;

{*************************************************************************************************************************}
function TALDynamicBaseCheckBox.TStateStyles.CreateCheckedStateStyles(const AParent: TALDynamicControl): TCheckStateStyles;
begin
  Result := TCheckStateStyles.Create(AParent);
end;

{***************************************************************************************************************************}
function TALDynamicBaseCheckBox.TStateStyles.CreateUncheckedStateStyles(const AParent: TALDynamicControl): TCheckStateStyles;
begin
  Result := TCheckStateStyles.Create(AParent);
end;

{************************************************************************}
procedure TALDynamicBaseCheckBox.TStateStyles.Assign(Source: TPersistent);
begin
  if Source is TStateStyles then begin
    BeginUpdate;
    Try
      Checked.Assign(TStateStyles(Source).Checked);
      Unchecked.Assign(TStateStyles(Source).Unchecked);
      inherited Assign(Source);
    Finally
      EndUpdate;
    End;
  end
  else
    ALAssignError(Source{ASource}, Self{ADest});
end;

{**************************************************}
procedure TALDynamicBaseCheckBox.TStateStyles.Reset;
begin
  BeginUpdate;
  Try
    inherited;
    Checked.reset;
    Unchecked.reset;
  finally
    EndUpdate;
  end;
end;

{*********************************************************}
procedure TALDynamicBaseCheckBox.TStateStyles.AlignToPixel;
begin
  BeginUpdate;
  Try
    inherited;
    Checked.AlignToPixel;
    Unchecked.AlignToPixel;
  finally
    EndUpdate;
  end;
end;

{*************************************************************}
procedure TALDynamicBaseCheckBox.TStateStyles.ApplyColorScheme;
begin
  BeginUpdate;
  Try
    inherited;
    Checked.ApplyColorScheme;
    Unchecked.ApplyColorScheme;
  finally
    EndUpdate;
  end;
end;

{*************************************************************}
procedure TALDynamicBaseCheckBox.TStateStyles.ClearBufDrawable;
begin
  inherited;
  Checked.ClearBufDrawable;
  Unchecked.ClearBufDrawable;
end;

{****************************************************************************************}
function TALDynamicBaseCheckBox.TStateStyles.GetCurrentRawStyle: TALDynamicBaseStateStyle;
begin
  if Parent.Checked then begin
    if Not Parent.Enabled then Result := Checked.Disabled
    else if Parent.Pressed then Result := Checked.Pressed
    //**else if Parent.IsFocused then Result := Checked.Focused
    else if Parent.IsMouseOver then Result := Checked.Hovered
    else result := Checked.Default;
  end
  else begin
    if Not Parent.Enabled then Result := UnChecked.Disabled
    else if Parent.Pressed then Result := UnChecked.Pressed
    //**else if Parent.IsFocused then Result := UnChecked.Focused
    else if Parent.IsMouseOver then Result := UnChecked.Hovered
    else result := UnChecked.Default;
  end;
end;

{*****************************************************************************}
function TALDynamicBaseCheckBox.TStateStyles.GetParent: TALDynamicBaseCheckBox;
begin
  Result := TALDynamicBaseCheckBox(inherited Parent);
end;

{***********************************************************************************}
function TALDynamicBaseCheckBox.TStateStyles.GetTransition: TStateStyles.TTransition;
begin
  Result := TStateStyles.TTransition(inherited Transition);
end;

{**************************************************************************************************}
procedure TALDynamicBaseCheckBox.TStateStyles.SetTransition(const AValue: TStateStyles.TTransition);
begin
  inherited Transition := AValue;
end;

{****************************************************************************************}
procedure TALDynamicBaseCheckBox.TStateStyles.SetChecked(const AValue: TCheckStateStyles);
begin
  FChecked.Assign(AValue);
end;

{******************************************************************************************}
procedure TALDynamicBaseCheckBox.TStateStyles.SetUnchecked(const AValue: TCheckStateStyles);
begin
  FUnchecked.Assign(AValue);
end;

{*****************************************************************************}
procedure TALDynamicBaseCheckBox.TStateStyles.CheckedChanged(ASender: TObject);
begin
  Change;
end;

{*******************************************************************************}
procedure TALDynamicBaseCheckBox.TStateStyles.UncheckedChanged(ASender: TObject);
begin
  Change;
end;

{***************************************************************}
constructor TALDynamicBaseCheckBox.Create(const AOwner: TObject);
begin
  inherited;
  //--
  //**SetAcceptsControls(False);
  //**CanFocus := True;
  Cursor := crHandPoint;
  //--
  FCheckMark := CreateCheckMark;
  FCheckMark.OnChanged := CheckMarkChanged;
  //--
  FChecked := False;
  FDoubleBuffered := true;
  FXRadius := DefaultXRadius;
  FYRadius := DefaultYRadius;
  FCacheIndex := 0;
  FCacheEngine := nil;
  {$IF NOT DEFINED(ALSkiaCanvas)}
  FRenderTargetSurface := ALNullSurface;
  FRenderTargetCanvas := ALNullCanvas;
  FRenderTargetDrawable := ALNullDrawable;
  {$ENDIF}
  FOnChange := nil;
  //--
  // Must be created at the end because it requires FCheckMark to
  // be already created.
  FStateStyles := CreateStateStyles;
  FStateStyles.OnChanged := StateStylesChanged;
end;

{****************************************}
destructor TALDynamicBaseCheckBox.Destroy;
begin
  ALFreeAndNil(FStateStyles);
  ALFreeAndNil(FCheckMark);
  {$IF NOT DEFINED(ALSkiaCanvas)}
  ClearRenderTargets;
  {$ENDIF}
  inherited;
end;

{*****************************************************************}
procedure TALDynamicBaseCheckBox.Assign(Source: TALDynamicControl);
begin
  BeginUpdate;
  Try
    if Source is TALDynamicBaseCheckBox then begin
      StateStyles.Assign(TALDynamicBaseCheckBox(Source).StateStyles);
      CheckMark.Assign(TALDynamicBaseCheckBox(Source).CheckMark);
      Checked := TALDynamicBaseCheckBox(Source).Checked;
      XRadius := TALDynamicBaseCheckBox(Source).XRadius;
      YRadius := TALDynamicBaseCheckBox(Source).YRadius;
      CacheIndex := TALDynamicBaseCheckBox(Source).CacheIndex;
      CacheEngine := TALDynamicBaseCheckBox(Source).CacheEngine;
      OnChange := TALDynamicBaseCheckBox(Source).OnChange;
    end
    else
      ALAssignError(Source{ASource}, Self{ADest});
    inherited Assign(Source);
  Finally
    EndUpdate;
  End;
end;

{***************************************************************}
function TALDynamicBaseCheckBox.CreateCheckMark: TCheckMarkBrush;
begin
  Result := TCheckMarkBrush.Create;
end;

{**************************************************************}
function TALDynamicBaseCheckBox.CreateStateStyles: TStateStyles;
begin
  Result := TStateStyles.Create(self);
end;

{********************************************}
procedure TALDynamicBaseCheckBox.AlignToPixel;
begin
  BeginUpdate;
  try
    inherited;
    StateStyles.AlignToPixel;
    CheckMark.AlignToPixel;
  finally
    EndUpdate;
  end;
end;

{************************************************}
procedure TALDynamicBaseCheckBox.ApplyColorScheme;
begin
  BeginUpdate;
  Try
    inherited;
    StateStyles.ApplyColorScheme;
    CheckMark.ApplyColorScheme;
  finally
    EndUpdate;
  end;
end;

{********************************************************}
function TALDynamicBaseCheckBox.GetCacheSubIndex: Integer;
begin
  Result := 0;
end;

{*********************************************************}
function TALDynamicBaseCheckBox.GetDoubleBuffered: boolean;
begin
  result := fDoubleBuffered;
end;

{************************************************************************}
procedure TALDynamicBaseCheckBox.SetDoubleBuffered(const AValue: Boolean);
begin
  if AValue <> fDoubleBuffered then begin
    fDoubleBuffered := AValue;
    if not fDoubleBuffered then ClearBufDrawable
    {$IF NOT DEFINED(ALSkiaCanvas)}
    else ClearRenderTargets;
    {$ENDIF}
  end;
end;

{**************************************************}
function TALDynamicBaseCheckBox.GetChecked: Boolean;
begin
  Result := FChecked;
end;

{****************************************************************}
procedure TALDynamicBaseCheckBox.SetChecked(const Value: Boolean);
begin
  if FChecked <> Value then begin
    FChecked := Value;
    if FChecked then DisabledOpacity := StateStyles.Checked.Disabled.opacity
    else DisabledOpacity := StateStyles.Unchecked.Disabled.opacity;
    DoChanged;
  end;
end;

{**************************************************************************}
procedure TALDynamicBaseCheckBox.SetCheckMark(const Value: TCheckMarkBrush);
begin
  FCheckMark.Assign(Value);
end;

{**************************************************************************}
procedure TALDynamicBaseCheckBox.SetStateStyles(const AValue: TStateStyles);
begin
  FStateStyles.Assign(AValue);
end;

{*******************************************************}
function TALDynamicBaseCheckBox.IsXRadiusStored: Boolean;
begin
  Result := not SameValue(FXRadius, DefaultXRadius, TEpsilon.Vector);
end;

{*******************************************************}
function TALDynamicBaseCheckBox.IsYRadiusStored: Boolean;
begin
  Result := not SameValue(FYRadius, DefaultYRadius, TEpsilon.Vector);
end;

{********************************************************}
function TALDynamicBaseCheckBox.GetDefaultXRadius: Single;
begin
  Result := 0;
end;

{********************************************************}
function TALDynamicBaseCheckBox.GetDefaultYRadius: Single;
begin
  Result := 0;
end;

{***************************************************************}
procedure TALDynamicBaseCheckBox.SetXRadius(const Value: Single);
begin
  if not SameValue(FXRadius, Value, TEpsilon.Vector) then begin
    ClearBufDrawable;
    FXRadius := Value;
    Repaint;
  end;
end;

{***************************************************************}
procedure TALDynamicBaseCheckBox.SetYRadius(const Value: Single);
begin
  if not SameValue(FYRadius, Value, TEpsilon.Vector) then begin
    ClearBufDrawable;
    FYRadius := Value;
    Repaint;
  end;
end;

{*****************************************************************}
procedure TALDynamicBaseCheckBox.CheckMarkChanged(Sender: TObject);
begin
  ClearBufDrawable;
  Repaint;
end;

{************************************************************}
procedure TALDynamicBaseCheckBox.FillChanged(Sender: TObject);
begin
  ClearBufDrawable;
  inherited;
end;

{**************************************************************}
procedure TALDynamicBaseCheckBox.StrokeChanged(Sender: TObject);
begin
  ClearBufDrawable;
  inherited;
end;

{**************************************************************}
procedure TALDynamicBaseCheckBox.ShadowChanged(Sender: TObject);
begin
  ClearBufDrawable;
  inherited;
end;

{*******************************************************************}
procedure TALDynamicBaseCheckBox.StateStylesChanged(Sender: TObject);
begin
  ClearBufDrawable;
  if Checked then DisabledOpacity := StateStyles.Checked.Disabled.opacity
  else DisabledOpacity := StateStyles.Unchecked.Disabled.opacity;
  Repaint;
end;

{**************************************************}
procedure TALDynamicBaseCheckBox.IsMouseOverChanged;
begin
  inherited;
  StateStyles.Transition.Start;
  repaint;
end;

{****************************************************}
//**procedure TALDynamicBaseCheckBox.IsFocusedChanged;
//**begin
//**  inherited;
//**  StateStyles.Transition.Start;
//**  repaint;
//**end;

{**********************************************}
procedure TALDynamicBaseCheckBox.PressedChanged;
begin
  inherited;
  StateStyles.Transition.Start;
  repaint;
end;

{************************************************************************************************************}
//**procedure TALDynamicBaseCheckBox.KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState);
//**begin
//**  inherited;
//**  if (KeyChar = ' ') then begin
//**    Click; // Emulate mouse click to perform Action.OnExecute
//**    KeyChar := #0;
//**  end;
//**end;

{********************************************}
procedure TALDynamicBaseCheckBox.DoClickSound;
begin
  if (ClickSound=TALClickSoundMode.Always) or
     ((ClickSound=TALClickSoundMode.Default) and ALGlobalClickSoundEnabled) then
    ALPlayClickSound;
end;

{*************************************}
procedure TALDynamicBaseCheckBox.Click;
begin
  if StateStyles.Transition.Running and StateStyles.Transition.DelayClick then begin
    Checked := not Checked;
    StateStyles.Transition.ClickDelayed := True
  end
  else begin
    if not StateStyles.Transition.ClickDelayed then
      Checked := not Checked;
    inherited click;
  end;
end;

{*****************************************************}
function TALDynamicBaseCheckBox.GetDefaultSize: TSizeF;
begin
  Result := TSizeF.Create(18, 18);
end;

{*****************************************}
procedure TALDynamicBaseCheckBox.DoChanged;
begin
  if Assigned(FOnChange) then
    FOnChange(Self);
  Repaint;
end;

{*****************************************}
procedure TALDynamicBaseCheckBox.DoResized;
begin
  ClearBufDrawable;
  inherited;
end;

{************************************************}
procedure TALDynamicBaseCheckBox.ClearBufDrawable;
begin
  {$IFDEF debug}
  if (FStateStyles <> nil) and
     (not IsDestroying) and
     ((not ALIsDrawableNull(FStateStyles.Checked.Default.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.Checked.Disabled.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.Checked.Hovered.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.Checked.Pressed.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.Checked.Focused.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.UnChecked.Default.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.UnChecked.Disabled.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.UnChecked.Hovered.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.UnChecked.Pressed.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.UnChecked.Focused.FBufDrawable))) then
    ALLog(Classname + '.ClearBufDrawable', 'BufDrawable has been cleared | Name: ' + Name, TalLogType.warn);
  {$endif}
  if FStateStyles <> nil then
    FStateStyles.ClearBufDrawable;
end;

{***********************************************}
procedure TALDynamicBaseCheckBox.MakeBufDrawable;

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  function _DoMakeBufDrawable(const AStateStyle: TBaseStateStyle): boolean;
  begin
    if (not ALIsDrawableNull(AStateStyle.FBufDrawable)) then exit(False);
    AStateStyle.SupersedeNoChanges(true{ASaveState});
    try

      {$IFDEF debug}
      ALLog(Classname + '.MakeBufDrawable', 'Name: ' + Name + ' | Style: ' + AStateStyle.ClassName + ' | Width: ' + ALFloatToStrW(Width)+ ' | Height: ' + ALFloatToStrW(Height));
      {$endif}

      CreateBufDrawable(
        AStateStyle.FBufDrawable, // var ABufDrawable: TALDrawable;
        AStateStyle.FBufDrawableRect, // var ABufDrawableRect: TRectF;
        ALGetScreenScale * AStateStyle.Scale, // const AScale: Single;
        AStateStyle.Fill, // const AFill: TALBrush;
        AStateStyle.StateLayer, // const AStateLayer: TALStateLayer;
        AStateStyle.Stroke, // const AStroke: TALStrokeBrush;
        AStateStyle.CheckMark, // const ACheckMark: TCheckMarkBrush;
        AStateStyle.Shadow); // const AShadow: TALShadow);

      // LStateStyle.FBufDrawableRect must include the LScale
      AStateStyle.FBufDrawableRect.Top := AStateStyle.FBufDrawableRect.Top * AStateStyle.Scale;
      AStateStyle.FBufDrawableRect.right := AStateStyle.FBufDrawableRect.right * AStateStyle.Scale;
      AStateStyle.FBufDrawableRect.left := AStateStyle.FBufDrawableRect.left * AStateStyle.Scale;
      AStateStyle.FBufDrawableRect.bottom := AStateStyle.FBufDrawableRect.bottom * AStateStyle.Scale;

      // Since LStateStyle.FBufDrawableRect can have different dimensions than the main BufDrawableRect (LocalRect.ReducePrecision)
      // (due to scale), we must center LStateStyle.FBufDrawableRect within the main BufDrawableRect (LocalRect.ReducePrecision)
      // to ensure that all changes are visually centered.
      var LCenteredRect := AStateStyle.FBufDrawableRect.CenterAt(LocalRect.ReducePrecision);
      AStateStyle.FBufDrawableRect.Offset(LCenteredRect.Left, LCenteredRect.top);

    finally
      AStateStyle.RestorestateNoChanges;
    end;
    Result := True;
  end;

begin
  //--- Do not create BufDrawable if not DoubleBuffered
  if {$IF not DEFINED(ALDPK)}(not DoubleBuffered){$ELSE}False{$ENDIF} then begin
    ClearBufDrawable;
    exit;
  end;
  //--
  var LSubIndexOffset: Integer;
  var LDefaultStateStyle: TBaseStateStyle;
  if Checked then begin
    LSubIndexOffset := GetCacheSubIndex{+0};
    LDefaultStateStyle := StateStyles.Checked.Default;
  end
  else begin
    LSubIndexOffset := GetCacheSubIndex+5;
    LDefaultStateStyle := StateStyles.UnChecked.Default;
  end;
  //--
  if (CacheIndex = 0) or
     (CacheEngine = nil) or
     (not CacheEngine.HasEntry(CacheIndex{AIndex}, LSubIndexOffset+LDefaultStateStyle.CacheSubIndex{ASubIndex})) then
    _DoMakeBufDrawable(LDefaultStateStyle);
  //--
  var LStateStyle := TBaseStateStyle(StateStyles.GetCurrentRawStyle);
  if LStateStyle = nil then exit;
  if LStateStyle.Inherit then exit;
  if (CacheIndex > 0) and
     (CacheEngine <> nil) and
     (CacheEngine.HasEntry(CacheIndex{AIndex}, LSubIndexOffset+LStateStyle.CacheSubIndex{ASubIndex})) then Exit;
  _DoMakeBufDrawable(LStateStyle);
  // No need to center LStateStyle.FBufDrawableRect on the main BufDrawableRect
  // because BufDrawableRect always has the width and height of the localRect.
end;

{*********************************************}
procedure TALDynamicBaseCheckBox.DrawCheckMark(
            const ACanvas: TALCanvas;
            const AScale: Single;
            const ADstRect: TrectF;
            const AOpacity: Single;
            const AChecked: Boolean;
            const ACheckMark: TCheckMarkBrush);
begin

  var LCanvasMatrix: TMatrix;
  var LCanvasScale: Single;
  if AutoAlignToPixel then ALExtractMatrixFromCanvas(Acanvas, LCanvasMatrix, LCanvasScale)
  else begin
    LCanvasMatrix := TMatrix.Identity;
    LCanvasScale := 1;
  end;
  var LRect := ADstRect;
  LRect.Top := LRect.Top * AScale;
  LRect.right := LRect.right * AScale;
  LRect.left := LRect.left * AScale;
  LRect.bottom := LRect.bottom * AScale;
  if AutoAlignToPixel then
    LRect := ALAlignToPixelRound(LRect, LCanvasMatrix, LCanvasScale, TEpsilon.Position);
  var LScaledMarginsRect := ACheckMark.Margins.Rect;
  LScaledMarginsRect.Left := LScaledMarginsRect.Left * AScale;
  LScaledMarginsRect.right := LScaledMarginsRect.right * AScale;
  LScaledMarginsRect.top := LScaledMarginsRect.top * AScale;
  LScaledMarginsRect.bottom := LScaledMarginsRect.bottom * AScale;
  if AutoAlignToPixel then
    LScaledMarginsRect := ALAlignEdgesToPixelRound(LScaledMarginsRect, LCanvasScale, TEpsilon.Position);
  LRect.Top := LRect.Top + LScaledMarginsRect.top;
  LRect.right := LRect.right - LScaledMarginsRect.right;
  LRect.left := LRect.left + LScaledMarginsRect.left;
  LRect.bottom := LRect.bottom - LScaledMarginsRect.bottom;
  if LRect.IsEmpty then exit;

  // Without ResourceName
  if ACheckMark.ResourceName = '' then begin

    // Exit if no color or no stroke
    var LScaledCheckMarkThickness := ACheckMark.Thickness * AScale;
    if (ACheckMark.Color = TalphaColors.Null) or (CompareValue(LScaledCheckMarkThickness, 0, TEpsilon.position) <= 0) then
      exit;
    if AutoAlignToPixel then
      LScaledCheckMarkThickness := ALAlignDimensionToPixelRound(LScaledCheckMarkThickness, LCanvasScale, TEpsilon.Position);

    // exit if not checked
    if not Achecked then
      exit;

    // Try to find LPoint2.x so that LPoint1, LPoint2 and LPoint3 form
    // a right triangle
    Var LHalfScaledCheckMarkThickness := ((LScaledCheckMarkThickness / Sqrt(2)) / 2);
    Var LCheckMarkRect := TRectF.Create(0,0,342,270).FitInto(Lrect);
    var LPoint1 := TPointF.Create(LCheckMarkRect.left + LHalfScaledCheckMarkThickness, LCheckMarkRect.top+(LCheckMarkRect.height * 0.5));
    var LPoint2 := TPointF.Create(0, LCheckMarkRect.Bottom - (2*LHalfScaledCheckMarkThickness));
    var LPoint3 := TPointF.Create(LCheckMarkRect.right-LHalfScaledCheckMarkThickness, LCheckMarkRect.top+LHalfScaledCheckMarkThickness);
    // Coefficients for the quadratic equation ax^2 + bx + c = 0
    var a: Single := 1;
    var b: Single := -(LPoint1.X + LPoint3.X);
    var c: Single := LPoint1.X * LPoint3.X + LPoint1.Y * LPoint3.Y - LPoint1.Y * LPoint2.Y - LPoint2.Y * LPoint3.Y + Sqr(LPoint2.Y);
    // Calculate the discriminant
    var LDiscriminant: Single := b * b - 4 * a * c;
    // Check if there are real solutions
    if LDiscriminant < 0 then begin
      // No real solution so use place LPoint2.x
      // at 33% from the left border
      LPoint2.x := LCheckMarkRect.Left + (LCheckMarkRect.Width * 0.33);
    end
    else begin
      // 2 solutions:
      //     (-b - Sqrt(LDiscriminant)) / (2 * a);
      //     (-b + Sqrt(LDiscriminant)) / (2 * a);
      // Use only the first one
      LPoint2.x := (-b - Sqrt(LDiscriminant)) / (2 * a);
    end;

    {$REGION 'SKIA'}
    {$IF defined(ALSkiaEngine)}

    // Create LPaint
    var LPaint := ALSkCheckHandle(sk4d_paint_create);
    try

      // Requests, but does not require, that edge pixels draw opaque or with partial transparency.
      sk4d_paint_set_antialias(LPaint, true);
      // Sets whether the geometry is filled, stroked, or filled and stroked.
      sk4d_paint_set_dither(LPaint, true);

      // Stroke with solid color
      sk4d_paint_set_style(LPaint, sk_paintstyle_t.STROKE_SK_PAINTSTYLE);
      sk4d_paint_set_stroke_width(LPaint, LScaledCheckMarkThickness);
      sk4d_paint_set_color(LPaint, ACheckMark.Color);
      var LPathBuilder := ALSkCheckHandle(sk4d_pathbuilder_create);
      try
        sk4d_pathbuilder_move_to(LPathBuilder, @LPoint1);
        sk4d_pathbuilder_line_to(LPathBuilder, @LPoint2);
        sk4d_pathbuilder_line_to(LPathBuilder, @LPoint3);
        var LPath := sk4d_pathbuilder_detach(LPathBuilder);
        try
          sk4d_canvas_draw_Path(ACanvas, LPath, LPaint);
        finally
          sk4d_path_destroy(LPath);
        end;
      finally
        sk4d_pathbuilder_destroy(LPathBuilder);
      end;

    finally
      sk4d_paint_destroy(LPaint);
    end;

    {$ENDIF}
    {$ENDREGION}

    {$REGION 'ANDROID'}
    {$IF (defined(ANDROID)) and (not defined(ALSkiaEngine))}

    // Create LPaint
    var LPaint := TJPaint.JavaClass.init;
    LPaint.setAntiAlias(true); // Enabling this flag will cause all draw operations that support antialiasing to use it.
    LPaint.setFilterBitmap(True); // enable bilinear sampling on scaled bitmaps. If cleared, scaled bitmaps will be drawn with nearest neighbor sampling, likely resulting in artifacts.
    LPaint.setDither(true); // Enabling this flag applies a dither to any blit operation where the target's colour space is more constrained than the source.

    // Stroke with solid color
    LPaint.setStyle(TJPaint_Style.JavaClass.STROKE);
    LPaint.setStrokeWidth(LScaledCheckMarkThickness);
    LPaint.setColor(integer(ACheckMark.Color));
    var LPath := TJPath.Create;
    LPath.moveTo(LPoint1.x, LPoint1.y);
    LPath.LineTo(LPoint2.x, LPoint2.y);
    LPath.LineTo(LPoint3.x, LPoint3.y);
    aCanvas.drawPath(LPath,LPaint);
    LPath := nil;

    //free the paint
    LPaint := nil;

    {$ENDIF}
    {$ENDREGION}

    {$REGION 'APPLEOS'}
    {$IF (defined(ALAppleOS)) and (not defined(ALSkiaEngine))}

    var LAlphaColor := TAlphaColorCGFloat.Create(ACheckMark.Color);
    CGContextSetRGBStrokeColor(ACanvas, LAlphaColor.R, LAlphaColor.G, LAlphaColor.B, LAlphaColor.A);
    CGContextSetLineWidth(ACanvas, LScaledCheckMarkThickness);

    var LGridHeight := CGBitmapContextGetHeight(ACanvas);

    CGContextBeginPath(ACanvas);
    CGContextMoveToPoint(ACanvas, LPoint1.x, LGridHeight - LPoint1.y);
    CGContextAddLineToPoint(ACanvas, LPoint2.x, LGridHeight - LPoint2.y);
    CGContextAddLineToPoint(ACanvas, LPoint3.x, LGridHeight - LPoint3.y);
    CGContextStrokePath(ACanvas);


    {$ENDIF}
    {$ENDREGION}

    {$REGION 'MSWINDOWS'}
    {$IF (not defined(ANDROID)) and (not defined(ALAppleOS)) and (not defined(ALSkiaEngine))}

    var LSaveState := ACanvas.SaveState;
    try
      ACanvas.Stroke.Color := ACheckMark.Color;
      ACanvas.Stroke.Thickness := LScaledCheckMarkThickness;
      ACanvas.DrawLine(LPoint1, LPoint2, 1{AOpacity});
      ACanvas.DrawLine(LPoint2, LPoint3, 1{AOpacity});
    finally
      ACanvas.RestoreState(LSaveState)
    end;

    {$ENDIF}
    {$ENDREGION}

  end

  // With ResourceName
  else begin

    TALDrawRectangleHelper.Create(ACanvas)
      .SetAlignToPixel(AutoAlignToPixel)
      .SetDstRect(LRect)
      .SetOpacity(AOpacity)
      .SetFillColor(ACheckMark.Color)
      .SetFillResourceName(ACheckMark.ResourceName)
      .SetFillWrapMode(ACheckMark.WrapMode)
      .Draw;

  end;

end;

{*************************************************}
Procedure TALDynamicBaseCheckBox.CreateBufDrawable(
            var ABufDrawable: TALDrawable;
            out ABufDrawableRect: TRectF;
            const AScale: Single;
            const AFill: TALBrush;
            const AStateLayer: TALStateLayer;
            const AStroke: TALStrokeBrush;
            const ACheckMark: TCheckMarkBrush;
            const AShadow: TALShadow);
begin

  if (not ALIsDrawableNull(ABufDrawable)) then exit;

  ABufDrawableRect := LocalRect.ReducePrecision;
  var LSurfaceRect := ALGetShapeSurfaceRect(
                        ABufDrawableRect, // const ARect: TRectF;
                        AutoAlignToPixel, // const AAlignToPixel: Boolean;
                        AFill, // const AFill: TALBrush;
                        nil, // const AFillResourceStream: TStream;
                        AStateLayer, // const AStateLayer: TALStateLayer;
                        AShadow); // const AShadow: TALShadow): TRectF;
  if ACheckMark.HasCheckMark then begin
    var LCheckMarkMarginsRect := ACheckMark.margins.Rect;
    if AutoAlignToPixel then LCheckMarkMarginsRect := ALAlignEdgesToPixelRound(LCheckMarkMarginsRect, ALGetScreenScale, TEpsilon.Position);
    var LCheckMarkRect := ABufDrawableRect;
    LCheckMarkRect.Inflate(-LCheckMarkMarginsRect.Left, -LCheckMarkMarginsRect.top, -LCheckMarkMarginsRect.right, -LCheckMarkMarginsRect.Bottom);
    LSurfaceRect := TRectF.Union(LCheckMarkRect, LSurfaceRect);
  end;
  ABufDrawableRect.Offset(-LSurfaceRect.Left, -LSurfaceRect.Top);

  var LSurface: TALSurface;
  var LCanvas: TALCanvas;
  ALCreateSurface(
    LSurface, // out ASurface: TALSurface;
    LCanvas, // out ACanvas: TALCanvas;
    AScale, // const AScale: Single;
    LSurfaceRect.Width, // const w: integer;
    LSurfaceRect.height);// const h: integer)
  try

    if ALCanvasBeginScene(LCanvas) then
    try

      TALDrawRectangleHelper.Create(LCanvas)
        .SetScale(AScale)
        .SetAlignToPixel(AutoAlignToPixel)
        .SetDstRect(ABufDrawableRect)
        .SetFill(AFill)
        .SetStateLayer(AStateLayer, ACheckMark.Color)
        .SetDrawStateLayerOnTop(False)
        .SetStroke(AStroke)
        .SetShadow(AShadow)
        .SetSides(AllSides)
        .SetCorners(AllCorners)
        .SetXRadius(XRadius)
        .SetYRadius(YRadius)
        .Draw;

      DrawCheckMark(
        LCanvas, // const ACanvas: TALCanvas;
        AScale, // const AScale: Single;
        ABufDrawableRect, // const ADstRect: TrectF;
        1, // const AOpacity: Single;
        Checked, // const AChecked: Boolean
        ACheckMark); // const ACheckMark: TCheckMarkBrush;

    finally
      ALCanvasEndScene(LCanvas)
    end;

    ABufDrawable := ALCreateDrawableFromSurface(LSurface);
    // The Shadow or Statelayer are not included in the dimensions of the fBufDrawableRect rectangle.
    // However, the fBufDrawableRect rectangle is offset by the dimensions of the shadow/Statelayer.
    ABufDrawableRect.Offset(-2*ABufDrawableRect.Left, -2*ABufDrawableRect.Top);

  finally
    ALFreeAndNilSurface(LSurface, LCanvas);
  end;

end;

{*****************************}
{$IF NOT DEFINED(ALSkiaCanvas)}
function TALDynamicBaseCheckBox.GetRenderTargetRect(const ARect: TrectF): TRectF;
begin
  if StateStyles.Transition.Running then begin
    Result := ARect;
    if StateStyles.Transition.FromStateStyle <> nil then begin
      var LFromSurfaceRect := ALGetShapeSurfaceRect(
                                ARect, // const ARect: TRectF;
                                AutoAlignToPixel, // const AAlignToPixel: Boolean;
                                _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.FromStateStyle).Fill, // const AFill: TALBrush;
                                nil, // const AFillResourceStream: TStream;
                                _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.FromStateStyle).StateLayer, // const AStateLayer: TALStateLayer;
                                _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.FromStateStyle).Shadow); // const AShadow: TALShadow): TRectF;
      Result := TRectF.Union(Result, LFromSurfaceRect); // add the extra space needed to draw the shadow/statelayer
    end;
    if StateStyles.Transition.ToStateStyle <> nil then begin
      var LToSurfaceRect := ALGetShapeSurfaceRect(
                              ARect, // const ARect: TRectF;
                              AutoAlignToPixel, // const AAlignToPixel: Boolean;
                              _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.ToStateStyle).Fill, // const AFill: TALBrush;
                              nil, // const AFillResourceStream: TStream;
                              _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.ToStateStyle).StateLayer, // const AStateLayer: TALStateLayer;
                              _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.ToStateStyle).Shadow); // const AShadow: TALShadow): TRectF;
      Result := TRectF.Union(Result, LToSurfaceRect); // add the extra space needed to draw the shadow/statelayer
    end;
  end
  else begin
    var LStateStyle := TBaseStateStyle(StateStyles.GetCurrentRawStyle);
    if LStateStyle <> nil then begin
      Result := ALGetShapeSurfaceRect(
                  ARect, // const ARect: TRectF;
                  AutoAlignToPixel, // const AAlignToPixel: Boolean;
                  LStateStyle.Fill, // const AFill: TALBrush;
                  nil, // const AFillResourceStream: TStream;
                  LStateStyle.StateLayer, // const AStateLayer: TALStateLayer;
                  LStateStyle.Shadow); // const AShadow: TALShadow): TRectF;
    end
    else begin
      Result := ALGetShapeSurfaceRect(
                  ARect, // const ARect: TRectF;
                  AutoAlignToPixel, // const AAlignToPixel: Boolean;
                  Fill, // const AFill: TALBrush;
                  nil, // const AFillResourceStream: TStream;
                  nil, // const AStateLayer: TALStateLayer;
                  Shadow); // const AShadow: TALShadow): TRectF;
    end;
  end;
end;
{$ENDIF}

{*****************************}
{$IF NOT DEFINED(ALSkiaCanvas)}
procedure TALDynamicBaseCheckBox.InitRenderTargets(var ARect: TrectF);
begin
  var LSurfaceRect := GetRenderTargetRect(ARect);
  ARect.Offset(-LSurfaceRect.Left, -LSurfaceRect.Top);
  ALInitControlRenderTargets(
    LSurfaceRect, // Const ARect: TrectF;
    FRenderTargetSurface, // var ARenderTargetSurface: TALSurface;
    FRenderTargetCanvas, // var ARenderTargetCanvas: TALCanvas;
    FRenderTargetDrawable); // var ARenderTargetDrawable: TALDrawable):
end;
{$ENDIF}

{*****************************}
{$IF NOT DEFINED(ALSkiaCanvas)}
procedure TALDynamicBaseCheckBox.ClearRenderTargets;
begin
  ALFreeAndNilDrawable(FRenderTargetDrawable);
  ALFreeAndNilSurface(FRenderTargetSurface, FRenderTargetCanvas);
end;
{$ENDIF}

{*************************************}
procedure TALDynamicBaseCheckBox.Paint;
begin

  StateStyles.UpdateLastPaintedRawStyle;

  var LDrawable: TALDrawable := ALNullDrawable;
  var LDrawableRect: TRectF := TRectF.Empty;
  if not StateStyles.Transition.Running then begin
    //--
    var LSubIndexOffset: Integer;
    var LDefaultStateStyle: TBaseStateStyle;
    if Checked then begin
      LSubIndexOffset := GetCacheSubIndex{+0};
      LDefaultStateStyle := StateStyles.Checked.Default;
    end
    else begin
      LSubIndexOffset := GetCacheSubIndex+5;
      LDefaultStateStyle := StateStyles.UnChecked.Default;
    end;
    //--
    var LStateStyle := TBaseStateStyle(StateStyles.GetCurrentRawStyle);
    if LStateStyle <> nil then begin
      if (CacheIndex <= 0) or
         (CacheEngine = nil) or
         (not CacheEngine.TryGetEntry(CacheIndex{AIndex}, LSubIndexOffset+LStateStyle.CacheSubIndex{ASubIndex}, LDrawable{ADrawable}, LDrawableRect{ARect})) then begin
        MakeBufDrawable;
        if (CacheIndex > 0) and (CacheEngine <> nil) and (not ALIsDrawableNull(LStateStyle.FBufDrawable)) then begin
          if not CacheEngine.TrySetEntry(CacheIndex{AIndex}, LSubIndexOffset+LStateStyle.CacheSubIndex{ASubIndex}, LStateStyle.FBufDrawable{ADrawable}, LStateStyle.FBufDrawableRect{ARect}) then ALFreeAndNilDrawable(LStateStyle.FBufDrawable)
          else LStateStyle.FBufDrawable := ALNullDrawable;
          if not CacheEngine.TryGetEntry(CacheIndex{AIndex}, LSubIndexOffset+LStateStyle.CacheSubIndex{ASubIndex}, LDrawable{ADrawable}, LDrawableRect{ARect}) then
            raise Exception.Create('Error BB5ACD27-7CF2-44D3-AEB1-22C8BB492762');
        end
        else begin
          LDrawable := LStateStyle.FBufDrawable;
          LDrawableRect := LStateStyle.FBufDrawableRect;
        end;
      end;
    end;
    //--
    If ALIsDrawableNull(LDrawable) then begin
      if (CacheIndex <= 0) or
         (CacheEngine = nil) or
         (not CacheEngine.TryGetEntry(CacheIndex{AIndex}, LSubIndexOffset+LDefaultStateStyle.CacheSubIndex{ASubIndex}, LDrawable{ADrawable}, LDrawableRect{ARect})) then begin
        if LStateStyle = nil then MakeBufDrawable;
        if (CacheIndex > 0) and (CacheEngine <> nil) and (not ALIsDrawableNull(LDefaultStateStyle.fBufDrawable)) then begin
          if not CacheEngine.TrySetEntry(CacheIndex{AIndex}, LSubIndexOffset+LDefaultStateStyle.CacheSubIndex{ASubIndex}, LDefaultStateStyle.fBufDrawable{ADrawable}, LDefaultStateStyle.fBufDrawableRect{ARect}) then ALFreeAndNilDrawable(LDefaultStateStyle.fBufDrawable)
          else LDefaultStateStyle.fBufDrawable := ALNullDrawable;
          if not CacheEngine.TryGetEntry(CacheIndex{AIndex}, LSubIndexOffset+LDefaultStateStyle.CacheSubIndex{ASubIndex}, LDrawable{ADrawable}, LDrawableRect{ARect}) then
            raise Exception.Create('Error BB5ACD27-7CF2-44D3-AEB1-22C8BB492762');
        end
        else begin
          LDrawable := LDefaultStateStyle.FBufDrawable;
          LDrawableRect := LDefaultStateStyle.FBufDrawableRect;
        end;
      end;
    end;
    //--
  end;

  if ALIsDrawableNull(LDrawable) then begin

    var LCurrentAdjustedStateStyle := TBaseStateStyle(StateStyles.GetCurrentAdjustedStyle);
    if LCurrentAdjustedStateStyle = nil then begin
      inherited Paint;
      exit;
    end;

    {$IF DEFINED(ALSkiaCanvas)}

    var LCanvasSaveState: TCanvasSaveState := ALScaleAndCenterCanvas(
                                                Canvas, // Const ACanvas: TCanvas;
                                                AbsoluteRect.ReducePrecision, // Const AAbsoluteRect: TRectF;
                                                LCurrentAdjustedStateStyle.Scale, // Const AScale: Single;
                                                true); // Const ASaveState: Boolean);
    try

      var LRect := LocalRect.ReducePrecision;

      if compareValue(AbsoluteOpacity, 1, Tepsilon.Scale) < 0 then begin
        var LLayerRect := ALGetShapeSurfaceRect(
                            LRect, // const ARect: TrectF;
                            AutoAlignToPixel, // const AAlignToPixel: Boolean;
                            LCurrentAdjustedStateStyle.Fill.Color, // const AFillColor: TAlphaColor;
                            LCurrentAdjustedStateStyle.Fill.Gradient.Colors, // const AFillGradientColors: TArray<TAlphaColor>;
                            LCurrentAdjustedStateStyle.Fill.ResourceName, // const AFillResourceName: String;
                            nil, // const AFillResourceStream: TStream;
                            LCurrentAdjustedStateStyle.Fill.BackgroundMargins.Rect, // Const AFillBackgroundMarginsRect: TRectF;
                            LCurrentAdjustedStateStyle.Fill.ImageMargins.Rect, // Const AFillImageMarginsRect: TRectF;
                            LCurrentAdjustedStateStyle.StateLayer.Opacity, // const AStateLayerOpacity: Single;
                            LCurrentAdjustedStateStyle.StateLayer.Color, // const AStateLayerColor: TAlphaColor;
                            LCurrentAdjustedStateStyle.StateLayer.UseContentColor, // const AStateLayerUseContentColor: Boolean;
                            LCurrentAdjustedStateStyle.StateLayer.Margins.Rect, // Const AStateLayerMarginsRect: TRectF;
                            LCurrentAdjustedStateStyle.Shadow.Color, // const AShadowColor: TAlphaColor;
                            LCurrentAdjustedStateStyle.Shadow.Blur, // const AShadowBlur: Single;
                            LCurrentAdjustedStateStyle.Shadow.OffsetX, // const AShadowOffsetX: Single;
                            LCurrentAdjustedStateStyle.Shadow.OffsetY); // const AShadowOffsetY: Single);
        ALBeginTransparencyLayer(
          TSkCanvasCustom(Canvas).Canvas.Handle, // const aCanvas: TALCanvas;
          LLayerRect, // const ARect: TRectF;
          AbsoluteOpacity); // const AOpacity: Single);
      end;
      try

        TALDrawRectangleHelper.Create(TSkCanvasCustom(Canvas).Canvas.Handle)
          .SetAlignToPixel(AutoAlignToPixel)
          .SetDstRect(LRect)
          .SetFill(LCurrentAdjustedStateStyle.Fill)
          .SetStateLayer(LCurrentAdjustedStateStyle.StateLayer, LCurrentAdjustedStateStyle.CheckMark.Color)
          .SetDrawStateLayerOnTop(False)
          .SetStroke(LCurrentAdjustedStateStyle.Stroke)
          .SetShadow(LCurrentAdjustedStateStyle.Shadow)
          .SetSides(AllSides)
          .SetCorners(AllCorners)
          .SetXRadius(XRadius)
          .SetYRadius(YRadius)
          .Draw;

        if (StateStyles.Transition.Running) and
           (StateStyles.Transition.FadeImage) and
           (StateStyles.Transition.FromStateStyle <> nil) and
           (TBaseStateStyle(StateStyles.Transition.FromStateStyle).CheckMark.ResourceName <> '') and
           (StateStyles.Transition.ToStateStyle <> nil) and
           (TBaseStateStyle(StateStyles.Transition.ToStateStyle).CheckMark.ResourceName <> '') and
           (TBaseStateStyle(StateStyles.Transition.FromStateStyle).CheckMark.ResourceName <> TBaseStateStyle(StateStyles.Transition.ToStateStyle).CheckMark.ResourceName) then begin

          LCurrentAdjustedStateStyle.BeginUpdate;
          try

            LCurrentAdjustedStateStyle.CheckMark.ResourceName := TBaseStateStyle(StateStyles.Transition.FromStateStyle).CheckMark.ResourceName;

            DrawCheckMark(
              TSkCanvasCustom(Canvas).Canvas.Handle, // const ACanvas: TALCanvas;
              1, // const AScale: Single;
              LRect, // const ADstRect: TrectF;
              1-StateStyles.Transition.CurrentValue, // const AOpacity: Single;
              // Check CheckMark.Color = TalphaColors.Null to enable an interpolation fade-out effect on the checkMark.
              // Without this, the checkMark disappears immediately.
              Checked or (TBaseStateStyle(StateStyles.GetCurrentRawStyle).CheckMark.Color = TalphaColors.Null), // const AChecked: Boolean
              LCurrentAdjustedStateStyle.CheckMark); // const ACheckMark: TCheckMarkBrush;

            LCurrentAdjustedStateStyle.CheckMark.ResourceName := TBaseStateStyle(StateStyles.Transition.ToStateStyle).CheckMark.ResourceName;

            DrawCheckMark(
              TSkCanvasCustom(Canvas).Canvas.Handle, // const ACanvas: TALCanvas;
              1, // const AScale: Single;
              LRect, // const ADstRect: TrectF;
              StateStyles.Transition.CurrentValue, // const AOpacity: Single;
              // Check CheckMark.Color = TalphaColors.Null to enable an interpolation fade-out effect on the checkMark.
              // Without this, the checkMark disappears immediately.
              Checked or (TBaseStateStyle(StateStyles.GetCurrentRawStyle).CheckMark.Color = TalphaColors.Null), // const AChecked: Boolean
              LCurrentAdjustedStateStyle.CheckMark); // const ACheckMark: TCheckMarkBrush;

          finally
            LCurrentAdjustedStateStyle.EndUpdateNoChanges;
          end;

        end
        else begin

          DrawCheckMark(
            TSkCanvasCustom(Canvas).Canvas.Handle, // const ACanvas: TALCanvas;
            1, // const AScale: Single;
            LRect, // const ADstRect: TrectF;
            1, // const AOpacity: Single;
            // Check CheckMark.Color = TalphaColors.Null to enable an interpolation fade-out effect on the checkMark.
            // Without this, the checkMark disappears immediately.
            Checked or (TBaseStateStyle(StateStyles.GetCurrentRawStyle).CheckMark.Color = TalphaColors.Null), // const AChecked: Boolean
            LCurrentAdjustedStateStyle.CheckMark); // const ACheckMark: TCheckMarkBrush;

        end;

      finally
        if compareValue(AbsoluteOpacity, 1, Tepsilon.Scale) < 0 then
          ALEndTransparencyLayer(TSkCanvasCustom(Canvas).Canvas.Handle);
      end;

    finally
      if LCanvasSaveState <> nil then
        Canvas.RestoreState(LCanvasSaveState);
    end;

    {$ELSE}

    var LRect := LocalRect.ReducePrecision;
    InitRenderTargets(LRect);
    if ALCanvasBeginScene(RenderTargetCanvas) then
    try

      ALClearCanvas(RenderTargetCanvas, TAlphaColors.Null);

      TALDrawRectangleHelper.Create(RenderTargetCanvas)
        .SetScale(ALGetScreenScale)
        .SetAlignToPixel(AutoAlignToPixel)
        .SetDstRect(LRect)
        .SetFill(LCurrentAdjustedStateStyle.Fill)
        .SetStateLayer(LCurrentAdjustedStateStyle.StateLayer, LCurrentAdjustedStateStyle.CheckMark.Color)
        .SetDrawStateLayerOnTop(False)
        .SetStroke(LCurrentAdjustedStateStyle.Stroke)
        .SetShadow(LCurrentAdjustedStateStyle.Shadow)
        .SetSides(AllSides)
        .SetCorners(AllCorners)
        .SetXRadius(XRadius)
        .SetYRadius(YRadius)
        .Draw;

      if (StateStyles.Transition.Running) and
         (StateStyles.Transition.FadeImage) and
         (StateStyles.Transition.FromStateStyle <> nil) and
         (TBaseStateStyle(StateStyles.Transition.FromStateStyle).CheckMark.ResourceName <> '') and
         (StateStyles.Transition.ToStateStyle <> nil) and
         (TBaseStateStyle(StateStyles.Transition.ToStateStyle).CheckMark.ResourceName <> '') and
         (TBaseStateStyle(StateStyles.Transition.FromStateStyle).CheckMark.ResourceName <> TBaseStateStyle(StateStyles.Transition.ToStateStyle).CheckMark.ResourceName) then begin

        LCurrentAdjustedStateStyle.BeginUpdate;
        try

          LCurrentAdjustedStateStyle.CheckMark.ResourceName := TBaseStateStyle(StateStyles.Transition.FromStateStyle).CheckMark.ResourceName;

          DrawCheckMark(
            RenderTargetCanvas, // const ACanvas: TALCanvas;
            ALGetScreenScale, // const AScale: Single;
            LRect, // const ADstRect: TrectF;
            1-StateStyles.Transition.CurrentValue, // const AOpacity: Single;
            // Check CheckMark.Color = TalphaColors.Null to enable an interpolation fade-out effect on the checkMark.
            // Without this, the checkMark disappears immediately.
            Checked or (TBaseStateStyle(StateStyles.GetCurrentRawStyle).CheckMark.Color = TalphaColors.Null), // const AChecked: Boolean
            LCurrentAdjustedStateStyle.CheckMark); // const ACheckMark: TCheckMarkBrush;

          LCurrentAdjustedStateStyle.CheckMark.ResourceName := TBaseStateStyle(StateStyles.Transition.ToStateStyle).CheckMark.ResourceName;

          DrawCheckMark(
            RenderTargetCanvas, // const ACanvas: TALCanvas;
            ALGetScreenScale, // const AScale: Single;
            LRect, // const ADstRect: TrectF;
            StateStyles.Transition.CurrentValue, // const AOpacity: Single;
            // Check CheckMark.Color = TalphaColors.Null to enable an interpolation fade-out effect on the checkMark.
            // Without this, the checkMark disappears immediately.
            Checked or (TBaseStateStyle(StateStyles.GetCurrentRawStyle).CheckMark.Color = TalphaColors.Null), // const AChecked: Boolean
            LCurrentAdjustedStateStyle.CheckMark); // const ACheckMark: TCheckMarkBrush;

        finally
          LCurrentAdjustedStateStyle.EndUpdateNoChanges;
        end;

      end
      else begin

        DrawCheckMark(
          RenderTargetCanvas, // const ACanvas: TALCanvas;
          ALGetScreenScale, // const AScale: Single;
          LRect, // const ADstRect: TrectF;
          1, // const AOpacity: Single;
          // Check CheckMark.Color = TalphaColors.Null to enable an interpolation fade-out effect on the checkMark.
          // Without this, the checkMark disappears immediately.
          Checked or (TBaseStateStyle(StateStyles.GetCurrentRawStyle).CheckMark.Color = TalphaColors.Null), // const AChecked: Boolean
          LCurrentAdjustedStateStyle.CheckMark); // const ACheckMark: TCheckMarkBrush;

      end;

    finally
      ALCanvasEndScene(RenderTargetCanvas)
    end;

    ALUpdateDrawableFromSurface(RenderTargetSurface, RenderTargetDrawable);

    // The Shadow or Statelayer are not included in the dimensions of the LRect rectangle.
    // However, the LRect rectangle is offset by the dimensions of the shadow/Statelayer.
    LRect.Offset(-2*LRect.Left, -2*LRect.Top);

    // LRect must include the LScale
    LRect.Top := LRect.Top * LCurrentAdjustedStateStyle.Scale;
    LRect.right := LRect.right * LCurrentAdjustedStateStyle.Scale;
    LRect.left := LRect.left * LCurrentAdjustedStateStyle.Scale;
    LRect.bottom := LRect.bottom * LCurrentAdjustedStateStyle.Scale;

    // Since LStateStyle.FBufDrawableRect can have different dimensions than the main BufDrawableRect (LocalRect.ReducePrecision)
    // (due to scale), we must center LStateStyle.FBufDrawableRect within the main BufDrawableRect (LocalRect.ReducePrecision)
    // to ensure that all changes are visually centered.
    var LCenteredRect := LRect.CenterAt(LocalRect.ReducePrecision);
    LRect.Offset(LCenteredRect.Left, LCenteredRect.top);

    // We cannot use the matrix because, if we do, ALAlignToPixelRound in ALDrawDrawable
    // will be ineffective since the matrix will no longer be a simple translation matrix.
    // In such a case, TCustomCanvasGpu(ACanvas).DrawTexture may produce border artifacts
    // if the texture is not perfectly pixel-aligned.
    var LDstRect := TRectF.Create(0, 0, ALGetDrawableWidth(RenderTargetDrawable), ALGetDrawableHeight(RenderTargetDrawable));
    LDstRect.Width := (LDstRect.Width / ALGetScreenScale) * LCurrentAdjustedStateStyle.Scale;
    LDstRect.height := (LDstRect.height / ALGetScreenScale) * LCurrentAdjustedStateStyle.Scale;
    LDstRect.SetLocation(
      LRect.Left,
      LRect.Top);
    ALDrawDrawable(
      Canvas, // const ACanvas: Tcanvas;
      RenderTargetDrawable, // const ADrawable: TALDrawable;
      LDstRect, // const ADstRect: TrectF; // IN Virtual pixels !
      AbsoluteOpacity); // const AOpacity: Single)

    {$ENDIF}

    exit;
  end;

  ALDrawDrawable(
    Canvas, // const ACanvas: Tcanvas;
    LDrawable, // const ADrawable: TALDrawable;
    LDrawableRect.TopLeft, // const ATopLeft: TpointF;
    AbsoluteOpacity); // const AOpacity: Single);

end;

{*******************************************************}
function TALDynamicCheckBox.GetStateStyles: TStateStyles;
begin
  Result := TStateStyles(inherited StateStyles);
end;

{**********************************************************************}
procedure TALDynamicCheckBox.SetStateStyles(const AValue: TStateStyles);
begin
  inherited StateStyles := AValue;
end;

{*********************************************************************************}
function TALDynamicCheckBox.CreateStateStyles: TALDynamicBaseCheckBox.TStateStyles;
begin
  Result := TStateStyles.Create(Self);
end;

{******************************************************************************}
function TALDynamicRadioButton.TCheckMarkBrush.TMargins.GetDefaultValue: TRectF;
begin
  Result := TRectF.Create(5,5,5,5);
end;

{**********************************************************************}
function TALDynamicRadioButton.TCheckMarkBrush.CreateMargins: TALBounds;
begin
  Result := TMargins.Create;
end;

{*************************************************************************************}
function TALDynamicRadioButton.TInheritCheckMarkBrush.TMargins.GetDefaultValue: TRectF;
begin
  Result := TRectF.Create(5,5,5,5);
end;

{*****************************************************************************}
function TALDynamicRadioButton.TInheritCheckMarkBrush.CreateMargins: TALBounds;
begin
  Result := TMargins.Create;
end;

{**********************************************************************************************************************************************************************}
function TALDynamicRadioButton.TDefaultStateStyle.CreateCheckMark(const AParent: TALDynamicBaseCheckBox.TCheckMarkBrush): TALDynamicBaseCheckBox.TInheritCheckMarkBrush;
begin
  Result := TInheritCheckMarkBrush.Create(AParent);
end;

{***********************************************************************************************************************************************************************}
function TALDynamicRadioButton.TDisabledStateStyle.CreateCheckMark(const AParent: TALDynamicBaseCheckBox.TCheckMarkBrush): TALDynamicBaseCheckBox.TInheritCheckMarkBrush;
begin
  Result := TInheritCheckMarkBrush.Create(AParent);
end;

{**********************************************************************************************************************************************************************}
function TALDynamicRadioButton.THoveredStateStyle.CreateCheckMark(const AParent: TALDynamicBaseCheckBox.TCheckMarkBrush): TALDynamicBaseCheckBox.TInheritCheckMarkBrush;
begin
  Result := TInheritCheckMarkBrush.Create(AParent);
end;

{**********************************************************************************************************************************************************************}
function TALDynamicRadioButton.TPressedStateStyle.CreateCheckMark(const AParent: TALDynamicBaseCheckBox.TCheckMarkBrush): TALDynamicBaseCheckBox.TInheritCheckMarkBrush;
begin
  Result := TInheritCheckMarkBrush.Create(AParent);
end;

{**********************************************************************************************************************************************************************}
function TALDynamicRadioButton.TFocusedStateStyle.CreateCheckMark(const AParent: TALDynamicBaseCheckBox.TCheckMarkBrush): TALDynamicBaseCheckBox.TInheritCheckMarkBrush;
begin
  Result := TInheritCheckMarkBrush.Create(AParent);
end;

{******************************************************************************************************************************************}
function TALDynamicRadioButton.TCheckStateStyles.CreateDefaultStateStyle(const AParent: TObject): TALDynamicBaseCheckBox.TDefaultStateStyle;
begin
  Result := TDefaultStateStyle.Create(AParent);
end;

{********************************************************************************************************************************************}
function TALDynamicRadioButton.TCheckStateStyles.CreateDisabledStateStyle(const AParent: TObject): TALDynamicBaseCheckBox.TDisabledStateStyle;
begin
  Result := TDisabledStateStyle.Create(AParent);
end;

{******************************************************************************************************************************************}
function TALDynamicRadioButton.TCheckStateStyles.CreateHoveredStateStyle(const AParent: TObject): TALDynamicBaseCheckBox.THoveredStateStyle;
begin
  Result := THoveredStateStyle.Create(AParent);
end;

{******************************************************************************************************************************************}
function TALDynamicRadioButton.TCheckStateStyles.CreatePressedStateStyle(const AParent: TObject): TALDynamicBaseCheckBox.TPressedStateStyle;
begin
  Result := TPressedStateStyle.Create(AParent);
end;

{******************************************************************************************************************************************}
function TALDynamicRadioButton.TCheckStateStyles.CreateFocusedStateStyle(const AParent: TObject): TALDynamicBaseCheckBox.TFocusedStateStyle;
begin
  Result := TFocusedStateStyle.Create(AParent);
end;

{***********************************************************************************************************************************************}
function TALDynamicRadioButton.TStateStyles.CreateCheckedStateStyles(const AParent: TALDynamicControl): TALDynamicBaseCheckBox.TCheckStateStyles;
begin
  Result := TCheckStateStyles.Create(AParent);
end;

{*************************************************************************************************************************************************}
function TALDynamicRadioButton.TStateStyles.CreateUncheckedStateStyles(const AParent: TALDynamicControl): TALDynamicBaseCheckBox.TCheckStateStyles;
begin
  Result := TCheckStateStyles.Create(AParent);
end;

{**************************************************************}
constructor TALDynamicRadioButton.Create(const AOwner: TObject);
begin
  inherited;
  FGroupName := '';
  fMandatory := false;
  TMessageManager.DefaultManager.SubscribeToMessage(TRadioButtonGroupMessage, GroupMessageCall);
end;

{************************************************}
procedure TALDynamicRadioButton.BeforeDestruction;
begin
  if BeforeDestructionExecuted then exit;
  // Unsubscribe from TRadioButtonGroupMessage to stop receiving messages.
  // This must be done in BeforeDestruction rather than in Destroy,
  // because the control might be freed in the background via ALFreeAndNil(..., delayed),
  // and BeforeDestruction is guaranteed to execute on the main thread.
  TMessageManager.DefaultManager.Unsubscribe(TRadioButtonGroupMessage, GroupMessageCall);
  inherited;
end;

{****************************************************************}
procedure TALDynamicRadioButton.Assign(Source: TALDynamicControl);
begin
  BeginUpdate;
  Try
    if Source is TALDynamicRadioButton then begin
      GroupName := TALDynamicRadioButton(Source).GroupName;
      Mandatory := TALDynamicRadioButton(Source).Mandatory;
    end
    else
      ALAssignError(Source{ASource}, Self{ADest});
    inherited Assign(Source);
  Finally
    EndUpdate;
  End;
end;

{*************************************************************************************}
function TALDynamicRadioButton.CreateCheckMark: TALDynamicBaseCheckBox.TCheckMarkBrush;
begin
  Result := TCheckMarkBrush.Create;
end;

{************************************************************************************}
function TALDynamicRadioButton.CreateStateStyles: TALDynamicBaseCheckBox.TStateStyles;
begin
  Result := TStateStyles.Create(self);
end;

{***************************************************************}
procedure TALDynamicRadioButton.SetChecked(const Value: Boolean);
begin
  if FChecked <> Value then begin
    //**if (csDesigning in ComponentState) and FChecked then inherited SetChecked(Value) // allows check/uncheck in design-mode
    //**else begin
      if (not value) and fMandatory then exit;
      var LOldMandatory := fMandatory;
      fMandatory := False;
      try
        inherited SetChecked(Value);
      finally
        fMandatory := LOldMandatory;
      end;
      if FChecked then begin
        var M := TRadioButtonGroupMessage.Create(GroupName);
        TMessageManager.DefaultManager.SendMessage(Self, M, True);
      end;
    //**end;
  end;
end;

{*******************************************************}
function TALDynamicRadioButton.GetDefaultXRadius: Single;
begin
  Result := -50;
end;

{*******************************************************}
function TALDynamicRadioButton.GetDefaultYRadius: Single;
begin
  Result := -50;
end;

{****************************************************}
function TALDynamicRadioButton.GetDefaultSize: TSizeF;
begin
  Result := TSizeF.Create(20, 20);
end;

{**************************************************}
function TALDynamicRadioButton.GetGroupName: string;
begin
  Result := FGroupName;
end;

{*****************************************************************************************}
procedure TALDynamicRadioButton.GroupMessageCall(const Sender: TObject; const M: TMessage);
begin
  if SameText(TRadioButtonGroupMessage(M).GroupName, GroupName) and (Sender <> Self) and (Host <> nil) and
     (not (Sender is TALDynamicControl) or ((Sender as TALDynamicControl).Host = Host)) then begin
    var LOldMandatory := fMandatory;
    fMandatory := False;
    try
      Checked := False;
    finally
      fMandatory := LOldMandatory;
    end;
  end;
end;

{******************************************************}
function TALDynamicRadioButton.GroupNameStored: Boolean;
begin
  Result := FGroupName <> '';
end;

{****************************************************************}
procedure TALDynamicRadioButton.SetGroupName(const Value: string);
begin
  if FGroupName <> Value then
    FGroupName := Value;
end;

{********************************************}
procedure TALDynamicRadioButton.DrawCheckMark(
            const ACanvas: TALCanvas;
            const AScale: Single;
            const ADstRect: TrectF;
            const AOpacity: Single;
            const AChecked: Boolean;
            const ACheckMark: TALDynamicBaseCheckBox.TCheckMarkBrush);
begin

  var LCanvasMatrix: TMatrix;
  var LCanvasScale: Single;
  if AutoAlignToPixel then ALExtractMatrixFromCanvas(Acanvas, LCanvasMatrix, LCanvasScale)
  else begin
    LCanvasMatrix := TMatrix.Identity;
    LCanvasScale := 1;
  end;
  var LRect := ADstRect;
  LRect.Top := LRect.Top * AScale;
  LRect.right := LRect.right * AScale;
  LRect.left := LRect.left * AScale;
  LRect.bottom := LRect.bottom * AScale;
  if AutoAlignToPixel then
    LRect := ALAlignToPixelRound(LRect, LCanvasMatrix, LCanvasScale, TEpsilon.Position);
  var LScaledMarginsRect := ACheckMark.Margins.Rect;
  LScaledMarginsRect.Left := LScaledMarginsRect.Left * AScale;
  LScaledMarginsRect.right := LScaledMarginsRect.right * AScale;
  LScaledMarginsRect.top := LScaledMarginsRect.top * AScale;
  LScaledMarginsRect.bottom := LScaledMarginsRect.bottom * AScale;
  if AutoAlignToPixel then
    LScaledMarginsRect := ALAlignEdgesToPixelRound(LScaledMarginsRect, LCanvasScale, TEpsilon.Position);
  LRect.Top := LRect.Top + LScaledMarginsRect.top;
  LRect.right := LRect.right - LScaledMarginsRect.right;
  LRect.left := LRect.left + LScaledMarginsRect.left;
  LRect.bottom := LRect.bottom - LScaledMarginsRect.bottom;
  if LRect.IsEmpty then exit;

  // Without ResourceName
  if ACheckMark.ResourceName = '' then begin

    // exit if not checked
    if not AChecked then
      exit;

    TALDrawRectangleHelper.Create(ACanvas)
      .SetAlignToPixel(AutoAlignToPixel)
      .SetDstRect(TRectF.Create(0, 0, 1, 1).FitInto(LRect))
      .SetFillColor(ACheckMark.Color)
      .SetFillResourceName(ACheckMark.ResourceName)
      .SetFillWrapMode(ACheckMark.WrapMode)
      .SetXRadius(-50)
      .SetYRadius(-50)
      .Draw;

  end

  // With ResourceName
  else begin

    TALDrawRectangleHelper.Create(ACanvas)
      .SetAlignToPixel(AutoAlignToPixel)
      .SetDstRect(LRect)
      .SetOpacity(AOpacity)
      .SetFillColor(ACheckMark.Color)
      .SetFillResourceName(ACheckMark.ResourceName)
      .SetFillWrapMode(ACheckMark.WrapMode)
      .Draw;

  end;

end;

{******************************************************************}
function TALDynamicSwitch.TTrack.TFill.GetDefaultColor: TAlphaColor;
begin
  Result := $ffc5c5c5;
end;

{********************************************************************}
function TALDynamicSwitch.TTrack.TStroke.GetDefaultColor: TAlphaColor;
begin
  Result := TAlphaColors.null;
end;

{**********************************************************************************}
function TALDynamicSwitch.TTrack.TBaseStateStyle.TFill.GetDefaultColor: TAlphaColor;
begin
  Result := $ffc5c5c5;
end;

{************************************************************************************}
function TALDynamicSwitch.TTrack.TBaseStateStyle.TStroke.GetDefaultColor: TAlphaColor;
begin
  Result := TAlphaColors.null;
end;

{*************************************************************************************}
function TALDynamicSwitch.TTrack.TBaseStateStyle.TStateLayer.GetDefaultXRadius: Single;
begin
  Result := -50;
end;

{*************************************************************************************}
function TALDynamicSwitch.TTrack.TBaseStateStyle.TStateLayer.GetDefaultYRadius: Single;
begin
  Result := -50;
end;

{****************************************************************************************************}
function TALDynamicSwitch.TTrack.TBaseStateStyle.CreateFill(const AParent: TALBrush): TALInheritBrush;
begin
  Result := TFill.Create(AParent);
end;

{******************************************************************************************************************}
function TALDynamicSwitch.TTrack.TBaseStateStyle.CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush;
begin
  Result := TStroke.Create(AParent);
end;

{*******************************************************************************}
function TALDynamicSwitch.TTrack.TBaseStateStyle.CreateStateLayer: TALStateLayer;
begin
  Result := TStateLayer.Create;
end;

{****************************************************************************}
function TALDynamicSwitch.TTrack.TDisabledStateStyle.IsOpacityStored: Boolean;
begin
  Result := not SameValue(FOpacity, TControl.DefaultDisabledOpacity, TEpsilon.Scale);
end;

{************************************************************************************}
procedure TALDynamicSwitch.TTrack.TDisabledStateStyle.SetOpacity(const Value: Single);
begin
  if not SameValue(FOpacity, Value, TEpsilon.Scale) then begin
    FOpacity := Value;
    Change;
  end;
end;

{****************************************************************************}
function TALDynamicSwitch.TTrack.TDefaultStateStyle.GetCacheSubIndex: Integer;
begin
  Result := 1;
end;

{*************************************************************************************}
constructor TALDynamicSwitch.TTrack.TDisabledStateStyle.Create(const AParent: TObject);
begin
  inherited Create(AParent);
  FOpacity := TControl.DefaultDisabledOpacity;
end;

{********************************************************************************}
procedure TALDynamicSwitch.TTrack.TDisabledStateStyle.Assign(Source: TPersistent);
begin
  BeginUpdate;
  Try
    if Source is TDisabledStateStyle then
      Opacity := TDisabledStateStyle(Source).Opacity
    else
      Opacity := TControl.DefaultDisabledOpacity;
    inherited Assign(Source);
  Finally
    EndUpdate;
  End;
end;

{**********************************************************}
procedure TALDynamicSwitch.TTrack.TDisabledStateStyle.Reset;
begin
  BeginUpdate;
  Try
    inherited;
    Opacity := TControl.DefaultDisabledOpacity;
  finally
    EndUpdate;
  end;
end;

{***********************************************************************}
function TALDynamicSwitch.TTrack.TDisabledStateStyle.GetInherit: Boolean;
begin
  // Opacity is not part of the GetInherit function because it updates the
  // disabledOpacity of the base control immediately every time it changes.
  // Essentially, it acts merely as a link to the disabledOpacity of the base control.
  Result := inherited GetInherit;
end;

{*****************************************************************************}
function TALDynamicSwitch.TTrack.TDisabledStateStyle.GetCacheSubIndex: Integer;
begin
  Result := 2;
end;

{****************************************************************************}
function TALDynamicSwitch.TTrack.THoveredStateStyle.GetCacheSubIndex: Integer;
begin
  Result := 3;
end;

{****************************************************************************}
function TALDynamicSwitch.TTrack.TPressedStateStyle.GetCacheSubIndex: Integer;
begin
  Result := 4;
end;

{****************************************************************************}
function TALDynamicSwitch.TTrack.TFocusedStateStyle.GetCacheSubIndex: Integer;
begin
  Result := 5;
end;

{*********************************************************************************************}
constructor TALDynamicSwitch.TTrack.TCheckStateStyles.Create(const AParent: TALDynamicControl);
begin
  inherited Create;
  //--
  FDefault := CreateDefaultStateStyle(AParent);
  FDefault.OnChanged := DefaultChanged;
  //--
  FDisabled := CreateDisabledStateStyle(FDefault);
  FDisabled.OnChanged := DisabledChanged;
  //--
  FHovered := CreateHoveredStateStyle(FDefault);
  FHovered.OnChanged := HoveredChanged;
  //--
  FPressed := CreatePressedStateStyle(FDefault);
  FPressed.OnChanged := PressedChanged;
  //--
  FFocused := CreateFocusedStateStyle(FDefault);
  FFocused.OnChanged := FocusedChanged;
end;

{***********************************************************}
destructor TALDynamicSwitch.TTrack.TCheckStateStyles.Destroy;
begin
  ALFreeAndNil(FDefault);
  ALFreeAndNil(FDisabled);
  ALFreeAndNil(FHovered);
  ALFreeAndNil(FPressed);
  ALFreeAndNil(FFocused);
  inherited Destroy;
end;

{*****************************************************************************************}
function TALDynamicSwitch.TTrack.TCheckStateStyles.CreateSavedState: TALPersistentObserver;
type
  TCheckStateStylesClass = class of TCheckStateStyles;
begin
  result := TCheckStateStylesClass(classtype).Create(nil{AParent});
end;

{*********************************************************************************************************************}
function TALDynamicSwitch.TTrack.TCheckStateStyles.CreateDefaultStateStyle(const AParent: TObject): TDefaultStateStyle;
begin
  Result := TDefaultStateStyle.Create(AParent);
end;

{***********************************************************************************************************************}
function TALDynamicSwitch.TTrack.TCheckStateStyles.CreateDisabledStateStyle(const AParent: TObject): TDisabledStateStyle;
begin
  Result := TDisabledStateStyle.Create(AParent);
end;

{*********************************************************************************************************************}
function TALDynamicSwitch.TTrack.TCheckStateStyles.CreateHoveredStateStyle(const AParent: TObject): THoveredStateStyle;
begin
  Result := THoveredStateStyle.Create(AParent);
end;

{*********************************************************************************************************************}
function TALDynamicSwitch.TTrack.TCheckStateStyles.CreatePressedStateStyle(const AParent: TObject): TPressedStateStyle;
begin
  Result := TPressedStateStyle.Create(AParent);
end;

{*********************************************************************************************************************}
function TALDynamicSwitch.TTrack.TCheckStateStyles.CreateFocusedStateStyle(const AParent: TObject): TFocusedStateStyle;
begin
  Result := TFocusedStateStyle.Create(AParent);
end;

{******************************************************************************}
procedure TALDynamicSwitch.TTrack.TCheckStateStyles.Assign(Source: TPersistent);
begin
  if Source is TCheckStateStyles then begin
    BeginUpdate;
    Try
      Default.Assign(TCheckStateStyles(Source).Default);
      Disabled.Assign(TCheckStateStyles(Source).Disabled);
      Hovered.Assign(TCheckStateStyles(Source).Hovered);
      Pressed.Assign(TCheckStateStyles(Source).Pressed);
      Focused.Assign(TCheckStateStyles(Source).Focused);
    Finally
      EndUpdate;
    End;
  end
  else
    ALAssignError(Source{ASource}, Self{ADest});
end;

{********************************************************}
procedure TALDynamicSwitch.TTrack.TCheckStateStyles.Reset;
begin
  BeginUpdate;
  Try
    inherited;
    Default.Reset;
    Disabled.Reset;
    Hovered.Reset;
    Pressed.Reset;
    Focused.Reset;
  finally
    EndUpdate;
  end;
end;

{***************************************************************}
procedure TALDynamicSwitch.TTrack.TCheckStateStyles.AlignToPixel;
begin
  BeginUpdate;
  Try
    Default.AlignToPixel;
    Disabled.AlignToPixel;
    Hovered.AlignToPixel;
    Pressed.AlignToPixel;
    Focused.AlignToPixel;
  finally
    EndUpdate;
  end;
end;

{*******************************************************************}
procedure TALDynamicSwitch.TTrack.TCheckStateStyles.ApplyColorScheme;
begin
  BeginUpdate;
  Try
    Default.ApplyColorScheme;
    Disabled.ApplyColorScheme;
    Hovered.ApplyColorScheme;
    Pressed.ApplyColorScheme;
    Focused.ApplyColorScheme;
  finally
    EndUpdate;
  end;
end;

{*******************************************************************}
procedure TALDynamicSwitch.TTrack.TCheckStateStyles.ClearBufDrawable;
begin
  Default.ClearBufDrawable;
  Disabled.ClearBufDrawable;
  Hovered.ClearBufDrawable;
  Pressed.ClearBufDrawable;
  Focused.ClearBufDrawable;
end;

{***********************************************************************************************}
procedure TALDynamicSwitch.TTrack.TCheckStateStyles.SetDefault(const AValue: TDefaultStateStyle);
begin
  FDefault.Assign(AValue);
end;

{*************************************************************************************************}
procedure TALDynamicSwitch.TTrack.TCheckStateStyles.SetDisabled(const AValue: TDisabledStateStyle);
begin
  FDisabled.Assign(AValue);
end;

{***********************************************************************************************}
procedure TALDynamicSwitch.TTrack.TCheckStateStyles.SetHovered(const AValue: THoveredStateStyle);
begin
  FHovered.Assign(AValue);
end;

{***********************************************************************************************}
procedure TALDynamicSwitch.TTrack.TCheckStateStyles.SetPressed(const AValue: TPressedStateStyle);
begin
  FPressed.Assign(AValue);
end;

{***********************************************************************************************}
procedure TALDynamicSwitch.TTrack.TCheckStateStyles.SetFocused(const AValue: TFocusedStateStyle);
begin
  FFocused.Assign(AValue);
end;

{***********************************************************************************}
procedure TALDynamicSwitch.TTrack.TCheckStateStyles.DefaultChanged(ASender: TObject);
begin
  Change;
end;

{************************************************************************************}
procedure TALDynamicSwitch.TTrack.TCheckStateStyles.DisabledChanged(ASender: TObject);
begin
  Change;
end;

{***********************************************************************************}
procedure TALDynamicSwitch.TTrack.TCheckStateStyles.HoveredChanged(ASender: TObject);
begin
  Change;
end;

{***********************************************************************************}
procedure TALDynamicSwitch.TTrack.TCheckStateStyles.PressedChanged(ASender: TObject);
begin
  Change;
end;

{***********************************************************************************}
procedure TALDynamicSwitch.TTrack.TCheckStateStyles.FocusedChanged(ASender: TObject);
begin
  Change;
end;

{****************************************************************************************}
constructor TALDynamicSwitch.TTrack.TStateStyles.Create(const AParent: TALDynamicControl);
begin
  inherited Create(AParent);
  //--
  FChecked := CreateCheckedStateStyles(AParent);
  FChecked.OnChanged := CheckedChanged;
  //--
  FUnchecked := CreateUnCheckedStateStyles(AParent);
  FUnchecked.OnChanged := UncheckedChanged;
end;

{******************************************************}
destructor TALDynamicSwitch.TTrack.TStateStyles.Destroy;
begin
  ALFreeAndNil(FChecked);
  ALFreeAndNil(FUnchecked);
  inherited Destroy;
end;

{**************************************************************************************************************************}
function TALDynamicSwitch.TTrack.TStateStyles.CreateCheckedStateStyles(const AParent: TALDynamicControl): TCheckStateStyles;
begin
  Result := TCheckStateStyles.Create(AParent);
end;

{****************************************************************************************************************************}
function TALDynamicSwitch.TTrack.TStateStyles.CreateUncheckedStateStyles(const AParent: TALDynamicControl): TCheckStateStyles;
begin
  Result := TCheckStateStyles.Create(AParent);
end;

{*************************************************************************}
procedure TALDynamicSwitch.TTrack.TStateStyles.Assign(Source: TPersistent);
begin
  if Source is TStateStyles then begin
    BeginUpdate;
    Try
      Checked.Assign(TStateStyles(Source).Checked);
      Unchecked.Assign(TStateStyles(Source).Unchecked);
      inherited Assign(Source);
    Finally
      EndUpdate;
    End;
  end
  else
    ALAssignError(Source{ASource}, Self{ADest});
end;

{***************************************************}
procedure TALDynamicSwitch.TTrack.TStateStyles.Reset;
begin
  BeginUpdate;
  Try
    inherited;
    Checked.reset;
    Unchecked.reset;
  finally
    EndUpdate;
  end;
end;

{**********************************************************}
procedure TALDynamicSwitch.TTrack.TStateStyles.AlignToPixel;
begin
  BeginUpdate;
  Try
    inherited;
    Checked.AlignToPixel;
    Unchecked.AlignToPixel;
  finally
    EndUpdate;
  end;
end;

{**************************************************************}
procedure TALDynamicSwitch.TTrack.TStateStyles.ApplyColorScheme;
begin
  BeginUpdate;
  Try
    inherited;
    Checked.ApplyColorScheme;
    Unchecked.ApplyColorScheme;
  finally
    EndUpdate;
  end;
end;

{**************************************************************}
procedure TALDynamicSwitch.TTrack.TStateStyles.ClearBufDrawable;
begin
  inherited;
  Checked.ClearBufDrawable;
  Unchecked.ClearBufDrawable;
end;

{*****************************************************************************************}
function TALDynamicSwitch.TTrack.TStateStyles.GetCurrentRawStyle: TALDynamicBaseStateStyle;
begin
  if Parent.Checked then begin
    if Not Parent.Enabled then Result := Checked.Disabled
    else if Parent.Pressed then Result := Checked.Pressed
    //**else if Parent.IsFocused then Result := Checked.Focused
    else if Parent.IsMouseOver then Result := Checked.Hovered
    else result := Checked.Default;
  end
  else begin
    if Not Parent.Enabled then Result := UnChecked.Disabled
    else if Parent.Pressed then Result := UnChecked.Pressed
    //**else if Parent.IsFocused then Result := UnChecked.Focused
    else if Parent.IsMouseOver then Result := UnChecked.Hovered
    else result := UnChecked.Default;
  end;
end;

{*******************************************************************************}
function TALDynamicSwitch.TTrack.TStateStyles.GetParent: TALDynamicSwitch.TTrack;
begin
  Result := TALDynamicSwitch.TTrack(inherited Parent);
end;

{*****************************************************************************************}
procedure TALDynamicSwitch.TTrack.TStateStyles.SetChecked(const AValue: TCheckStateStyles);
begin
  FChecked.Assign(AValue);
end;

{*******************************************************************************************}
procedure TALDynamicSwitch.TTrack.TStateStyles.SetUnchecked(const AValue: TCheckStateStyles);
begin
  FUnchecked.Assign(AValue);
end;

{******************************************************************************}
procedure TALDynamicSwitch.TTrack.TStateStyles.CheckedChanged(ASender: TObject);
begin
  Change;
end;

{********************************************************************************}
procedure TALDynamicSwitch.TTrack.TStateStyles.UncheckedChanged(ASender: TObject);
begin
  Change;
end;

{****************************************************************}
constructor TALDynamicSwitch.TTrack.Create(const AOwner: TObject);
begin
  inherited;
  //--
  //**SetAcceptsControls(False);
  //**CanFocus := False;
  //**Locked := True;
  HitTest := False;
  //--
  FChecked := False;
  FDoubleBuffered := true;
  FXRadius := DefaultXRadius;
  FYRadius := DefaultYRadius;
  FCacheIndex := 0;
  FCacheEngine := nil;
  {$IF NOT DEFINED(ALSkiaCanvas)}
  FRenderTargetSurface := ALNullSurface;
  FRenderTargetCanvas := ALNullCanvas;
  FRenderTargetDrawable := ALNullDrawable;
  {$ENDIF}
  //--
  // Must be created at the end because it requires FCheckMark to
  // be already created.
  FStateStyles := CreateStateStyles;
  FStateStyles.OnChanged := StateStylesChanged;
end;

{*****************************************}
destructor TALDynamicSwitch.TTrack.Destroy;
begin
  ALFreeAndNil(FStateStyles);
  {$IF NOT DEFINED(ALSkiaCanvas)}
  ClearRenderTargets;
  {$ENDIF}
  inherited;
end;

{****************************************************}
function TALDynamicSwitch.TTrack.CreateFill: TALBrush;
begin
  Result := TFill.Create;
end;

{************************************************************}
function TALDynamicSwitch.TTrack.CreateStroke: TALStrokeBrush;
begin
  Result := TStroke.Create;
end;

{***************************************************************}
function TALDynamicSwitch.TTrack.CreateStateStyles: TStateStyles;
begin
  Result := TStateStyles.Create(self);
end;

{*********************************************}
procedure TALDynamicSwitch.TTrack.AlignToPixel;
begin
  BeginUpdate;
  try
    inherited;
    StateStyles.AlignToPixel;
  finally
    EndUpdate;
  end;
end;

{*************************************************}
procedure TALDynamicSwitch.TTrack.ApplyColorScheme;
begin
  BeginUpdate;
  try
    inherited;
    StateStyles.ApplyColorScheme;
  finally
    EndUpdate;
  end;
end;

{******************************************************}
function TALDynamicSwitch.TTrack.GetDefaultSize: TSizeF;
begin
  Result := TSizeF.Create(52, 32);
end;

{*********************************************************}
function TALDynamicSwitch.TTrack.GetCacheSubIndex: Integer;
begin
  // The Thumb uses 11 slots:
  // 0     - Unused
  // 1..5  - Checked state drawables
  // 6..10 - Unchecked state drawables
  Result := 11;
end;

{**********************************************************}
function TALDynamicSwitch.TTrack.GetDoubleBuffered: boolean;
begin
  result := fDoubleBuffered;
end;

{*************************************************************************}
procedure TALDynamicSwitch.TTrack.SetDoubleBuffered(const AValue: Boolean);
begin
  if AValue <> fDoubleBuffered then begin
    fDoubleBuffered := AValue;
    if not fDoubleBuffered then ClearBufDrawable
    {$IF NOT DEFINED(ALSkiaCanvas)}
    else ClearRenderTargets;
    {$ENDIF}
  end;
end;

{***************************************************}
function TALDynamicSwitch.TTrack.GetChecked: Boolean;
begin
  Result := FChecked;
end;

{*****************************************************************}
procedure TALDynamicSwitch.TTrack.SetChecked(const Value: Boolean);
begin
  if FChecked <> Value then begin
    FChecked := Value;
    if FChecked then DisabledOpacity := StateStyles.Checked.Disabled.opacity
    else DisabledOpacity := StateStyles.Unchecked.Disabled.opacity;
    DoChanged;
  end;
end;

{***************************************************************************}
procedure TALDynamicSwitch.TTrack.SetStateStyles(const AValue: TStateStyles);
begin
  FStateStyles.Assign(AValue);
end;

{********************************************************}
function TALDynamicSwitch.TTrack.IsXRadiusStored: Boolean;
begin
  Result := not SameValue(FXRadius, DefaultXRadius, TEpsilon.Vector);
end;

{********************************************************}
function TALDynamicSwitch.TTrack.IsYRadiusStored: Boolean;
begin
  Result := not SameValue(FYRadius, DefaultYRadius, TEpsilon.Vector);
end;

{*********************************************************}
function TALDynamicSwitch.TTrack.GetDefaultXRadius: Single;
begin
  Result := -50;
end;

{*********************************************************}
function TALDynamicSwitch.TTrack.GetDefaultYRadius: Single;
begin
  Result := -50;
end;

{****************************************************************}
procedure TALDynamicSwitch.TTrack.SetXRadius(const Value: Single);
begin
  if not SameValue(FXRadius, Value, TEpsilon.Vector) then begin
    ClearBufDrawable;
    FXRadius := Value;
    Repaint;
  end;
end;

{****************************************************************}
procedure TALDynamicSwitch.TTrack.SetYRadius(const Value: Single);
begin
  if not SameValue(FYRadius, Value, TEpsilon.Vector) then begin
    ClearBufDrawable;
    FYRadius := Value;
    Repaint;
  end;
end;

{*************************************************************}
procedure TALDynamicSwitch.TTrack.FillChanged(Sender: TObject);
begin
  ClearBufDrawable;
  inherited;
end;

{***************************************************************}
procedure TALDynamicSwitch.TTrack.StrokeChanged(Sender: TObject);
begin
  ClearBufDrawable;
  inherited;
end;

{***************************************************************}
procedure TALDynamicSwitch.TTrack.ShadowChanged(Sender: TObject);
begin
  ClearBufDrawable;
  inherited;
end;

{********************************************************************}
procedure TALDynamicSwitch.TTrack.StateStylesChanged(Sender: TObject);
begin
  ClearBufDrawable;
  if Checked then DisabledOpacity := StateStyles.Checked.Disabled.opacity
  else DisabledOpacity := StateStyles.Unchecked.Disabled.opacity;
  Repaint;
end;

{***************************************************}
procedure TALDynamicSwitch.TTrack.IsMouseOverChanged;
begin
  inherited;
  StateStyles.Transition.Start;
  repaint;
end;

{*****************************************************}
//**procedure TALDynamicSwitch.TTrack.IsFocusedChanged;
//**begin
//**  inherited;
//**  StateStyles.Transition.Start;
//**  repaint;
//**end;

{***********************************************}
procedure TALDynamicSwitch.TTrack.PressedChanged;
begin
  inherited;
  StateStyles.Transition.Start;
  repaint;
end;

{******************************************}
procedure TALDynamicSwitch.TTrack.DoChanged;
begin
  Repaint;
end;

{******************************************}
procedure TALDynamicSwitch.TTrack.DoResized;
begin
  ClearBufDrawable;
  inherited;
end;

{*************************************************}
procedure TALDynamicSwitch.TTrack.ClearBufDrawable;
begin
  {$IFDEF debug}
  if (FStateStyles <> nil) and
     (not IsDestroying) and
     ((not ALIsDrawableNull(FStateStyles.Checked.Default.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.Checked.Disabled.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.Checked.Hovered.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.Checked.Pressed.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.Checked.Focused.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.UnChecked.Default.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.UnChecked.Disabled.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.UnChecked.Hovered.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.UnChecked.Pressed.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.UnChecked.Focused.FBufDrawable))) then
    ALLog(Classname + '.ClearBufDrawable', 'BufDrawable has been cleared | Name: ' + Name, TalLogType.warn);
  {$endif}
  if FStateStyles <> nil then
    FStateStyles.ClearBufDrawable;
end;

{************************************************}
procedure TALDynamicSwitch.TTrack.MakeBufDrawable;

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  function _DoMakeBufDrawable(const AStateStyle: TBaseStateStyle): boolean;
  begin
    if (not ALIsDrawableNull(AStateStyle.FBufDrawable)) then exit(False);
    AStateStyle.SupersedeNoChanges(true{ASaveState});
    try

      {$IFDEF debug}
      ALLog(Classname + '.MakeBufDrawable', 'Name: ' + Name + ' | Style: ' + AStateStyle.ClassName + ' | Width: ' + ALFloatToStrW(Width)+ ' | Height: ' + ALFloatToStrW(Height));
      {$endif}

      CreateBufDrawable(
        AStateStyle.FBufDrawable, // var ABufDrawable: TALDrawable;
        AStateStyle.FBufDrawableRect, // var ABufDrawableRect: TRectF;
        ALGetScreenScale * AStateStyle.Scale, // const AScale: Single;
        AStateStyle.Fill, // const AFill: TALBrush;
        AStateStyle.StateLayer, // const AStateLayer: TALStateLayer;
        AStateStyle.Stroke, // const AStroke: TALStrokeBrush;
        AStateStyle.Shadow); // const AShadow: TALShadow);

      // LStateStyle.FBufDrawableRect must include the LScale
      AStateStyle.FBufDrawableRect.Top := AStateStyle.FBufDrawableRect.Top * AStateStyle.Scale;
      AStateStyle.FBufDrawableRect.right := AStateStyle.FBufDrawableRect.right * AStateStyle.Scale;
      AStateStyle.FBufDrawableRect.left := AStateStyle.FBufDrawableRect.left * AStateStyle.Scale;
      AStateStyle.FBufDrawableRect.bottom := AStateStyle.FBufDrawableRect.bottom * AStateStyle.Scale;

      // Since LStateStyle.FBufDrawableRect can have different dimensions than the main BufDrawableRect (LocalRect.ReducePrecision)
      // (due to scale), we must center LStateStyle.FBufDrawableRect within the main BufDrawableRect (LocalRect.ReducePrecision)
      // to ensure that all changes are visually centered.
      var LCenteredRect := AStateStyle.FBufDrawableRect.CenterAt(LocalRect.ReducePrecision);
      AStateStyle.FBufDrawableRect.Offset(LCenteredRect.Left, LCenteredRect.top);

    finally
      AStateStyle.RestorestateNoChanges;
    end;
    Result := True;
  end;

begin
  //--- Do not create BufDrawable if not DoubleBuffered
  if {$IF not DEFINED(ALDPK)}(not DoubleBuffered){$ELSE}False{$ENDIF} then begin
    ClearBufDrawable;
    exit;
  end;
  //--
  var LSubIndexOffset: Integer;
  var LDefaultStateStyle: TBaseStateStyle;
  if Checked then begin
    LSubIndexOffset := GetCacheSubIndex{+0};
    LDefaultStateStyle := StateStyles.Checked.Default;
  end
  else begin
    LSubIndexOffset := GetCacheSubIndex+5;
    LDefaultStateStyle := StateStyles.UnChecked.Default;
  end;
  //--
  if (CacheIndex = 0) or
     (CacheEngine = nil) or
     (not CacheEngine.HasEntry(CacheIndex{AIndex}, LSubIndexOffset+LDefaultStateStyle.CacheSubIndex{ASubIndex})) then
    _DoMakeBufDrawable(LDefaultStateStyle);
  //--
  var LStateStyle := TBaseStateStyle(StateStyles.GetCurrentRawStyle);
  if LStateStyle = nil then exit;
  if LStateStyle.Inherit then exit;
  if (CacheIndex > 0) and
     (CacheEngine <> nil) and
     (CacheEngine.HasEntry(CacheIndex{AIndex}, LSubIndexOffset+LStateStyle.CacheSubIndex{ASubIndex})) then Exit;
  _DoMakeBufDrawable(LStateStyle);
  // No need to center LStateStyle.FBufDrawableRect on the main BufDrawableRect
  // because BufDrawableRect always has the width and height of the localRect.
end;

{**************************************************}
Procedure TALDynamicSwitch.TTrack.CreateBufDrawable(
            var ABufDrawable: TALDrawable;
            out ABufDrawableRect: TRectF;
            const AScale: Single;
            const AFill: TALBrush;
            const AStateLayer: TALStateLayer;
            const AStroke: TALStrokeBrush;
            const AShadow: TALShadow);
begin

  if (not ALIsDrawableNull(ABufDrawable)) then exit;

  ABufDrawableRect := LocalRect.ReducePrecision;
  var LSurfaceRect := ALGetShapeSurfaceRect(
                        ABufDrawableRect, // const ARect: TRectF;
                        AutoAlignToPixel, // const AAlignToPixel: Boolean;
                        AFill, // const AFill: TALBrush;
                        nil, // const AFillResourceStream: TStream;
                        AStateLayer, // const AStateLayer: TALStateLayer;
                        AShadow); // const AShadow: TALShadow): TRectF;
  ABufDrawableRect.Offset(-LSurfaceRect.Left, -LSurfaceRect.Top);

  var LSurface: TALSurface;
  var LCanvas: TALCanvas;
  ALCreateSurface(
    LSurface, // out ASurface: TALSurface;
    LCanvas, // out ACanvas: TALCanvas;
    AScale, // const AScale: Single;
    LSurfaceRect.Width, // const w: integer;
    LSurfaceRect.height);// const h: integer)
  try

    if ALCanvasBeginScene(LCanvas) then
    try

      TALDrawRectangleHelper.Create(LCanvas)
        .SetScale(AScale)
        .SetAlignToPixel(AutoAlignToPixel)
        .SetDstRect(ABufDrawableRect)
        .SetFill(AFill)
        .SetStateLayer(AStateLayer, TAlphaColors.Null)
        .SetDrawStateLayerOnTop(False)
        .SetStroke(AStroke)
        .SetShadow(AShadow)
        .SetSides(AllSides)
        .SetCorners(AllCorners)
        .SetXRadius(XRadius)
        .SetYRadius(YRadius)
        .Draw;

    finally
      ALCanvasEndScene(LCanvas)
    end;

    ABufDrawable := ALCreateDrawableFromSurface(LSurface);
    // The Shadow or Statelayer are not included in the dimensions of the fBufDrawableRect rectangle.
    // However, the fBufDrawableRect rectangle is offset by the dimensions of the shadow/Statelayer.
    ABufDrawableRect.Offset(-2*ABufDrawableRect.Left, -2*ABufDrawableRect.Top);

  finally
    ALFreeAndNilSurface(LSurface, LCanvas);
  end;

end;

{*****************************}
{$IF NOT DEFINED(ALSkiaCanvas)}
function TALDynamicSwitch.TTrack.GetRenderTargetRect(const ARect: TrectF): TRectF;
begin
  if StateStyles.Transition.Running then begin
    Result := ARect;
    if StateStyles.Transition.FromStateStyle <> nil then begin
      var LFromSurfaceRect := ALGetShapeSurfaceRect(
                                ARect, // const ARect: TRectF;
                                AutoAlignToPixel, // const AAlignToPixel: Boolean;
                                _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.FromStateStyle).Fill, // const AFill: TALBrush;
                                nil, // const AFillResourceStream: TStream;
                                _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.FromStateStyle).StateLayer, // const AStateLayer: TALStateLayer;
                                _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.FromStateStyle).Shadow); // const AShadow: TALShadow): TRectF;
      Result := TRectF.Union(Result, LFromSurfaceRect); // add the extra space needed to draw the shadow/statelayer
    end;
    if StateStyles.Transition.ToStateStyle <> nil then begin
      var LToSurfaceRect := ALGetShapeSurfaceRect(
                              ARect, // const ARect: TRectF;
                              AutoAlignToPixel, // const AAlignToPixel: Boolean;
                              _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.ToStateStyle).Fill, // const AFill: TALBrush;
                              nil, // const AFillResourceStream: TStream;
                              _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.ToStateStyle).StateLayer, // const AStateLayer: TALStateLayer;
                              _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.ToStateStyle).Shadow); // const AShadow: TALShadow): TRectF;
      Result := TRectF.Union(Result, LToSurfaceRect); // add the extra space needed to draw the shadow/statelayer
    end;
  end
  else begin
    var LStateStyle := TBaseStateStyle(StateStyles.GetCurrentRawStyle);
    if LStateStyle <> nil then begin
      Result := ALGetShapeSurfaceRect(
                  ARect, // const ARect: TRectF;
                  AutoAlignToPixel, // const AAlignToPixel: Boolean;
                  LStateStyle.Fill, // const AFill: TALBrush;
                  nil, // const AFillResourceStream: TStream;
                  LStateStyle.StateLayer, // const AStateLayer: TALStateLayer;
                  LStateStyle.Shadow); // const AShadow: TALShadow): TRectF;
    end
    else begin
      Result := ALGetShapeSurfaceRect(
                  ARect, // const ARect: TRectF;
                  AutoAlignToPixel, // const AAlignToPixel: Boolean;
                  Fill, // const AFill: TALBrush;
                  nil, // const AFillResourceStream: TStream;
                  nil, // const AStateLayer: TALStateLayer;
                  Shadow); // const AShadow: TALShadow): TRectF;
    end;
  end;
end;
{$ENDIF}

{*****************************}
{$IF NOT DEFINED(ALSkiaCanvas)}
procedure TALDynamicSwitch.TTrack.InitRenderTargets(var ARect: TrectF);
begin
  var LSurfaceRect := GetRenderTargetRect(ARect);
  ARect.Offset(-LSurfaceRect.Left, -LSurfaceRect.Top);
  ALInitControlRenderTargets(
    LSurfaceRect, // Const ARect: TrectF;
    FRenderTargetSurface, // var ARenderTargetSurface: TALSurface;
    FRenderTargetCanvas, // var ARenderTargetCanvas: TALCanvas;
    FRenderTargetDrawable); // var ARenderTargetDrawable: TALDrawable):
end;
{$ENDIF}

{*****************************}
{$IF NOT DEFINED(ALSkiaCanvas)}
procedure TALDynamicSwitch.TTrack.ClearRenderTargets;
begin
  ALFreeAndNilDrawable(FRenderTargetDrawable);
  ALFreeAndNilSurface(FRenderTargetSurface, FRenderTargetCanvas);
end;
{$ENDIF}

{**************************************}
procedure TALDynamicSwitch.TTrack.Paint;
begin

  StateStyles.UpdateLastPaintedRawStyle;

  var LDrawable: TALDrawable := ALNullDrawable;
  var LDrawableRect: TRectF := TRectF.Empty;
  if not StateStyles.Transition.Running then begin
    //--
    var LSubIndexOffset: Integer;
    var LDefaultStateStyle: TBaseStateStyle;
    if Checked then begin
      LSubIndexOffset := GetCacheSubIndex{+0};
      LDefaultStateStyle := StateStyles.Checked.Default;
    end
    else begin
      LSubIndexOffset := GetCacheSubIndex+5;
      LDefaultStateStyle := StateStyles.UnChecked.Default;
    end;
    //--
    var LStateStyle := TBaseStateStyle(StateStyles.GetCurrentRawStyle);
    if LStateStyle <> nil then begin
      if (CacheIndex <= 0) or
         (CacheEngine = nil) or
         (not CacheEngine.TryGetEntry(CacheIndex{AIndex}, LSubIndexOffset+LStateStyle.CacheSubIndex{ASubIndex}, LDrawable{ADrawable}, LDrawableRect{ARect})) then begin
        MakeBufDrawable;
        if (CacheIndex > 0) and (CacheEngine <> nil) and (not ALIsDrawableNull(LStateStyle.FBufDrawable)) then begin
          if not CacheEngine.TrySetEntry(CacheIndex{AIndex}, LSubIndexOffset+LStateStyle.CacheSubIndex{ASubIndex}, LStateStyle.FBufDrawable{ADrawable}, LStateStyle.FBufDrawableRect{ARect}) then ALFreeAndNilDrawable(LStateStyle.FBufDrawable)
          else LStateStyle.FBufDrawable := ALNullDrawable;
          if not CacheEngine.TryGetEntry(CacheIndex{AIndex}, LSubIndexOffset+LStateStyle.CacheSubIndex{ASubIndex}, LDrawable{ADrawable}, LDrawableRect{ARect}) then
            raise Exception.Create('Error BB5ACD27-7CF2-44D3-AEB1-22C8BB492762');
        end
        else begin
          LDrawable := LStateStyle.FBufDrawable;
          LDrawableRect := LStateStyle.FBufDrawableRect;
        end;
      end;
    end;
    //--
    If ALIsDrawableNull(LDrawable) then begin
      if (CacheIndex <= 0) or
         (CacheEngine = nil) or
         (not CacheEngine.TryGetEntry(CacheIndex{AIndex}, LSubIndexOffset+LDefaultStateStyle.CacheSubIndex{ASubIndex}, LDrawable{ADrawable}, LDrawableRect{ARect})) then begin
        if LStateStyle = nil then MakeBufDrawable;
        if (CacheIndex > 0) and (CacheEngine <> nil) and (not ALIsDrawableNull(LDefaultStateStyle.fBufDrawable)) then begin
          if not CacheEngine.TrySetEntry(CacheIndex{AIndex}, LSubIndexOffset+LDefaultStateStyle.CacheSubIndex{ASubIndex}, LDefaultStateStyle.fBufDrawable{ADrawable}, LDefaultStateStyle.fBufDrawableRect{ARect}) then ALFreeAndNilDrawable(LDefaultStateStyle.fBufDrawable)
          else LDefaultStateStyle.fBufDrawable := ALNullDrawable;
          if not CacheEngine.TryGetEntry(CacheIndex{AIndex}, LSubIndexOffset+LDefaultStateStyle.CacheSubIndex{ASubIndex}, LDrawable{ADrawable}, LDrawableRect{ARect}) then
            raise Exception.Create('Error BB5ACD27-7CF2-44D3-AEB1-22C8BB492762');
        end
        else begin
          LDrawable := LDefaultStateStyle.FBufDrawable;
          LDrawableRect := LDefaultStateStyle.FBufDrawableRect;
        end;
      end;
    end;
    //--
  end;

  if ALIsDrawableNull(LDrawable) then begin

    var LCurrentAdjustedStateStyle := TBaseStateStyle(StateStyles.GetCurrentAdjustedStyle);
    if LCurrentAdjustedStateStyle = nil then begin
      inherited Paint;
      exit;
    end;

    {$IF DEFINED(ALSkiaCanvas)}

    var LCanvasSaveState: TCanvasSaveState := ALScaleAndCenterCanvas(
                                                Canvas, // Const ACanvas: TCanvas;
                                                AbsoluteRect.ReducePrecision, // Const AAbsoluteRect: TRectF;
                                                LCurrentAdjustedStateStyle.Scale, // Const AScale: Single;
                                                true); // Const ASaveState: Boolean);
    try

      var LRect := LocalRect.ReducePrecision;

      if compareValue(AbsoluteOpacity, 1, Tepsilon.Scale) < 0 then begin
        var LLayerRect := ALGetShapeSurfaceRect(
                            LRect, // const ARect: TrectF;
                            AutoAlignToPixel, // const AAlignToPixel: Boolean;
                            LCurrentAdjustedStateStyle.Fill.Color, // const AFillColor: TAlphaColor;
                            LCurrentAdjustedStateStyle.Fill.Gradient.Colors, // const AFillGradientColors: TArray<TAlphaColor>;
                            LCurrentAdjustedStateStyle.Fill.ResourceName, // const AFillResourceName: String;
                            nil, // const AFillResourceStream: TStream;
                            LCurrentAdjustedStateStyle.Fill.BackgroundMargins.Rect, // Const AFillBackgroundMarginsRect: TRectF;
                            LCurrentAdjustedStateStyle.Fill.ImageMargins.Rect, // Const AFillImageMarginsRect: TRectF;
                            LCurrentAdjustedStateStyle.StateLayer.Opacity, // const AStateLayerOpacity: Single;
                            LCurrentAdjustedStateStyle.StateLayer.Color, // const AStateLayerColor: TAlphaColor;
                            LCurrentAdjustedStateStyle.StateLayer.UseContentColor, // const AStateLayerUseContentColor: Boolean;
                            LCurrentAdjustedStateStyle.StateLayer.Margins.Rect, // Const AStateLayerMarginsRect: TRectF;
                            LCurrentAdjustedStateStyle.Shadow.Color, // const AShadowColor: TAlphaColor;
                            LCurrentAdjustedStateStyle.Shadow.Blur, // const AShadowBlur: Single;
                            LCurrentAdjustedStateStyle.Shadow.OffsetX, // const AShadowOffsetX: Single;
                            LCurrentAdjustedStateStyle.Shadow.OffsetY); // const AShadowOffsetY: Single);
        ALBeginTransparencyLayer(
          TSkCanvasCustom(Canvas).Canvas.Handle, // const aCanvas: TALCanvas;
          LLayerRect, // const ARect: TRectF;
          AbsoluteOpacity); // const AOpacity: Single);
      end;
      try

        TALDrawRectangleHelper.Create(TSkCanvasCustom(Canvas).Canvas.Handle)
          .SetAlignToPixel(AutoAlignToPixel)
          .SetDstRect(LRect)
          .SetFill(LCurrentAdjustedStateStyle.Fill)
          .SetStateLayer(LCurrentAdjustedStateStyle.StateLayer, TAlphaColors.Null)
          .SetDrawStateLayerOnTop(False)
          .SetStroke(LCurrentAdjustedStateStyle.Stroke)
          .SetShadow(LCurrentAdjustedStateStyle.Shadow)
          .SetSides(AllSides)
          .SetCorners(AllCorners)
          .SetXRadius(XRadius)
          .SetYRadius(YRadius)
          .Draw;

      finally
        if compareValue(AbsoluteOpacity, 1, Tepsilon.Scale) < 0 then
          ALEndTransparencyLayer(TSkCanvasCustom(Canvas).Canvas.Handle);
      end;

    finally
      if LCanvasSaveState <> nil then
        Canvas.RestoreState(LCanvasSaveState);
    end;

    {$ELSE}

    var LRect := LocalRect.ReducePrecision;
    InitRenderTargets(LRect);
    if ALCanvasBeginScene(RenderTargetCanvas) then
    try

      ALClearCanvas(RenderTargetCanvas, TAlphaColors.Null);

      TALDrawRectangleHelper.Create(RenderTargetCanvas)
        .SetScale(ALGetScreenScale)
        .SetAlignToPixel(AutoAlignToPixel)
        .SetDstRect(LRect)
        .SetFill(LCurrentAdjustedStateStyle.Fill)
        .SetStateLayer(LCurrentAdjustedStateStyle.StateLayer, TAlphaColors.Null)
        .SetDrawStateLayerOnTop(False)
        .SetStroke(LCurrentAdjustedStateStyle.Stroke)
        .SetShadow(LCurrentAdjustedStateStyle.Shadow)
        .SetSides(AllSides)
        .SetCorners(AllCorners)
        .SetXRadius(XRadius)
        .SetYRadius(YRadius)
        .Draw;

    finally
      ALCanvasEndScene(RenderTargetCanvas)
    end;

    ALUpdateDrawableFromSurface(RenderTargetSurface, RenderTargetDrawable);

    // The Shadow or Statelayer are not included in the dimensions of the LRect rectangle.
    // However, the LRect rectangle is offset by the dimensions of the shadow/Statelayer.
    LRect.Offset(-2*LRect.Left, -2*LRect.Top);

    // LRect must include the LScale
    LRect.Top := LRect.Top * LCurrentAdjustedStateStyle.Scale;
    LRect.right := LRect.right * LCurrentAdjustedStateStyle.Scale;
    LRect.left := LRect.left * LCurrentAdjustedStateStyle.Scale;
    LRect.bottom := LRect.bottom * LCurrentAdjustedStateStyle.Scale;

    // Since LStateStyle.FBufDrawableRect can have different dimensions than the main BufDrawableRect (LocalRect.ReducePrecision)
    // (due to scale), we must center LStateStyle.FBufDrawableRect within the main BufDrawableRect (LocalRect.ReducePrecision)
    // to ensure that all changes are visually centered.
    var LCenteredRect := LRect.CenterAt(LocalRect.ReducePrecision);
    LRect.Offset(LCenteredRect.Left, LCenteredRect.top);

    // We cannot use the matrix because, if we do, ALAlignToPixelRound in ALDrawDrawable
    // will be ineffective since the matrix will no longer be a simple translation matrix.
    // In such a case, TCustomCanvasGpu(ACanvas).DrawTexture may produce border artifacts
    // if the texture is not perfectly pixel-aligned.
    var LDstRect := TRectF.Create(0, 0, ALGetDrawableWidth(RenderTargetDrawable), ALGetDrawableHeight(RenderTargetDrawable));
    LDstRect.Width := (LDstRect.Width / ALGetScreenScale) * LCurrentAdjustedStateStyle.Scale;
    LDstRect.height := (LDstRect.height / ALGetScreenScale) * LCurrentAdjustedStateStyle.Scale;
    LDstRect.SetLocation(
      LRect.Left,
      LRect.Top);
    ALDrawDrawable(
      Canvas, // const ACanvas: Tcanvas;
      RenderTargetDrawable, // const ADrawable: TALDrawable;
      LDstRect, // const ADstRect: TrectF; // IN Virtual pixels !
      AbsoluteOpacity); // const AOpacity: Single)

    {$ENDIF}

    exit;
  end;

  ALDrawDrawable(
    Canvas, // const ACanvas: Tcanvas;
    LDrawable, // const ADrawable: TALDrawable;
    LDrawableRect.TopLeft, // const ATopLeft: TpointF;
    AbsoluteOpacity); // const AOpacity: Single);

end;

{********************************************************************}
function TALDynamicSwitch.TThumb.TStroke.GetDefaultColor: TAlphaColor;
begin
  Result := TAlphaColors.null;
end;

{********************************************************************************}
function TALDynamicSwitch.TThumb.TCheckMarkBrush.TMargins.GetDefaultValue: TRectF;
begin
  Result := TRectF.Create(6,6,6,6);
end;

{************************************************************************}
function TALDynamicSwitch.TThumb.TCheckMarkBrush.CreateMargins: TALBounds;
begin
  Result := TMargins.Create;
end;

{***************************************************************************************}
function TALDynamicSwitch.TThumb.TInheritCheckMarkBrush.TMargins.GetDefaultValue: TRectF;
begin
  Result := TRectF.Create(6,6,6,6);
end;

{*******************************************************************************}
function TALDynamicSwitch.TThumb.TInheritCheckMarkBrush.CreateMargins: TALBounds;
begin
  Result := TMargins.Create;
end;

{***************************************************************************************}
function TALDynamicSwitch.TThumb.TDefaultStateStyle.TStroke.GetDefaultColor: TAlphaColor;
begin
  Result := TAlphaColors.null;
end;

{*********************************************************************************************************************}
function TALDynamicSwitch.TThumb.TDefaultStateStyle.CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush;
begin
  Result := TStroke.Create(AParent);
end;

{************************************************************************************************************************************************************************}
function TALDynamicSwitch.TThumb.TDefaultStateStyle.CreateCheckMark(const AParent: TALDynamicBaseCheckBox.TCheckMarkBrush): TALDynamicBaseCheckBox.TInheritCheckMarkBrush;
begin
  Result := TInheritCheckMarkBrush.Create(AParent);
end;

{****************************************************************************************}
function TALDynamicSwitch.TThumb.TDisabledStateStyle.TStroke.GetDefaultColor: TAlphaColor;
begin
  Result := TAlphaColors.null;
end;

{**********************************************************************************************************************}
function TALDynamicSwitch.TThumb.TDisabledStateStyle.CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush;
begin
  Result := TStroke.Create(AParent);
end;

{*************************************************************************************************************************************************************************}
function TALDynamicSwitch.TThumb.TDisabledStateStyle.CreateCheckMark(const AParent: TALDynamicBaseCheckBox.TCheckMarkBrush): TALDynamicBaseCheckBox.TInheritCheckMarkBrush;
begin
  Result := TInheritCheckMarkBrush.Create(AParent);
end;

{***************************************************************************************}
function TALDynamicSwitch.TThumb.THoveredStateStyle.TStroke.GetDefaultColor: TAlphaColor;
begin
  Result := TAlphaColors.null;
end;

{*********************************************************************************************************************}
function TALDynamicSwitch.TThumb.THoveredStateStyle.CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush;
begin
  Result := TStroke.Create(AParent);
end;

{************************************************************************************************************************************************************************}
function TALDynamicSwitch.TThumb.THoveredStateStyle.CreateCheckMark(const AParent: TALDynamicBaseCheckBox.TCheckMarkBrush): TALDynamicBaseCheckBox.TInheritCheckMarkBrush;
begin
  Result := TInheritCheckMarkBrush.Create(AParent);
end;

{***************************************************************************************}
function TALDynamicSwitch.TThumb.TPressedStateStyle.TStroke.GetDefaultColor: TAlphaColor;
begin
  Result := TAlphaColors.null;
end;

{*********************************************************************************************************************}
function TALDynamicSwitch.TThumb.TPressedStateStyle.CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush;
begin
  Result := TStroke.Create(AParent);
end;

{************************************************************************************************************************************************************************}
function TALDynamicSwitch.TThumb.TPressedStateStyle.CreateCheckMark(const AParent: TALDynamicBaseCheckBox.TCheckMarkBrush): TALDynamicBaseCheckBox.TInheritCheckMarkBrush;
begin
  Result := TInheritCheckMarkBrush.Create(AParent);
end;

{***************************************************************************************}
function TALDynamicSwitch.TThumb.TFocusedStateStyle.TStroke.GetDefaultColor: TAlphaColor;
begin
  Result := TAlphaColors.null;
end;

{*********************************************************************************************************************}
function TALDynamicSwitch.TThumb.TFocusedStateStyle.CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush;
begin
  Result := TStroke.Create(AParent);
end;

{************************************************************************************************************************************************************************}
function TALDynamicSwitch.TThumb.TFocusedStateStyle.CreateCheckMark(const AParent: TALDynamicBaseCheckBox.TCheckMarkBrush): TALDynamicBaseCheckBox.TInheritCheckMarkBrush;
begin
  Result := TInheritCheckMarkBrush.Create(AParent);
end;

{********************************************************************************************************************************************}
function TALDynamicSwitch.TThumb.TCheckStateStyles.CreateDefaultStateStyle(const AParent: TObject): TALDynamicBaseCheckBox.TDefaultStateStyle;
begin
  Result := TDefaultStateStyle.Create(AParent);
end;

{**********************************************************************************************************************************************}
function TALDynamicSwitch.TThumb.TCheckStateStyles.CreateDisabledStateStyle(const AParent: TObject): TALDynamicBaseCheckBox.TDisabledStateStyle;
begin
  Result := TDisabledStateStyle.Create(AParent);
end;

{********************************************************************************************************************************************}
function TALDynamicSwitch.TThumb.TCheckStateStyles.CreateHoveredStateStyle(const AParent: TObject): TALDynamicBaseCheckBox.THoveredStateStyle;
begin
  Result := THoveredStateStyle.Create(AParent);
end;

{********************************************************************************************************************************************}
function TALDynamicSwitch.TThumb.TCheckStateStyles.CreatePressedStateStyle(const AParent: TObject): TALDynamicBaseCheckBox.TPressedStateStyle;
begin
  Result := TPressedStateStyle.Create(AParent);
end;

{********************************************************************************************************************************************}
function TALDynamicSwitch.TThumb.TCheckStateStyles.CreateFocusedStateStyle(const AParent: TObject): TALDynamicBaseCheckBox.TFocusedStateStyle;
begin
  Result := TFocusedStateStyle.Create(AParent);
end;

{***************************************************************}
procedure TALDynamicSwitch.TThumb.TStateStyles.TTransition.Start;
begin
  FStartPositionX := Owner{StateStyles}.Parent{Thumb}.Left;
  inherited;
  if not Running then
    TALDynamicSwitch(Owner{StateStyles}.Parent{Thumb}.Owner{Track}.Owner{Switch}).AlignThumb;
end;

{*******************************************************************}
procedure TALDynamicSwitch.TThumb.TStateStyles.TTransition.DoProcess;
begin
  if Enabled then begin
    var LThumb := Owner{StateStyles}.Parent{Thumb};
    var LSwitch := TALDynamicSwitch(LThumb.Owner{Track}.Owner{Switch});
    if (not LSwitch.Pressed) and (Lthumb.Align = TALAlignLayout.None) then begin
      var LStopPositionX: Single;
      If LSwitch.Checked then LStopPositionX := LSwitch.GetMaxThumbPos
      else LStopPositionX := LSwitch.GetMinThumbPos;
      LThumb.Left := FStartPositionX + (LStopPositionX - FStartPositionX) * CurrentValue;
    end;
  end;
  inherited;
end;

{******************************************************************}
procedure TALDynamicSwitch.TThumb.TStateStyles.TTransition.DoFinish;
begin
  if Enabled then begin
    TALDynamicSwitch(Owner{StateStyles}.Parent{Thumb}.Owner{Track}.Owner{Switch}).AlignThumb;
  end;
  inherited;
end;

{****************************************************************************************************}
function TALDynamicSwitch.TThumb.TStateStyles.CreateTransition: TALDynamicBaseStateStyles.TTransition;
begin
  result := TTransition.Create(Self);
end;

{*************************************************************************************************************************************************}
function TALDynamicSwitch.TThumb.TStateStyles.CreateCheckedStateStyles(const AParent: TALDynamicControl): TALDynamicBaseCheckBox.TCheckStateStyles;
begin
  Result := TCheckStateStyles.Create(AParent);
end;

{***************************************************************************************************************************************************}
function TALDynamicSwitch.TThumb.TStateStyles.CreateUncheckedStateStyles(const AParent: TALDynamicControl): TALDynamicBaseCheckBox.TCheckStateStyles;
begin
  Result := TCheckStateStyles.Create(AParent);
end;

{****************************************************************}
function TALDynamicSwitch.TThumb.TMargins.GetDefaultValue: TRectF;
begin
  Result := TRectF.Create(4,4,4,4);
end;

{****************************************************************}
constructor TALDynamicSwitch.TThumb.Create(const AOwner: TObject);
begin
  inherited;
  //--
  //**SetAcceptsControls(False);
  //**CanFocus := False;
  //**Locked := True;
  HitTest := False;
  //--
  //**Margins.DefaultValue := TRectF.Create(4,4,4,4);
  //**Margins.Rect := Margins.DefaultValue;
end;

{********************************************************}
function TALDynamicSwitch.TThumb.CreateMargins: TALBounds;
begin
  Result := TMargins.Create;
end;

{************************************************************}
function TALDynamicSwitch.TThumb.CreateStroke: TALStrokeBrush;
begin
  Result := TStroke.Create;
end;

{***************************************************************************************}
function TALDynamicSwitch.TThumb.CreateCheckMark: TALDynamicBaseCheckBox.TCheckMarkBrush;
begin
  Result := TCheckMarkBrush.Create;
end;

{**************************************************************************************}
function TALDynamicSwitch.TThumb.CreateStateStyles: TALDynamicBaseCheckBox.TStateStyles;
begin
  result := TStateStyles.Create(Self);
end;

{*********************************************************}
function TALDynamicSwitch.TThumb.GetDefaultXRadius: Single;
begin
  Result := -50;
end;

{*********************************************************}
function TALDynamicSwitch.TThumb.GetDefaultYRadius: Single;
begin
  Result := -50;
end;

{******************************************************}
function TALDynamicSwitch.TThumb.GetDefaultSize: TSizeF;
begin
  Result := TSizeF.Create(24, 24);
end;

{**************************************}
procedure TALDynamicSwitch.TThumb.Click;
begin
  // Since TALDynamicSwitch.TThumb has HitTest set to false, this event
  // is triggered only at the end of the transition animation when
  // DelayClick is set to true.
  TALDynamicSwitch(Owner{Track}.Owner{Switch}).click;
end;

{**********************************************************************************************}
constructor TALDynamicSwitch.TTransition.TInterpolationParams.Create(Const AOwner: TTransition);
begin
  inherited create;
  FOwner := AOwner;
end;

{*****************************************************************************}
function TALDynamicSwitch.TTransition.TInterpolationParams.GetBezierX1: Single;
begin
  Result := FOwner{TTransition}.FOwner{TALDynamicSwitch}.Thumb.StateStyles.Transition.InterpolationParams.BezierX1;
end;

{*****************************************************************************}
function TALDynamicSwitch.TTransition.TInterpolationParams.GetBezierY1: Single;
begin
  Result := FOwner{TTransition}.FOwner{TALDynamicSwitch}.Thumb.StateStyles.Transition.InterpolationParams.BezierY1;
end;

{*****************************************************************************}
function TALDynamicSwitch.TTransition.TInterpolationParams.GetBezierX2: Single;
begin
  Result := FOwner{TTransition}.FOwner{TALDynamicSwitch}.Thumb.StateStyles.Transition.InterpolationParams.BezierX2;
end;

{*****************************************************************************}
function TALDynamicSwitch.TTransition.TInterpolationParams.GetBezierY2: Single;
begin
  Result := FOwner{TTransition}.FOwner{TALDynamicSwitch}.Thumb.StateStyles.Transition.InterpolationParams.BezierY2;
end;

{********************************************************************************************}
procedure TALDynamicSwitch.TTransition.TInterpolationParams.SetBezierX1(const AValue: Single);
begin
  FOwner{TTransition}.FOwner{TALDynamicSwitch}.Thumb.StateStyles.Transition.InterpolationParams.BezierX1 := AValue;
  FOwner{TTransition}.FOwner{TALDynamicSwitch}.Track.StateStyles.Transition.InterpolationParams.BezierX1 := AValue;
end;

{********************************************************************************************}
procedure TALDynamicSwitch.TTransition.TInterpolationParams.SetBezierY1(const AValue: Single);
begin
  FOwner{TTransition}.FOwner{TALDynamicSwitch}.Thumb.StateStyles.Transition.InterpolationParams.BezierY1 := AValue;
  FOwner{TTransition}.FOwner{TALDynamicSwitch}.Track.StateStyles.Transition.InterpolationParams.BezierY1 := AValue;
end;

{********************************************************************************************}
procedure TALDynamicSwitch.TTransition.TInterpolationParams.SetBezierX2(const AValue: Single);
begin
  FOwner{TTransition}.FOwner{TALDynamicSwitch}.Thumb.StateStyles.Transition.InterpolationParams.BezierX2 := AValue;
  FOwner{TTransition}.FOwner{TALDynamicSwitch}.Track.StateStyles.Transition.InterpolationParams.BezierX2 := AValue;
end;

{********************************************************************************************}
procedure TALDynamicSwitch.TTransition.TInterpolationParams.SetBezierY2(const AValue: Single);
begin
  FOwner{TTransition}.FOwner{TALDynamicSwitch}.Thumb.StateStyles.Transition.InterpolationParams.BezierY2 := AValue;
  FOwner{TTransition}.FOwner{TALDynamicSwitch}.Track.StateStyles.Transition.InterpolationParams.BezierY2 := AValue;
end;

{******************************************************************************}
function TALDynamicSwitch.TTransition.TInterpolationParams.GetOvershoot: Single;
begin
  Result := FOwner{TTransition}.FOwner{TALDynamicSwitch}.Thumb.StateStyles.Transition.InterpolationParams.Overshoot;
end;

{*********************************************************************************************}
procedure TALDynamicSwitch.TTransition.TInterpolationParams.SetOvershoot(const AValue: Single);
begin
  FOwner{TTransition}.FOwner{TALDynamicSwitch}.Thumb.StateStyles.Transition.InterpolationParams.Overshoot := AValue;
  FOwner{TTransition}.FOwner{TALDynamicSwitch}.Track.StateStyles.Transition.InterpolationParams.Overshoot := AValue;
end;

{******************************************************************************}
constructor TALDynamicSwitch.TTransition.Create(Const AOwner: TALDynamicSwitch);
begin
  inherited create;
  FOwner := AOwner;
  FInterpolationParams := TInterpolationParams.Create(self);
end;

{**********************************************}
destructor TALDynamicSwitch.TTransition.Destroy;
begin
  ALFreeAndNil(FInterpolationParams);
  inherited;
end;

{*******************************************}
procedure TALDynamicSwitch.TTransition.Start;
begin
  FOwner{TALDynamicSwitch}.Thumb.StateStyles.Transition.Start;
  FOwner{TALDynamicSwitch}.Track.StateStyles.Transition.Start;
end;

{********************************************************}
function TALDynamicSwitch.TTransition.GetDuration: Single;
begin
  Result := FOwner{TALDynamicSwitch}.Thumb.StateStyles.Transition.Duration;
end;

{***********************************************************************}
procedure TALDynamicSwitch.TTransition.SetDuration(const AValue: Single);
begin
  FOwner{TALDynamicSwitch}.Thumb.StateStyles.Transition.Duration := AValue;
  FOwner{TALDynamicSwitch}.Track.StateStyles.Transition.Duration := AValue;
end;

{***********************************************************}
function TALDynamicSwitch.TTransition.GetDelayClick: Boolean;
begin
  Result := FOwner{TALDynamicSwitch}.Thumb.StateStyles.Transition.DelayClick;
end;

{**************************************************************************}
procedure TALDynamicSwitch.TTransition.SetDelayClick(const AValue: Boolean);
begin
  FOwner{TALDynamicSwitch}.Thumb.StateStyles.Transition.DelayClick := AValue;
  FOwner{TALDynamicSwitch}.Track.StateStyles.Transition.DelayClick := AValue;
end;

{*******************************************************************************}
function TALDynamicSwitch.TTransition.GetInterpolationType: TALInterpolationType;
begin
  Result := FOwner{TALDynamicSwitch}.Thumb.StateStyles.Transition.InterpolationType;
end;

{**********************************************************************************************}
procedure TALDynamicSwitch.TTransition.SetInterpolationType(const AValue: TALInterpolationType);
begin
  FOwner{TALDynamicSwitch}.Thumb.StateStyles.Transition.InterpolationType := AValue;
  FOwner{TALDynamicSwitch}.Track.StateStyles.Transition.InterpolationType := AValue;
end;

{*******************************************************************************}
function TALDynamicSwitch.TTransition.GetInterpolationMode: TALInterpolationMode;
begin
  Result := FOwner{TALDynamicSwitch}.Thumb.StateStyles.Transition.InterpolationMode;
end;

{**********************************************************************************************}
procedure TALDynamicSwitch.TTransition.SetInterpolationMode(const AValue: TALInterpolationMode);
begin
  FOwner{TALDynamicSwitch}.Thumb.StateStyles.Transition.InterpolationMode := AValue;
  FOwner{TALDynamicSwitch}.Track.StateStyles.Transition.InterpolationMode := AValue;
end;

{************************************************************************************************}
procedure TALDynamicSwitch.TTransition.SetInterpolationParams(const AValue: TInterpolationParams);
begin
  // No action required; Transition acts only as a proxy
end;

{**************************************************************}
Function TALDynamicSwitch.TTransition.IsDurationStored: Boolean;
begin
  result := not SameValue(Duration, FOwner{TALDynamicSwitch}.Thumb.StateStyles.Transition.DefaultDuration, TALAnimation.TimeEpsilon);
end;

{****************************************************************}
Function TALDynamicSwitch.TTransition.IsDelayClickStored: Boolean;
begin
  result := DelayClick <> FOwner{TALDynamicSwitch}.Thumb.StateStyles.Transition.DefaultDelayClick;
end;

{***********************************************************************}
Function TALDynamicSwitch.TTransition.IsInterpolationTypeStored: Boolean;
begin
  result := InterpolationType <> FOwner{TALDynamicSwitch}.Thumb.StateStyles.Transition.DefaultInterpolationType;
end;

{***********************************************************************}
Function TALDynamicSwitch.TTransition.IsInterpolationModeStored: Boolean;
begin
  result := InterpolationMode <> FOwner{TALDynamicSwitch}.Thumb.StateStyles.Transition.DefaultInterpolationMode;
end;

{*********************************************************}
constructor TALDynamicSwitch.Create(const AOwner: TObject);
begin
  inherited;
  //**CanFocus := True;
  //**SetAcceptsControls(False);
  AutoCapture := True;
  Cursor := crHandPoint;
  DisabledOpacity := 1;
  //--
  FOnChange := nil;
  FPressedThumbPos := TpointF.create(0,0);
  //--
  fScrollCapturedByMe := False;
  TMessageManager.DefaultManager.SubscribeToMessage(TALScrollCapturedMessage, ScrollCapturedByOtherHandler);
  //--
  FTrack := CreateTrack;
  //**FTrack.Parent := self;
  //**FTrack.Stored := False;
  //**FTrack.SetSubComponent(True);
  //**FTrack.Name := 'Track'; // Useful at design time in the IDE
  FTrack.Align := TALAlignLayout.Client;
  //--
  // Use 'self' instead of 'FTrack' to ensure that
  // 'Fthumb.loaded' is called.
  FThumb := CreateThumb;
  //**FThumb.Parent := FTrack;
  //**FThumb.Stored := False;
  //**FThumb.SetSubComponent(True);
  //**FThumb.Name := 'Thumb'; // Useful at design time in the IDE
  //--
  FTransition := TTransition.Create(Self);
end;

{**********************************}
destructor TALDynamicSwitch.Destroy;
begin
  ALFreeAndNil(FTransition);
  inherited;
end;

{*******************************************}
procedure TALDynamicSwitch.BeforeDestruction;
begin
  if BeforeDestructionExecuted then exit;
  // Unsubscribe from TALScrollCapturedMessage to stop receiving messages.
  // This must be done in BeforeDestruction rather than in Destroy,
  // because the control might be freed in the background via ALFreeAndNil(..., delayed),
  // and BeforeDestruction is guaranteed to execute on the main thread.
  TMessageManager.DefaultManager.Unsubscribe(TALScrollCapturedMessage, ScrollCapturedByOtherHandler);
  inherited;
end;

{*******************************************}
procedure TALDynamicSwitch.AfterConstruction;
begin
  inherited;
  //**if not IsOwnerLoading then
    AlignThumb;
end;

{********************************************}
function TALDynamicSwitch.CreateTrack: TTrack;
begin
  Result := TTrack.Create(self);
end;

{********************************************}
function TALDynamicSwitch.CreateThumb: TThumb;
begin
  Result := TThumb.Create(self);
end;

{************************************}
//**procedure TALDynamicSwitch.Loaded;
//**begin
//**  inherited;
//**  AlignThumb;
//**end;

{**************************************}
procedure TALDynamicSwitch.AlignToPixel;
begin
  BeginUpdate;
  try
    inherited;
    Thumb.AlignToPixel;
    Track.AlignToPixel;
  finally
    EndUpdate;
  end;
end;

{******************************************}
procedure TALDynamicSwitch.ApplyColorScheme;
begin
  //BeginUpdate;
  //try
    inherited;
    //Thumb.ApplyColorScheme;
    //Track.ApplyColorScheme;
  //finally
    //EndUpdate;
  //end;
end;

{*****************************************}
procedure TALDynamicSwitch.MakeBufDrawable;
begin
  Track.MakeBufDrawable;
  Thumb.MakeBufDrawable;
end;

{******************************************}
procedure TALDynamicSwitch.ClearBufDrawable;
begin
  Track.ClearBufDrawable;
  Thumb.ClearBufDrawable;
end;

{***********************************************}
function TALDynamicSwitch.GetDefaultSize: TSizeF;
begin
  Result := TSizeF.Create(52, 32);
end;

{***************************************************}
function TALDynamicSwitch.GetDoubleBuffered: boolean;
begin
  result := Track.DoubleBuffered and Thumb.DoubleBuffered;
end;

{******************************************************************}
procedure TALDynamicSwitch.SetDoubleBuffered(const AValue: Boolean);
begin
  Track.DoubleBuffered := AValue;
  Thumb.DoubleBuffered := AValue;
end;

{********************************************}
procedure TALDynamicSwitch.IsMouseOverChanged;
begin
  inherited;
  Track.FIsMouseOver := IsMouseOver;
  Thumb.FIsMouseOver := IsMouseOver;
  Track.IsMouseOverChanged;
  Thumb.IsMouseOverChanged;
end;

{**********************************************}
//**procedure TALDynamicSwitch.IsFocusedChanged;
//**begin
//**  inherited;
//**  Track.FIsFocused := IsFocused;
//**  Thumb.FIsFocused := IsFocused;
//**  Track.IsFocusedChanged;
//**  Thumb.IsFocusedChanged;
//**end;

{****************************************}
procedure TALDynamicSwitch.PressedChanged;
begin
  inherited;
  Track.Pressed := Pressed;
  Thumb.Pressed := Pressed;
end;

{****************************************}
procedure TALDynamicSwitch.EnabledChanged;
begin
  inherited;
  Track.enabled := enabled;
  Thumb.enabled := enabled;
end;

{**********************************}
procedure TALDynamicSwitch.DoChange;
begin
  if Assigned(FOnChange) then FOnChange(Self);
end;

{*****************************************************************}
procedure TALDynamicSwitch.SetTransition(const Value: TTransition);
begin
  // No action required; Transition acts only as a proxy
end;

{*******************************************************************************************}
procedure TALDynamicSwitch.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Single);
begin
  inherited;
  if Pressed then begin
    fThumb.Align := TALALignLayout.None;
    FPressedThumbPos := TPointF.Create(Single(FThumb.left), Single(FThumb.top));
  end;
end;

{*********************************************************************}
procedure TALDynamicSwitch.MouseMove(Shift: TShiftState; X, Y: Single);
begin
  {$IFDEF DEBUG}
  //ALLog(
  //  'TALDynamicSwitch.MouseMove',
  //  'Position:' + ALFormatFloatW('0.##', x) + ',' + ALFormatFloatW('0.##', y));
  {$ENDIF}
  if Pressed then begin

    if (not fScrollCapturedByMe) then begin
      If (abs(X - PressedPosition.X) > abs(Y - PressedPosition.Y)) and
         (abs(X - PressedPosition.X) > TALScrollEngine.DefaultTouchSlop) then begin
        {$IFDEF DEBUG}
        //ALLog(
        //  'TALDynamicSwitch.MouseMove',
        //  'ScrollCapturedByMe');
        {$ENDIF}
        PressedPosition := TpointF.Create(X,Y);
        fScrollCapturedByMe := true;
        TMessageManager.DefaultManager.SendMessage(self, TALScrollCapturedMessage.Create(true), True);
      end;
    end;

    if fScrollCapturedByMe then begin
      var LNewThumbPosX := FPressedThumbPos.x + (X - PressedPosition.X);
      LNewThumbPosX := min(LNewThumbPosX, GetMaxThumbPos);
      LNewThumbPosX := max(LNewThumbPosX, GetMinThumbPos);
      FThumb.Left :=LNewThumbPosX;
    end;

  end;
  inherited;
end;

{*****************************************************************************************}
procedure TALDynamicSwitch.MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Single);
begin
  inherited;
  if fScrollCapturedByMe then begin
    FScrollCapturedByMe := False;
    var LChecked: Boolean;
    if fThumb.Left + (fThumb.Width / 2) < Track.Width / 2 then LChecked := False
    else LChecked := True;
    if LChecked <> Checked then begin
      if (transition.DelayClick) and
         (compareValue(FTransition.Duration,0.0,TEpsilon.Scale) > 0) then
        Thumb.StateStyles.Transition.ClickDelayed := True;
      FTrack.Checked := LChecked;
      FThumb.Checked := LChecked;
      if not Thumb.StateStyles.Transition.ClickDelayed then
        DoChange;
    end;
    fThumb.Align := TALALignLayout.None;
    Transition.Start;
  end;
end;

{************************************}
procedure TALDynamicSwitch.MouseLeave;
begin
  inherited;
  if fScrollCapturedByMe then begin
    FScrollCapturedByMe := False;
    var LChecked: Boolean;
    if fThumb.Left + (fThumb.Width / 2) < Track.Width / 2 then LChecked := False
    else LChecked := True;
    if LChecked <> Checked then begin
      if (transition.DelayClick) and
         (compareValue(FTransition.Duration,0.0,TEpsilon.Scale) > 0) then
        Thumb.StateStyles.Transition.ClickDelayed := True;
      FTrack.Checked := LChecked;
      FThumb.Checked := LChecked;
      if not Thumb.StateStyles.Transition.ClickDelayed then
        DoChange;
    end;
    fThumb.Align := TALALignLayout.None;
    Transition.Start;
  end;
end;

{**************************************}
procedure TALDynamicSwitch.DoClickSound;
begin
  if (ClickSound=TALClickSoundMode.Always) or
     ((ClickSound=TALClickSoundMode.Default) and ALGlobalClickSoundEnabled) then
    ALPlayClickSound;
end;

{*******************************}
procedure TALDynamicSwitch.Click;
begin
  // If fScrollCapturedByMe is true, the MouseUp event will handle the task.
  if fScrollCapturedByMe then Exit
  // If Pressed is true, it means this event is triggered by MouseDown/MouseUp.
  // In this case, if a delay is requested for the click, apply the delay.
  else if (Pressed) and
          (Transition.DelayClick) and
          (compareValue(FTransition.Duration,0.0,TEpsilon.Scale) > 0) then begin
    Thumb.StateStyles.Transition.ClickDelayed := True;
    var LChecked := not Checked;
    FTrack.Checked := LChecked;
    FThumb.Checked := LChecked;
    fThumb.Align := TALALignLayout.None;
    Transition.Start;
    exit;
  end
  // If Pressed is true, it means this event is triggered by MouseDown/MouseUp.
  else if Pressed then begin
    var LChecked := not Checked;
    FTrack.Checked := LChecked;
    FThumb.Checked := LChecked;
    fThumb.Align := TALALignLayout.None;
    DoChange;
    inherited;
    Transition.Start;
  end
  // if not Pressed, it means this event is triggered by event like TransitionAnimationFinish
  else begin
    DoChange;
    inherited;
    AlignThumb;
  end;
end;

{************************************************************************************************}
procedure TALDynamicSwitch.ScrollCapturedByOtherHandler(const Sender: TObject; const M: TMessage);
begin
  if (Sender = self) then exit;
  {$IFDEF DEBUG}
  //ALLog(
  //  'TALDynamicSwitch.ScrollCapturedByOtherHandler',
  //  'Captured: ' + ALBoolToStrW(TALScrollCapturedMessage(M).Captured)+ ' | ' +
  //  'Pressed: ' + ALBoolToStrW(Pressed));
  {$ENDIF}
  if TALScrollCapturedMessage(M).Captured then begin
    {$IFDEF DEBUG}
    if fScrollCapturedByMe then
      raise Exception.Create('Error 6C41BEC8-3AE9-4EC0-9D80-117ED5697397');
    {$ENDIF}
    Pressed := False;
  end;
end;

{***********************************************}
function TALDynamicSwitch.GetCacheIndex: integer;
begin
  Result := FThumb.CacheIndex;
end;

{**************************************************************}
procedure TALDynamicSwitch.SetCacheIndex(const AValue: Integer);
begin
  FThumb.CacheIndex := AValue;
  FTrack.CacheIndex := AValue;
end;

{******************************************************************}
function TALDynamicSwitch.GetCacheEngine: TALBufDrawableCacheEngine;
begin
  Result := FThumb.CacheEngine;
end;

{*********************************************************************************}
procedure TALDynamicSwitch.SetCacheEngine(const AValue: TALBufDrawableCacheEngine);
begin
  FThumb.CacheEngine := AValue;
  FTrack.CacheEngine := AValue;
end;

{***********************************************}
function TALDynamicSwitch.GetMinThumbPos: Single;
begin
  result := Track.Padding.left + fThumb.Margins.left;
end;

{***********************************************}
function TALDynamicSwitch.GetMaxThumbPos: Single;
begin
  result := Track.Width - fThumb.Width - Track.Padding.Right - fThumb.Margins.Right;
end;

{************************************}
procedure TALDynamicSwitch.AlignThumb;
begin
  //**if csLoading in ComponentState then exit;
  if pressed or fScrollCapturedByMe then exit;
  If Checked then FThumb.Align := TALAlignLayout.right
  else FThumb.Align := TALAlignLayout.left;
end;

{********************************************}
function TALDynamicSwitch.GetChecked: boolean;
begin
  Result := FTrack.Checked and FThumb.Checked;
end;

{**********************************************************}
procedure TALDynamicSwitch.SetChecked(const Value: Boolean);
begin
  if GetChecked <> Value then begin
    FTrack.Checked := Value;
    FThumb.Checked := Value;
    AlignThumb;
    DoChange;
  end;
end;

{***********************************************************}
function TALDynamicButton.TFill.GetDefaultColor: TAlphaColor;
begin
  Result := $ffe1e1e1;
end;

{*************************************************************}
function TALDynamicButton.TStroke.GetDefaultColor: TAlphaColor;
begin
  Result := $ffadadad;
end;

{**************************************************************************}
function TALDynamicButton.TTextSettings.TFont.GetDefaultWeight: TFontWeight;
begin
  Result := TFontWeight.medium;
end;

{**********************************************************}
function TALDynamicButton.TTextSettings.CreateFont: TALFont;
begin
  Result := TFont.Create;
end;

{****************************************************************************}
function TALDynamicButton.TTextSettings.GetDefaultHorzAlign: TALTextHorzAlign;
begin
  Result := TALTextHorzAlign.center;
end;

{***************************************************************************}
function TALDynamicButton.TBaseStateStyle.TFill.GetDefaultColor: TAlphaColor;
begin
  Result := $FFE1E1E1;
end;

{*****************************************************************************}
function TALDynamicButton.TBaseStateStyle.TStroke.GetDefaultColor: TAlphaColor;
begin
  Result := $FFADADAD;
end;

{******************************************************************************************}
function TALDynamicButton.TBaseStateStyle.TTextSettings.TFont.GetDefaultWeight: TFontWeight;
begin
  Result := TFontWeight.medium;
end;

{**************************************************************************}
function TALDynamicButton.TBaseStateStyle.TTextSettings.CreateFont: TALFont;
begin
  Result := TFont.Create;
end;

{**************************************************************************}
constructor TALDynamicButton.TBaseStateStyle.Create(const AParent: TObject);
begin
  inherited Create(AParent);
  FText := DefaultText;
  if StateStyleParent <> nil then FTextSettings := CreateTextSettings(StateStyleParent.TextSettings)
  else if ControlParent <> nil then FTextSettings := CreateTextSettings(ControlParent.TextSettings)
  else FTextSettings := CreateTextSettings(nil);
  FTextSettings.OnChanged := TextSettingsChanged;
  FXRadius := DefaultXRadius;
  FYRadius := DefaultYRadius;
end;

{**************************************************}
destructor TALDynamicButton.TBaseStateStyle.Destroy;
begin
  ALFreeAndNil(FTextSettings);
  inherited Destroy;
end;

{*********************************************************************************************}
function TALDynamicButton.TBaseStateStyle.CreateFill(const AParent: TALBrush): TALInheritBrush;
begin
  Result := TFill.Create(AParent);
end;

{***********************************************************************************************************}
function TALDynamicButton.TBaseStateStyle.CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush;
begin
  Result := TStroke.Create(AParent);
end;

{******************************************************************************************************************************}
function TALDynamicButton.TBaseStateStyle.CreateTextSettings(const AParent: TALBaseTextSettings): TBaseStateStyle.TTextSettings;
begin
  Result := TTextSettings.Create(AParent);
end;

{*********************************************************************}
procedure TALDynamicButton.TBaseStateStyle.Assign(Source: TPersistent);
begin
  if Source is TBaseStateStyle then begin
    BeginUpdate;
    Try
      Text := TBaseStateStyle(Source).text;
      TextSettings.Assign(TBaseStateStyle(Source).TextSettings);
      XRadius := TBaseStateStyle(Source).XRadius;
      YRadius := TBaseStateStyle(Source).YRadius;
      inherited Assign(Source);
    Finally
      EndUpdate;
    End;
  end
  else
    ALAssignError(Source{ASource}, Self{ADest});
end;

{***********************************************}
procedure TALDynamicButton.TBaseStateStyle.Reset;
begin
  BeginUpdate;
  Try
    inherited;
    Text := DefaultText;
    TextSettings.reset;
    XRadius := DefaultXRadius;
    YRadius := DefaultYRadius;
  finally
    EndUpdate;
  end;
end;

{******************************************************}
procedure TALDynamicButton.TBaseStateStyle.AlignToPixel;
begin
  BeginUpdate;
  Try
    inherited;
    TextSettings.AlignToPixel;
  finally
    EndUpdate;
  end;
end;

{**********************************************************}
procedure TALDynamicButton.TBaseStateStyle.ApplyColorScheme;
begin
  BeginUpdate;
  Try
    inherited;
    TextSettings.ApplyColorScheme;
  finally
    EndUpdate;
  end;
end;

{**************************************************************************************************************************************************}
procedure TALDynamicButton.TBaseStateStyle.Interpolate(const ATo: TALDynamicBaseStateStyle; const ANormalizedTime: Single; const AReverse: Boolean);
begin
  {$IF defined(debug)}
  if (ATo <> nil) and (not (ATo is TBaseStateStyle)) then
    Raise Exception.Create('Error F3C72244-894F-4B67-AD86-F24DF5039927');
  {$ENDIF}
  BeginUpdate;
  try
    Inherited Interpolate(ATo, ANormalizedTime, AReverse);
    if ATo <> nil then begin
      if not AReverse then Text := TBaseStateStyle(ATo).Text;
      TextSettings.Interpolate(TBaseStateStyle(ATo).TextSettings, ANormalizedTime, AReverse);
      XRadius := InterpolateSingle(XRadius{Start}, TBaseStateStyle(ATo).XRadius{Stop}, ANormalizedTime);
      YRadius := InterpolateSingle(YRadius{Start}, TBaseStateStyle(ATo).YRadius{Stop}, ANormalizedTime);
    end
    else if StateStyleParent <> nil then begin
      StateStyleParent.SupersedeNoChanges(true{ASaveState});
      try
        if not AReverse then Text := StateStyleParent.Text;
        TextSettings.Interpolate(StateStyleParent.TextSettings, ANormalizedTime, AReverse);
        XRadius := InterpolateSingle(XRadius{Start}, StateStyleParent.XRadius{Stop}, ANormalizedTime);
        YRadius := InterpolateSingle(YRadius{Start}, StateStyleParent.YRadius{Stop}, ANormalizedTime);
      finally
        StateStyleParent.RestoreStateNoChanges;
      end;
    end
    else if ControlParent <> nil then begin
      if not AReverse then Text := ControlParent.Text;
      TextSettings.Interpolate(ControlParent.TextSettings, ANormalizedTime, AReverse);
      XRadius := InterpolateSingle(XRadius{Start}, ControlParent.XRadius{Stop}, ANormalizedTime);
      YRadius := InterpolateSingle(YRadius{Start}, ControlParent.YRadius{Stop}, ANormalizedTime);
    end
    else begin
      if not AReverse then Text := DefaultText;
      TextSettings.Interpolate(nil, ANormalizedTime, AReverse);
      XRadius := InterpolateSingle(XRadius{Start}, ALIfThen(IsNaN(DefaultXRadius), 0, DefaultXRadius){Stop}, ANormalizedTime);
      YRadius := InterpolateSingle(YRadius{Start}, ALIfThen(IsNaN(DefaultYRadius), 0, DefaultYRadius){Stop}, ANormalizedTime);
    end;
  finally
    EndUpdate;
  end;
end;

{*****************************************************}
procedure TALDynamicButton.TBaseStateStyle.DoSupersede;
begin
  Inherited;
  if Text = '' then begin
    if StateStyleParent <> nil then Text := StateStyleParent.Text
    else Text := ControlParent.Text;
  end;
  if IsNaN(XRadius) then begin
    if StateStyleParent <> nil then XRadius := StateStyleParent.XRadius
    else XRadius := ControlParent.XRadius;
  end;
  if IsNaN(YRadius) then begin
    if StateStyleParent <> nil then YRadius := StateStyleParent.YRadius
    else YRadius := ControlParent.YRadius;
  end;
  TextSettings.SuperSede;
end;

{*****************************************************************************}
function TALDynamicButton.TBaseStateStyle.GetStateStyleParent: TBaseStateStyle;
begin
  {$IF defined(debug)}
  if (inherited StateStyleParent <> nil) and
     (not (inherited StateStyleParent is TBaseStateStyle)) then
    raise Exception.Create('StateStyleParent must be of type TBaseStateStyle');
  {$ENDIF}
  Result := TBaseStateStyle(inherited StateStyleParent);
end;

{***************************************************************************}
function TALDynamicButton.TBaseStateStyle.GetControlParent: TALDynamicButton;
begin
  {$IF defined(debug)}
  if (inherited ControlParent <> nil) and
     (not (inherited ControlParent is TALDynamicButton)) then
    raise Exception.Create('ControlParent must be of type TALDynamicButton');
  {$ENDIF}
  Result := TALDynamicButton(inherited ControlParent);
end;

{**********************************************************************}
procedure TALDynamicButton.TBaseStateStyle.SetText(const Value: string);
begin
  if FText <> Value then begin
    FText := Value;
    Change;
  end;
end;

{******************************************************************************************************}
procedure TALDynamicButton.TBaseStateStyle.SetTextSettings(const AValue: TBaseStateStyle.TTextSettings);
begin
  FTextSettings.Assign(AValue);
end;

{*************************************************************************}
procedure TALDynamicButton.TBaseStateStyle.SetXRadius(const Value: Single);
begin
  if IsNan(FXRadius) and IsNan(Value) then Exit;
  if not SameValue(FXRadius, Value, TEpsilon.Vector) then begin
    FXRadius := Value;
    Change;
  end;
end;

{*************************************************************************}
procedure TALDynamicButton.TBaseStateStyle.SetYRadius(const Value: Single);
begin
  if IsNan(FYRadius) and IsNan(Value) then Exit;
  if not SameValue(FYRadius, Value, TEpsilon.Vector) then begin
    FYRadius := Value;
    Change;
  end;
end;

{***************************************************************}
function TALDynamicButton.TBaseStateStyle.GetDefaultText: String;
begin
  Result := '';
end;

{******************************************************************}
function TALDynamicButton.TBaseStateStyle.GetDefaultXRadius: Single;
begin
  Result := NaN;
end;

{******************************************************************}
function TALDynamicButton.TBaseStateStyle.GetDefaultYRadius: Single;
begin
  Result := NaN;
end;

{************************************************************}
function TALDynamicButton.TBaseStateStyle.GetInherit: Boolean;
begin
  Result := inherited GetInherit and
            IsNan(FXRadius) and
            IsNan(FYRadius) and
            Text.IsEmpty and
            TextSettings.Inherit;
end;

{*******************************************************************************}
procedure TALDynamicButton.TBaseStateStyle.TextSettingsChanged(ASender: TObject);
begin
  Change;
end;

{**************************************************************}
function TALDynamicButton.TBaseStateStyle.IsTextStored: Boolean;
begin
  Result := FText <> DefaultText;
end;

{*****************************************************************}
function TALDynamicButton.TBaseStateStyle.IsXRadiusStored: Boolean;
begin
  if IsNan(FXRadius) and IsNan(DefaultXRadius) then Exit(False);
  Result := not SameValue(FXRadius, DefaultXRadius, TEpsilon.Vector);
end;

{*****************************************************************}
function TALDynamicButton.TBaseStateStyle.IsYRadiusStored: Boolean;
begin
  if IsNan(FYRadius) and IsNan(DefaultYRadius) then Exit(False);
  Result := not SameValue(FYRadius, DefaultYRadius, TEpsilon.Vector);
end;

{*********************************************************************}
function TALDynamicButton.TDisabledStateStyle.IsOpacityStored: Boolean;
begin
  Result := not SameValue(FOpacity, TControl.DefaultDisabledOpacity, TEpsilon.Scale);
end;

{*****************************************************************************}
procedure TALDynamicButton.TDisabledStateStyle.SetOpacity(const Value: Single);
begin
  if not SameValue(FOpacity, Value, TEpsilon.Scale) then begin
    FOpacity := Value;
    Change;
  end;
end;

{******************************************************************************}
constructor TALDynamicButton.TDisabledStateStyle.Create(const AParent: TObject);
begin
  inherited Create(AParent);
  FOpacity := TControl.DefaultDisabledOpacity;
end;

{*************************************************************************}
procedure TALDynamicButton.TDisabledStateStyle.Assign(Source: TPersistent);
begin
  BeginUpdate;
  Try
    if Source is TDisabledStateStyle then
      Opacity := TDisabledStateStyle(Source).Opacity
    else
      Opacity := TControl.DefaultDisabledOpacity;
    inherited Assign(Source);
  Finally
    EndUpdate;
  End;
end;

{***************************************************}
procedure TALDynamicButton.TDisabledStateStyle.Reset;
begin
  BeginUpdate;
  Try
    inherited;
    Opacity := TControl.DefaultDisabledOpacity;
  finally
    EndUpdate;
  end;
end;

{****************************************************************}
function TALDynamicButton.TDisabledStateStyle.GetInherit: Boolean;
begin
  // Opacity is not part of the GetInherit function because it updates the
  // disabledOpacity of the base control immediately every time it changes.
  // Essentially, it acts merely as a link to the disabledOpacity of the base control.
  Result := inherited GetInherit;
end;

{**********************************************************************}
function TALDynamicButton.TDisabledStateStyle.GetCacheSubIndex: Integer;
begin
  Result := 1;
end;

{*********************************************************************}
function TALDynamicButton.THoveredStateStyle.GetCacheSubIndex: Integer;
begin
  Result := 2;
end;

{*********************************************************************}
function TALDynamicButton.TPressedStateStyle.GetCacheSubIndex: Integer;
begin
  Result := 3;
end;

{*********************************************************************}
function TALDynamicButton.TFocusedStateStyle.GetCacheSubIndex: Integer;
begin
  Result := 4;
end;

{*********************************************************************************}
constructor TALDynamicButton.TStateStyles.Create(const AParent: TALDynamicControl);
begin
  inherited Create(AParent);
  //--
  FDisabled := CreateDisabledStateStyle(AParent);
  FDisabled.OnChanged := DisabledChanged;
  //--
  FHovered := CreateHoveredStateStyle(AParent);
  FHovered.OnChanged := HoveredChanged;
  //--
  FPressed := CreatePressedStateStyle(AParent);
  FPressed.OnChanged := PressedChanged;
  //--
  FFocused := CreateFocusedStateStyle(AParent);
  FFocused.OnChanged := FocusedChanged;
end;

{***********************************************}
destructor TALDynamicButton.TStateStyles.Destroy;
begin
  ALFreeAndNil(FDisabled);
  ALFreeAndNil(FHovered);
  ALFreeAndNil(FPressed);
  ALFreeAndNil(FFocused);
  inherited Destroy;
end;

{***********************************************************************************************************}
function TALDynamicButton.TStateStyles.CreateDisabledStateStyle(const AParent: TObject): TDisabledStateStyle;
begin
  Result := TDisabledStateStyle.Create(AParent);
end;

{*********************************************************************************************************}
function TALDynamicButton.TStateStyles.CreateHoveredStateStyle(const AParent: TObject): THoveredStateStyle;
begin
  Result := THoveredStateStyle.Create(AParent);
end;

{*********************************************************************************************************}
function TALDynamicButton.TStateStyles.CreatePressedStateStyle(const AParent: TObject): TPressedStateStyle;
begin
  Result := TPressedStateStyle.Create(AParent);
end;

{*********************************************************************************************************}
function TALDynamicButton.TStateStyles.CreateFocusedStateStyle(const AParent: TObject): TFocusedStateStyle;
begin
  Result := TFocusedStateStyle.Create(AParent);
end;

{******************************************************************}
procedure TALDynamicButton.TStateStyles.Assign(Source: TPersistent);
begin
  if Source is TStateStyles then begin
    BeginUpdate;
    Try
      Disabled.Assign(TStateStyles(Source).Disabled);
      Hovered.Assign(TStateStyles(Source).Hovered);
      Pressed.Assign(TStateStyles(Source).Pressed);
      Focused.Assign(TStateStyles(Source).Focused);
      inherited Assign(Source);
    Finally
      EndUpdate;
    End;
  end
  else
    ALAssignError(Source{ASource}, Self{ADest});
end;

{********************************************}
procedure TALDynamicButton.TStateStyles.Reset;
begin
  BeginUpdate;
  Try
    inherited;
    Disabled.reset;
    Hovered.reset;
    Pressed.reset;
    Focused.reset;
  finally
    EndUpdate;
  end;
end;

{***************************************************}
procedure TALDynamicButton.TStateStyles.AlignToPixel;
begin
  BeginUpdate;
  Try
    inherited;
    Disabled.AlignToPixel;
    Hovered.AlignToPixel;
    Pressed.AlignToPixel;
    Focused.AlignToPixel;
  finally
    EndUpdate;
  end;
end;

{*******************************************************}
procedure TALDynamicButton.TStateStyles.ApplyColorScheme;
begin
  BeginUpdate;
  Try
    inherited;
    Disabled.ApplyColorScheme;
    Hovered.ApplyColorScheme;
    Pressed.ApplyColorScheme;
    Focused.ApplyColorScheme;
  finally
    EndUpdate;
  end;
end;

{*******************************************************}
procedure TALDynamicButton.TStateStyles.ClearBufDrawable;
begin
  inherited;
  Disabled.ClearBufDrawable;
  Hovered.ClearBufDrawable;
  Pressed.ClearBufDrawable;
  Focused.ClearBufDrawable;
end;

{**********************************************************************************}
function TALDynamicButton.TStateStyles.GetCurrentRawStyle: TALDynamicBaseStateStyle;
begin
  if Not Parent.Enabled then Result := Disabled
  else if Parent.Pressed then Result := Pressed
  //**else if Parent.IsFocused then Result := Focused
  else if Parent.IsMouseOver then Result := Hovered
  else result := nil;
end;

{*****************************************************************}
function TALDynamicButton.TStateStyles.GetParent: TALDynamicButton;
begin
  Result := TALDynamicButton(inherited Parent);
end;

{*************************************************************************************}
procedure TALDynamicButton.TStateStyles.SetDisabled(const AValue: TDisabledStateStyle);
begin
  FDisabled.Assign(AValue);
end;

{***********************************************************************************}
procedure TALDynamicButton.TStateStyles.SetHovered(const AValue: THoveredStateStyle);
begin
  FHovered.Assign(AValue);
end;

{***********************************************************************************}
procedure TALDynamicButton.TStateStyles.SetPressed(const AValue: TPressedStateStyle);
begin
  FPressed.Assign(AValue);
end;

{***********************************************************************************}
procedure TALDynamicButton.TStateStyles.SetFocused(const AValue: TFocusedStateStyle);
begin
  FFocused.Assign(AValue);
end;

{************************************************************************}
procedure TALDynamicButton.TStateStyles.DisabledChanged(ASender: TObject);
begin
  Change;
end;

{***********************************************************************}
procedure TALDynamicButton.TStateStyles.HoveredChanged(ASender: TObject);
begin
  Change;
end;

{***********************************************************************}
procedure TALDynamicButton.TStateStyles.PressedChanged(ASender: TObject);
begin
  Change;
end;

{***********************************************************************}
procedure TALDynamicButton.TStateStyles.FocusedChanged(ASender: TObject);
begin
  Change;
end;

{***************************************************************************}
constructor TALDynamicButton.TLoadingIndicator.Create(const AOwner: TObject);
begin
  inherited;
  FTransitionAnimation := TALFloatAnimation.Create;
  FTransitionAnimation.OnProcess := TransitionAnimationProcess;
  FTransitionAnimation.OnFinish := TransitionAnimationFinish;
  FTransitionAnimation.Duration := 0.2;
  FTransitionPhase := TTransitionPhase.Idle;
  FTransitionKind := TTransitionKind.CollapseWidth;
  Align := TALAlignLayout.VertCenter;
  Visible := False;
end;

{****************************************************}
destructor TALDynamicButton.TLoadingIndicator.Destroy;
begin
  ALFreeAndNil(FTransitionAnimation);
  inherited;
end;

{*************************************************************}
procedure TALDynamicButton.TLoadingIndicator.BeforeDestruction;
begin
  if BeforeDestructionExecuted then exit;
  // Necessary if the control is destroyed using
  // AlFreeAndNil with the delayed flag
  FTransitionAnimation.Enabled := False;
  inherited;
end;

{***************************************************************************************}
procedure TALDynamicButton.TLoadingIndicator.TransitionAnimationProcess(Sender: TObject);
begin
  If TransitionPhase in [TLoadingIndicator.TTransitionPhase.LoadingIndicatorIn,
                         TLoadingIndicator.TTransitionPhase.LoadingIndicatorOut] then begin
    case FTransitionKind of
      TTransitionKind.CollapseWidth: Scale := TPointF.create(FTransitionAnimation.CurrentValue, Scale.Y);
      TTransitionKind.CollapseHeight: Scale := TPointF.create(Scale.X, FTransitionAnimation.CurrentValue);
      TTransitionKind.CollapseBoth: Scale := TPointF.create(FTransitionAnimation.CurrentValue, FTransitionAnimation.CurrentValue);
      else Raise Exception.Create('Error 3AFB95DD-9B2A-47B2-8D92-929C1EA545B3')
    end;
  end
  else if Owner <> nil then
    Owner.Repaint;
end;

{**************************************************************************************}
procedure TALDynamicButton.TLoadingIndicator.TransitionAnimationFinish(Sender: TObject);
begin
  case FTransitionPhase of
    // ButtonOut
    TTransitionPhase.ButtonOut: begin
      Visible := True;
      FTransitionPhase := TTransitionPhase.LoadingIndicatorIn;
      FTransitionAnimation.Enabled := False;
      FTransitionAnimation.InterpolationType := TALInterpolationType.Material3EmphasizedDecelerate;
      FTransitionAnimation.StartValue := 0;
      FTransitionAnimation.StopValue := 1;
      FTransitionAnimation.Start;
    end;
    // ButtonIn
    TTransitionPhase.ButtonIn: begin
      Visible := False;
      FTransitionPhase := TTransitionPhase.Idle;
    end;
    // LoadingIndicatorOut
    TTransitionPhase.LoadingIndicatorOut: begin
      Visible := False;
      FTransitionPhase := TTransitionPhase.ButtonIn;
      FTransitionAnimation.Enabled := False;
      FTransitionAnimation.InterpolationType := TALInterpolationType.Material3EmphasizedDecelerate;
      FTransitionAnimation.StartValue := 0;
      FTransitionAnimation.StopValue := 1;
      FTransitionAnimation.Start;
    end;
    // LoadingIndicatorIn
    TTransitionPhase.LoadingIndicatorIn: begin
      FTransitionPhase := TTransitionPhase.Idle;
    end;
    // Error
    else
      Raise Exception.create('Error 287EE611-AC66-4B57-B916-4BD5CB195128')
  end;
end;

{*********************************************************}
function TALDynamicButton.TPadding.GetDefaultValue: TRectF;
begin
  Result := TRectF.Create(12{Left}, 6{Top}, 12{Right}, 6{Bottom});
end;

{*********************************************************}
constructor TALDynamicButton.Create(const AOwner: TObject);
begin
  {$IF defined(ALDPK)}
  FPrevStateStyles := nil;
  {$ENDIF}
  FStateStyles := nil;
  //--
  inherited Create(AOwner);
  //--
  //**CanFocus := True;
  HitTest := True;
  AutoSize := TALAutoSizeMode.Both;
  Cursor := crHandPoint;
  //--
  //**var LPaddingChange: TNotifyEvent := Padding.OnChange;
  //**Padding.OnChange := nil;
  //**Padding.DefaultValue := TRectF.create(12{Left}, 6{Top}, 12{Right}, 6{Bottom});
  //**Padding.Rect := Padding.DefaultValue;
  //**padding.OnChange := LPaddingChange;
  //--
  {$IF defined(ALDPK)}
  FPrevStateStyles := TStateStyles.Create(nil);
  {$ENDIF}
  //--
  FStateStyles := CreateStateStyles;
  FStateStyles.OnChanged := StateStylesChanged;
  //--
  FLoadingIndicator := nil;
end;

{*************************************************}
function TALDynamicButton.CreatePadding: TALBounds;
begin
  Result := TPadding.Create;
end;

{**********************************}
destructor TALDynamicButton.Destroy;
begin
  {$IF defined(ALDPK)}
  ALFreeAndNil(FPrevStateStyles);
  {$ENDIF}
  ALFreeAndNil(FStateStyles);
  inherited Destroy;
end;

{***********************************************************}
procedure TALDynamicButton.Assign(Source: TALDynamicControl);
begin
  BeginUpdate;
  Try
    if Source is TALDynamicButton then begin
      StateStyles.Assign(TALDynamicButton(Source).StateStyles);
    end
    else
      ALAssignError(Source{ASource}, Self{ADest});
    inherited Assign(Source);
  Finally
    EndUpdate;
  End;
end;

{**************************************}
procedure TALDynamicButton.AlignToPixel;
begin
  BeginUpdate;
  try
    inherited;
    StateStyles.AlignToPixel;
  finally
    EndUpdate;
  end;
end;

{******************************************}
procedure TALDynamicButton.ApplyColorScheme;
begin
  BeginUpdate;
  try
    inherited;
    StateStyles.ApplyColorScheme;
  finally
    EndUpdate;
  end;
end;

{*********************************************}
function TALDynamicButton.CreateFill: TALBrush;
begin
  Result := TFill.Create;
end;

{*****************************************************}
function TALDynamicButton.CreateStroke: TALStrokeBrush;
begin
  Result := TStroke.Create;
end;

{****************************************************************}
function TALDynamicButton.CreateTextSettings: TALBaseTextSettings;
begin
  Result := TTextSettings.Create;
end;

{********************************************************}
function TALDynamicButton.CreateStateStyles: TStateStyles;
begin
  Result := TStateStyles.Create(self);
end;

{*******************************************************}
function TALDynamicButton.GetTextSettings: TTextSettings;
begin
  Result := TTextSettings(Inherited TextSettings);
end;

{*********************************************************************}
procedure TALDynamicButton.SetTextSettings(const Value: TTextSettings);
begin
  Inherited SetTextSettings(Value);
end;

{******************************************************************}
//**procedure TALDynamicButton.SetName(const Value: TComponentName);
//**begin
//**  var LChangeText := not (csLoading in ComponentState) and (Name = Text) and
//**    ((Owner = nil) or not (csLoading in TComponent(Owner).ComponentState));
//**  inherited SetName(Value);
//**  if LChangeText then
//**    Text := Value;
//**end;

{********************************************************************}
procedure TALDynamicButton.SetStateStyles(const AValue: TStateStyles);
begin
  FStateStyles.Assign(AValue);
end;

{**************************************************************}
procedure TALDynamicButton.TextSettingsChanged(Sender: TObject);

  {~~~~~~~~~~~~~~~~~~}
  {$IF defined(ALDPK)}
  procedure _PropagateChanges(const APrevStateStyle: TBaseStateStyle; const AToStateStyle: TBaseStateStyle);
  begin

    if //**(not (csLoading in ComponentState)) and
       (not AToStateStyle.TextSettings.inherit) then begin

      if APrevStateStyle.TextSettings.font.Family = AToStateStyle.TextSettings.font.Family then AToStateStyle.TextSettings.font.Family := TextSettings.font.Family;
      if SameValue(APrevStateStyle.TextSettings.font.Size, AToStateStyle.TextSettings.font.Size, TEpsilon.fontSize) then AToStateStyle.TextSettings.font.Size := TextSettings.font.Size;
      if APrevStateStyle.TextSettings.font.Weight = AToStateStyle.TextSettings.font.Weight then AToStateStyle.TextSettings.font.Weight := TextSettings.font.Weight;
      if APrevStateStyle.TextSettings.font.Slant = AToStateStyle.TextSettings.font.Slant then AToStateStyle.TextSettings.font.Slant := TextSettings.font.Slant;
      if APrevStateStyle.TextSettings.font.Stretch = AToStateStyle.TextSettings.font.Stretch then AToStateStyle.TextSettings.font.Stretch := TextSettings.font.Stretch;
      if (APrevStateStyle.TextSettings.font.Color = AToStateStyle.TextSettings.font.Color) and
         (APrevStateStyle.TextSettings.font.ColorKey = AToStateStyle.TextSettings.font.ColorKey) then begin
        AToStateStyle.TextSettings.font.Color := TextSettings.font.Color;
        AToStateStyle.TextSettings.font.ColorKey := TextSettings.font.ColorKey;
      end;

      if APrevStateStyle.TextSettings.Decoration.Kinds = AToStateStyle.TextSettings.Decoration.Kinds then AToStateStyle.TextSettings.Decoration.Kinds := TextSettings.Decoration.Kinds;
      if APrevStateStyle.TextSettings.Decoration.Style = AToStateStyle.TextSettings.Decoration.Style then AToStateStyle.TextSettings.Decoration.Style := TextSettings.Decoration.Style;
      if SameValue(APrevStateStyle.TextSettings.Decoration.ThicknessMultiplier, AToStateStyle.TextSettings.Decoration.ThicknessMultiplier, TEpsilon.Scale) then AToStateStyle.TextSettings.Decoration.ThicknessMultiplier := TextSettings.Decoration.ThicknessMultiplier;
      if (APrevStateStyle.TextSettings.Decoration.Color = AToStateStyle.TextSettings.Decoration.Color) and
         (APrevStateStyle.TextSettings.Decoration.ColorKey = AToStateStyle.TextSettings.Decoration.ColorKey) then begin
        AToStateStyle.TextSettings.Decoration.Color := TextSettings.Decoration.Color;
        AToStateStyle.TextSettings.Decoration.ColorKey := TextSettings.Decoration.ColorKey;
      end;

    end;

    APrevStateStyle.TextSettings.font.Family := TextSettings.font.Family;
    APrevStateStyle.TextSettings.font.Size := TextSettings.font.Size;
    APrevStateStyle.TextSettings.font.Weight := TextSettings.font.Weight;
    APrevStateStyle.TextSettings.font.Slant := TextSettings.font.Slant;
    APrevStateStyle.TextSettings.font.Stretch := TextSettings.font.Stretch;
    APrevStateStyle.TextSettings.font.Color := TextSettings.font.Color;
    APrevStateStyle.TextSettings.font.ColorKey := TextSettings.font.ColorKey;

    APrevStateStyle.TextSettings.Decoration.Kinds := TextSettings.Decoration.Kinds;
    APrevStateStyle.TextSettings.Decoration.Style := TextSettings.Decoration.Style;
    APrevStateStyle.TextSettings.Decoration.ThicknessMultiplier := TextSettings.Decoration.ThicknessMultiplier;
    APrevStateStyle.TextSettings.Decoration.Color := TextSettings.Decoration.Color;
    APrevStateStyle.TextSettings.Decoration.ColorKey := TextSettings.Decoration.ColorKey;

  end;
  {$ENDIF}

begin
  {$IF defined(ALDPK)}
  if (StateStyles <> nil) and (FPrevStateStyles <> nil) then begin
    _PropagateChanges(FPrevStateStyles.Disabled, StateStyles.Disabled);
    _PropagateChanges(FPrevStateStyles.Hovered, StateStyles.Hovered);
    _PropagateChanges(FPrevStateStyles.Pressed, StateStyles.Pressed);
    _PropagateChanges(FPrevStateStyles.Focused, StateStyles.Focused);
  end;
  {$ENDIF}
  inherited;
end;

{*************************************************************}
procedure TALDynamicButton.StateStylesChanged(Sender: TObject);
begin
  ClearBufDrawable;
  DisabledOpacity := StateStyles.Disabled.opacity;
  Repaint;
end;

{********************************************}
procedure TALDynamicButton.IsMouseOverChanged;
begin
  inherited;
  StateStyles.Transition.Start;
  repaint;
end;

{**********************************************}
//**procedure TALDynamicButton.IsFocusedChanged;
//**begin
//**  inherited;
//**  StateStyles.Transition.Start;
//**  repaint;
//**end;

{****************************************}
procedure TALDynamicButton.PressedChanged;
begin
  inherited;
  StateStyles.Transition.Start;
  repaint;
end;

{*******************************}
procedure TALDynamicButton.Click;
begin
  if (FLoadingIndicator <> nil) and
     (FLoadingIndicator.TransitionAnimation.Running) then exit;
  if StateStyles.Transition.Running and StateStyles.Transition.DelayClick then
    StateStyles.Transition.ClickDelayed := True
  else
    inherited click;
end;

{**********************************************}
procedure TALDynamicButton.ShowLoadingIndicator(
            const AResourceName: String = 'alcinoe_loading_indicator';
            const ATintColor: TAlphaColor = TalphaColors.Null;
            const ATransitionKind: TLoadingIndicator.TTransitionKind = TLoadingIndicator.TTransitionKind.CollapseWidth);
begin
  if FLoadingIndicator = nil then begin
    FLoadingIndicator := TLoadingIndicator.Create(self);
    FLoadingIndicator.Owner := Self;
  end;
  FLoadingIndicator.Width := Height;
  FLoadingIndicator.ResourceName := AResourceName;
  FLoadingIndicator.TintColor := ATintColor;
  FLoadingIndicator.TransitionKind := ATransitionKind;

  FLoadingIndicator.TransitionPhase := TLoadingIndicator.TTransitionPhase.ButtonOut;
  FLoadingIndicator.TransitionAnimation.Enabled := False;
  FLoadingIndicator.TransitionAnimation.InterpolationType := TALInterpolationType.Material3EmphasizedAccelerate;
  FLoadingIndicator.TransitionAnimation.StartValue := 1;
  FLoadingIndicator.TransitionAnimation.StopValue := 0;
  FLoadingIndicator.TransitionAnimation.Start;
end;

{**********************************************}
procedure TALDynamicButton.HideLoadingIndicator;
begin
  if (FLoadingIndicator = nil) or (not FLoadingIndicator.visible) then exit;
  FLoadingIndicator.TransitionPhase := TLoadingIndicator.TTransitionPhase.LoadingIndicatorOut;
  FLoadingIndicator.TransitionAnimation.Enabled := False;
  FLoadingIndicator.TransitionAnimation.InterpolationType := TALInterpolationType.Material3EmphasizedAccelerate;
  FLoadingIndicator.TransitionAnimation.StartValue := 1;
  FLoadingIndicator.TransitionAnimation.StopValue := 0;
  FLoadingIndicator.TransitionAnimation.Start;
end;

{******************************************}
procedure TALDynamicButton.ClearBufDrawable;
begin
  {$IFDEF debug}
  if (FStateStyles <> nil) and
     (not IsDestroying) and
     (ALIsDrawableNull(FBufDrawable)) and // warn will be raise in inherited
     ((not ALIsDrawableNull(FStateStyles.Disabled.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.Hovered.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.Pressed.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.Focused.FBufDrawable))) then
    ALLog(Classname + '.ClearBufDrawable', 'BufDrawable has been cleared | Name: ' + Name, TalLogType.warn);
  {$endif}
  if FStateStyles <> nil then
    FStateStyles.ClearBufDrawable;
  inherited ClearBufDrawable;
end;

{*****************************************}
procedure TALDynamicButton.MakeBufDrawable;
begin
  //--- Do not create BufDrawable if not DoubleBuffered
  if {$IF not DEFINED(ALDPK)}(not DoubleBuffered){$ELSE}False{$ENDIF} then begin
    ClearBufDrawable;
    exit;
  end;
  //--
  inherited MakeBufDrawable;
  //--
  var LStateStyle := TBaseStateStyle(StateStyles.GetCurrentRawStyle);
  if LStateStyle = nil then exit;
  if LStateStyle.Inherit then exit;
  if (not ALIsDrawableNull(LStateStyle.FBufDrawable)) then exit;
  if (CacheIndex > 0) and
     (CacheEngine <> nil) and
     (CacheEngine.HasEntry(CacheIndex{AIndex}, GetCacheSubIndex+LStateStyle.CacheSubIndex{ASubIndex})) then Exit;
  LStateStyle.SupersedeNoChanges(true{ASaveState});
  try

    {$IFDEF debug}
    ALLog(Classname + '.MakeBufDrawable', 'Name: ' + Name + ' | Style: ' + LStateStyle.ClassName + ' | Width: ' + ALFloatToStrW(Width)+ ' | Height: ' + ALFloatToStrW(Height));
    {$endif}

    // Create the BufDrawable
    var LTextBroken: Boolean;
    var LAllTextDrawn: Boolean;
    var LElements: TALTextElements;
    CreateBufDrawable(
      LStateStyle.FBufDrawable, // var ABufDrawable: TALDrawable;
      LStateStyle.FBufDrawableRect, // var ABufDrawableRect: TRectF;
      LTextBroken, // var ABufTextBroken: Boolean;
      LAllTextDrawn, // var ABufAllTextDrawn: Boolean;
      LElements, // var ABufElements: TALTextElements;
      ALGetScreenScale * LStateStyle.Scale, // const AScale: Single;
      LStateStyle.Text, // const AText: String;
      LStateStyle.TextSettings.Font, // const AFont: TALFont;
      LStateStyle.TextSettings.Decoration, // const ADecoration: TALTextDecoration;
      LStateStyle.TextSettings.Font, // const AEllipsisFont: TALFont;
      LStateStyle.TextSettings.Decoration, // const AEllipsisDecoration: TALTextDecoration;
      LStateStyle.Fill, // const AFill: TALBrush;
      LStateStyle.StateLayer, // const AStateLayer: TALStateLayer;
      LStateStyle.Stroke, // const AStroke: TALStrokeBrush;
      LStateStyle.Shadow, // const AShadow: TALShadow;
      LStateStyle.XRadius, // const AXRadius: Single;
      LStateStyle.YRadius); // const AYRadius: Single

    // LStateStyle.FBufDrawableRect must include the LScale
    LStateStyle.FBufDrawableRect.Top := LStateStyle.FBufDrawableRect.Top * LStateStyle.Scale;
    LStateStyle.FBufDrawableRect.right := LStateStyle.FBufDrawableRect.right * LStateStyle.Scale;
    LStateStyle.FBufDrawableRect.left := LStateStyle.FBufDrawableRect.left * LStateStyle.Scale;
    LStateStyle.FBufDrawableRect.bottom := LStateStyle.FBufDrawableRect.bottom * LStateStyle.Scale;

    // Since LStateStyle.FBufDrawableRect can have different dimensions than the main BufDrawableRect
    // (due to autosizing with different font sizes), we must center LStateStyle.FBufDrawableRect
    // within the main BufDrawableRect to ensure that all changes are visually centered.
    var LMainDrawableRect: TRectF;
    if (CacheIndex <= 0) or
       (CacheEngine = nil) or
       (not CacheEngine.TryGetEntry(CacheIndex{AIndex}, GetCacheSubIndex{ASubIndex}, LMainDrawableRect{ARect})) then begin
      If AlIsDrawableNull(FBufDrawable) then LMainDrawableRect :=LocalRect.ReducePrecision
      else LMainDrawableRect := FBufDrawableRect;
    end;
    LMainDrawableRect.Offset(-LMainDrawableRect.Left, -LMainDrawableRect.Top);
    var LCenteredRect := LStateStyle.FBufDrawableRect.CenterAt(LMainDrawableRect);
    LStateStyle.FBufDrawableRect.Offset(LCenteredRect.Left, LCenteredRect.top);

  finally
    LStateStyle.RestorestateNoChanges;
  end;
end;

{*********************************************************************************************************************************************************************}
Procedure TALDynamicButton.DrawMultilineTextAdjustRect(const ACanvas: TALCanvas; const AOptions: TALMultiLineTextOptions; var ARect: TrectF; var ASurfaceSize: TSizeF);
begin

  // If we are drawing directly on the form, center ARect in LocalRect. This is necessary if, for example,
  // the 'to' font size is smaller than the 'from' font size.
  {$IF defined(ALSkiaCanvas)}
  If (Canvas <> nil) and (TSkCanvasCustom(Canvas).Canvas <> nil) and (TSkCanvasCustom(Canvas).Canvas.Handle = ACanvas) then
    // ALAlignToPixelRound is used because when we call ALDrawDrawable,
    // we do LDstRect := AALAlignToPixelRound(LDstRect).
    // Therefore, when drawing directly on the canvas,
    // we must draw at the exact same position as when we call ALDrawDrawable.
    ARect := ALAlignToPixelRound(ARect.CenterAt(LocalRect.ReducePrecision), Canvas.Matrix, Canvas.Scale, TEpsilon.position)
  else
  {$ENDIF}

end;

{*****************************}
{$IF NOT DEFINED(ALSkiaCanvas)}
function TALDynamicButton.GetRenderTargetRect(const ARect: TrectF): TRectF;
begin
  if StateStyles.Transition.Running then begin
    Result := ARect;
    if StateStyles.Transition.FromStateStyle <> nil then begin
      var LFromSurfaceRect := ALGetShapeSurfaceRect(
                                ARect, // const ARect: TRectF;
                                AutoAlignToPixel, // const AAlignToPixel: Boolean;
                                _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.FromStateStyle).Fill, // const AFill: TALBrush;
                                nil, // const AFillResourceStream: TStream;
                                _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.FromStateStyle).StateLayer, // const AStateLayer: TALStateLayer;
                                _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.FromStateStyle).Shadow); // const AShadow: TALShadow): TRectF;
      Result := TRectF.Union(Result, LFromSurfaceRect); // add the extra space needed to draw the shadow/statelayer
    end;
    if StateStyles.Transition.ToStateStyle <> nil then begin
      var LToSurfaceRect := ALGetShapeSurfaceRect(
                              ARect, // const ARect: TRectF;
                              AutoAlignToPixel, // const AAlignToPixel: Boolean;
                              _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.ToStateStyle).Fill, // const AFill: TALBrush;
                              nil, // const AFillResourceStream: TStream;
                              _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.ToStateStyle).StateLayer, // const AStateLayer: TALStateLayer;
                              _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.ToStateStyle).Shadow); // const AShadow: TALShadow): TRectF;
      Result := TRectF.Union(Result, LToSurfaceRect); // add the extra space needed to draw the shadow/statelayer
    end;
  end
  else begin
    var LStateStyle := TBaseStateStyle(StateStyles.GetCurrentRawStyle);
    if LStateStyle <> nil then begin
      Result := ALGetShapeSurfaceRect(
                  ARect, // const ARect: TRectF;
                  AutoAlignToPixel, // const AAlignToPixel: Boolean;
                  LStateStyle.Fill, // const AFill: TALBrush;
                  nil, // const AFillResourceStream: TStream;
                  LStateStyle.StateLayer, // const AStateLayer: TALStateLayer;
                  LStateStyle.Shadow); // const AShadow: TALShadow): TRectF;
    end
    else begin
      Result := ALGetShapeSurfaceRect(
                  ARect, // const ARect: TRectF;
                  AutoAlignToPixel, // const AAlignToPixel: Boolean;
                  Fill, // const AFill: TALBrush;
                  nil, // const AFillResourceStream: TStream;
                  nil, // const AStateLayer: TALStateLayer;
                  Shadow); // const AShadow: TALShadow): TRectF;
    end;
  end;
end;
{$ENDIF}

{*******************************}
procedure TALDynamicButton.Paint;
begin

  var LSavedMatrix := Canvas.Matrix;
  if FLoadingIndicator <> nil then begin
    if FLoadingIndicator.Visible then exit;
    if FLoadingIndicator.TransitionAnimation.Running then begin
      var LMatrixPivotPoint: TpointF;
      LMatrixPivotPoint.X := (Width / 2) + Canvas.Matrix.m31;
      LMatrixPivotPoint.Y := (Height / 2) + Canvas.Matrix.m32;
      var LMatrix := Canvas.Matrix;
      LMatrix := LMatrix * TMatrix.CreateTranslation(-LMatrixPivotPoint.X,-LMatrixPivotPoint.Y);
      case FLoadingIndicator.TransitionKind of
        TLoadingIndicator.TTransitionKind.CollapseWidth: LMatrix := LMatrix * TMatrix.CreateScaling(FLoadingIndicator.TransitionAnimation.CurrentValue{AScaleX}, 1{AScaleY});
        TLoadingIndicator.TTransitionKind.CollapseHeight: LMatrix := LMatrix * TMatrix.CreateScaling(1{AScaleX}, FLoadingIndicator.TransitionAnimation.CurrentValue{AScaleY});
        TLoadingIndicator.TTransitionKind.CollapseBoth: LMatrix := LMatrix * TMatrix.CreateScaling(FLoadingIndicator.TransitionAnimation.CurrentValue{AScaleX}, FLoadingIndicator.TransitionAnimation.CurrentValue{AScaleY});
        else Raise Exception.Create('Error 27862E0A-9BD8-461A-BDFB-FC6A43F3A387')
      end;
      LMatrix := LMatrix * TMatrix.CreateTranslation(LMatrixPivotPoint.X,LMatrixPivotPoint.Y);
      Canvas.SetMatrix(LMatrix);
    end;
  end;
  try

    StateStyles.UpdateLastPaintedRawStyle;

    var LDrawable: TALDrawable := ALNullDrawable;
    var LDrawableRect: TRectF := TRectF.Empty;
    if not StateStyles.Transition.Running then begin
      //--
      var LStateStyle := TBaseStateStyle(StateStyles.GetCurrentRawStyle);
      if LStateStyle <> nil then begin
        if (CacheIndex <= 0) or
           (CacheEngine = nil) or
           (not CacheEngine.TryGetEntry(CacheIndex{AIndex}, GetCacheSubIndex+LStateStyle.CacheSubIndex{ASubIndex}, LDrawable{ADrawable}, LDrawableRect{ARect})) then begin
          MakeBufDrawable;
          if (CacheIndex > 0) and (CacheEngine <> nil) and (not ALIsDrawableNull(LStateStyle.FBufDrawable)) then begin
            if not CacheEngine.TrySetEntry(CacheIndex{AIndex}, GetCacheSubIndex+LStateStyle.CacheSubIndex{ASubIndex}, LStateStyle.FBufDrawable{ADrawable}, LStateStyle.FBufDrawableRect{ARect}) then ALFreeAndNilDrawable(LStateStyle.FBufDrawable)
            else LStateStyle.FBufDrawable := ALNullDrawable;
            if not CacheEngine.TryGetEntry(CacheIndex{AIndex}, GetCacheSubIndex+LStateStyle.CacheSubIndex{ASubIndex}, LDrawable{ADrawable}, LDrawableRect{ARect}) then
              raise Exception.Create('Error BB5ACD27-7CF2-44D3-AEB1-22C8BB492762');
          end
          else begin
            LDrawable := LStateStyle.FBufDrawable;
            LDrawableRect := LStateStyle.FBufDrawableRect;
          end;
        end;
      end;
      //--
      If ALIsDrawableNull(LDrawable) then begin
        if (CacheIndex <= 0) or
           (CacheEngine = nil) or
           (not CacheEngine.TryGetEntry(CacheIndex{AIndex}, GetCacheSubIndex{ASubIndex}, LDrawable{ADrawable}, LDrawableRect{ARect})) then begin
          if LStateStyle = nil then MakeBufDrawable;
          if (CacheIndex > 0) and (CacheEngine <> nil) and (not ALIsDrawableNull(fBufDrawable)) then begin
            if not CacheEngine.TrySetEntry(CacheIndex{AIndex}, GetCacheSubIndex{ASubIndex}, fBufDrawable{ADrawable}, fBufDrawableRect{ARect}) then ALFreeAndNilDrawable(fBufDrawable)
            else fBufDrawable := ALNullDrawable;
            if not CacheEngine.TryGetEntry(CacheIndex{AIndex}, GetCacheSubIndex{ASubIndex}, LDrawable{ADrawable}, LDrawableRect{ARect}) then
              raise Exception.Create('Error BB5ACD27-7CF2-44D3-AEB1-22C8BB492762');
          end
          else begin
            LDrawable := FBufDrawable;
            LDrawableRect := FBufDrawableRect;
          end;
        end;
      end;
      //--
    end;

    if ALIsDrawableNull(LDrawable) then begin

      var LCurrentAdjustedStateStyle := TBaseStateStyle(StateStyles.GetCurrentAdjustedStyle);
      if LCurrentAdjustedStateStyle = nil then begin
        inherited Paint;
        exit;
      end;

      {$IF DEFINED(ALSkiaCanvas)}

      // Using a matrix on the canvas results in smoother animations compared to using
      // Ascale with DrawMultilineText. This is because changes in scale affect the font size,
      // leading to rounding issues (I spent many hours looking for a way to avoid this).
      // If there is an animation, it appears jerky because the text position
      // shifts up or down with scale changes due to pixel alignment.
      var LCanvasSaveState: TCanvasSaveState := ALScaleAndCenterCanvas(
                                                  Canvas, // Const ACanvas: TCanvas;
                                                  AbsoluteRect.ReducePrecision, // Const AAbsoluteRect: TRectF;
                                                  LCurrentAdjustedStateStyle.Scale, // Const AScale: Single;
                                                  true); // Const ASaveState: Boolean);
      try

        var LRect := LocalRect.ReducePrecision;
        var LTextBroken: Boolean;
        var LAllTextDrawn: Boolean;
        var LElements: TALTextElements;
        DrawMultilineText(
          TSkCanvasCustom(Canvas).Canvas.Handle, // const ACanvas: TALCanvas;
          LRect, // var ARect: TRectF;
          LTextBroken, // out ATextBroken: Boolean;
          LAllTextDrawn, // out AAllTextDrawn: Boolean;
          LElements, // out AElements: TALTextElements;
          1{Ascale},
          AbsoluteOpacity, // const AOpacity: Single;
          LCurrentAdjustedStateStyle.Text, // const AText: String;
          LCurrentAdjustedStateStyle.TextSettings.Font, // const AFont: TALFont;
          LCurrentAdjustedStateStyle.TextSettings.Decoration, // const ADecoration: TALTextDecoration;
          LCurrentAdjustedStateStyle.TextSettings.EllipsisSettings.font, // const AEllipsisFont: TALFont;
          LCurrentAdjustedStateStyle.TextSettings.EllipsisSettings.Decoration, // const AEllipsisDecoration: TALTextDecoration;
          LCurrentAdjustedStateStyle.Fill, // const AFill: TALBrush;
          LCurrentAdjustedStateStyle.StateLayer, // const AStateLayer: TALStateLayer;
          LCurrentAdjustedStateStyle.Stroke, // const AStroke: TALStrokeBrush;
          LCurrentAdjustedStateStyle.Shadow, // const AShadow: TALShadow);
          LCurrentAdjustedStateStyle.XRadius, // const AXRadius: Single;
          LCurrentAdjustedStateStyle.YRadius); // const AYRadius: Single

      finally
        if LCanvasSaveState <> nil then
          Canvas.RestoreState(LCanvasSaveState);
      end;

      {$ELSE}

      var LRect := LocalRect.ReducePrecision;
      InitRenderTargets(LRect);
      if ALCanvasBeginScene(RenderTargetCanvas) then
      try

        ALClearCanvas(RenderTargetCanvas, TAlphaColors.Null);

        var LTextBroken: Boolean;
        var LAllTextDrawn: Boolean;
        var LElements: TALTextElements;
        DrawMultilineText(
          RenderTargetCanvas, // const ACanvas: TALCanvas;
          LRect, // out ARect: TRectF;
          LTextBroken, // out ATextBroken: Boolean;
          LAllTextDrawn, // out AAllTextDrawn: Boolean;
          LElements, // out AElements: TALTextElements;
          ALGetScreenScale{Ascale},
          1, // const AOpacity: Single;
          LCurrentAdjustedStateStyle.Text, // const AText: String;
          LCurrentAdjustedStateStyle.TextSettings.Font, // const AFont: TALFont;
          LCurrentAdjustedStateStyle.TextSettings.Decoration, // const ADecoration: TALTextDecoration;
          LCurrentAdjustedStateStyle.TextSettings.EllipsisSettings.font, // const AEllipsisFont: TALFont;
          LCurrentAdjustedStateStyle.TextSettings.EllipsisSettings.Decoration, // const AEllipsisDecoration: TALTextDecoration;
          LCurrentAdjustedStateStyle.Fill, // const AFill: TALBrush;
          LCurrentAdjustedStateStyle.StateLayer, // const AStateLayer: TALStateLayer;
          LCurrentAdjustedStateStyle.Stroke, // const AStroke: TALStrokeBrush;
          LCurrentAdjustedStateStyle.Shadow, // const AShadow: TALShadow;
          LCurrentAdjustedStateStyle.XRadius, // const AXRadius: Single;
          LCurrentAdjustedStateStyle.YRadius); // const AYRadius: Single;

      finally
        ALCanvasEndScene(RenderTargetCanvas)
      end;

      ALUpdateDrawableFromSurface(RenderTargetSurface, RenderTargetDrawable);

      // The Shadow or Statelayer are not included in the dimensions of the LRect rectangle.
      // However, the LRect rectangle is offset by the dimensions of the shadow/Statelayer.
      LRect.Offset(-2*LRect.Left, -2*LRect.Top);

      // LRect must include the LScale
      LRect.Top := LRect.Top * LCurrentAdjustedStateStyle.Scale;
      LRect.right := LRect.right * LCurrentAdjustedStateStyle.Scale;
      LRect.left := LRect.left * LCurrentAdjustedStateStyle.Scale;
      LRect.bottom := LRect.bottom * LCurrentAdjustedStateStyle.Scale;

      // Since LStateStyle.FBufDrawableRect can have different dimensions than the main BufDrawableRect
      // (due to autosizing with different font sizes), we must center LStateStyle.FBufDrawableRect
      // within the main BufDrawableRect to ensure that all changes are visually centered.
      var LMainDrawableRect: TRectF;
      if (CacheIndex <= 0) or
         (CacheEngine = nil) or
         (not CacheEngine.TryGetEntry(CacheIndex{AIndex}, GetCacheSubIndex{ASubIndex}, LMainDrawableRect{ARect})) then begin
        If AlIsDrawableNull(FBufDrawable) then LMainDrawableRect :=LocalRect.ReducePrecision
        else LMainDrawableRect := FBufDrawableRect;
      end;
      LMainDrawableRect.Offset(-LMainDrawableRect.Left, -LMainDrawableRect.Top);
      var LCenteredRect := LRect.CenterAt(LMainDrawableRect);
      LRect.Offset(LCenteredRect.Left, LCenteredRect.top);

      // We cannot use the matrix because, if we do, ALAlignToPixelRound in ALDrawDrawable
      // will be ineffective since the matrix will no longer be a simple translation matrix.
      // In such a case, TCustomCanvasGpu(ACanvas).DrawTexture may produce border artifacts
      // if the texture is not perfectly pixel-aligned.
      var LDstRect := TRectF.Create(0, 0, ALGetDrawableWidth(RenderTargetDrawable), ALGetDrawableHeight(RenderTargetDrawable));
      LDstRect.Width := (LDstRect.Width / ALGetScreenScale) * LCurrentAdjustedStateStyle.Scale;
      LDstRect.height := (LDstRect.height / ALGetScreenScale) * LCurrentAdjustedStateStyle.Scale;
      LDstRect.SetLocation(
        LRect.Left,
        LRect.Top);
      ALDrawDrawable(
        Canvas, // const ACanvas: Tcanvas;
        RenderTargetDrawable, // const ADrawable: TALDrawable;
        LDstRect, // const ADstRect: TrectF; // IN Virtual pixels !
        AbsoluteOpacity); // const AOpacity: Single)

      {$ENDIF}

      exit;
    end;

    ALDrawDrawable(
      Canvas, // const ACanvas: Tcanvas;
      LDrawable, // const ADrawable: TALDrawable;
      LDrawableRect.TopLeft, // const ATopLeft: TpointF;
      AbsoluteOpacity); // const AOpacity: Single);

  finally
    if (FLoadingIndicator <> nil) and
       (FLoadingIndicator.TransitionAnimation.Running) then
      Canvas.SetMatrix(LSavedMatrix);
  end;
end;

{********************************************************************************}
constructor TALDynamicToggleButton.TGroupMessage.Create(const AGroupName: string);
begin
  inherited Create;
  FGroupName := AGroupName;
end;

{*****************************************************************}
function TALDynamicToggleButton.TFill.GetDefaultColor: TAlphaColor;
begin
  Result := $ffe1e1e1;
end;

{*******************************************************************}
function TALDynamicToggleButton.TStroke.GetDefaultColor: TAlphaColor;
begin
  Result := $ffadadad;
end;

{********************************************************************************}
function TALDynamicToggleButton.TTextSettings.TFont.GetDefaultWeight: TFontWeight;
begin
  Result := TFontWeight.medium;
end;

{****************************************************************}
function TALDynamicToggleButton.TTextSettings.CreateFont: TALFont;
begin
  Result := TFont.Create;
end;

{**********************************************************************************}
function TALDynamicToggleButton.TTextSettings.GetDefaultHorzAlign: TALTextHorzAlign;
begin
  Result := TALTextHorzAlign.center;
end;

{*********************************************************************************}
function TALDynamicToggleButton.TBaseStateStyle.TFill.GetDefaultColor: TAlphaColor;
begin
  Result := $FFE1E1E1;
end;

{***********************************************************************************}
function TALDynamicToggleButton.TBaseStateStyle.TStroke.GetDefaultColor: TAlphaColor;
begin
  Result := $FFADADAD;
end;

{************************************************************************************************}
function TALDynamicToggleButton.TBaseStateStyle.TTextSettings.TFont.GetDefaultWeight: TFontWeight;
begin
  Result := TFontWeight.medium;
end;

{********************************************************************************}
function TALDynamicToggleButton.TBaseStateStyle.TTextSettings.CreateFont: TALFont;
begin
  Result := TFont.Create;
end;

{********************************************************************************}
constructor TALDynamicToggleButton.TBaseStateStyle.Create(const AParent: TObject);
begin
  inherited Create(AParent);
  FText := DefaultText;
  if StateStyleParent <> nil then FTextSettings := CreateTextSettings(StateStyleParent.TextSettings)
  else if ControlParent <> nil then FTextSettings := CreateTextSettings(ControlParent.TextSettings)
  else FTextSettings := CreateTextSettings(nil);
  FTextSettings.OnChanged := TextSettingsChanged;
  FXRadius := DefaultXRadius;
  FYRadius := DefaultYRadius;
end;

{********************************************************}
destructor TALDynamicToggleButton.TBaseStateStyle.Destroy;
begin
  ALFreeAndNil(FTextSettings);
  inherited Destroy;
end;

{***************************************************************************************************}
function TALDynamicToggleButton.TBaseStateStyle.CreateFill(const AParent: TALBrush): TALInheritBrush;
begin
  Result := TFill.Create(AParent);
end;

{*****************************************************************************************************************}
function TALDynamicToggleButton.TBaseStateStyle.CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush;
begin
  Result := TStroke.Create(AParent);
end;

{************************************************************************************************************************************}
function TALDynamicToggleButton.TBaseStateStyle.CreateTextSettings(const AParent: TALBaseTextSettings): TBaseStateStyle.TTextSettings;
begin
  Result := TTextSettings.Create(AParent);
end;

{***************************************************************************}
procedure TALDynamicToggleButton.TBaseStateStyle.Assign(Source: TPersistent);
begin
  if Source is TBaseStateStyle then begin
    BeginUpdate;
    Try
      Text := TBaseStateStyle(Source).text;
      TextSettings.Assign(TBaseStateStyle(Source).TextSettings);
      XRadius := TBaseStateStyle(Source).XRadius;
      YRadius := TBaseStateStyle(Source).YRadius;
      inherited Assign(Source);
    Finally
      EndUpdate;
    End;
  end
  else
    ALAssignError(Source{ASource}, Self{ADest});
end;

{*****************************************************}
procedure TALDynamicToggleButton.TBaseStateStyle.Reset;
begin
  BeginUpdate;
  Try
    inherited;
    Text := DefaultText;
    TextSettings.reset;
    XRadius := DefaultXRadius;
    YRadius := DefaultYRadius;
  finally
    EndUpdate;
  end;
end;

{************************************************************}
procedure TALDynamicToggleButton.TBaseStateStyle.AlignToPixel;
begin
  BeginUpdate;
  Try
    inherited;
    TextSettings.AlignToPixel;
  finally
    EndUpdate;
  end;
end;

{****************************************************************}
procedure TALDynamicToggleButton.TBaseStateStyle.ApplyColorScheme;
begin
  BeginUpdate;
  Try
    inherited;
    TextSettings.ApplyColorScheme;
  finally
    EndUpdate;
  end;
end;

{********************************************************************************************************************************************************}
procedure TALDynamicToggleButton.TBaseStateStyle.Interpolate(const ATo: TALDynamicBaseStateStyle; const ANormalizedTime: Single; const AReverse: Boolean);
begin
  {$IF defined(debug)}
  if (ATo <> nil) and (not (ATo is TBaseStateStyle)) then
    Raise Exception.Create('Error F3C72244-894F-4B67-AD86-F24DF5039927');
  {$ENDIF}
  BeginUpdate;
  try
    Inherited Interpolate(ATo, ANormalizedTime, AReverse);
    if ATo <> nil then begin
      if not AReverse then Text := TBaseStateStyle(ATo).Text;
      TextSettings.Interpolate(TBaseStateStyle(ATo).TextSettings, ANormalizedTime, AReverse);
      XRadius := InterpolateSingle(XRadius{Start}, TBaseStateStyle(ATo).XRadius{Stop}, ANormalizedTime);
      YRadius := InterpolateSingle(YRadius{Start}, TBaseStateStyle(ATo).YRadius{Stop}, ANormalizedTime);
    end
    else if StateStyleParent <> nil then begin
      StateStyleParent.SupersedeNoChanges(true{ASaveState});
      try
        if not AReverse then Text := StateStyleParent.Text;
        TextSettings.Interpolate(StateStyleParent.TextSettings, ANormalizedTime, AReverse);
        XRadius := InterpolateSingle(XRadius{Start}, StateStyleParent.XRadius{Stop}, ANormalizedTime);
        YRadius := InterpolateSingle(YRadius{Start}, StateStyleParent.YRadius{Stop}, ANormalizedTime);
      finally
        StateStyleParent.RestoreStateNoChanges;
      end;
    end
    else if ControlParent <> nil then begin
      if not AReverse then Text := ControlParent.Text;
      TextSettings.Interpolate(ControlParent.TextSettings, ANormalizedTime, AReverse);
      XRadius := InterpolateSingle(XRadius{Start}, ControlParent.XRadius{Stop}, ANormalizedTime);
      YRadius := InterpolateSingle(YRadius{Start}, ControlParent.YRadius{Stop}, ANormalizedTime);
    end
    else begin
      if not AReverse then Text := DefaultText;
      TextSettings.Interpolate(nil, ANormalizedTime, AReverse);
      XRadius := InterpolateSingle(XRadius{Start}, ALIfThen(IsNaN(DefaultXRadius), 0, DefaultXRadius){Stop}, ANormalizedTime);
      YRadius := InterpolateSingle(YRadius{Start}, ALIfThen(IsNaN(DefaultYRadius), 0, DefaultYRadius){Stop}, ANormalizedTime);
    end;
  finally
    EndUpdate;
  end;
end;

{***********************************************************}
procedure TALDynamicToggleButton.TBaseStateStyle.DoSupersede;
begin
  Inherited;
  if Text = '' then begin
    if StateStyleParent <> nil then Text := StateStyleParent.Text
    else Text := ControlParent.Text;
  end;
  if IsNaN(XRadius) then begin
    if StateStyleParent <> nil then XRadius := StateStyleParent.XRadius
    else XRadius := ControlParent.XRadius;
  end;
  if IsNaN(YRadius) then begin
    if StateStyleParent <> nil then YRadius := StateStyleParent.YRadius
    else YRadius := ControlParent.YRadius;
  end;
  TextSettings.SuperSede;
end;

{***********************************************************************************}
function TALDynamicToggleButton.TBaseStateStyle.GetStateStyleParent: TBaseStateStyle;
begin
  {$IF defined(debug)}
  if (inherited StateStyleParent <> nil) and
     (not (inherited StateStyleParent is TBaseStateStyle)) then
    raise Exception.Create('StateStyleParent must be of type TBaseStateStyle');
  {$ENDIF}
  result := TBaseStateStyle(inherited StateStyleParent);
end;

{***************************************************************************************}
function TALDynamicToggleButton.TBaseStateStyle.GetControlParent: TALDynamicToggleButton;
begin
  {$IF defined(debug)}
  if (inherited ControlParent <> nil) and
     (not (inherited ControlParent is TALDynamicToggleButton)) then
    raise Exception.Create('ControlParent must be of type TALDynamicToggleButton');
  {$ENDIF}
  result := TALDynamicToggleButton(inherited ControlParent);
end;

{****************************************************************************}
procedure TALDynamicToggleButton.TBaseStateStyle.SetText(const Value: string);
begin
  if FText <> Value then begin
    FText := Value;
    Change;
  end;
end;

{************************************************************************************************************}
procedure TALDynamicToggleButton.TBaseStateStyle.SetTextSettings(const AValue: TBaseStateStyle.TTextSettings);
begin
  FTextSettings.Assign(AValue);
end;

{*******************************************************************************}
procedure TALDynamicToggleButton.TBaseStateStyle.SetXRadius(const Value: Single);
begin
  if IsNan(FXRadius) and IsNan(Value) then Exit;
  if not SameValue(FXRadius, Value, TEpsilon.Vector) then begin
    FXRadius := Value;
    Change;
  end;
end;

{*******************************************************************************}
procedure TALDynamicToggleButton.TBaseStateStyle.SetYRadius(const Value: Single);
begin
  if IsNan(FYRadius) and IsNan(Value) then Exit;
  if not SameValue(FYRadius, Value, TEpsilon.Vector) then begin
    FYRadius := Value;
    Change;
  end;
end;

{*********************************************************************}
function TALDynamicToggleButton.TBaseStateStyle.GetDefaultText: String;
begin
  Result := '';
end;

{************************************************************************}
function TALDynamicToggleButton.TBaseStateStyle.GetDefaultXRadius: Single;
begin
  Result := NaN;
end;

{************************************************************************}
function TALDynamicToggleButton.TBaseStateStyle.GetDefaultYRadius: Single;
begin
  Result := NaN;
end;

{******************************************************************}
function TALDynamicToggleButton.TBaseStateStyle.GetInherit: Boolean;
begin
  Result := inherited GetInherit and
            IsNan(FXRadius) and
            IsNan(FYRadius) and
            Text.IsEmpty and
            TextSettings.Inherit;
end;

{*************************************************************************************}
procedure TALDynamicToggleButton.TBaseStateStyle.TextSettingsChanged(ASender: TObject);
begin
  Change;
end;

{********************************************************************}
function TALDynamicToggleButton.TBaseStateStyle.IsTextStored: Boolean;
begin
  Result := FText <> DefaultText;
end;

{***********************************************************************}
function TALDynamicToggleButton.TBaseStateStyle.IsXRadiusStored: Boolean;
begin
  if IsNan(FXRadius) and IsNan(DefaultXRadius) then Exit(False);
  Result := not SameValue(FXRadius, DefaultXRadius, TEpsilon.Vector);
end;

{***********************************************************************}
function TALDynamicToggleButton.TBaseStateStyle.IsYRadiusStored: Boolean;
begin
  if IsNan(FYRadius) and IsNan(DefaultYRadius) then Exit(False);
  Result := not SameValue(FYRadius, DefaultYRadius, TEpsilon.Vector);
end;

{***************************************************************************}
function TALDynamicToggleButton.TDefaultStateStyle.GetCacheSubIndex: Integer;
begin
  Result := 1;
end;

{***************************************************************************}
function TALDynamicToggleButton.TDisabledStateStyle.IsOpacityStored: Boolean;
begin
  Result := not SameValue(FOpacity, TControl.DefaultDisabledOpacity, TEpsilon.Scale);
end;

{***********************************************************************************}
procedure TALDynamicToggleButton.TDisabledStateStyle.SetOpacity(const Value: Single);
begin
  if not SameValue(FOpacity, Value, TEpsilon.Scale) then begin
    FOpacity := Value;
    Change;
  end;
end;

{************************************************************************************}
constructor TALDynamicToggleButton.TDisabledStateStyle.Create(const AParent: TObject);
begin
  inherited Create(AParent);
  FOpacity := TControl.DefaultDisabledOpacity;
end;

{*******************************************************************************}
procedure TALDynamicToggleButton.TDisabledStateStyle.Assign(Source: TPersistent);
begin
  BeginUpdate;
  Try
    if Source is TDisabledStateStyle then
      Opacity := TDisabledStateStyle(Source).Opacity
    else
      Opacity := TControl.DefaultDisabledOpacity;
    inherited Assign(Source);
  Finally
    EndUpdate;
  End;
end;

{*********************************************************}
procedure TALDynamicToggleButton.TDisabledStateStyle.Reset;
begin
  BeginUpdate;
  Try
    inherited;
    Opacity := TControl.DefaultDisabledOpacity;
  finally
    EndUpdate;
  end;
end;

{**********************************************************************}
function TALDynamicToggleButton.TDisabledStateStyle.GetInherit: Boolean;
begin
  // Opacity is not part of the GetInherit function because it updates the
  // disabledOpacity of the base control immediately every time it changes.
  // Essentially, it acts merely as a link to the disabledOpacity of the base control.
  Result := inherited GetInherit;
end;

{****************************************************************************}
function TALDynamicToggleButton.TDisabledStateStyle.GetCacheSubIndex: Integer;
begin
  Result := 2;
end;

{***************************************************************************}
function TALDynamicToggleButton.THoveredStateStyle.GetCacheSubIndex: Integer;
begin
  Result := 3;
end;

{***************************************************************************}
function TALDynamicToggleButton.TPressedStateStyle.GetCacheSubIndex: Integer;
begin
  Result := 4;
end;

{***************************************************************************}
function TALDynamicToggleButton.TFocusedStateStyle.GetCacheSubIndex: Integer;
begin
  Result := 5;
end;

{********************************************************************************************}
constructor TALDynamicToggleButton.TCheckStateStyles.Create(const AParent: TALDynamicControl);
begin
  inherited Create;
  //--
  FDefault := CreateDefaultStateStyle(AParent);
  FDefault.OnChanged := DefaultChanged;
  //--
  FDisabled := CreateDisabledStateStyle(FDefault);
  FDisabled.OnChanged := DisabledChanged;
  //--
  FHovered := CreateHoveredStateStyle(FDefault);
  FHovered.OnChanged := HoveredChanged;
  //--
  FPressed := CreatePressedStateStyle(FDefault);
  FPressed.OnChanged := PressedChanged;
  //--
  FFocused := CreateFocusedStateStyle(FDefault);
  FFocused.OnChanged := FocusedChanged;
end;

{**********************************************************}
destructor TALDynamicToggleButton.TCheckStateStyles.Destroy;
begin
  ALFreeAndNil(FDefault);
  ALFreeAndNil(FDisabled);
  ALFreeAndNil(FHovered);
  ALFreeAndNil(FPressed);
  ALFreeAndNil(FFocused);
  inherited Destroy;
end;

{****************************************************************************************}
function TALDynamicToggleButton.TCheckStateStyles.CreateSavedState: TALPersistentObserver;
type
  TCheckStateStylesClass = class of TCheckStateStyles;
begin
  result := TCheckStateStylesClass(classtype).Create(nil{AParent});
end;

{********************************************************************************************************************}
function TALDynamicToggleButton.TCheckStateStyles.CreateDefaultStateStyle(const AParent: TObject): TDefaultStateStyle;
begin
  Result := TDefaultStateStyle.Create(AParent);
end;

{**********************************************************************************************************************}
function TALDynamicToggleButton.TCheckStateStyles.CreateDisabledStateStyle(const AParent: TObject): TDisabledStateStyle;
begin
  Result := TDisabledStateStyle.Create(AParent);
end;

{********************************************************************************************************************}
function TALDynamicToggleButton.TCheckStateStyles.CreateHoveredStateStyle(const AParent: TObject): THoveredStateStyle;
begin
  Result := THoveredStateStyle.Create(AParent);
end;

{********************************************************************************************************************}
function TALDynamicToggleButton.TCheckStateStyles.CreatePressedStateStyle(const AParent: TObject): TPressedStateStyle;
begin
  Result := TPressedStateStyle.Create(AParent);
end;

{********************************************************************************************************************}
function TALDynamicToggleButton.TCheckStateStyles.CreateFocusedStateStyle(const AParent: TObject): TFocusedStateStyle;
begin
  Result := TFocusedStateStyle.Create(AParent);
end;

{*****************************************************************************}
procedure TALDynamicToggleButton.TCheckStateStyles.Assign(Source: TPersistent);
begin
  if Source is TCheckStateStyles then begin
    BeginUpdate;
    Try
      Default.Assign(TCheckStateStyles(Source).Default);
      Disabled.Assign(TCheckStateStyles(Source).Disabled);
      Hovered.Assign(TCheckStateStyles(Source).Hovered);
      Pressed.Assign(TCheckStateStyles(Source).Pressed);
      Focused.Assign(TCheckStateStyles(Source).Focused);
    Finally
      EndUpdate;
    End;
  end
  else
    ALAssignError(Source{ASource}, Self{ADest});
end;

{*******************************************************}
procedure TALDynamicToggleButton.TCheckStateStyles.Reset;
begin
  BeginUpdate;
  Try
    inherited;
    Default.Reset;
    Disabled.Reset;
    Hovered.Reset;
    Pressed.Reset;
    Focused.Reset;
  finally
    EndUpdate;
  end;
end;

{**************************************************************}
procedure TALDynamicToggleButton.TCheckStateStyles.AlignToPixel;
begin
  BeginUpdate;
  Try
    Default.AlignToPixel;
    Disabled.AlignToPixel;
    Hovered.AlignToPixel;
    Pressed.AlignToPixel;
    Focused.AlignToPixel;
  finally
    EndUpdate;
  end;
end;

{******************************************************************}
procedure TALDynamicToggleButton.TCheckStateStyles.ApplyColorScheme;
begin
  BeginUpdate;
  Try
    Default.ApplyColorScheme;
    Disabled.ApplyColorScheme;
    Hovered.ApplyColorScheme;
    Pressed.ApplyColorScheme;
    Focused.ApplyColorScheme;
  finally
    EndUpdate;
  end;
end;

{******************************************************************}
procedure TALDynamicToggleButton.TCheckStateStyles.ClearBufDrawable;
begin
  Default.ClearBufDrawable;
  Disabled.ClearBufDrawable;
  Hovered.ClearBufDrawable;
  Pressed.ClearBufDrawable;
  Focused.ClearBufDrawable;
end;

{**********************************************************************************************}
procedure TALDynamicToggleButton.TCheckStateStyles.SetDefault(const AValue: TDefaultStateStyle);
begin
  FDefault.Assign(AValue);
end;

{************************************************************************************************}
procedure TALDynamicToggleButton.TCheckStateStyles.SetDisabled(const AValue: TDisabledStateStyle);
begin
  FDisabled.Assign(AValue);
end;

{**********************************************************************************************}
procedure TALDynamicToggleButton.TCheckStateStyles.SetHovered(const AValue: THoveredStateStyle);
begin
  FHovered.Assign(AValue);
end;

{**********************************************************************************************}
procedure TALDynamicToggleButton.TCheckStateStyles.SetPressed(const AValue: TPressedStateStyle);
begin
  FPressed.Assign(AValue);
end;

{**********************************************************************************************}
procedure TALDynamicToggleButton.TCheckStateStyles.SetFocused(const AValue: TFocusedStateStyle);
begin
  FFocused.Assign(AValue);
end;

{**********************************************************************************}
procedure TALDynamicToggleButton.TCheckStateStyles.DefaultChanged(ASender: TObject);
begin
  Change;
end;

{***********************************************************************************}
procedure TALDynamicToggleButton.TCheckStateStyles.DisabledChanged(ASender: TObject);
begin
  Change;
end;

{**********************************************************************************}
procedure TALDynamicToggleButton.TCheckStateStyles.HoveredChanged(ASender: TObject);
begin
  Change;
end;

{**********************************************************************************}
procedure TALDynamicToggleButton.TCheckStateStyles.PressedChanged(ASender: TObject);
begin
  Change;
end;

{**********************************************************************************}
procedure TALDynamicToggleButton.TCheckStateStyles.FocusedChanged(ASender: TObject);
begin
  Change;
end;

{***************************************************************************************}
constructor TALDynamicToggleButton.TStateStyles.Create(const AParent: TALDynamicControl);
begin
  inherited Create(AParent);
  //--
  FChecked := CreateCheckedStateStyles(AParent);
  FChecked.OnChanged := CheckedChanged;
  //--
  FUnchecked := CreateUnCheckedStateStyles(AParent);
  FUnchecked.OnChanged := UncheckedChanged;
end;

{*****************************************************}
destructor TALDynamicToggleButton.TStateStyles.Destroy;
begin
  ALFreeAndNil(FChecked);
  ALFreeAndNil(FUnchecked);
  inherited Destroy;
end;

{***************************************************************************************************}
function TALDynamicToggleButton.TStateStyles.CreateTransition: TALDynamicBaseStateStyles.TTransition;
begin
  result := TTransition.Create(Self);
end;

{*************************************************************************************************************************}
function TALDynamicToggleButton.TStateStyles.CreateCheckedStateStyles(const AParent: TALDynamicControl): TCheckStateStyles;
begin
  Result := TCheckStateStyles.Create(AParent);
end;

{***************************************************************************************************************************}
function TALDynamicToggleButton.TStateStyles.CreateUncheckedStateStyles(const AParent: TALDynamicControl): TCheckStateStyles;
begin
  Result := TCheckStateStyles.Create(AParent);
end;

{************************************************************************}
procedure TALDynamicToggleButton.TStateStyles.Assign(Source: TPersistent);
begin
  if Source is TStateStyles then begin
    BeginUpdate;
    Try
      Checked.Assign(TStateStyles(Source).Checked);
      Unchecked.Assign(TStateStyles(Source).Unchecked);
      inherited Assign(Source);
    Finally
      EndUpdate;
    End;
  end
  else
    ALAssignError(Source{ASource}, Self{ADest});
end;

{**************************************************}
procedure TALDynamicToggleButton.TStateStyles.Reset;
begin
  BeginUpdate;
  Try
    inherited;
    Checked.reset;
    Unchecked.reset;
  finally
    EndUpdate;
  end;
end;

{*********************************************************}
procedure TALDynamicToggleButton.TStateStyles.AlignToPixel;
begin
  BeginUpdate;
  Try
    inherited;
    Checked.AlignToPixel;
    Unchecked.AlignToPixel;
  finally
    EndUpdate;
  end;
end;

{*************************************************************}
procedure TALDynamicToggleButton.TStateStyles.ApplyColorScheme;
begin
  BeginUpdate;
  Try
    inherited;
    Checked.ApplyColorScheme;
    Unchecked.ApplyColorScheme;
  finally
    EndUpdate;
  end;
end;

{*************************************************************}
procedure TALDynamicToggleButton.TStateStyles.ClearBufDrawable;
begin
  inherited;
  Checked.ClearBufDrawable;
  Unchecked.ClearBufDrawable;
end;

{****************************************************************************************}
function TALDynamicToggleButton.TStateStyles.GetCurrentRawStyle: TALDynamicBaseStateStyle;
begin
  if Parent.Checked then begin
    if Not Parent.Enabled then Result := Checked.Disabled
    else if Parent.Pressed then Result := Checked.Pressed
    //**else if Parent.IsFocused then Result := Checked.Focused
    else if Parent.IsMouseOver then Result := Checked.Hovered
    else result := Checked.Default;
  end
  else begin
    if Not Parent.Enabled then Result := UnChecked.Disabled
    else if Parent.Pressed then Result := UnChecked.Pressed
    //**else if Parent.IsFocused then Result := UnChecked.Focused
    else if Parent.IsMouseOver then Result := UnChecked.Hovered
    else result := UnChecked.Default;
  end;
end;

{*****************************************************************************}
function TALDynamicToggleButton.TStateStyles.GetParent: TALDynamicToggleButton;
begin
  Result := TALDynamicToggleButton(inherited Parent);
end;

{***********************************************************************************}
function TALDynamicToggleButton.TStateStyles.GetTransition: TStateStyles.TTransition;
begin
  Result := TStateStyles.TTransition(inherited Transition);
end;

{**************************************************************************************************}
procedure TALDynamicToggleButton.TStateStyles.SetTransition(const AValue: TStateStyles.TTransition);
begin
  inherited Transition := AValue;
end;

{****************************************************************************************}
procedure TALDynamicToggleButton.TStateStyles.SetChecked(const AValue: TCheckStateStyles);
begin
  FChecked.Assign(AValue);
end;

{******************************************************************************************}
procedure TALDynamicToggleButton.TStateStyles.SetUnchecked(const AValue: TCheckStateStyles);
begin
  FUnchecked.Assign(AValue);
end;

{*****************************************************************************}
procedure TALDynamicToggleButton.TStateStyles.CheckedChanged(ASender: TObject);
begin
  Change;
end;

{*******************************************************************************}
procedure TALDynamicToggleButton.TStateStyles.UncheckedChanged(ASender: TObject);
begin
  Change;
end;

{***************************************************************}
function TALDynamicToggleButton.TPadding.GetDefaultValue: TRectF;
begin
  Result := TRectF.Create(12{Left}, 6{Top}, 12{Right}, 6{Bottom});
end;

{***************************************************************}
constructor TALDynamicToggleButton.Create(const AOwner: TObject);
begin
  {$IF defined(ALDPK)}
  FPrevStateStyles := nil;
  {$ENDIF}
  FStateStyles := nil;
  //--
  inherited Create(AOwner);
  //--
  //**CanFocus := True;
  HitTest := True;
  AutoSize := TALAutoSizeMode.Both;
  Cursor := crHandPoint;
  //--
  FGroupName := '';
  fMandatory := false;
  TMessageManager.DefaultManager.SubscribeToMessage(TGroupMessage, GroupMessageCall);
  //--
  FChecked := False;
  FOnChange := nil;
  //--
  //**var LPaddingChange: TNotifyEvent := Padding.OnChange;
  //**Padding.OnChange := nil;
  //**Padding.DefaultValue := TRectF.create(12{Left}, 6{Top}, 12{Right}, 6{Bottom});
  //**Padding.Rect := Padding.DefaultValue;
  //**padding.OnChange := LPaddingChange;
  //--
  {$IF defined(ALDPK)}
  FPrevStateStyles := TStateStyles.Create(nil);
  {$ENDIF}
  //--
  FStateStyles := CreateStateStyles;
  FStateStyles.OnChanged := StateStylesChanged;
end;

{*******************************************************}
function TALDynamicToggleButton.CreatePadding: TALBounds;
begin
  Result := TPadding.Create;
end;

{****************************************}
destructor TALDynamicToggleButton.Destroy;
begin
  {$IF defined(ALDPK)}
  ALFreeAndNil(FPrevStateStyles);
  {$ENDIF}
  ALFreeAndNil(FStateStyles);
  inherited Destroy;
end;

{*************************************************}
procedure TALDynamicToggleButton.BeforeDestruction;
begin
  if BeforeDestructionExecuted then exit;
  // Unsubscribe from TGroupMessage to stop receiving messages.
  // This must be done in BeforeDestruction rather than in Destroy,
  // because the control might be freed in the background via ALFreeAndNil(..., delayed),
  // and BeforeDestruction is guaranteed to execute on the main thread.
  TMessageManager.DefaultManager.Unsubscribe(TGroupMessage, GroupMessageCall);
  inherited;
end;

{*****************************************************************}
procedure TALDynamicToggleButton.Assign(Source: TALDynamicControl);
begin
  BeginUpdate;
  Try
    if Source is TALDynamicToggleButton then begin
      StateStyles.Assign(TALDynamicToggleButton(Source).StateStyles);
      GroupName := TALDynamicToggleButton(Source).GroupName;
      Mandatory := TALDynamicToggleButton(Source).Mandatory;
      Checked := TALDynamicToggleButton(Source).Checked;
      OnChange := TALDynamicToggleButton(Source).OnChange;
    end
    else
      ALAssignError(Source{ASource}, Self{ADest});
    inherited Assign(Source);
  Finally
    EndUpdate;
  End;
end;

{********************************************}
procedure TALDynamicToggleButton.AlignToPixel;
begin
  BeginUpdate;
  try
    inherited;
    StateStyles.AlignToPixel;
  finally
    EndUpdate;
  end;
end;

{************************************************}
procedure TALDynamicToggleButton.ApplyColorScheme;
begin
  BeginUpdate;
  Try
    inherited;
    StateStyles.ApplyColorScheme;
  finally
    EndUpdate;
  end;
end;

{***************************************************}
function TALDynamicToggleButton.CreateFill: TALBrush;
begin
  Result := TFill.Create;
end;

{***********************************************************}
function TALDynamicToggleButton.CreateStroke: TALStrokeBrush;
begin
  Result := TStroke.Create;
end;

{**********************************************************************}
function TALDynamicToggleButton.CreateTextSettings: TALBaseTextSettings;
begin
  Result := TTextSettings.Create;
end;

{**************************************************************}
function TALDynamicToggleButton.CreateStateStyles: TStateStyles;
begin
  Result := TStateStyles.Create(self);
end;

{**************************************************}
function TALDynamicToggleButton.GetChecked: Boolean;
begin
  Result := FChecked;
end;

{****************************************************************}
procedure TALDynamicToggleButton.SetChecked(const Value: Boolean);

  {~~~~~~~~~~~~~~~~~~~~~~}
  procedure _doSetChecked;
  begin
    FChecked := Value;
    if FChecked then DisabledOpacity := StateStyles.Checked.Disabled.opacity
    else DisabledOpacity := StateStyles.Unchecked.Disabled.opacity;
    AdjustSize;
    DoChanged;
  end;

begin
  if FChecked <> Value then begin
    //**if (csDesigning in ComponentState) and FChecked then _doSetChecked // allows check/uncheck in design-mode
    //**else begin
      if (not value) and fMandatory then exit;
      var LOldMandatory := fMandatory;
      fMandatory := False;
      try
        _doSetChecked;
      finally
        fMandatory := LOldMandatory;
      end;
      if FChecked and (GroupName <> '') then begin
        var M := TGroupMessage.Create(GroupName);
        TMessageManager.DefaultManager.SendMessage(Self, M, True);
      end;
    //**end;
  end;
end;

{*************************************************************}
function TALDynamicToggleButton.GetTextSettings: TTextSettings;
begin
  Result := TTextSettings(Inherited TextSettings);
end;

{***************************************************************************}
procedure TALDynamicToggleButton.SetTextSettings(const Value: TTextSettings);
begin
  Inherited SetTextSettings(Value);
end;

{************************************************************************}
//**procedure TALDynamicToggleButton.SetName(const Value: TComponentName);
//**begin
//**  var LChangeText := not (csLoading in ComponentState) and (Name = Text) and
//**    ((Owner = nil) or not (csLoading in TComponent(Owner).ComponentState));
//**  inherited SetName(Value);
//**  if LChangeText then
//**    Text := Value;
//**end;

{**************************************************************************}
procedure TALDynamicToggleButton.SetStateStyles(const AValue: TStateStyles);
begin
  FStateStyles.Assign(AValue);
end;

{***************************************************}
function TALDynamicToggleButton.GetGroupName: string;
begin
  Result := FGroupName;
end;

{******************************************************************************************}
procedure TALDynamicToggleButton.GroupMessageCall(const Sender: TObject; const M: TMessage);
begin
  if SameText(TGroupMessage(M).GroupName, GroupName) and (Sender <> Self) and (Host <> nil) and
     (not (Sender is TALDynamicControl) or ((Sender as TALDynamicControl).Host = Host)) then begin
    var LOldMandatory := fMandatory;
    fMandatory := False;
    try
      Checked := False;
    finally
      fMandatory := LOldMandatory;
    end;
  end;
end;

{*******************************************************}
function TALDynamicToggleButton.GroupNameStored: Boolean;
begin
  Result := FGroupName <> '';
end;

{*****************************************************************}
procedure TALDynamicToggleButton.SetGroupName(const Value: string);
begin
  if FGroupName <> Value then
    FGroupName := Value;
end;

{********************************************************************}
procedure TALDynamicToggleButton.TextSettingsChanged(Sender: TObject);

  {~~~~~~~~~~~~~~~~~~}
  {$IF defined(ALDPK)}
  procedure _PropagateChanges(const APrevStateStyle: TBaseStateStyle; const AToStateStyle: TBaseStateStyle);
  begin

    if //**(not (csLoading in ComponentState)) and
       (not AToStateStyle.TextSettings.inherit) then begin

      if APrevStateStyle.TextSettings.font.Family = AToStateStyle.TextSettings.font.Family then AToStateStyle.TextSettings.font.Family := TextSettings.font.Family;
      if SameValue(APrevStateStyle.TextSettings.font.Size, AToStateStyle.TextSettings.font.Size, TEpsilon.fontSize) then AToStateStyle.TextSettings.font.Size := TextSettings.font.Size;
      if APrevStateStyle.TextSettings.font.Weight = AToStateStyle.TextSettings.font.Weight then AToStateStyle.TextSettings.font.Weight := TextSettings.font.Weight;
      if APrevStateStyle.TextSettings.font.Slant = AToStateStyle.TextSettings.font.Slant then AToStateStyle.TextSettings.font.Slant := TextSettings.font.Slant;
      if APrevStateStyle.TextSettings.font.Stretch = AToStateStyle.TextSettings.font.Stretch then AToStateStyle.TextSettings.font.Stretch := TextSettings.font.Stretch;
      if (APrevStateStyle.TextSettings.font.Color = AToStateStyle.TextSettings.font.Color) and
         (APrevStateStyle.TextSettings.font.ColorKey = AToStateStyle.TextSettings.font.ColorKey) then begin
        AToStateStyle.TextSettings.font.Color := TextSettings.font.Color;
        AToStateStyle.TextSettings.font.ColorKey := TextSettings.font.ColorKey;
      end;

      if APrevStateStyle.TextSettings.Decoration.Kinds = AToStateStyle.TextSettings.Decoration.Kinds then AToStateStyle.TextSettings.Decoration.Kinds := TextSettings.Decoration.Kinds;
      if APrevStateStyle.TextSettings.Decoration.Style = AToStateStyle.TextSettings.Decoration.Style then AToStateStyle.TextSettings.Decoration.Style := TextSettings.Decoration.Style;
      if SameValue(APrevStateStyle.TextSettings.Decoration.ThicknessMultiplier, AToStateStyle.TextSettings.Decoration.ThicknessMultiplier, TEpsilon.Scale) then AToStateStyle.TextSettings.Decoration.ThicknessMultiplier := TextSettings.Decoration.ThicknessMultiplier;
      if (APrevStateStyle.TextSettings.Decoration.Color = AToStateStyle.TextSettings.Decoration.Color) and
         (APrevStateStyle.TextSettings.Decoration.ColorKey = AToStateStyle.TextSettings.Decoration.ColorKey) then begin
        AToStateStyle.TextSettings.Decoration.Color := TextSettings.Decoration.Color;
        AToStateStyle.TextSettings.Decoration.ColorKey := TextSettings.Decoration.ColorKey;
      end;

    end;

    APrevStateStyle.TextSettings.font.Family := TextSettings.font.Family;
    APrevStateStyle.TextSettings.font.Size := TextSettings.font.Size;
    APrevStateStyle.TextSettings.font.Weight := TextSettings.font.Weight;
    APrevStateStyle.TextSettings.font.Slant := TextSettings.font.Slant;
    APrevStateStyle.TextSettings.font.Stretch := TextSettings.font.Stretch;
    APrevStateStyle.TextSettings.font.Color := TextSettings.font.Color;
    APrevStateStyle.TextSettings.font.ColorKey := TextSettings.font.ColorKey;

    APrevStateStyle.TextSettings.Decoration.Kinds := TextSettings.Decoration.Kinds;
    APrevStateStyle.TextSettings.Decoration.Style := TextSettings.Decoration.Style;
    APrevStateStyle.TextSettings.Decoration.ThicknessMultiplier := TextSettings.Decoration.ThicknessMultiplier;
    APrevStateStyle.TextSettings.Decoration.Color := TextSettings.Decoration.Color;
    APrevStateStyle.TextSettings.Decoration.ColorKey := TextSettings.Decoration.ColorKey;

  end;
  {$ENDIF}

begin
  {$IF defined(ALDPK)}
  if (StateStyles <> nil) and (FPrevStateStyles <> nil) then begin
    _PropagateChanges(FPrevStateStyles.checked.Default, StateStyles.checked.Default);
    _PropagateChanges(FPrevStateStyles.checked.Disabled, StateStyles.checked.Disabled);
    _PropagateChanges(FPrevStateStyles.checked.Hovered, StateStyles.checked.Hovered);
    _PropagateChanges(FPrevStateStyles.checked.Pressed, StateStyles.checked.Pressed);
    _PropagateChanges(FPrevStateStyles.checked.Focused, StateStyles.checked.Focused);
    _PropagateChanges(FPrevStateStyles.Unchecked.Default, StateStyles.Unchecked.Default);
    _PropagateChanges(FPrevStateStyles.Unchecked.Disabled, StateStyles.Unchecked.Disabled);
    _PropagateChanges(FPrevStateStyles.Unchecked.Hovered, StateStyles.Unchecked.Hovered);
    _PropagateChanges(FPrevStateStyles.Unchecked.Pressed, StateStyles.Unchecked.Pressed);
    _PropagateChanges(FPrevStateStyles.Unchecked.Focused, StateStyles.Unchecked.Focused);
  end;
  {$ENDIF}
  inherited;
end;

{*******************************************************************}
procedure TALDynamicToggleButton.StateStylesChanged(Sender: TObject);
begin
  ClearBufDrawable;
  if Checked then DisabledOpacity := StateStyles.Checked.Disabled.opacity
  else DisabledOpacity := StateStyles.Unchecked.Disabled.opacity;
  Repaint;
end;

{**************************************************}
procedure TALDynamicToggleButton.IsMouseOverChanged;
begin
  inherited;
  StateStyles.Transition.Start;
  repaint;
end;

{****************************************************}
//**procedure TALDynamicToggleButton.IsFocusedChanged;
//**begin
//**  inherited;
//**  StateStyles.Transition.Start;
//**  repaint;
//**end;

{**********************************************}
procedure TALDynamicToggleButton.PressedChanged;
begin
  inherited;
  StateStyles.Transition.Start;
  repaint;
end;

{************************************************************************************************************}
//**procedure TALDynamicToggleButton.KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState);
//**begin
//**  inherited;
//**  if (KeyChar = ' ') then begin
//**    Click; // Emulate mouse click to perform Action.OnExecute
//**    KeyChar := #0;
//**  end;
//**end;

{********************************************}
procedure TALDynamicToggleButton.DoClickSound;
begin
  if (ClickSound=TALClickSoundMode.Always) or
     ((ClickSound=TALClickSoundMode.Default) and ALGlobalClickSoundEnabled) then
    ALPlayClickSound;
end;

{*************************************}
procedure TALDynamicToggleButton.Click;
begin
  if StateStyles.Transition.Running and StateStyles.Transition.DelayClick then begin
    Checked := not Checked;
    StateStyles.Transition.ClickDelayed := True
  end
  else begin
    if not StateStyles.Transition.ClickDelayed then
      Checked := not Checked;
    inherited click;
  end;
end;

{*****************************************}
procedure TALDynamicToggleButton.DoChanged;
begin
  if Assigned(FOnChange) then
    FOnChange(Self);
  Repaint;
end;

{************************************************}
procedure TALDynamicToggleButton.ClearBufDrawable;
begin
  {$IFDEF debug}
  if (FStateStyles <> nil) and
     (not IsDestroying) and
     (ALIsDrawableNull(FBufDrawable)) and // warn will be raise in inherited
     ((not ALIsDrawableNull(FStateStyles.Checked.Default.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.Checked.Disabled.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.Checked.Hovered.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.Checked.Pressed.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.Checked.Focused.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.UnChecked.Default.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.UnChecked.Disabled.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.UnChecked.Hovered.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.UnChecked.Pressed.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.UnChecked.Focused.FBufDrawable))) then
    ALLog(Classname + '.ClearBufDrawable', 'BufDrawable has been cleared | Name: ' + Name, TalLogType.warn);
  {$endif}
  if FStateStyles <> nil then
    FStateStyles.ClearBufDrawable;
  inherited ClearBufDrawable;
end;

{******************************************}
procedure TALDynamicToggleButton.AdjustSize;
begin
  var LHasUnconstrainedAutosizeWidth := HasUnconstrainedAutosizeWidth;
  var LHasUnconstrainedAutosizeHeight := HasUnconstrainedAutosizeHeight;
  if //**(not (csLoading in ComponentState)) and // loaded will call again AdjustSize
     (not IsDestroying) and // if csDestroying do not do autosize
     (StateStyles <> nil) and // if StateStyles in nil nothing to adjust
     (LHasUnconstrainedAutosizeWidth or LHasUnconstrainedAutosizeHeight) and // if AutoSize is false nothing to adjust
     (TNonReentrantHelper.EnterSection(FIsAdjustingSize)) then begin // non-reantrant
    try

      if isupdating then begin
        FAdjustSizeOnEndUpdate := True;
        Exit;
      end
      else
        FAdjustSizeOnEndUpdate := False;

      var LSubIndexOffset: Integer;
      var LDefaultStateStyle: TBaseStateStyle;
      if Checked then begin
        LSubIndexOffset := GetCacheSubIndex{+0};
        LDefaultStateStyle := StateStyles.Checked.Default;
      end
      else begin
        LSubIndexOffset := GetCacheSubIndex+5;
        LDefaultStateStyle := StateStyles.UnChecked.Default;
      end;
      LDefaultStateStyle.SupersedeNoChanges(true{ASaveState});
      try

        // if Text is empty do not do autosize
        if LDefaultStateStyle.Text = '' then exit;

        {$IF defined(debug)}
        //ALLog(ClassName + '.AdjustSize', 'Name: ' + Name + ' | HasUnconstrainedAutosize(X/Y) : '+ALBoolToStrW(LHasUnconstrainedAutosizeWidth)+'/'+ALBoolToStrW(LHasUnconstrainedAutosizeHeight));
        {$ENDIF}

        var R: TrectF;
        If {$IF not DEFINED(ALDPK)}DoubleBuffered{$ELSE}True{$ENDIF} then begin
          if (CacheIndex <= 0) or
             (CacheEngine = nil) or
             (not CacheEngine.TryGetEntry(CacheIndex{AIndex}, LSubIndexOffset+LDefaultStateStyle.CacheSubIndex{ASubIndex}, R{ARect})) then begin
            MakeBufDrawable;
            R := LDefaultStateStyle.FBufDrawableRect;
          end;
        end
        else begin
          {$IF not DEFINED(ALDPK)}
          var LTextBroken: Boolean;
          var LAllTextDrawn: Boolean;
          var LElements: TALTextElements;
          MeasureMultilineText(
            R, // out ARect: TRectF;
            LTextBroken, // out ATextBroken: Boolean;
            LAllTextDrawn, // out AAllTextDrawn: Boolean;
            LElements, // out AElements: TALTextElements;
            1, // const AScale: Single;
            LDefaultStateStyle.Text, // const AText: String;
            LDefaultStateStyle.TextSettings.Font, // const AFont: TALFont;
            LDefaultStateStyle.TextSettings.Decoration, // const ADecoration: TALTextDecoration;
            LDefaultStateStyle.TextSettings.EllipsisSettings.font, // const AEllipsisFont: TALFont;
            LDefaultStateStyle.TextSettings.EllipsisSettings.Decoration, // const AEllipsisDecoration: TALTextDecoration;
            LDefaultStateStyle.Fill, // const AFill: TALBrush;
            nil, // const AStateLayer: TALStateLayer;
            LDefaultStateStyle.Stroke, // const AStroke: TALStrokeBrush;
            LDefaultStateStyle.Shadow, // const AShadow: TALShadow);
            LDefaultStateStyle.XRadius, // const AXRadius: Single;
            LDefaultStateStyle.YRadius); // const AYRadius: Single
          {$ENDIF}
        end;

        if not LHasUnconstrainedAutosizeWidth then begin
          r.Left := 0;
          r.Width := Width;
        end;
        if not LHasUnconstrainedAutosizeHeight then begin
          r.Top := 0;
          r.height := height;
        end;

        SetFixedSizeBounds(Left, Top, R.Width, R.Height);

      finally
        LDefaultStateStyle.RestorestateNoChanges;
      end;

    finally
      TNonReentrantHelper.LeaveSection(FIsAdjustingSize)
    end;
  end;
end;

{***********************************************}
procedure TALDynamicToggleButton.MakeBufDrawable;

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  function _DoMakeBufDrawable(const AStateStyle: TBaseStateStyle): boolean;
  begin
    if (not ALIsDrawableNull(AStateStyle.FBufDrawable)) then exit(False);
    AStateStyle.SupersedeNoChanges(true{ASaveState});
    try

      {$IFDEF debug}
      ALLog(Classname + '.MakeBufDrawable', 'Name: ' + Name + ' | Style: ' + AStateStyle.ClassName + ' | Width: ' + ALFloatToStrW(Width)+ ' | Height: ' + ALFloatToStrW(Height));
      {$endif}

      // Create the BufDrawable
      var LTextBroken: Boolean;
      var LAllTextDrawn: Boolean;
      var LElements: TALTextElements;
      CreateBufDrawable(
        AStateStyle.FBufDrawable, // var ABufDrawable: TALDrawable;
        AStateStyle.FBufDrawableRect, // var ABufDrawableRect: TRectF;
        LTextBroken, // var ABufTextBroken: Boolean;
        LAllTextDrawn, // var ABufAllTextDrawn: Boolean;
        LElements, // var ABufElements: TALTextElements;
        ALGetScreenScale * AStateStyle.Scale, // const AScale: Single;
        AStateStyle.Text, // const AText: String;
        AStateStyle.TextSettings.Font, // const AFont: TALFont;
        AStateStyle.TextSettings.Decoration, // const ADecoration: TALTextDecoration;
        AStateStyle.TextSettings.Font, // const AEllipsisFont: TALFont;
        AStateStyle.TextSettings.Decoration, // const AEllipsisDecoration: TALTextDecoration;
        AStateStyle.Fill, // const AFill: TALBrush;
        AStateStyle.StateLayer, // const AStateLayer: TALStateLayer;
        AStateStyle.Stroke, // const AStroke: TALStrokeBrush;
        AStateStyle.Shadow, // const AShadow: TALShadow);
        AStateStyle.XRadius, // const AXRadius: Single;
        AStateStyle.YRadius); // const AYRadius: Single

      // LStateStyle.FBufDrawableRect must include the LScale
      AStateStyle.FBufDrawableRect.Top := AStateStyle.FBufDrawableRect.Top * AStateStyle.Scale;
      AStateStyle.FBufDrawableRect.right := AStateStyle.FBufDrawableRect.right * AStateStyle.Scale;
      AStateStyle.FBufDrawableRect.left := AStateStyle.FBufDrawableRect.left * AStateStyle.Scale;
      AStateStyle.FBufDrawableRect.bottom := AStateStyle.FBufDrawableRect.bottom * AStateStyle.Scale;

      // Since LStateStyle.FBufDrawableRect can have different dimensions than the main BufDrawableRect
      // (due to autosizing with different font sizes), we must center LStateStyle.FBufDrawableRect
      // within the main BufDrawableRect to ensure that all changes are visually centered.
      If Checked then begin
        if AStateStyle <> StateStyles.Checked.Default then begin
          var LMainDrawableRect: TRectF;
          if (CacheIndex <= 0) or
             (CacheEngine = nil) or
             (not CacheEngine.TryGetEntry(CacheIndex{AIndex}, GetCacheSubIndex{+0}+StateStyles.Checked.Default.GetCacheSubIndex{ASubIndex}, LMainDrawableRect{ARect})) then begin
            If AlIsDrawableNull(StateStyles.Checked.Default.FBufDrawable) then LMainDrawableRect :=LocalRect.ReducePrecision
            else LMainDrawableRect := StateStyles.Checked.Default.FBufDrawableRect;
          end;
          LMainDrawableRect.Offset(-LMainDrawableRect.Left, -LMainDrawableRect.Top);
          var LCenteredRect := AStateStyle.FBufDrawableRect.CenterAt(LMainDrawableRect);
          AStateStyle.FBufDrawableRect.Offset(LCenteredRect.Left, LCenteredRect.top);
        end;
      end
      else begin
        if AStateStyle <> StateStyles.Unchecked.Default then begin
          var LMainDrawableRect: TRectF;
          if (CacheIndex <= 0) or
             (CacheEngine = nil) or
             (not CacheEngine.TryGetEntry(CacheIndex{AIndex}, GetCacheSubIndex+5+StateStyles.Unchecked.Default.GetCacheSubIndex{ASubIndex}, LMainDrawableRect{ARect})) then begin
            If AlIsDrawableNull(StateStyles.Unchecked.Default.FBufDrawable) then LMainDrawableRect :=LocalRect.ReducePrecision
            else LMainDrawableRect := StateStyles.Unchecked.Default.FBufDrawableRect;
          end;
          LMainDrawableRect.Offset(-LMainDrawableRect.Left, -LMainDrawableRect.Top);
          var LCenteredRect := AStateStyle.FBufDrawableRect.CenterAt(LMainDrawableRect);
          AStateStyle.FBufDrawableRect.Offset(LCenteredRect.Left, LCenteredRect.top);
        end;
      end;

    finally
      AStateStyle.RestorestateNoChanges;
    end;
    Result := True;
  end;

begin
  //--- Do not create BufDrawable if not DoubleBuffered
  if {$IF not DEFINED(ALDPK)}(not DoubleBuffered){$ELSE}False{$ENDIF} then begin
    ClearBufDrawable;
    exit;
  end;
  //--
  var LSubIndexOffset: Integer;
  var LDefaultStateStyle: TBaseStateStyle;
  if Checked then begin
    LSubIndexOffset := GetCacheSubIndex{+0};
    LDefaultStateStyle := StateStyles.Checked.Default;
  end
  else begin
    LSubIndexOffset := GetCacheSubIndex+5;
    LDefaultStateStyle := StateStyles.UnChecked.Default;
  end;
  //--
  if (CacheIndex = 0) or
     (CacheEngine = nil) or
     (not CacheEngine.HasEntry(CacheIndex{AIndex}, LSubIndexOffset+LDefaultStateStyle.CacheSubIndex{ASubIndex})) then
    _DoMakeBufDrawable(LDefaultStateStyle);
  //--
  var LStateStyle := TBaseStateStyle(StateStyles.GetCurrentRawStyle);
  if LStateStyle = nil then exit;
  if LStateStyle.Inherit then exit;
  if (CacheIndex > 0) and
     (CacheEngine <> nil) and
     (CacheEngine.HasEntry(CacheIndex{AIndex}, LSubIndexOffset+LStateStyle.CacheSubIndex{ASubIndex})) then Exit;
  _DoMakeBufDrawable(LStateStyle);
  // No need to center LStateStyle.FBufDrawableRect on the main BufDrawableRect
  // because BufDrawableRect always has the width and height of the localRect.
end;

{***************************************************************************************************************************************************************************}
Procedure TALDynamicToggleButton.DrawMultilineTextAdjustRect(const ACanvas: TALCanvas; const AOptions: TALMultiLineTextOptions; var ARect: TrectF; var ASurfaceSize: TSizeF);
begin

  // If we are drawing directly on the form, center ARect in LocalRect. This is necessary if, for example,
  // the 'to' font size is smaller than the 'from' font size.
  {$IF defined(ALSkiaCanvas)}
  If (Canvas <> nil) and (TSkCanvasCustom(Canvas).Canvas <> nil) and (TSkCanvasCustom(Canvas).Canvas.Handle = ACanvas) then
    // ALAlignToPixelRound is used because when we call ALDrawDrawable,
    // we do LDstRect := AALAlignToPixelRound(LDstRect).
    // Therefore, when drawing directly on the canvas,
    // we must draw at the exact same position as when we call ALDrawDrawable.
    ARect := ALAlignToPixelRound(ARect.CenterAt(LocalRect.ReducePrecision), Canvas.Matrix, Canvas.Scale, TEpsilon.position)
  else
  {$ENDIF}

end;

{*****************************}
{$IF NOT DEFINED(ALSkiaCanvas)}
function TALDynamicToggleButton.GetRenderTargetRect(const ARect: TrectF): TRectF;
begin
  if StateStyles.Transition.Running then begin
    Result := ARect;
    if StateStyles.Transition.FromStateStyle <> nil then begin
      var LFromSurfaceRect := ALGetShapeSurfaceRect(
                                ARect, // const ARect: TRectF;
                                AutoAlignToPixel, // const AAlignToPixel: Boolean;
                                _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.FromStateStyle).Fill, // const AFill: TALBrush;
                                nil, // const AFillResourceStream: TStream;
                                _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.FromStateStyle).StateLayer, // const AStateLayer: TALStateLayer;
                                _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.FromStateStyle).Shadow); // const AShadow: TALShadow): TRectF;
      Result := TRectF.Union(Result, LFromSurfaceRect); // add the extra space needed to draw the shadow/statelayer
    end;
    if StateStyles.Transition.ToStateStyle <> nil then begin
      var LToSurfaceRect := ALGetShapeSurfaceRect(
                              ARect, // const ARect: TRectF;
                              AutoAlignToPixel, // const AAlignToPixel: Boolean;
                              _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.ToStateStyle).Fill, // const AFill: TALBrush;
                              nil, // const AFillResourceStream: TStream;
                              _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.ToStateStyle).StateLayer, // const AStateLayer: TALStateLayer;
                              _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.ToStateStyle).Shadow); // const AShadow: TALShadow): TRectF;
      Result := TRectF.Union(Result, LToSurfaceRect); // add the extra space needed to draw the shadow/statelayer
    end;
  end
  else begin
    var LStateStyle := TBaseStateStyle(StateStyles.GetCurrentRawStyle);
    if LStateStyle <> nil then begin
      Result := ALGetShapeSurfaceRect(
                  ARect, // const ARect: TRectF;
                  AutoAlignToPixel, // const AAlignToPixel: Boolean;
                  LStateStyle.Fill, // const AFill: TALBrush;
                  nil, // const AFillResourceStream: TStream;
                  LStateStyle.StateLayer, // const AStateLayer: TALStateLayer;
                  LStateStyle.Shadow); // const AShadow: TALShadow): TRectF;
    end
    else begin
      Result := ALGetShapeSurfaceRect(
                  ARect, // const ARect: TRectF;
                  AutoAlignToPixel, // const AAlignToPixel: Boolean;
                  Fill, // const AFill: TALBrush;
                  nil, // const AFillResourceStream: TStream;
                  nil, // const AStateLayer: TALStateLayer;
                  Shadow); // const AShadow: TALShadow): TRectF;
    end;
  end;
end;
{$ENDIF}

{*************************************}
procedure TALDynamicToggleButton.Paint;
begin

  StateStyles.UpdateLastPaintedRawStyle;

  var LDrawable: TALDrawable := ALNullDrawable;
  var LDrawableRect: TRectF := TRectF.Empty;
  if not StateStyles.Transition.Running then begin
    //--
    var LSubIndexOffset: Integer;
    var LDefaultStateStyle: TBaseStateStyle;
    if Checked then begin
      LSubIndexOffset := GetCacheSubIndex{+0};
      LDefaultStateStyle := StateStyles.Checked.Default;
    end
    else begin
      LSubIndexOffset := GetCacheSubIndex+5;
      LDefaultStateStyle := StateStyles.UnChecked.Default;
    end;
    //--
    var LStateStyle := TBaseStateStyle(StateStyles.GetCurrentRawStyle);
    if LStateStyle <> nil then begin
      if (CacheIndex <= 0) or
         (CacheEngine = nil) or
         (not CacheEngine.TryGetEntry(CacheIndex{AIndex}, LSubIndexOffset+LStateStyle.CacheSubIndex{ASubIndex}, LDrawable{ADrawable}, LDrawableRect{ARect})) then begin
        MakeBufDrawable;
        if (CacheIndex > 0) and (CacheEngine <> nil) and (not ALIsDrawableNull(LStateStyle.FBufDrawable)) then begin
          if not CacheEngine.TrySetEntry(CacheIndex{AIndex}, LSubIndexOffset+LStateStyle.CacheSubIndex{ASubIndex}, LStateStyle.FBufDrawable{ADrawable}, LStateStyle.FBufDrawableRect{ARect}) then ALFreeAndNilDrawable(LStateStyle.FBufDrawable)
          else LStateStyle.FBufDrawable := ALNullDrawable;
          if not CacheEngine.TryGetEntry(CacheIndex{AIndex}, LSubIndexOffset+LStateStyle.CacheSubIndex{ASubIndex}, LDrawable{ADrawable}, LDrawableRect{ARect}) then
            raise Exception.Create('Error BB5ACD27-7CF2-44D3-AEB1-22C8BB492762');
        end
        else begin
          LDrawable := LStateStyle.FBufDrawable;
          LDrawableRect := LStateStyle.FBufDrawableRect;
        end;
      end;
    end;
    //--
    If ALIsDrawableNull(LDrawable) then begin
      if (CacheIndex <= 0) or
         (CacheEngine = nil) or
         (not CacheEngine.TryGetEntry(CacheIndex{AIndex}, LSubIndexOffset+LDefaultStateStyle.CacheSubIndex{ASubIndex}, LDrawable{ADrawable}, LDrawableRect{ARect})) then begin
        if LStateStyle = nil then MakeBufDrawable;
        if (CacheIndex > 0) and (CacheEngine <> nil) and (not ALIsDrawableNull(LDefaultStateStyle.fBufDrawable)) then begin
          if not CacheEngine.TrySetEntry(CacheIndex{AIndex}, LSubIndexOffset+LDefaultStateStyle.CacheSubIndex{ASubIndex}, LDefaultStateStyle.fBufDrawable{ADrawable}, LDefaultStateStyle.fBufDrawableRect{ARect}) then ALFreeAndNilDrawable(LDefaultStateStyle.fBufDrawable)
          else LDefaultStateStyle.fBufDrawable := ALNullDrawable;
          if not CacheEngine.TryGetEntry(CacheIndex{AIndex}, LSubIndexOffset+LDefaultStateStyle.CacheSubIndex{ASubIndex}, LDrawable{ADrawable}, LDrawableRect{ARect}) then
            raise Exception.Create('Error BB5ACD27-7CF2-44D3-AEB1-22C8BB492762');
        end
        else begin
          LDrawable := LDefaultStateStyle.FBufDrawable;
          LDrawableRect := LDefaultStateStyle.FBufDrawableRect;
        end;
      end;
    end;
    //--
  end;

  if ALIsDrawableNull(LDrawable) then begin

    var LCurrentAdjustedStateStyle := TBaseStateStyle(StateStyles.GetCurrentAdjustedStyle);
    if LCurrentAdjustedStateStyle = nil then begin
      inherited Paint;
      exit;
    end;

    {$IF DEFINED(ALSkiaCanvas)}

    // Using a matrix on the canvas results in smoother animations compared to using
    // Ascale with DrawMultilineText. This is because changes in scale affect the font size,
    // leading to rounding issues (I spent many hours looking for a way to avoid this).
    // If there is an animation, it appears jerky because the text position
    // shifts up or down with scale changes due to pixel alignment.
    var LCanvasSaveState: TCanvasSaveState := ALScaleAndCenterCanvas(
                                                Canvas, // Const ACanvas: TCanvas;
                                                AbsoluteRect.ReducePrecision, // Const AAbsoluteRect: TRectF;
                                                LCurrentAdjustedStateStyle.Scale, // Const AScale: Single;
                                                true); // Const ASaveState: Boolean);
    try

      var LRect := LocalRect.ReducePrecision;
      var LTextBroken: Boolean;
      var LAllTextDrawn: Boolean;
      var LElements: TALTextElements;

      if (StateStyles.Transition.Running) and
         (StateStyles.Transition.FadeImage) and
         (LCurrentAdjustedStateStyle.Text = '') and
         (StateStyles.Transition.FromStateStyle <> nil) and
         (TBaseStateStyle(StateStyles.Transition.FromStateStyle).fill.ResourceName <> '') and
         (StateStyles.Transition.ToStateStyle <> nil) and
         (TBaseStateStyle(StateStyles.Transition.ToStateStyle).fill.ResourceName <> '') and
         (TBaseStateStyle(StateStyles.Transition.FromStateStyle).fill.ResourceName <> TBaseStateStyle(StateStyles.Transition.ToStateStyle).fill.ResourceName) then begin

        LCurrentAdjustedStateStyle.BeginUpdate;
        try

          LCurrentAdjustedStateStyle.Fill.ResourceName := TBaseStateStyle(StateStyles.Transition.FromStateStyle).fill.ResourceName;
          LCurrentAdjustedStateStyle.Fill.ImageTintColor := TBaseStateStyle(StateStyles.Transition.FromStateStyle).fill.ImageTintColor;

          DrawMultilineText(
            TSkCanvasCustom(Canvas).Canvas.Handle, // const ACanvas: TALCanvas;
            LRect, // var ARect: TRectF;
            LTextBroken, // out ATextBroken: Boolean;
            LAllTextDrawn, // out AAllTextDrawn: Boolean;
            LElements, // out AElements: TALTextElements;
            1{Ascale},
            1-StateStyles.Transition.CurrentValue, // const AOpacity: Single;
            '', // const AText: String;
            nil, // const AFont: TALFont;
            nil, // const ADecoration: TALTextDecoration;
            nil, // const AEllipsisFont: TALFont;
            nil, // const AEllipsisDecoration: TALTextDecoration;
            LCurrentAdjustedStateStyle.Fill, // const AFill: TALBrush;
            LCurrentAdjustedStateStyle.StateLayer, // const AStateLayer: TALStateLayer;
            LCurrentAdjustedStateStyle.Stroke, // const AStroke: TALStrokeBrush;
            LCurrentAdjustedStateStyle.Shadow, // const AShadow: TALShadow);
            LCurrentAdjustedStateStyle.XRadius, // const AXRadius: Single;
            LCurrentAdjustedStateStyle.YRadius); // const AYRadius: Single

          LCurrentAdjustedStateStyle.Fill.ResourceName := TBaseStateStyle(StateStyles.Transition.ToStateStyle).fill.ResourceName;
          LCurrentAdjustedStateStyle.Fill.ImageTintColor := TBaseStateStyle(StateStyles.Transition.ToStateStyle).fill.ImageTintColor;

          DrawMultilineText(
            TSkCanvasCustom(Canvas).Canvas.Handle, // const ACanvas: TALCanvas;
            LRect, // var ARect: TRectF;
            LTextBroken, // out ATextBroken: Boolean;
            LAllTextDrawn, // out AAllTextDrawn: Boolean;
            LElements, // out AElements: TALTextElements;
            1{Ascale},
            StateStyles.Transition.CurrentValue, // const AOpacity: Single;
            '', // const AText: String;
            nil, // const AFont: TALFont;
            nil, // const ADecoration: TALTextDecoration;
            nil, // const AEllipsisFont: TALFont;
            nil, // const AEllipsisDecoration: TALTextDecoration;
            LCurrentAdjustedStateStyle.Fill, // const AFill: TALBrush;
            LCurrentAdjustedStateStyle.StateLayer, // const AStateLayer: TALStateLayer;
            LCurrentAdjustedStateStyle.Stroke, // const AStroke: TALStrokeBrush;
            LCurrentAdjustedStateStyle.Shadow, // const AShadow: TALShadow);
            LCurrentAdjustedStateStyle.XRadius, // const AXRadius: Single;
            LCurrentAdjustedStateStyle.YRadius); // const AYRadius: Single

        finally
          LCurrentAdjustedStateStyle.EndUpdateNoChanges;
        end;

      end
      else begin

        DrawMultilineText(
          TSkCanvasCustom(Canvas).Canvas.Handle, // const ACanvas: TALCanvas;
          LRect, // var ARect: TRectF;
          LTextBroken, // out ATextBroken: Boolean;
          LAllTextDrawn, // out AAllTextDrawn: Boolean;
          LElements, // out AElements: TALTextElements;
          1{Ascale},
          AbsoluteOpacity, // const AOpacity: Single;
          LCurrentAdjustedStateStyle.Text, // const AText: String;
          LCurrentAdjustedStateStyle.TextSettings.Font, // const AFont: TALFont;
          LCurrentAdjustedStateStyle.TextSettings.Decoration, // const ADecoration: TALTextDecoration;
          LCurrentAdjustedStateStyle.TextSettings.EllipsisSettings.font, // const AEllipsisFont: TALFont;
          LCurrentAdjustedStateStyle.TextSettings.EllipsisSettings.Decoration, // const AEllipsisDecoration: TALTextDecoration;
          LCurrentAdjustedStateStyle.Fill, // const AFill: TALBrush;
          LCurrentAdjustedStateStyle.StateLayer, // const AStateLayer: TALStateLayer;
          LCurrentAdjustedStateStyle.Stroke, // const AStroke: TALStrokeBrush;
          LCurrentAdjustedStateStyle.Shadow, // const AShadow: TALShadow);
          LCurrentAdjustedStateStyle.XRadius, // const AXRadius: Single;
          LCurrentAdjustedStateStyle.YRadius); // const AYRadius: Single

      end;

    finally
      if LCanvasSaveState <> nil then
        Canvas.RestoreState(LCanvasSaveState);
    end;

    {$ELSE}

    var LRect := LocalRect.ReducePrecision;
    InitRenderTargets(LRect);
    if ALCanvasBeginScene(RenderTargetCanvas) then
    try

      ALClearCanvas(RenderTargetCanvas, TAlphaColors.Null);

      var LTextBroken: Boolean;
      var LAllTextDrawn: Boolean;
      var LElements: TALTextElements;

      if (StateStyles.Transition.Running) and
         (StateStyles.Transition.FadeImage) and
         (LCurrentAdjustedStateStyle.Text = '') and
         (StateStyles.Transition.FromStateStyle <> nil) and
         (TBaseStateStyle(StateStyles.Transition.FromStateStyle).fill.ResourceName <> '') and
         (StateStyles.Transition.ToStateStyle <> nil) and
         (TBaseStateStyle(StateStyles.Transition.ToStateStyle).fill.ResourceName <> '') and
         (TBaseStateStyle(StateStyles.Transition.FromStateStyle).fill.ResourceName <> TBaseStateStyle(StateStyles.Transition.ToStateStyle).fill.ResourceName) then begin

        LCurrentAdjustedStateStyle.BeginUpdate;
        try

          LCurrentAdjustedStateStyle.Fill.ResourceName := TBaseStateStyle(StateStyles.Transition.FromStateStyle).fill.ResourceName;
          LCurrentAdjustedStateStyle.Fill.ImageTintColor := TBaseStateStyle(StateStyles.Transition.FromStateStyle).fill.ImageTintColor;

          DrawMultilineText(
            RenderTargetCanvas, // const ACanvas: TALCanvas;
            LRect, // var ARect: TRectF;
            LTextBroken, // out ATextBroken: Boolean;
            LAllTextDrawn, // out AAllTextDrawn: Boolean;
            LElements, // out AElements: TALTextElements;
            ALGetScreenScale{Ascale},
            1-StateStyles.Transition.CurrentValue, // const AOpacity: Single;
            '', // const AText: String;
            nil, // const AFont: TALFont;
            nil, // const ADecoration: TALTextDecoration;
            nil, // const AEllipsisFont: TALFont;
            nil, // const AEllipsisDecoration: TALTextDecoration;
            LCurrentAdjustedStateStyle.Fill, // const AFill: TALBrush;
            LCurrentAdjustedStateStyle.StateLayer, // const AStateLayer: TALStateLayer;
            LCurrentAdjustedStateStyle.Stroke, // const AStroke: TALStrokeBrush;
            LCurrentAdjustedStateStyle.Shadow, // const AShadow: TALShadow);
            LCurrentAdjustedStateStyle.XRadius, // const AXRadius: Single;
            LCurrentAdjustedStateStyle.YRadius); // const AYRadius: Single

          LCurrentAdjustedStateStyle.Fill.ResourceName := TBaseStateStyle(StateStyles.Transition.ToStateStyle).fill.ResourceName;
          LCurrentAdjustedStateStyle.Fill.ImageTintColor := TBaseStateStyle(StateStyles.Transition.ToStateStyle).fill.ImageTintColor;

          DrawMultilineText(
            RenderTargetCanvas, // const ACanvas: TALCanvas;
            LRect, // var ARect: TRectF;
            LTextBroken, // out ATextBroken: Boolean;
            LAllTextDrawn, // out AAllTextDrawn: Boolean;
            LElements, // out AElements: TALTextElements;
            ALGetScreenScale{Ascale},
            StateStyles.Transition.CurrentValue, // const AOpacity: Single;
            '', // const AText: String;
            nil, // const AFont: TALFont;
            nil, // const ADecoration: TALTextDecoration;
            nil, // const AEllipsisFont: TALFont;
            nil, // const AEllipsisDecoration: TALTextDecoration;
            LCurrentAdjustedStateStyle.Fill, // const AFill: TALBrush;
            LCurrentAdjustedStateStyle.StateLayer, // const AStateLayer: TALStateLayer;
            LCurrentAdjustedStateStyle.Stroke, // const AStroke: TALStrokeBrush;
            LCurrentAdjustedStateStyle.Shadow, // const AShadow: TALShadow);
            LCurrentAdjustedStateStyle.XRadius, // const AXRadius: Single;
            LCurrentAdjustedStateStyle.YRadius); // const AYRadius: Single

        finally
          LCurrentAdjustedStateStyle.EndUpdateNoChanges;
        end;

      end
      else begin

        DrawMultilineText(
          RenderTargetCanvas, // const ACanvas: TALCanvas;
          LRect, // out ARect: TRectF;
          LTextBroken, // out ATextBroken: Boolean;
          LAllTextDrawn, // out AAllTextDrawn: Boolean;
          LElements, // out AElements: TALTextElements;
          ALGetScreenScale{Ascale},
          1, // const AOpacity: Single;
          LCurrentAdjustedStateStyle.Text, // const AText: String;
          LCurrentAdjustedStateStyle.TextSettings.Font, // const AFont: TALFont;
          LCurrentAdjustedStateStyle.TextSettings.Decoration, // const ADecoration: TALTextDecoration;
          LCurrentAdjustedStateStyle.TextSettings.EllipsisSettings.font, // const AEllipsisFont: TALFont;
          LCurrentAdjustedStateStyle.TextSettings.EllipsisSettings.Decoration, // const AEllipsisDecoration: TALTextDecoration;
          LCurrentAdjustedStateStyle.Fill, // const AFill: TALBrush;
          LCurrentAdjustedStateStyle.StateLayer, // const AStateLayer: TALStateLayer;
          LCurrentAdjustedStateStyle.Stroke, // const AStroke: TALStrokeBrush;
          LCurrentAdjustedStateStyle.Shadow, // const AShadow: TALShadow;
          LCurrentAdjustedStateStyle.XRadius, // const AXRadius: Single;
          LCurrentAdjustedStateStyle.YRadius); // const AYRadius: Single

      end;

    finally
      ALCanvasEndScene(RenderTargetCanvas)
    end;

    ALUpdateDrawableFromSurface(RenderTargetSurface, RenderTargetDrawable);

    // The Shadow or Statelayer are not included in the dimensions of the LRect rectangle.
    // However, the LRect rectangle is offset by the dimensions of the shadow/Statelayer.
    LRect.Offset(-2*LRect.Left, -2*LRect.Top);

    // LRect must include the LScale
    LRect.Top := LRect.Top * LCurrentAdjustedStateStyle.Scale;
    LRect.right := LRect.right * LCurrentAdjustedStateStyle.Scale;
    LRect.left := LRect.left * LCurrentAdjustedStateStyle.Scale;
    LRect.bottom := LRect.bottom * LCurrentAdjustedStateStyle.Scale;

    // Since LStateStyle.FBufDrawableRect can have different dimensions than the main BufDrawableRect
    // (due to autosizing with different font sizes), we must center LStateStyle.FBufDrawableRect
    // within the main BufDrawableRect to ensure that all changes are visually centered.
    If Checked then begin
      var LMainDrawableRect: TRectF;
      if (CacheIndex <= 0) or
         (CacheEngine = nil) or
         (not CacheEngine.TryGetEntry(CacheIndex{AIndex}, GetCacheSubIndex{+0}+StateStyles.Checked.Default.GetCacheSubIndex{ASubIndex}, LMainDrawableRect{ARect})) then begin
        If AlIsDrawableNull(StateStyles.Checked.Default.FBufDrawable) then LMainDrawableRect :=LocalRect.ReducePrecision
        else LMainDrawableRect := StateStyles.Checked.Default.FBufDrawableRect;
      end;
      LMainDrawableRect.Offset(-LMainDrawableRect.Left, -LMainDrawableRect.Top);
      var LCenteredRect := LRect.CenterAt(LMainDrawableRect);
      LRect.Offset(LCenteredRect.Left, LCenteredRect.top);
    end
    else begin
      var LMainDrawableRect: TRectF;
      if (CacheIndex <= 0) or
         (CacheEngine = nil) or
         (not CacheEngine.TryGetEntry(CacheIndex{AIndex}, GetCacheSubIndex+5+StateStyles.Unchecked.Default.GetCacheSubIndex{ASubIndex}, LMainDrawableRect{ARect})) then begin
        If AlIsDrawableNull(StateStyles.Unchecked.Default.FBufDrawable) then LMainDrawableRect :=LocalRect.ReducePrecision
        else LMainDrawableRect := StateStyles.Unchecked.Default.FBufDrawableRect;
      end;
      LMainDrawableRect.Offset(-LMainDrawableRect.Left, -LMainDrawableRect.Top);
      var LCenteredRect := LRect.CenterAt(LMainDrawableRect);
      LRect.Offset(LCenteredRect.Left, LCenteredRect.top);
    end;

    // We cannot use the matrix because, if we do, ALAlignToPixelRound in ALDrawDrawable
    // will be ineffective since the matrix will no longer be a simple translation matrix.
    // In such a case, TCustomCanvasGpu(ACanvas).DrawTexture may produce border artifacts
    // if the texture is not perfectly pixel-aligned.
    var LDstRect := TRectF.Create(0, 0, ALGetDrawableWidth(RenderTargetDrawable), ALGetDrawableHeight(RenderTargetDrawable));
    LDstRect.Width := (LDstRect.Width / ALGetScreenScale) * LCurrentAdjustedStateStyle.Scale;
    LDstRect.height := (LDstRect.height / ALGetScreenScale) * LCurrentAdjustedStateStyle.Scale;
    LDstRect.SetLocation(
      LRect.Left,
      LRect.Top);
    ALDrawDrawable(
      Canvas, // const ACanvas: Tcanvas;
      RenderTargetDrawable, // const ADrawable: TALDrawable;
      LDstRect, // const ADstRect: TrectF; // IN Virtual pixels !
      AbsoluteOpacity); // const AOpacity: Single)

    {$ENDIF}

    exit;
  end;

  ALDrawDrawable(
    Canvas, // const ACanvas: Tcanvas;
    LDrawable, // const ADrawable: TALDrawable;
    LDrawableRect.TopLeft, // const ATopLeft: TpointF;
    AbsoluteOpacity); // const AOpacity: Single);

end;

{*************************************************************************}
function TALDynamicCustomTrack.TThumb.TStroke.GetDefaultColor: TAlphaColor;
begin
  Result := $ffd5d5d5;
end;

{*****************************************************************************************}
function TALDynamicCustomTrack.TThumb.TBaseStateStyle.TStroke.GetDefaultColor: TAlphaColor;
begin
  Result := $ffd5d5d5;
end;

{******************************************************************************************}
function TALDynamicCustomTrack.TThumb.TBaseStateStyle.TStateLayer.GetDefaultXRadius: Single;
begin
  Result := -50;
end;

{******************************************************************************************}
function TALDynamicCustomTrack.TThumb.TBaseStateStyle.TStateLayer.GetDefaultYRadius: Single;
begin
  Result := -50;
end;

{***********************************************************************************************************************}
function TALDynamicCustomTrack.TThumb.TBaseStateStyle.CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush;
begin
  Result := TStroke.Create(AParent);
end;

{************************************************************************************}
function TALDynamicCustomTrack.TThumb.TBaseStateStyle.CreateStateLayer: TALStateLayer;
begin
  Result := TStateLayer.Create;
end;

{*********************************************************************************}
function TALDynamicCustomTrack.TThumb.TDisabledStateStyle.IsOpacityStored: Boolean;
begin
  Result := not SameValue(FOpacity, TControl.DefaultDisabledOpacity, TEpsilon.Scale);
end;

{*****************************************************************************************}
procedure TALDynamicCustomTrack.TThumb.TDisabledStateStyle.SetOpacity(const Value: Single);
begin
  if not SameValue(FOpacity, Value, TEpsilon.Scale) then begin
    FOpacity := Value;
    Change;
  end;
end;

{******************************************************************************************}
constructor TALDynamicCustomTrack.TThumb.TDisabledStateStyle.Create(const AParent: TObject);
begin
  inherited Create(AParent);
  FOpacity := TControl.DefaultDisabledOpacity;
end;

{*************************************************************************************}
procedure TALDynamicCustomTrack.TThumb.TDisabledStateStyle.Assign(Source: TPersistent);
begin
  BeginUpdate;
  Try
    if Source is TDisabledStateStyle then
      Opacity := TDisabledStateStyle(Source).Opacity
    else
      Opacity := TControl.DefaultDisabledOpacity;
    inherited Assign(Source);
  Finally
    EndUpdate;
  End;
end;

{***************************************************************}
procedure TALDynamicCustomTrack.TThumb.TDisabledStateStyle.Reset;
begin
  BeginUpdate;
  Try
    inherited;
    Opacity := TControl.DefaultDisabledOpacity;
  finally
    EndUpdate;
  end;
end;

{****************************************************************************}
function TALDynamicCustomTrack.TThumb.TDisabledStateStyle.GetInherit: Boolean;
begin
  // Opacity is not part of the GetInherit function because it updates the
  // disabledOpacity of the base control immediately every time it changes.
  // Essentially, it acts merely as a link to the disabledOpacity of the base control.
  Result := inherited GetInherit;
end;

{*********************************************************************************************}
constructor TALDynamicCustomTrack.TThumb.TStateStyles.Create(const AParent: TALDynamicControl);
begin
  inherited Create(AParent);
  //--
  FDisabled := CreateDisabledStateStyle(AParent);
  FDisabled.OnChanged := DisabledChanged;
  //--
  FHovered := CreateHoveredStateStyle(AParent);
  FHovered.OnChanged := HoveredChanged;
  //--
  FPressed := CreatePressedStateStyle(AParent);
  FPressed.OnChanged := PressedChanged;
  //--
  FFocused := CreateFocusedStateStyle(AParent);
  FFocused.OnChanged := FocusedChanged;
end;

{***********************************************************}
destructor TALDynamicCustomTrack.TThumb.TStateStyles.Destroy;
begin
  ALFreeAndNil(FDisabled);
  ALFreeAndNil(FHovered);
  ALFreeAndNil(FPressed);
  ALFreeAndNil(FFocused);
  inherited Destroy;
end;

{***********************************************************************************************************************}
function TALDynamicCustomTrack.TThumb.TStateStyles.CreateDisabledStateStyle(const AParent: TObject): TDisabledStateStyle;
begin
  Result := TDisabledStateStyle.Create(AParent);
end;

{*********************************************************************************************************************}
function TALDynamicCustomTrack.TThumb.TStateStyles.CreateHoveredStateStyle(const AParent: TObject): THoveredStateStyle;
begin
  Result := THoveredStateStyle.Create(AParent);
end;

{*********************************************************************************************************************}
function TALDynamicCustomTrack.TThumb.TStateStyles.CreatePressedStateStyle(const AParent: TObject): TPressedStateStyle;
begin
  Result := TPressedStateStyle.Create(AParent);
end;

{*********************************************************************************************************************}
function TALDynamicCustomTrack.TThumb.TStateStyles.CreateFocusedStateStyle(const AParent: TObject): TFocusedStateStyle;
begin
  Result := TFocusedStateStyle.Create(AParent);
end;

{******************************************************************************}
procedure TALDynamicCustomTrack.TThumb.TStateStyles.Assign(Source: TPersistent);
begin
  if Source is TStateStyles then begin
    BeginUpdate;
    Try
      Disabled.Assign(TStateStyles(Source).Disabled);
      Hovered.Assign(TStateStyles(Source).Hovered);
      Pressed.Assign(TStateStyles(Source).Pressed);
      Focused.Assign(TStateStyles(Source).Focused);
      inherited Assign(Source);
    Finally
      EndUpdate;
    End;
  end
  else
    ALAssignError(Source{ASource}, Self{ADest});
end;

{********************************************************}
procedure TALDynamicCustomTrack.TThumb.TStateStyles.Reset;
begin
  BeginUpdate;
  Try
    inherited;
    Disabled.reset;
    Hovered.reset;
    Pressed.reset;
    Focused.reset;
  finally
    EndUpdate;
  end;
end;

{***************************************************************}
procedure TALDynamicCustomTrack.TThumb.TStateStyles.AlignToPixel;
begin
  BeginUpdate;
  Try
    inherited;
    Disabled.AlignToPixel;
    Hovered.AlignToPixel;
    Pressed.AlignToPixel;
    Focused.AlignToPixel;
  finally
    EndUpdate;
  end;
end;

{*******************************************************************}
procedure TALDynamicCustomTrack.TThumb.TStateStyles.ApplyColorScheme;
begin
  BeginUpdate;
  Try
    inherited;
    Disabled.ApplyColorScheme;
    Hovered.ApplyColorScheme;
    Pressed.ApplyColorScheme;
    Focused.ApplyColorScheme;
  finally
    EndUpdate;
  end;
end;

{*******************************************************************}
procedure TALDynamicCustomTrack.TThumb.TStateStyles.ClearBufDrawable;
begin
  inherited;
  Disabled.ClearBufDrawable;
  Hovered.ClearBufDrawable;
  Pressed.ClearBufDrawable;
  Focused.ClearBufDrawable;
end;

{**********************************************************************************************}
function TALDynamicCustomTrack.TThumb.TStateStyles.GetCurrentRawStyle: TALDynamicBaseStateStyle;
begin
  if Not Parent.Enabled then Result := Disabled
  else if Parent.Pressed then Result := Pressed
  //**else if Parent.IsFocused then Result := Focused
  else if Parent.IsMouseOver then Result := Hovered
  else result := nil;
end;

{*****************************************************************************************}
function TALDynamicCustomTrack.TThumb.TStateStyles.GetParent: TALDynamicCustomTrack.TThumb;
begin
  Result := TALDynamicCustomTrack.TThumb(inherited Parent);
end;

{*************************************************************************************************}
procedure TALDynamicCustomTrack.TThumb.TStateStyles.SetDisabled(const AValue: TDisabledStateStyle);
begin
  FDisabled.Assign(AValue);
end;

{***********************************************************************************************}
procedure TALDynamicCustomTrack.TThumb.TStateStyles.SetHovered(const AValue: THoveredStateStyle);
begin
  FHovered.Assign(AValue);
end;

{***********************************************************************************************}
procedure TALDynamicCustomTrack.TThumb.TStateStyles.SetPressed(const AValue: TPressedStateStyle);
begin
  FPressed.Assign(AValue);
end;

{***********************************************************************************************}
procedure TALDynamicCustomTrack.TThumb.TStateStyles.SetFocused(const AValue: TFocusedStateStyle);
begin
  FFocused.Assign(AValue);
end;

{************************************************************************************}
procedure TALDynamicCustomTrack.TThumb.TStateStyles.DisabledChanged(ASender: TObject);
begin
  Change;
end;

{***********************************************************************************}
procedure TALDynamicCustomTrack.TThumb.TStateStyles.HoveredChanged(ASender: TObject);
begin
  Change;
end;

{***********************************************************************************}
procedure TALDynamicCustomTrack.TThumb.TStateStyles.PressedChanged(ASender: TObject);
begin
  Change;
end;

{***********************************************************************************}
procedure TALDynamicCustomTrack.TThumb.TStateStyles.FocusedChanged(ASender: TObject);
begin
  Change;
end;

{*****************************************************************************************}
constructor TALDynamicCustomTrack.TThumb.Create(const ACustomTrack: TALDynamicCustomTrack);
begin
  FStateStyles := nil;
  //--
  inherited create(ACustomTrack);
  FCustomTrack := ACustomTrack;
  //--
  //**CanFocus := ACustomTrack.CanFocus;
  //**TabStop := ACustomTrack.TabStop;
  cursor := crHandPoint;
  AutoCapture := True;
  //**Locked := True;
  //--
  FValueRange := TValueRange.create(_ALDummyComponent);
  {$IFDEF debug}
  if (FValueRange.Min <> 0) or
     (FValueRange.Max <> FMX.StdActns.DefaultMaxValue) or
     (FValueRange.Value <> 0) or
     (FValueRange.ViewportSize <> 0) or
     (FValueRange.Frequency <> 0) then
    Raise Exception.Create('Error 577E0A1F-9305-475A-AD94-AE60E257C8D2');
  {$ENDIF}
  FValueRange.onchanged := ValueRangeChanged;
  //--
  fCustomTrackMouseDownPos := TpointF.Zero;
  fScrollCapturedByMe := False;
  TMessageManager.DefaultManager.SubscribeToMessage(TALScrollCapturedMessage, ScrollCapturedByOtherHandler);
  //--
  FStateStyles := CreateStateStyles;
  FStateStyles.OnChanged := StateStylesChanged;
end;

{**********************************************}
destructor TALDynamicCustomTrack.TThumb.Destroy;
begin
  ALFreeAndNil(FStateStyles);
  ALFreeAndNil(FValueRange);
  inherited;
end;

{*******************************************************}
procedure TALDynamicCustomTrack.TThumb.BeforeDestruction;
begin
  if BeforeDestructionExecuted then exit;
  // Unsubscribe from TALScrollCapturedMessage to stop receiving messages.
  // This must be done in BeforeDestruction rather than in Destroy,
  // because the control might be freed in the background via ALFreeAndNil(..., delayed),
  // and BeforeDestruction is guaranteed to execute on the main thread.
  TMessageManager.DefaultManager.Unsubscribe(TALScrollCapturedMessage, ScrollCapturedByOtherHandler);
  inherited;
end;

{***********************************************************************}
procedure TALDynamicCustomTrack.TThumb.Assign(Source: TALDynamicControl);
begin
  BeginUpdate;
  Try
    if Source is TThumb then begin
      StateStyles.Assign(TThumb(Source).StateStyles);
    end
    else
      ALAssignError(Source{ASource}, Self{ADest});
    inherited Assign(Source);
  Finally
    EndUpdate;
  End;
end;

{*****************************************************************}
function TALDynamicCustomTrack.TThumb.CreateStroke: TALStrokeBrush;
begin
  Result := TStroke.Create;
end;

{********************************************************************}
function TALDynamicCustomTrack.TThumb.CreateStateStyles: TStateStyles;
begin
  Result := TStateStyles.Create(self);
end;

{***************************************************}
procedure TALDynamicCustomTrack.TThumb.DoBeginUpdate;
begin
  fValueRange.BeginUpdate;
  inherited;
end;

{*************************************************}
procedure TALDynamicCustomTrack.TThumb.DoEndUpdate;
begin
  fValueRange.EndUpdate;
  inherited;
end;

{**************************************************}
procedure TALDynamicCustomTrack.TThumb.AlignToPixel;
begin
  BeginUpdate;
  try
    inherited;
    StateStyles.AlignToPixel;
  finally
    EndUpdate;
  end;
end;

{******************************************************}
procedure TALDynamicCustomTrack.TThumb.ApplyColorScheme;
begin
  BeginUpdate;
  try
    inherited;
    StateStyles.ApplyColorScheme;
  finally
    EndUpdate;
  end;
end;

{*****************************************************}
function TALDynamicCustomTrack.TThumb.GetValue: Double;
begin
  Result := FValueRange.Value;
end;

{********************************************************************************}
procedure TALDynamicCustomTrack.TThumb.SetStateStyles(const AValue: TStateStyles);
begin
  FStateStyles.Assign(AValue);
end;

{**************************************************************}
function TALDynamicCustomTrack.TThumb.GetDefaultXRadius: Single;
begin
  result := -50;
end;

{**************************************************************}
function TALDynamicCustomTrack.TThumb.GetDefaultYRadius: Single;
begin
  result := -50;
end;

{*************************************************************************}
procedure TALDynamicCustomTrack.TThumb.StateStylesChanged(Sender: TObject);
begin
  ClearBufDrawable;
  DisabledOpacity := StateStyles.Disabled.opacity;
  Repaint;
end;

{********************************************************}
procedure TALDynamicCustomTrack.TThumb.IsMouseOverChanged;
begin
  inherited;
  StateStyles.Transition.start;
  if FcustomTrack.FValueIndicator <> nil then
    FcustomTrack.FValueIndicator.Refresh(Self);
  repaint;
end;

{**********************************************************}
//**procedure TALDynamicCustomTrack.TThumb.IsFocusedChanged;
//**begin
//**  inherited;
//**  StateStyles.Transition.start;
//**  if FcustomTrack.FValueIndicator <> nil then
//**    FcustomTrack.FValueIndicator.Refresh(Self);
//**  repaint;
//**end;

{****************************************************}
procedure TALDynamicCustomTrack.TThumb.PressedChanged;
begin
  inherited;
  StateStyles.Transition.start;
  if FcustomTrack.FValueIndicator <> nil then
    FcustomTrack.FValueIndicator.Refresh(Self);
  repaint;
end;

{************************************************************************}
procedure TALDynamicCustomTrack.TThumb.ValueRangeChanged(Sender: TObject);
begin
  FcustomTrack.Realign;
  if FcustomTrack.FValueIndicator <> nil then
    FcustomTrack.FValueIndicator.Refresh(Self);
  FcustomTrack.DoChanged;
end;

{******************************************************************************************************************}
//**procedure TALDynamicCustomTrack.TThumb.KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState);
//**begin
//**  var LInc: Double := fValueRange.Frequency;
//**  if LInc = 0 then LInc := 1;
//**  inherited;
//**  var LValue: Double;
//**  case Key of
//**    vkHome: LValue := fValueRange.Min;
//**    vkEnd: LValue := fValueRange.Max;
//**    vkUp: LValue := fValueRange.Value - LInc;
//**    vkDown: LValue := fValueRange.Value + LInc;
//**    vkLeft: LValue := fValueRange.Value - LInc;
//**    vkRight: LValue := fValueRange.Value + LInc;
//**    else Exit;
//**  end;
//**  Key := 0;
//**  fValueRange.Value := LValue;
//**end;

{************************************************************************************************************}
procedure TALDynamicCustomTrack.TThumb.ScrollCapturedByOtherHandler(const Sender: TObject; const M: TMessage);
begin
  if (Sender = self) then exit;
  {$IFDEF DEBUG}
  //ALLog(
  //  'TALDynamicCustomTrack.TThumb.ScrollCapturedByOtherHandler',
  //  'Captured: ' + ALBoolToStrW(TALScrollCapturedMessage(M).Captured)+ ' | ' +
  //  'Pressed: ' + ALBoolToStrW(Pressed));
  {$ENDIF}
  if TALScrollCapturedMessage(M).Captured then begin
    {$IFDEF DEBUG}
    if fScrollCapturedByMe then
      raise Exception.Create('Error 40ED19CA-9F47-4A56-AC46-FA5D8D5429C0');
    {$ENDIF}
    Pressed := False;
  end;
end;

{*******************************************************************************************************}
procedure TALDynamicCustomTrack.TThumb.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Single);
begin
  inherited;
  if Pressed then begin
    BringToFront;
    fCustomTrackMouseDownPos := FCustomTrack.AbsoluteToLocal(LocalToAbsolute(PressedPosition)).ReducePrecision;
  end;
end;

{*********************************************************************************}
procedure TALDynamicCustomTrack.TThumb.MouseMove(Shift: TShiftState; X, Y: Single);

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  function _PosToValue(MinValue, MaxValue, ViewportSize: Double; TrackSize, Pos: Single): Double;
  begin
    Result := MinValue;
    if ViewportSize < 0 then ViewportSize := 0;
    var LValRel: Double := TrackSize;
    if LValRel > 0 then begin
      LValRel := Pos / LValRel;
      if LValRel < 0 then LValRel := 0;
      if LValRel > 1 then LValRel := 1;
      Result := MinValue + LValRel * (MaxValue - MinValue - ViewportSize);
    end;
  end;

begin
  {$IFDEF DEBUG}
  //ALLog(
  //  'TALDynamicCustomTrack.MouseMove',
  //  'Position:' + ALFormatFloatW('0.##', x) + ',' + ALFormatFloatW('0.##', y));
  {$ENDIF}
  if Pressed then begin

    if (not fScrollCapturedByMe) then begin
      var LCustomTrackMousePos := FCustomTrack.AbsoluteToLocal(LocalToAbsolute(TpointF.Create(X,Y))).ReducePrecision;
      If ((FCustomtrack.Orientation = TOrientation.Horizontal) and
          (abs(FCustomTrackMouseDownPos.x - LCustomTrackMousePos.x) > abs(FCustomTrackMouseDownPos.y - LCustomTrackMousePos.y)) and
          (abs(FCustomTrackMouseDownPos.x - LCustomTrackMousePos.x) > TALScrollEngine.DefaultTouchSlop))
         or
         ((FCustomtrack.Orientation = TOrientation.Vertical) and
          (abs(FCustomTrackMouseDownPos.y - LCustomTrackMousePos.y) > abs(FCustomTrackMouseDownPos.x - LCustomTrackMousePos.x)) and
          (abs(FCustomTrackMouseDownPos.y - LCustomTrackMousePos.y) > TALScrollEngine.DefaultTouchSlop)) then begin
        {$IFDEF DEBUG}
        //ALLog(
        //  'TALDynamicCustomTrack.MouseMove',
        //  'ScrollCapturedByMe');
        {$ENDIF}
        PressedPosition := PointF(X, Y);
        fCustomTrackMouseDownPos := LCustomTrackMousePos;
        fScrollCapturedByMe := true;
        TMessageManager.DefaultManager.SendMessage(self, TALScrollCapturedMessage.Create(true), True);
      end;
    end;

    if fScrollCapturedByMe then begin
      if FCustomTrack.Orientation = TOrientation.Horizontal then begin
        var P := FCustomTrack.AbsoluteToLocal(LocalToAbsolute(TPointF.Create(X - PressedPosition.X, 0)));
        FValueRange.Value := _PosToValue(
                               FCustomTrack.Min, // MinValue
                               FCustomTrack.Max, // MaxValue
                               FCustomTrack.ViewportSize, // ViewportSize
                               FCustomTrack.GetTrackSize, // TrackSize
                               P.X - FCustomTrack.padding.Left - FCustomTrack.GetLeadingTrackStartPadding); // Pos
      end
      else begin
        var P := FCustomTrack.AbsoluteToLocal(LocalToAbsolute(TPointF.Create(0, Y - PressedPosition.Y)));
        FValueRange.Value := _PosToValue(
                               FCustomTrack.Min, // MinValue
                               FCustomTrack.Max, // MaxValue
                               FCustomTrack.ViewportSize, // ViewportSize
                               FCustomTrack.GetTrackSize, // TrackSize
                               P.Y - FCustomTrack.padding.Top - FCustomTrack.GetLeadingTrackStartPadding); // Pos
      end;
    end;

  end;
  inherited;
end;

{*****************************************************************************************************}
procedure TALDynamicCustomTrack.TThumb.MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Single);
begin
  inherited;
  if FScrollCapturedByMe then
    FScrollCapturedByMe := False;
end;

{************************************************}
procedure TALDynamicCustomTrack.TThumb.MouseLeave;
begin
  inherited;
  if FScrollCapturedByMe then
    FScrollCapturedByMe := False;
end;

{******************************************************}
procedure TALDynamicCustomTrack.TThumb.ClearBufDrawable;
begin
  {$IFDEF debug}
  if (FStateStyles <> nil) and
     (not IsDestroying) and
     (ALIsDrawableNull(FBufDrawable)) and // warn will be raise in inherited
     ((not ALIsDrawableNull(FStateStyles.Disabled.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.Hovered.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.Pressed.FBufDrawable)) or
      (not ALIsDrawableNull(FStateStyles.Focused.FBufDrawable))) then
    ALLog(Classname + '.ClearBufDrawable', 'BufDrawable has been cleared | Name: ' + Name, TalLogType.warn);
  {$endif}
  if FStateStyles <> nil then
    FStateStyles.ClearBufDrawable;
  inherited ClearBufDrawable;
end;

{*****************************************************}
procedure TALDynamicCustomTrack.TThumb.MakeBufDrawable;
begin
  //--- Do not create BufDrawable if not DoubleBuffered
  if {$IF not DEFINED(ALDPK)}(not DoubleBuffered){$ELSE}False{$ENDIF} then begin
    ClearBufDrawable;
    exit;
  end;
  //--
  inherited MakeBufDrawable;
  //--
  var LStateStyle := TBaseStateStyle(StateStyles.GetCurrentRawStyle);
  if LStateStyle = nil then exit;
  if LStateStyle.Inherit then exit;
  if (not ALIsDrawableNull(LStateStyle.FBufDrawable)) then exit;
  LStateStyle.SupersedeNoChanges(true{ASaveState});
  try

    {$IFDEF debug}
    ALLog(Classname + '.MakeBufDrawable', 'Name: ' + Name + ' | Style: ' + LStateStyle.ClassName + ' | Width: ' + ALFloatToStrW(Width)+ ' | Height: ' + ALFloatToStrW(Height));
    {$endif}

    // Create the BufDrawable
    CreateBufDrawable(
      LStateStyle.FBufDrawable, // var ABufDrawable: TALDrawable;
      LStateStyle.FBufDrawableRect, // var ABufDrawableRect: TRectF;
      ALGetScreenScale * LStateStyle.Scale, // const AScale: Single;
      LStateStyle.Fill, // const AFill: TALBrush;
      LStateStyle.StateLayer, // const AStateLayer: TALStateLayer;
      TAlphaColors.null, // const AStateLayerContentColor: TAlphaColor;
      False, // const ADrawStateLayerOnTop: Boolean;
      LStateStyle.Stroke, // const AStroke: TALStrokeBrush;
      LStateStyle.Shadow); // const AShadow: TALShadow);

    // LStateStyle.FBufDrawableRect must include the LStateStyle.Scale
    LStateStyle.FBufDrawableRect.Top := LStateStyle.FBufDrawableRect.Top * LStateStyle.Scale;
    LStateStyle.FBufDrawableRect.right := LStateStyle.FBufDrawableRect.right * LStateStyle.Scale;
    LStateStyle.FBufDrawableRect.left := LStateStyle.FBufDrawableRect.left * LStateStyle.Scale;
    LStateStyle.FBufDrawableRect.bottom := LStateStyle.FBufDrawableRect.bottom * LStateStyle.Scale;

    // Since LStateStyle.FBufDrawableRect can have different dimensions than the main BufDrawableRect
    // (due to scale), we must center LStateStyle.FBufDrawableRect
    // within the main BufDrawableRect to ensure that all changes are visually centered.
    var LMainDrawableRect: TRectF;
    If AlIsDrawableNull(FBufDrawable) then LMainDrawableRect :=LocalRect.ReducePrecision
    else LMainDrawableRect := FBufDrawableRect;
    LMainDrawableRect.Offset(-LMainDrawableRect.Left, -LMainDrawableRect.Top);
    var LCenteredRect := LStateStyle.FBufDrawableRect.CenterAt(LMainDrawableRect);
    LStateStyle.FBufDrawableRect.Offset(LCenteredRect.Left, LCenteredRect.top);

  finally
    LStateStyle.RestorestateNoChanges;
  end;
end;

{*****************************}
{$IF NOT DEFINED(ALSkiaCanvas)}
function TALDynamicCustomTrack.TThumb.GetRenderTargetRect(const ARect: TrectF): TRectF;
begin
  if StateStyles.Transition.Running then begin
    Result := ARect;
    if StateStyles.Transition.FromStateStyle <> nil then begin
      var LFromSurfaceRect := ALGetShapeSurfaceRect(
                                ARect, // const ARect: TRectF;
                                AutoAlignToPixel, // const AAlignToPixel: Boolean;
                                _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.FromStateStyle).Fill, // const AFill: TALBrush;
                                nil, // const AFillResourceStream: TStream;
                                _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.FromStateStyle).StateLayer, // const AStateLayer: TALStateLayer;
                                _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.FromStateStyle).Shadow); // const AShadow: TALShadow): TRectF;
      Result := TRectF.Union(Result, LFromSurfaceRect); // add the extra space needed to draw the shadow/statelayer
    end;
    if StateStyles.Transition.ToStateStyle <> nil then begin
      var LToSurfaceRect := ALGetShapeSurfaceRect(
                              ARect, // const ARect: TRectF;
                              AutoAlignToPixel, // const AAlignToPixel: Boolean;
                              _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.ToStateStyle).Fill, // const AFill: TALBrush;
                              nil, // const AFillResourceStream: TStream;
                              _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.ToStateStyle).StateLayer, // const AStateLayer: TALStateLayer;
                              _TALDynamicBaseStateStyleProtectedAccess(StateStyles.Transition.ToStateStyle).Shadow); // const AShadow: TALShadow): TRectF;
      Result := TRectF.Union(Result, LToSurfaceRect); // add the extra space needed to draw the shadow/statelayer
    end;
  end
  else begin
    var LStateStyle := TBaseStateStyle(StateStyles.GetCurrentRawStyle);
    if LStateStyle <> nil then begin
      Result := ALGetShapeSurfaceRect(
                  ARect, // const ARect: TRectF;
                  AutoAlignToPixel, // const AAlignToPixel: Boolean;
                  LStateStyle.Fill, // const AFill: TALBrush;
                  nil, // const AFillResourceStream: TStream;
                  LStateStyle.StateLayer, // const AStateLayer: TALStateLayer;
                  LStateStyle.Shadow); // const AShadow: TALShadow): TRectF;
    end
    else begin
      Result := ALGetShapeSurfaceRect(
                  ARect, // const ARect: TRectF;
                  AutoAlignToPixel, // const AAlignToPixel: Boolean;
                  Fill, // const AFill: TALBrush;
                  nil, // const AFillResourceStream: TStream;
                  nil, // const AStateLayer: TALStateLayer;
                  Shadow); // const AShadow: TALShadow): TRectF;
    end;
  end;
end;
{$ENDIF}

{*******************************************}
procedure TALDynamicCustomTrack.TThumb.Paint;
begin

  StateStyles.UpdateLastPaintedRawStyle;
  MakeBufDrawable;

  var LDrawable: TALDrawable;
  var LDrawableRect: TRectF;
  if StateStyles.Transition.Running then begin
    LDrawable := ALNullDrawable;
    LDrawableRect := TRectF.Empty;
  end
  else begin
    var LStateStyle := TBaseStateStyle(StateStyles.GetCurrentRawStyle);
    if LStateStyle <> nil then begin
      LDrawable := LStateStyle.FBufDrawable;
      LDrawableRect := LStateStyle.FBufDrawableRect;
      if ALIsDrawableNull(LDrawable) then begin
        LDrawable := FBufDrawable;
        LDrawableRect := FBufDrawableRect;
      end;
    end
    else begin
      LDrawable := FBufDrawable;
      LDrawableRect := FBufDrawableRect;
    end;
  end;

  if ALIsDrawableNull(LDrawable) then begin

    var LCurrentAdjustedStateStyle := TBaseStateStyle(StateStyles.GetCurrentAdjustedStyle);
    if LCurrentAdjustedStateStyle = nil then begin
      inherited Paint;
      exit;
    end;

    {$IF DEFINED(ALSkiaCanvas)}

    // Using a matrix on the canvas results in smoother animations compared to using
    // Ascale with DrawMultilineText. This is because changes in scale affect the font size,
    // leading to rounding issues (I spent many hours looking for a way to avoid this).
    // If there is an animation, it appears jerky because the text position
    // shifts up or down with scale changes due to pixel alignment.
    var LCanvasSaveState: TCanvasSaveState := ALScaleAndCenterCanvas(
                                                Canvas, // Const ACanvas: TCanvas;
                                                AbsoluteRect.ReducePrecision, // Const AAbsoluteRect: TRectF;
                                                LCurrentAdjustedStateStyle.Scale, // Const AScale: Single;
                                                true); // Const ASaveState: Boolean);
    try

      TALDrawRectangleHelper.Create(TSkCanvasCustom(Canvas).Canvas.Handle)
        .SetAlignToPixel(AutoAlignToPixel)
        .SetDstRect(LocalRect.ReducePrecision)
        .SetOpacity(AbsoluteOpacity)
        .SetFill(LCurrentAdjustedStateStyle.Fill)
        .SetStateLayer(LCurrentAdjustedStateStyle.StateLayer, TalphaColors.Null)
        .SetStroke(LCurrentAdjustedStateStyle.Stroke)
        .SetShadow(LCurrentAdjustedStateStyle.Shadow)
        .SetSides(Sides)
        .SetCorners(Corners)
        .SetXRadius(XRadius)
        .SetYRadius(YRadius)
        .Draw;

    finally
      if LCanvasSaveState <> nil then
        Canvas.RestoreState(LCanvasSaveState);
    end;

    {$ELSE}

    var LRect := LocalRect.ReducePrecision;
    InitRenderTargets(LRect);
    if ALCanvasBeginScene(RenderTargetCanvas) then
    try

      ALClearCanvas(RenderTargetCanvas, TAlphaColors.Null);

      TALDrawRectangleHelper.Create(RenderTargetCanvas)
        .SetScale(ALGetScreenScale)
        .SetAlignToPixel(AutoAlignToPixel)
        .SetDstRect(LRect)
        .SetOpacity(AbsoluteOpacity)
        .SetFill(LCurrentAdjustedStateStyle.Fill)
        .SetStateLayer(LCurrentAdjustedStateStyle.StateLayer, TalphaColors.Null)
        .SetStroke(LCurrentAdjustedStateStyle.Stroke)
        .SetShadow(LCurrentAdjustedStateStyle.Shadow)
        .SetSides(Sides)
        .SetCorners(Corners)
        .SetXRadius(XRadius)
        .SetYRadius(YRadius)
        .Draw;

    finally
      ALCanvasEndScene(RenderTargetCanvas)
    end;

    ALUpdateDrawableFromSurface(RenderTargetSurface, RenderTargetDrawable);

    // The Shadow or Statelayer are not included in the dimensions of the LRect rectangle.
    // However, the LRect rectangle is offset by the dimensions of the shadow/Statelayer.
    LRect.Offset(-2*LRect.Left, -2*LRect.Top);

    // LRect must include the LScale
    LRect.Top := LRect.Top * LCurrentAdjustedStateStyle.Scale;
    LRect.right := LRect.right * LCurrentAdjustedStateStyle.Scale;
    LRect.left := LRect.left * LCurrentAdjustedStateStyle.Scale;
    LRect.bottom := LRect.bottom * LCurrentAdjustedStateStyle.Scale;

    // Since LStateStyle.FBufDrawableRect can have different dimensions than the main BufDrawableRect
    // (due to autosizing with different font sizes), we must center LStateStyle.FBufDrawableRect
    // within the main BufDrawableRect to ensure that all changes are visually centered.
    var LMainDrawableRect: TRectF;
    If AlIsDrawableNull(FBufDrawable) then LMainDrawableRect :=LocalRect.ReducePrecision
    else LMainDrawableRect := FBufDrawableRect;
    LMainDrawableRect.Offset(-LMainDrawableRect.Left, -LMainDrawableRect.Top);
    var LCenteredRect := LRect.CenterAt(LMainDrawableRect);
    LRect.Offset(LCenteredRect.Left, LCenteredRect.top);

    // We cannot use the matrix because, if we do, ALAlignToPixelRound in ALDrawDrawable
    // will be ineffective since the matrix will no longer be a simple translation matrix.
    // In such a case, TCustomCanvasGpu(ACanvas).DrawTexture may produce border artifacts
    // if the texture is not perfectly pixel-aligned.
    var LDstRect := TRectF.Create(0, 0, ALGetDrawableWidth(RenderTargetDrawable), ALGetDrawableHeight(RenderTargetDrawable));
    LDstRect.Width := (LDstRect.Width / ALGetScreenScale) * LCurrentAdjustedStateStyle.Scale;
    LDstRect.height := (LDstRect.height / ALGetScreenScale) * LCurrentAdjustedStateStyle.Scale;
    LDstRect.SetLocation(
      LRect.Left,
      LRect.Top);
    ALDrawDrawable(
      Canvas, // const ACanvas: Tcanvas;
      RenderTargetDrawable, // const ADrawable: TALDrawable;
      LDstRect, // const ADstRect: TrectF; // IN Virtual pixels !
      AbsoluteOpacity); // const AOpacity: Single)

    {$ENDIF}

    exit;
  end;

  ALDrawDrawable(
    Canvas, // const ACanvas: Tcanvas;
    LDrawable, // const ADrawable: TALDrawable;
    LDrawableRect.TopLeft, // const ATopLeft: TpointF;
    AbsoluteOpacity); // const AOpacity: Single);

end;

{********************************************************************************}
function TALDynamicCustomTrack.TValueIndicator.TFill.GetDefaultColor: TAlphaColor;
begin
  Result := TAlphacolors.Black;
end;

{***********************************************************************************************}
function TALDynamicCustomTrack.TValueIndicator.TTextSettings.TFont.GetDefaultWeight: TFontWeight;
begin
  Result := TFontWeight.medium;
end;

{**********************************************************************************************}
function TALDynamicCustomTrack.TValueIndicator.TTextSettings.TFont.GetDefaultColor: TAlphaColor;
begin
  Result := TAlphaColors.White;
end;

{*******************************************************************************}
function TALDynamicCustomTrack.TValueIndicator.TTextSettings.CreateFont: TALFont;
begin
  Result := TFont.Create;
end;

{*************************************************************************************************}
function TALDynamicCustomTrack.TValueIndicator.TTextSettings.GetDefaultHorzAlign: TALTextHorzAlign;
begin
  Result := TALTextHorzAlign.center;
end;

{******************************************************************************}
function TALDynamicCustomTrack.TValueIndicator.TMargins.GetDefaultValue: TRectF;
begin
  Result := TRectF.Create(6{Left}, 4{Top}, 6{Right}, 4{Bottom});
end;

{******************************************************************************}
function TALDynamicCustomTrack.TValueIndicator.TPadding.GetDefaultValue: TRectF;
begin
  Result := TRectF.Create(16{Left}, 12{Top}, 16{Right}, 12{Bottom});
end;

{**************************************************************************************************}
constructor TALDynamicCustomTrack.TValueIndicator.Create(const ACustomTrack: TALDynamicCustomTrack);
begin
  inherited create(ACustomTrack);
  AutoSize := TALAutoSizeMode.Both;
  Visible := False;
  Pivot := TPointF.Create(0.5,1);
  FCustomTrack := ACustomTrack;
  FFormat := DefaultFormat;
  FOnCustomFormat := nil;
  FAnimation := TAnimation.ScaleInOut;
  FShowOnInteraction := False;
  //--
  FFloatAnimation := TALFloatAnimation.Create;
  FFloatAnimation.StartValue := 0;
  FFloatAnimation.StopValue := 1;
  FFloatAnimation.Duration := 0.2;
  FFloatAnimation.InterpolationType := TALInterpolationType.cubic;
  FFloatAnimation.InterpolationMode := TALInterpolationMode.out;
  FFloatAnimation.OnProcess := AnimationProcess;
  FFloatAnimation.OnFinish := AnimationFinish;
  //--
  //**var LMarginsChange: TNotifyEvent := Margins.OnChange;
  //**Margins.OnChange := nil;
  //**Margins.DefaultValue := TRectF.create(6{Left}, 4{Top}, 6{Right}, 4{Bottom});
  //**Margins.Rect := Margins.DefaultValue;
  //**Margins.OnChange := LMarginsChange;
  //--
  //**var LPaddingChange: TNotifyEvent := Padding.OnChange;
  //**Padding.OnChange := nil;
  //**Padding.DefaultValue := TRectF.create(16{Left}, 12{Top}, 16{Right}, 12{Bottom});
  //**Padding.Rect := Padding.DefaultValue;
  //**padding.OnChange := LPaddingChange;
end;

{**********************************************************************}
function TALDynamicCustomTrack.TValueIndicator.CreatePadding: TALBounds;
begin
  Result := TPadding.Create;
end;

{**********************************************************************}
function TALDynamicCustomTrack.TValueIndicator.CreateMargins: TALBounds;
begin
  Result := TMargins.Create;
end;

{*******************************************************}
destructor TALDynamicCustomTrack.TValueIndicator.Destroy;
begin
  ALFreeAndNil(FFloatAnimation);
  inherited;
end;

{********************************************************************************}
procedure TALDynamicCustomTrack.TValueIndicator.Assign(Source: TALDynamicControl);
begin
  BeginUpdate;
  Try
    if Source is TValueIndicator then begin
      Format := TValueIndicator(Source).Format;
      OnCustomFormat := TValueIndicator(Source).OnCustomFormat;
      Animation := TValueIndicator(Source).Animation;
      ShowOnInteraction := TValueIndicator(Source).ShowOnInteraction;
    end
    else
      ALAssignError(Source{ASource}, Self{ADest});
    inherited Assign(Source);
  Finally
    EndUpdate;
  End;
end;

{***********************************************************************************}
procedure TALDynamicCustomTrack.TValueIndicator.AdjustPosition(const AThumb: TThumb);
begin
  if FCustomTrack.Orientation = TOrientation.Horizontal then begin
    Position := TALPointD.Create(
                  AThumb.Left - ((Width - AThumb.Width) / 2),
                  AThumb.Top - Height - Margins.Bottom);
  end
  else begin
    Position := TALPointD.Create(
                  AThumb.Left + AThumb.Width + Margins.Left,
                  AThumb.Top - ((Height - AThumb.Height) / 2));
  end;
end;

{****************************************************************************}
procedure TALDynamicCustomTrack.TValueIndicator.Refresh(const AThumb: TThumb);
begin
  if not FShowOnInteraction then exit;
  If {AThumb.IsFocused or} Athumb.IsMouseOver or AThumb.Pressed then begin
    if assigned(OnCustomFormat) then begin
      var LText: String;
      OnCustomFormat(Self, AThumb.GetValue, LText);
      Text := LText;
    end
    else
      Text := ALFormatFloatW(Format, AThumb.GetValue, FormatSettings);
    if FFloatAnimation.TagObject <> AThumb then begin
      FFloatAnimation.Enabled := False;
      visible := False;
    end;
    FFloatAnimation.TagObject := AThumb;
    if not visible then begin
      case FAnimation of
        TAnimation.None: begin
          AdjustPosition(AThumb);
          Visible := True;
          exit;
        end;
        TAnimation.ScaleInOut: begin
          AdjustPosition(AThumb);
          Opacity := 1;
          Scale := TPointF.Create(0, 0);
        end;
        TAnimation.Opacity: begin
          AdjustPosition(AThumb);
          Opacity := 0;
          Scale := TPointF.Create(1, 1);
        end
        else
          Raise Exception.Create('Error A2F4F658-97FC-4F92-AFA4-3BB8192003A8')
      end;
      Visible := True;
      FFloatAnimation.StopAtCurrent;
      FFloatAnimation.Inverse := False;
      FFloatAnimation.Start;
    end
    else if (FFloatAnimation.Running) and
            (FFloatAnimation.Inverse) then begin
      FFloatAnimation.Inverse := False;
    end
    else begin
      AdjustPosition(AThumb);
    end;
  end
  else begin
    if FFloatAnimation.TagObject <> AThumb then begin
      FFloatAnimation.Enabled := False;
      visible := False;
    end;
    FFloatAnimation.TagObject := AThumb;
    If Visible then begin
      if (not FFloatAnimation.Running) then begin
        FFloatAnimation.Inverse := true;
        FFloatAnimation.Start;
      end
      else if (not FFloatAnimation.Inverse) then begin
        FFloatAnimation.Inverse := True;
      end;
    end;
  end;
end;

{********************************************************************************}
procedure TALDynamicCustomTrack.TValueIndicator.AnimationProcess(Sender: TObject);
begin
  case FAnimation of
    TAnimation.ScaleInOut: Scale := TPointF.Create(FFloatAnimation.CurrentValue, FFloatAnimation.CurrentValue);
    TAnimation.Opacity: Opacity := FFloatAnimation.CurrentValue
    else Raise Exception.Create('Error D6F17D76-E47E-4144-8FBA-5CAD3EBF84F3')
  end;
end;

{*******************************************************************************}
procedure TALDynamicCustomTrack.TValueIndicator.AnimationFinish(Sender: TObject);
begin
  FFloatAnimation.Enabled := False;
  case FAnimation of
    TAnimation.ScaleInOut: begin
      if SameValue(Scale.X, 0, TEpsilon.Scale) and SameValue(Scale.Y, 0, TEpsilon.Scale) then
        visible := False;
    end;
    TAnimation.Opacity: begin
      if SameValue(Opacity, 0, TEpsilon.Vector) then
        visible := False;
    end
    else
      Raise Exception.Create('Error D6F17D76-E47E-4144-8FBA-5CAD3EBF84F3')
  end;
end;

{******************************************************************}
function TALDynamicCustomTrack.TValueIndicator.CreateFill: TALBrush;
begin
  Result := TFill.Create;
end;

{*************************************************************************************}
function TALDynamicCustomTrack.TValueIndicator.CreateTextSettings: TALBaseTextSettings;
begin
  Result := TTextSettings.Create;
end;

{******************************************************************************}
function TALDynamicCustomTrack.TValueIndicator.GetTextSettings: TALTextSettings;
begin
  Result := TALTextSettings(Inherited TextSettings);
end;

{********************************************************************************************}
procedure TALDynamicCustomTrack.TValueIndicator.SetTextSettings(const Value: TALTextSettings);
begin
  Inherited SetTextSettings(Value);
end;

{***********************************************************************}
function TALDynamicCustomTrack.TValueIndicator.GetDefaultXRadius: Single;
begin
  Result := -50;
end;

{***********************************************************************}
function TALDynamicCustomTrack.TValueIndicator.GetDefaultYRadius: Single;
begin
  Result := -50;
end;

{**********************************************************************}
function TALDynamicCustomTrack.TValueIndicator.GetDefaultFormat: String;
begin
  Result := Format0;
end;

{*****************************************************************************}
procedure TALDynamicCustomTrack.TValueIndicator.SetFormat(const Value: string);
begin
  if FFormat <> Value then
  begin
    ClearBufDrawable;
    FFormat := Value;
  end;
end;

{*********************************************************************}
function TALDynamicCustomTrack.TValueIndicator.IsFormatStored: Boolean;
begin
  Result := FFormat <> DefaultFormat;
end;

{***********************************************************************}
function TALDynamicCustomTrack.TTrack.TFill.GetDefaultColor: TAlphaColor;
begin
  Result := $ffc5c5c5;
end;

{*************************************************************************}
function TALDynamicCustomTrack.TTrack.TStroke.GetDefaultColor: TAlphaColor;
begin
  Result := TAlphaColors.Null;
end;

{******************************************************************}
constructor TALDynamicCustomTrack.TTrack.TStopIndicatorBrush.Create;
begin
  inherited Create;
  FColor := DefaultColor;
  FColorKey := DefaultColorKey;
  FResourceName := DefaultResourceName;
  FWrapMode := DefaultWrapMode;
  FSize := DefaultSize;
end;

{*************************************************************************************}
function TALDynamicCustomTrack.TTrack.TStopIndicatorBrush.GetDefaultColor: TAlphaColor;
begin
  Result := TAlphaColors.Null;
end;

{***********************************************************************************}
function TALDynamicCustomTrack.TTrack.TStopIndicatorBrush.GetDefaultColorKey: String;
begin
  Result := '';
end;

{***************************************************************************************}
function TALDynamicCustomTrack.TTrack.TStopIndicatorBrush.GetDefaultResourceName: String;
begin
  Result := '';
end;

{*********************************************************************************************}
function TALDynamicCustomTrack.TTrack.TStopIndicatorBrush.GetDefaultWrapMode: TALImageWrapMode;
begin
  Result := TALImageWrapMode.Fit;
end;

{*******************************************************************************}
function TALDynamicCustomTrack.TTrack.TStopIndicatorBrush.GetDefaultSize: Single;
begin
  Result := 4;
end;

{*************************************************************************************}
procedure TALDynamicCustomTrack.TTrack.TStopIndicatorBrush.Assign(Source: TPersistent);
begin
  if Source is TStopIndicatorBrush then begin
    BeginUpdate;
    Try
      Color := TStopIndicatorBrush(Source).Color;
      ColorKey := TStopIndicatorBrush(Source).ColorKey;
      ResourceName := TStopIndicatorBrush(Source).ResourceName;
      WrapMode := TStopIndicatorBrush(Source).WrapMode;
      Size := TStopIndicatorBrush(Source).Size;
    Finally
      EndUpdate;
    End;
  end
  else
    ALAssignError(Source{ASource}, Self{ADest});
end;

{***************************************************************}
procedure TALDynamicCustomTrack.TTrack.TStopIndicatorBrush.Reset;
begin
  BeginUpdate;
  Try
    inherited;
    Color := DefaultColor;
    ColorKey := DefaultColorKey;
    ResourceName := DefaultResourceName;
    WrapMode := DefaultWrapMode;
    Size := DefaultSize;
  finally
    EndUpdate;
  end;
end;

{**********************************************************************}
procedure TALDynamicCustomTrack.TTrack.TStopIndicatorBrush.AlignToPixel;
begin
  BeginUpdate;
  try
    Size := ALAlignDimensionToPixelRound(Size, ALGetScreenScale, Tepsilon.Position);
  finally
    EndUpdate;
  end;
end;

{**************************************************************************}
procedure TALDynamicCustomTrack.TTrack.TStopIndicatorBrush.ApplyColorScheme;
begin
  if FColorKey <> '' then begin
    var LColor := TALStyleManager.Instance.GetColor(FColorKey);
    if FColor <> LColor then begin
      FColor := LColor;
      Change;
    end;
  end;
end;

{*************************************************************************************************************************************************************}
procedure TALDynamicCustomTrack.TTrack.TStopIndicatorBrush.Interpolate(const ATo: TStopIndicatorBrush; const ANormalizedTime: Single; const AReverse: Boolean);
begin
  BeginUpdate;
  Try
    var LPrevColorKey := FColorKey;
    if ATo <> nil then begin
      Color := ALInterpolateColor(Color{Start}, ATo.Color{Stop}, ANormalizedTime);
      if not AReverse then ResourceName := ATo.ResourceName;
      if not AReverse then WrapMode := ATo.WrapMode;
      Size := InterpolateSingle(Size{Start}, ATo.Size{Stop}, ANormalizedTime);
    end
    else begin
      Color := ALInterpolateColor(Color{Start}, DefaultColor{Stop}, ANormalizedTime);
      if not AReverse then ResourceName := DefaultResourceName;
      if not AReverse then WrapMode := DefaultWrapMode;
      Size := InterpolateSingle(Size{Start}, DefaultSize{Stop}, ANormalizedTime);
    end;
    FColorKey := LPrevColorKey;
  finally
    EndUpdate;
  end;
end;

{**********************************************************************************************************************************************************************}
procedure TALDynamicCustomTrack.TTrack.TStopIndicatorBrush.InterpolateNoChanges(const ATo: TStopIndicatorBrush; const ANormalizedTime: Single; const AReverse: Boolean);
begin
  BeginUpdate;
  Try
    Interpolate(ATo, ANormalizedTime, AReverse);
  Finally
    EndUpdateNoChanges;
  end;
end;

{**********************************************************************************}
function TALDynamicCustomTrack.TTrack.TStopIndicatorBrush.hasStopIndicator: Boolean;
begin
  Result := (CompareValue(FSize, 0, TEpsilon.Position) > 0) and
            ((Color <> TalphaColors.Null) or
             (ResourceName <> ''));
end;

{*******************************************************************************}
function TALDynamicCustomTrack.TTrack.TStopIndicatorBrush.IsColorStored: Boolean;
begin
  result := FColor <> DefaultColor;
end;

{**********************************************************************************}
function TALDynamicCustomTrack.TTrack.TStopIndicatorBrush.IsColorKeyStored: Boolean;
begin
  result := FColorKey <> DefaultColorKey;
end;

{**************************************************************************************}
function TALDynamicCustomTrack.TTrack.TStopIndicatorBrush.IsResourceNameStored: Boolean;
begin
  result := FResourceName <> DefaultResourceName;
end;

{**********************************************************************************}
function TALDynamicCustomTrack.TTrack.TStopIndicatorBrush.IsWrapModeStored: Boolean;
begin
  result := FWrapMode <> DefaultWrapMode;
end;

{******************************************************************************}
function TALDynamicCustomTrack.TTrack.TStopIndicatorBrush.IsSizeStored: Boolean;
begin
  result := not SameValue(fSize, DefaultSize, Tepsilon.Position);
end;

{********************************************************************************************}
procedure TALDynamicCustomTrack.TTrack.TStopIndicatorBrush.SetColor(const Value: TAlphaColor);
begin
  if fColor <> Value then begin
    fColor := Value;
    FColorKey := '';
    Change;
  end;
end;

{******************************************************************************************}
procedure TALDynamicCustomTrack.TTrack.TStopIndicatorBrush.SetColorKey(const Value: String);
begin
  if FColorKey <> Value then begin
    FColorKey := Value;
    ApplyColorScheme;
  end;
end;

{**********************************************************************************************}
procedure TALDynamicCustomTrack.TTrack.TStopIndicatorBrush.SetResourceName(const Value: String);
begin
  if fResourceName <> Value then begin
    fResourceName := Value;
    Change;
  end;
end;

{****************************************************************************************************}
procedure TALDynamicCustomTrack.TTrack.TStopIndicatorBrush.SetWrapMode(const Value: TALImageWrapMode);
begin
  if fWrapMode <> Value then begin
    fWrapMode := Value;
    Change;
  end;
end;

{**************************************************************************************}
procedure TALDynamicCustomTrack.TTrack.TStopIndicatorBrush.SetSize(const Value: Single);
begin
  if not SameValue(FSize, Value, TEpsilon.Position) then begin
    FSize := Value;
    Change;
  end;
end;

{*************************************************************************************************************}
constructor TALDynamicCustomTrack.TTrack.TInheritStopIndicatorBrush.Create(const AParent: TStopIndicatorBrush);
begin
  inherited create;
  FParent := AParent;
  FInherit := True;
  fSuperseded := False;
end;

{*******************************************************************************************************}
function TALDynamicCustomTrack.TTrack.TInheritStopIndicatorBrush.CreateSavedState: TALPersistentObserver;
type
  TInheritStopIndicatorBrushClass = class of TInheritStopIndicatorBrush;
begin
  result := TInheritStopIndicatorBrushClass(classtype).Create(nil{AParent});
end;

{**************************************************************************************************}
procedure TALDynamicCustomTrack.TTrack.TInheritStopIndicatorBrush.SetInherit(const AValue: Boolean);
begin
  If FInherit <> AValue then begin
    FInherit := AValue;
    Change;
  end;
end;

{********************************************************************************************}
procedure TALDynamicCustomTrack.TTrack.TInheritStopIndicatorBrush.Assign(Source: TPersistent);
begin
  BeginUpdate;
  Try
    if Source is TInheritStopIndicatorBrush then begin
      Inherit := TInheritStopIndicatorBrush(Source).Inherit;
      fSuperseded := TInheritStopIndicatorBrush(Source).fSuperseded;
    end
    else begin
      Inherit := False;
      fSuperseded := False;
    end;
    inherited Assign(Source);
  Finally
    EndUpdate;
  End;
end;

{**********************************************************************}
procedure TALDynamicCustomTrack.TTrack.TInheritStopIndicatorBrush.Reset;
begin
  BeginUpdate;
  Try
    inherited;
    Inherit := True;
    fSuperseded := False;
  finally
    EndUpdate;
  end;
end;

{****************************************************************************}
procedure TALDynamicCustomTrack.TTrack.TInheritStopIndicatorBrush.DoSupersede;
begin
  Assign(FParent);
end;

{*************************************************************************************************************}
procedure TALDynamicCustomTrack.TTrack.TInheritStopIndicatorBrush.Supersede(Const ASaveState: Boolean = False);
begin
  if ASaveState then SaveState;
  if (FSuperseded) or
     (not inherit) or
     (FParent = nil) then exit;
  BeginUpdate;
  try
    var LParentSuperseded := False;
    if FParent is TInheritStopIndicatorBrush then begin
      TInheritStopIndicatorBrush(FParent).SupersedeNoChanges(true{ASaveState});
      LParentSuperseded := True;
    end;
    try
      DoSupersede;
    finally
      if LParentSuperseded then
        TInheritStopIndicatorBrush(FParent).restoreStateNoChanges;
    end;
    Inherit := False;
    FSuperseded := True;
  finally
    EndUpdate;
  end;
end;

{**********************************************************************************************************************}
procedure TALDynamicCustomTrack.TTrack.TInheritStopIndicatorBrush.SupersedeNoChanges(Const ASaveState: Boolean = False);
begin
  BeginUpdate;
  try
    Supersede(ASaveState);
  finally
    EndUpdateNoChanges;
  end;
end;

{***************************************************************************************}
function TALDynamicCustomTrack.TTrack.TBaseStateStyle.TFill.GetDefaultColor: TAlphaColor;
begin
  Result := $ffc5c5c5;
end;

{*****************************************************************************************}
function TALDynamicCustomTrack.TTrack.TBaseStateStyle.TStroke.GetDefaultColor: TAlphaColor;
begin
  Result := TalphaColors.Null;
end;

{******************************************************************************************}
function TALDynamicCustomTrack.TTrack.TBaseStateStyle.TStateLayer.GetDefaultXRadius: Single;
begin
  Result := -50;
end;

{******************************************************************************************}
function TALDynamicCustomTrack.TTrack.TBaseStateStyle.TStateLayer.GetDefaultYRadius: Single;
begin
  Result := -50;
end;

{**************************************************************************************}
constructor TALDynamicCustomTrack.TTrack.TBaseStateStyle.Create(const AParent: TObject);
begin
  inherited Create(AParent);
  if StateStyleParent <> nil then Raise Exception.create('Error 19ACDBF0-E33C-49D2-B199-5C232A0A71DB')
  else if ControlParent <> nil then FStopIndicator := CreateStopIndicator(ControlParent.StopIndicator)
  else FStopIndicator := CreateStopIndicator(nil);
  FStopIndicator.OnChanged := StopIndicatorChanged;
end;

{**************************************************************}
destructor TALDynamicCustomTrack.TTrack.TBaseStateStyle.Destroy;
begin
  ALFreeAndNil(FStopIndicator);
  inherited Destroy;
end;

{*********************************************************************************************************}
function TALDynamicCustomTrack.TTrack.TBaseStateStyle.CreateFill(const AParent: TALBrush): TALInheritBrush;
begin
  Result := TFill.Create(AParent);
end;

{***********************************************************************************************************************}
function TALDynamicCustomTrack.TTrack.TBaseStateStyle.CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush;
begin
  Result := TStroke.Create(AParent);
end;

{************************************************************************************}
function TALDynamicCustomTrack.TTrack.TBaseStateStyle.CreateStateLayer: TALStateLayer;
begin
  Result := TStateLayer.Create;
end;

{****************************************************************************************************************************************}
function TALDynamicCustomTrack.TTrack.TBaseStateStyle.CreateStopIndicator(const AParent: TStopIndicatorBrush): TInheritStopIndicatorBrush;
begin
  Result := TInheritStopIndicatorBrush.Create(AParent);
end;

{*********************************************************************************}
procedure TALDynamicCustomTrack.TTrack.TBaseStateStyle.Assign(Source: TPersistent);
begin
  if Source is TBaseStateStyle then begin
    BeginUpdate;
    Try
      StopIndicator.Assign(TBaseStateStyle(Source).StopIndicator);
      inherited Assign(Source);
    Finally
      EndUpdate;
    End;
  end
  else
    ALAssignError(Source{ASource}, Self{ADest});
end;

{***********************************************************}
procedure TALDynamicCustomTrack.TTrack.TBaseStateStyle.Reset;
begin
  BeginUpdate;
  Try
    inherited;
    StopIndicator.Reset;
  finally
    EndUpdate;
  end;
end;

{******************************************************************}
procedure TALDynamicCustomTrack.TTrack.TBaseStateStyle.AlignToPixel;
begin
  BeginUpdate;
  try
    Inherited;
    StopIndicator.AlignToPixel;
  finally
    EndUpdate;
  end;
end;

{**********************************************************************}
procedure TALDynamicCustomTrack.TTrack.TBaseStateStyle.ApplyColorScheme;
begin
  BeginUpdate;
  try
    Inherited;
    StopIndicator.ApplyColorScheme;
  finally
    EndUpdate;
  end;
end;

{**************************************************************************************************************************************************************}
procedure TALDynamicCustomTrack.TTrack.TBaseStateStyle.Interpolate(const ATo: TALDynamicBaseStateStyle; const ANormalizedTime: Single; const AReverse: Boolean);
begin
  {$IF defined(debug)}
  if (ATo <> nil) and (not (ATo is TBaseStateStyle)) then
    Raise Exception.Create('Error 70FA71DE-6270-441D-AB33-6F987A011C09');
  {$ENDIF}
  BeginUpdate;
  Try
    inherited Interpolate(ATo, ANormalizedTime, AReverse);
    if ATo <> nil then StopIndicator.Interpolate(TBaseStateStyle(ATo).StopIndicator, ANormalizedTime, AReverse)
    {$IF defined(debug)}
    else if StateStyleParent <> nil then Raise Exception.Create('Error 9B674B61-66C2-4BB1-8A94-D6A58AEAF404')
    {$ENDIF}
    else if ControlParent <> nil then StopIndicator.Interpolate(ControlParent.StopIndicator, ANormalizedTime, AReverse)
    else StopIndicator.Interpolate(nil, ANormalizedTime, AReverse);
  Finally
    EndUpdate;
  End;
end;

{*****************************************************************************}
function TALDynamicCustomTrack.TTrack.TBaseStateStyle.GetControlParent: TTrack;
begin
  {$IF defined(debug)}
  if (inherited ControlParent <> nil) and
     (not (inherited ControlParent is TTrack)) then
    raise Exception.Create('ControlParent must be of type TTrack');
  {$ENDIF}
  result := TTrack(inherited ControlParent);
end;

{*****************************************************************}
procedure TALDynamicCustomTrack.TTrack.TBaseStateStyle.DoSupersede;
begin
  inherited;
  StopIndicator.Supersede;
end;

{****************************************************************************************************************}
procedure TALDynamicCustomTrack.TTrack.TBaseStateStyle.SetStopIndicator(const AValue: TInheritStopIndicatorBrush);
begin
  FStopIndicator.Assign(AValue);
end;

{************************************************************************}
function TALDynamicCustomTrack.TTrack.TBaseStateStyle.GetInherit: Boolean;
begin
  Result := inherited GetInherit and
            StopIndicator.Inherit;
end;

{********************************************************************************************}
procedure TALDynamicCustomTrack.TTrack.TBaseStateStyle.StopIndicatorChanged(ASender: TObject);
begin
  Change;
end;

{*********************************************************************************}
function TALDynamicCustomTrack.TTrack.TDisabledStateStyle.IsOpacityStored: Boolean;
begin
  Result := not SameValue(FOpacity, TControl.DefaultDisabledOpacity, TEpsilon.Scale);
end;

{*****************************************************************************************}
procedure TALDynamicCustomTrack.TTrack.TDisabledStateStyle.SetOpacity(const Value: Single);
begin
  if not SameValue(FOpacity, Value, TEpsilon.Scale) then begin
    FOpacity := Value;
    Change;
  end;
end;

{******************************************************************************************}
constructor TALDynamicCustomTrack.TTrack.TDisabledStateStyle.Create(const AParent: TObject);
begin
  inherited Create(AParent);
  FOpacity := TControl.DefaultDisabledOpacity;
end;

{*************************************************************************************}
procedure TALDynamicCustomTrack.TTrack.TDisabledStateStyle.Assign(Source: TPersistent);
begin
  BeginUpdate;
  Try
    if Source is TDisabledStateStyle then
      Opacity := TDisabledStateStyle(Source).Opacity
    else
      Opacity := TControl.DefaultDisabledOpacity;
    inherited Assign(Source);
  Finally
    EndUpdate;
  End;
end;

{***************************************************************}
procedure TALDynamicCustomTrack.TTrack.TDisabledStateStyle.Reset;
begin
  BeginUpdate;
  Try
    inherited;
    Opacity := TControl.DefaultDisabledOpacity;
  finally
    EndUpdate;
  end;
end;

{****************************************************************************}
function TALDynamicCustomTrack.TTrack.TDisabledStateStyle.GetInherit: Boolean;
begin
  // Opacity is not part of the GetInherit function because it updates the
  // disabledOpacity of the base control immediately every time it changes.
  // Essentially, it acts merely as a link to the disabledOpacity of the base control.
  Result := inherited GetInherit;
end;

{*********************************************************************************************}
constructor TALDynamicCustomTrack.TTrack.TStateStyles.Create(const AParent: TALDynamicControl);
begin
  inherited Create(AParent);
  FDisabled := CreateDisabledStateStyle(AParent);
  FDisabled.OnChanged := DisabledChanged;
end;

{***********************************************************}
destructor TALDynamicCustomTrack.TTrack.TStateStyles.Destroy;
begin
  ALFreeAndNil(FDisabled);
  inherited Destroy;
end;

{***********************************************************************************************************************}
function TALDynamicCustomTrack.TTrack.TStateStyles.CreateDisabledStateStyle(const AParent: TObject): TDisabledStateStyle;
begin
  Result := TDisabledStateStyle.Create(AParent);
end;

{******************************************************************************}
procedure TALDynamicCustomTrack.TTrack.TStateStyles.Assign(Source: TPersistent);
begin
  if Source is TStateStyles then begin
    BeginUpdate;
    Try
      Disabled.Assign(TStateStyles(Source).Disabled);
      inherited Assign(Source);
    Finally
      EndUpdate;
    End;
  end
  else
    ALAssignError(Source{ASource}, Self{ADest});
end;

{********************************************************}
procedure TALDynamicCustomTrack.TTrack.TStateStyles.Reset;
begin
  BeginUpdate;
  Try
    inherited;
    Disabled.reset;
  finally
    EndUpdate;
  end;
end;

{***************************************************************}
procedure TALDynamicCustomTrack.TTrack.TStateStyles.AlignToPixel;
begin
  BeginUpdate;
  Try
    inherited;
    Disabled.AlignToPixel;
  finally
    EndUpdate;
  end;
end;

{*******************************************************************}
procedure TALDynamicCustomTrack.TTrack.TStateStyles.ApplyColorScheme;
begin
  BeginUpdate;
  Try
    inherited;
    Disabled.ApplyColorScheme;
  finally
    EndUpdate;
  end;
end;

{*******************************************************************}
procedure TALDynamicCustomTrack.TTrack.TStateStyles.ClearBufDrawable;
begin
  inherited;
  Disabled.ClearBufDrawable;
end;

{**********************************************************************************************}
function TALDynamicCustomTrack.TTrack.TStateStyles.GetCurrentRawStyle: TALDynamicBaseStateStyle;
begin
  if Not Parent.Enabled then Result := Disabled
  else result := nil;
end;

{*****************************************************************************************}
function TALDynamicCustomTrack.TTrack.TStateStyles.GetParent: TALDynamicCustomTrack.TTrack;
begin
  Result := TALDynamicCustomTrack.TTrack(inherited Parent);
end;

{*************************************************************************************************}
procedure TALDynamicCustomTrack.TTrack.TStateStyles.SetDisabled(const AValue: TDisabledStateStyle);
begin
  FDisabled.Assign(AValue);
end;

{************************************************************************************}
procedure TALDynamicCustomTrack.TTrack.TStateStyles.DisabledChanged(ASender: TObject);
begin
  Change;
end;

{*********************************************************************}
function TALDynamicCustomTrack.TTrack.TMargins.GetDefaultValue: TRectF;
begin
  Result := TRectF.Create(0{Left}, 15{Top}, 0{Right}, 15{Bottom});
end;

{*****************************************************************************************}
constructor TALDynamicCustomTrack.TTrack.Create(const ACustomTrack: TALDynamicCustomTrack);
begin
  FStateStyles := nil;
  //--
  inherited Create(ACustomTrack);
  FCustomTrack := ACustomTrack;
  FStopIndicator := CreateStopIndicator;
  FStopIndicator.OnChanged := StopIndicatorChanged;
  //**Locked := True;
  HitTest := False;
  //--
  FStateStyles := CreateStateStyles;
  FStateStyles.OnChanged := StateStylesChanged;
end;

{*************************************************************}
function TALDynamicCustomTrack.TTrack.CreateMargins: TALBounds;
begin
  Result := TMargins.Create;
end;

{**********************************************}
destructor TALDynamicCustomTrack.TTrack.Destroy;
begin
  ALFreeAndNil(FStateStyles);
  ALFreeAndNil(FStopIndicator);
  inherited;
end;

{***********************************************************************}
procedure TALDynamicCustomTrack.TTrack.Assign(Source: TALDynamicControl);
begin
  BeginUpdate;
  Try
    if Source is TTrack then begin
      StateStyles.Assign(TTrack(Source).StateStyles);
      StopIndicator.Assign(TTrack(Source).StopIndicator);
    end
    else
      ALAssignError(Source{ASource}, Self{ADest});
    inherited Assign(Source);
  Finally
    EndUpdate;
  End;
end;

{*********************************************************}
function TALDynamicCustomTrack.TTrack.CreateFill: TALBrush;
begin
  Result := TFill.Create;
end;

{*****************************************************************}
function TALDynamicCustomTrack.TTrack.CreateStroke: TALStrokeBrush;
begin
  Result := TStroke.Create;
end;

{*****************************************************************************}
function TALDynamicCustomTrack.TTrack.CreateStopIndicator: TStopIndicatorBrush;
begin
  Result := TStopIndicatorBrush.Create;
end;

{********************************************************************}
function TALDynamicCustomTrack.TTrack.CreateStateStyles: TStateStyles;
begin
  Result := TStateStyles.Create(self);
end;

{**************************************************}
procedure TALDynamicCustomTrack.TTrack.AlignToPixel;
begin
  beginUpdate;
  try
    inherited;
    StateStyles.AlignToPixel;
    StopIndicator.AlignToPixel;
  finally
    EndUpdate;
  end;
end;

{******************************************************}
procedure TALDynamicCustomTrack.TTrack.ApplyColorScheme;
begin
  beginUpdate;
  try
    inherited;
    StateStyles.ApplyColorScheme;
    StopIndicator.ApplyColorScheme;
  finally
    EndUpdate;
  end;
end;

{***********************************************************}
function TALDynamicCustomTrack.TTrack.HasCustomDraw: Boolean;
begin
  Result := StopIndicator.hasStopIndicator;
end;

{********************************************************************************}
procedure TALDynamicCustomTrack.TTrack.SetStateStyles(const AValue: TStateStyles);
begin
  FStateStyles.Assign(AValue);
end;

{****************************************************************************************}
procedure TALDynamicCustomTrack.TTrack.SetStopIndicator(const Value: TStopIndicatorBrush);
begin
  FStopIndicator.Assign(Value);
end;

{*************************************************************************}
procedure TALDynamicCustomTrack.TTrack.StateStylesChanged(Sender: TObject);
begin
  ClearBufDrawable;
  DisabledOpacity := StateStyles.Disabled.opacity;
  Repaint;
end;

{***************************************************************************}
procedure TALDynamicCustomTrack.TTrack.StopIndicatorChanged(Sender: TObject);
begin
  ClearBufDrawable;
  Repaint;
end;

{****************************************************}
procedure TALDynamicCustomTrack.TTrack.PaddingChanged;
begin
  inherited;
  ClearBufDrawable;
  Repaint;
end;

{******************************************************}
procedure TALDynamicCustomTrack.TTrack.ClearBufDrawable;
begin
  if FcustomTrack.FIsAligningTracks then exit;
  {$IFDEF debug}
  if (FStateStyles <> nil) and
     (not IsDestroying) and
     (ALIsDrawableNull(FBufDrawable)) and // warn will be raise in inherited
     (not ALIsDrawableNull(FStateStyles.Disabled.FBufDrawable)) then
    ALLog(Classname + '.ClearBufDrawable', 'BufDrawable has been cleared | Name: ' + Name, TalLogType.warn);
  {$endif}
  if FStateStyles <> nil then
    FStateStyles.ClearBufDrawable;
  inherited ClearBufDrawable;
end;

{*****************************************************}
procedure TALDynamicCustomTrack.TTrack.MakeBufDrawable;
begin
  //--- Do not create BufDrawable if not DoubleBuffered
  if {$IF not DEFINED(ALDPK)}(not DoubleBuffered){$ELSE}False{$ENDIF} then begin
    ClearBufDrawable;
    exit;
  end;
  //--
  inherited MakeBufDrawable;
  //--
  var LStateStyle := TBaseStateStyle(StateStyles.GetCurrentRawStyle);
  if LStateStyle = nil then exit;
  if LStateStyle.Inherit then exit;
  if (not ALIsDrawableNull(LStateStyle.FBufDrawable)) then exit;
  LStateStyle.SupersedeNoChanges(true{ASaveState});
  try

    {$IFDEF debug}
    ALLog(Classname + '.MakeBufDrawable', 'Name: ' + Name + ' | Style: ' + LStateStyle.ClassName + ' | Width: ' + ALFloatToStrW(Width)+ ' | Height: ' + ALFloatToStrW(Height));
    {$endif}

    // Create the BufDrawable
    CreateBufDrawable(
      LStateStyle.FBufDrawable, // var ABufDrawable: TALDrawable;
      LStateStyle.FBufDrawableRect, // var ABufDrawableRect: TRectF;
      ALGetScreenScale, // const AScale: Single;
      LStateStyle.Fill, // const AFill: TALBrush;
      LStateStyle.StateLayer, // const AStateLayer: TALStateLayer;
      TAlphaColors.null, // const AStateLayerContentColor: TAlphaColor;
      False, // const ADrawStateLayerOnTop: Boolean;
      LStateStyle.Stroke, // const AStroke: TALStrokeBrush;
      LStateStyle.Shadow, // const AShadow: TALShadow
      LStateStyle.StopIndicator); // const AStopIndicator: TStopIndicator);

  finally
    LStateStyle.RestorestateNoChanges;
  end;
end;

{*******************************************************}
Procedure TALDynamicCustomTrack.TTrack.CreateBufDrawable(
            var ABufDrawable: TALDrawable;
            out ABufDrawableRect: TRectF;
            const AScale: Single;
            const AFill: TALBrush;
            const AStateLayer: TALStateLayer;
            const AStateLayerContentColor: TAlphaColor;
            const ADrawStateLayerOnTop: Boolean;
            const AStroke: TALStrokeBrush;
            const AShadow: TALShadow);
begin
  CreateBufDrawable(
    ABufDrawable, // var ABufDrawable: TALDrawable;
    ABufDrawableRect, // out ABufDrawableRect: TRectF;
    AScale, // const AScale: Single;
    AFill, // const AFill: TALBrush;
    AStateLayer, // const AStateLayer: TALStateLayer;
    AStateLayerContentColor, // const AStateLayerContentColor: TAlphaColor;
    ADrawStateLayerOnTop, // const ADrawStateLayerOnTop: Boolean;
    AStroke, // const AStroke: TALStrokeBrush;
    AShadow, // const AShadow: TALShadow;
    StopIndicator); // const AStopIndicator: TStopIndicator);
end;

{*******************************************************}
Procedure TALDynamicCustomTrack.TTrack.CreateBufDrawable(
            var ABufDrawable: TALDrawable;
            out ABufDrawableRect: TRectF;
            const AScale: Single;
            const AFill: TALBrush;
            const AStateLayer: TALStateLayer;
            const AStateLayerContentColor: TAlphaColor;
            const ADrawStateLayerOnTop: Boolean;
            const AStroke: TALStrokeBrush;
            const AShadow: TALShadow;
            const AStopIndicator: TStopIndicatorBrush);
begin

  if (not ALIsDrawableNull(ABufDrawable)) then exit;

  ABufDrawableRect := LocalRect.ReducePrecision;
  if FCustomTrack.Orientation = TOrientation.Horizontal then
    ABufDrawableRect.Width := FCustomTrack.GetTrackSize(true{AIncludeTrackPadding})
  else
    ABufDrawableRect.Height := FCustomTrack.GetTrackSize(true{AIncludeTrackPadding});
  var LSurfaceRect := ALGetShapeSurfaceRect(
                        ABufDrawableRect, // const ARect: TRectF;
                        AutoAlignToPixel, // const AAlignToPixel: Boolean;
                        AFill, // const AFill: TALBrush;
                        nil, // const AFillResourceStream: TStream;
                        AStateLayer, // const AStateLayer: TALStateLayer;
                        AShadow); // const AShadow: TALShadow): TRectF;
  ABufDrawableRect.Offset(-LSurfaceRect.Left, -LSurfaceRect.Top);

  var LSurface: TALSurface;
  var LCanvas: TALCanvas;
  ALCreateSurface(
    LSurface, // out ASurface: TALSurface;
    LCanvas, // out ACanvas: TALCanvas;
    AScale, // const AScale: Single;
    LSurfaceRect.Width, // const w: integer;
    LSurfaceRect.height);// const h: integer)
  try

    if ALCanvasBeginScene(LCanvas) then
    try

      TALDrawRectangleHelper.Create(LCanvas)
        .SetScale(AScale)
        .SetAlignToPixel(AutoAlignToPixel)
        .SetDstRect(ABufDrawableRect)
        .SetFill(AFill)
        .SetStateLayer(AStateLayer, AStateLayerContentColor)
        .SetDrawStateLayerOnTop(ADrawStateLayerOnTop)
        .SetStroke(AStroke)
        .SetShadow(AShadow)
        .SetSides(Sides)
        .SetCorners(Corners)
        .SetXRadius(XRadius)
        .SetYRadius(YRadius)
        .Draw;

      If AStopIndicator.hasStopIndicator then begin
        var LStopIndicatorCount: integer;
        if FCustomTrack.Frequency > 0 then
          LStopIndicatorCount := Ceil((FCustomTrack.Max - FCustomTrack.Min) / FCustomTrack.Frequency) + 1
        else
          LStopIndicatorCount := 2;
        if FCustomTrack.Orientation = TOrientation.Horizontal then begin
          if LStopIndicatorCount * 2{1 indicator + 1 empty space} > ABufDrawableRect.Width / AStopIndicator.Size then
            LStopIndicatorCount := 2;
        end
        else begin
          if LStopIndicatorCount * 2{1 indicator + 1 empty space} > ABufDrawableRect.Height / AStopIndicator.Size then
            LStopIndicatorCount := 2;
        end;
        LStopIndicatorCount := system.Math.Max(LStopIndicatorCount, 2);
        For var i := 0 to LStopIndicatorCount -1 do begin
          var LDstRect := TrectF.Create(0,0,AStopIndicator.Size, AStopIndicator.Size);
          LDstRect := LDstRect.CenterAt(ABufDrawableRect);
          var LPos: Single;
          if (LStopIndicatorCount = 2) and (I = 1) then
            LPos := FCustomTrack.GetThumbPos(FCustomTrack.Max)
          else
            LPos := FCustomTrack.GetThumbPos(System.math.Min(FCustomTrack.Min + (i * FCustomTrack.Frequency), FCustomTrack.Max));
          LPos := LPos - FCustomTrack.Padding.Left - (AStopIndicator.Size / 2);
          if FCustomTrack.Orientation = TOrientation.Horizontal then
            LDstRect.SetLocation(LPos, LDstRect.Top)
          else
            LDstRect.SetLocation(LDstRect.Left, Lpos);
          TALDrawRectangleHelper.Create(LCanvas)
            .SetScale(AScale)
            .SetAlignToPixel(AutoAlignToPixel)
            .SetDstRect(TRectF.Create(0, 0, 1, 1).FitInto(LDstRect))
            .SetFillColor(AStopIndicator.Color)
            .SetFillResourceName(AStopIndicator.ResourceName)
            .SetFillWrapMode(AStopIndicator.WrapMode)
            .SetXRadius(-50)
            .SetYRadius(-50)
            .Draw;
        end;
      end;

    finally
      ALCanvasEndScene(LCanvas)
    end;

    ABufDrawable := ALCreateDrawableFromSurface(LSurface);
    // The Shadow or Statelayer are not included in the dimensions of the fBufDrawableRect rectangle.
    // However, the fBufDrawableRect rectangle is offset by the dimensions of the shadow/Statelayer.
    ABufDrawableRect.Offset(-2*ABufDrawableRect.Left, -2*ABufDrawableRect.Top);

  finally
    ALFreeAndNilSurface(LSurface, LCanvas);
  end;

end;

{*******************************************}
procedure TALDynamicCustomTrack.TTrack.Paint;
begin

  StateStyles.UpdateLastPaintedRawStyle;
  MakeBufDrawable;

  var LDrawable: TALDrawable;
  var LDrawableRect: TRectF;
  var LStateStyle := TBaseStateStyle(StateStyles.GetCurrentRawStyle);
  if LStateStyle <> nil then begin
    LDrawable := LStateStyle.FBufDrawable;
    LDrawableRect := LStateStyle.FBufDrawableRect;
    if ALIsDrawableNull(LDrawable) then begin
      LDrawable := FBufDrawable;
      LDrawableRect := FBufDrawableRect;
    end;
  end
  else begin
    LDrawable := FBufDrawable;
    LDrawableRect := FBufDrawableRect;
  end;

  if ALIsDrawableNull(LDrawable) then begin

    var LCurrentAdjustedStateStyle := TBaseStateStyle(StateStyles.GetCurrentAdjustedStyle);
    if LCurrentAdjustedStateStyle = nil then begin
      inherited Paint;
      exit;
    end;

    {$IF DEFINED(ALSkiaCanvas)}

    TALDrawRectangleHelper.Create(TSkCanvasCustom(Canvas).Canvas.Handle)
      .SetAlignToPixel(AutoAlignToPixel)
      .SetDstRect(LocalRect.ReducePrecision)
      .SetOpacity(AbsoluteOpacity)
      .SetFill(LCurrentAdjustedStateStyle.Fill)
      .SetStateLayer(LCurrentAdjustedStateStyle.StateLayer, TalphaColors.Null)
      .SetStroke(LCurrentAdjustedStateStyle.Stroke)
      .SetShadow(LCurrentAdjustedStateStyle.Shadow)
      .SetSides(Sides)
      .SetCorners(Corners)
      .SetXRadius(XRadius)
      .SetYRadius(YRadius)
      .Draw;

    {$ELSE}

    {$IF defined(DEBUG)}
    if not doublebuffered then begin
      ALLog('TALDynamicCustomTrack.TTrack.Paint', 'Controls that are not double-buffered only work when SKIA is enabled', TALLogType.ERROR);
      exit;
    end;
    {$ENDIF}

    {$ENDIF}

    exit;
  end;

  var LSrcRect := GetBufDrawableSrcRect;
  var LDstRect := LSrcRect;
  LDstRect.Width := LDstRect.Width / Canvas.Scale;
  LDstRect.height := LDstRect.height / Canvas.Scale;
  LDstRect.SetLocation(0,0);
  ALDrawDrawable(
    Canvas, // const ACanvas: Tcanvas;
    LDrawable, // const ADrawable: TALDrawable;
    LSrcRect, // const ASrcRect: TrectF; // IN REAL PIXEL !
    LDstRect, // const ADstRect: TrectF; // IN Virtual pixels !
    AbsoluteOpacity); // const AOpacity: Single);

end;

{**************************************************************************}
function TALDynamicCustomTrack.TInactiveTrack.GetBufDrawableSrcRect: TRectF;
begin
  if ALIsDrawableNull(FBufDrawable) then Exit(TRectF.Empty);
  Result := TRectF.Create(0, 0, ALGetDrawableWidth(FBufDrawable), ALGetDrawableHeight(FBufDrawable));
  if FCustomTrack.Orientation = TOrientation.Horizontal then begin
    Result.SetLocation(
      Result.width - (Width * Canvas.Scale) - 1{For AddPixelForAlignment in ALCreateSurface},
      Result.Top);
    Result.Width := (Width * Canvas.Scale) + 1{For AddPixelForAlignment in ALCreateSurface};
  end
  else begin
    Result.SetLocation(
      Result.Left,
      Result.Height - (Height * Canvas.Scale) - 1{For AddPixelForAlignment in ALCreateSurface});
    Result.Height := (Height * Canvas.Scale) + 1{For AddPixelForAlignment in ALCreateSurface};
  end;
  Result := ALAlignToPixelRound(Result, TMatrix.Identity, ALGetScreenScale{Scale}, TEpsilon.Position);
end;

{*****************************************************************************}
function TALDynamicCustomTrack.TActiveTrack.TFill.GetDefaultColor: TAlphaColor;
begin
  Result := $ff167efc;
end;

{*************************************************************************************************}
function TALDynamicCustomTrack.TActiveTrack.TDisabledStateStyle.TFill.GetDefaultColor: TAlphaColor;
begin
  Result := $ff167efc;
end;

{*******************************************************************************************************************}
function TALDynamicCustomTrack.TActiveTrack.TDisabledStateStyle.CreateFill(const AParent: TALBrush): TALInheritBrush;
begin
  Result := TFill.Create(AParent);
end;

{************************************************************************************************************************************}
function TALDynamicCustomTrack.TActiveTrack.TStateStyles.CreateDisabledStateStyle(const AParent: TObject): TTrack.TDisabledStateStyle;
begin
  Result := TDisabledStateStyle.Create(AParent);
end;

{***************************************************************}
function TALDynamicCustomTrack.TActiveTrack.CreateFill: TALBrush;
begin
  Result := TFill.Create;
end;

{*********************************************************************************}
function TALDynamicCustomTrack.TActiveTrack.CreateStateStyles: TTrack.TStateStyles;
begin
  Result := TStateStyles.Create(self);
end;

{************************************************************************}
function TALDynamicCustomTrack.TActiveTrack.GetBufDrawableSrcRect: TRectF;
begin
  if ALIsDrawableNull(FBufDrawable) then Exit(TRectF.Empty);
  Result := TRectF.Create(0, 0, ALGetDrawableWidth(FBufDrawable), ALGetDrawableHeight(FBufDrawable));
  if FCustomTrack.Orientation = TOrientation.Horizontal then
    Result.Width := Width * Canvas.Scale
  else
    Result.Height := Height * Canvas.Scale;
  Result := ALAlignToPixelRound(Result, TMatrix.Identity, ALGetScreenScale{Scale}, TEpsilon.Position);
end;

{**************************************************************}
constructor TALDynamicCustomTrack.Create(const AOwner: TObject);
begin
  FThumb := nil;
  FInactiveTrack := nil;
  FActiveTrack := nil;
  FValueIndicator := nil;
  //--
  inherited;
  //--
  //**SetAcceptsControls(False);
  DisabledOpacity := 1;
  //**CanFocus := True;
  //**inherited TabStop := False;
  FTabStop := True;
  FIsAligningTracks := False;
  FOrientation := TOrientation.Horizontal;
  FOnChange := nil;
  //--
  FThumb := CreateThumb;
  FInactiveTrack := CreateInactiveTrack;
  FActiveTrack := CreateActiveTrack;
  FValueIndicator := CreateValueIndicator;
end;

{************************************************}
procedure TALDynamicCustomTrack.AfterConstruction;
begin
  inherited;
  realign;
end;

{****************************************************************}
procedure TALDynamicCustomTrack.Assign(Source: TALDynamicControl);
begin
  BeginUpdate;
  Try
    if Source is TALDynamicCustomTrack then begin
      //**TabStop := TALDynamicCustomTrack(Source).TabStop;
      if InactiveTrack <> nil then InactiveTrack.assign(TALDynamicCustomTrack(Source).InactiveTrack);
      if ActiveTrack <> nil then ActiveTrack.assign(TALDynamicCustomTrack(Source).ActiveTrack);
      if Thumb <> nil then Thumb.assign(TALDynamicCustomTrack(Source).Thumb);
      if ValueIndicator <> nil then ValueIndicator.assign(TALDynamicCustomTrack(Source).ValueIndicator);
      Orientation := TALDynamicCustomTrack(Source).Orientation;
      OnChange := TALDynamicCustomTrack(Source).OnChange;
    end
    else
      ALAssignError(Source{ASource}, Self{ADest});
    inherited Assign(Source);
  Finally
    EndUpdate;
  End;
end;

{*****************************************}
//**procedure TALDynamicCustomTrack.Loaded;
//**begin
//**  if FThumb.FValueRange.IsChanged then
//**    FThumb.FValueRange.Changed(True);
//**  inherited;
//**end;

{**************************************************************************************************************************************************************}
function TALDynamicCustomTrack.CreateInactiveTrack(const AInactiveTrackClass: TInactiveTrackClass = nil; Const AName: String = 'InactiveTrack'): TInactiveTrack;
begin
  if AInactiveTrackClass = nil then Exit(CreateInactiveTrack(TInactiveTrack, AName));
  //--
  Result := AInactiveTrackClass.Create(self);
  //**Result.Parent := self;
  //**Result.Stored := False;
  //**Result.SetSubComponent(True);
  Result.Name := AName; // Useful at design time in the IDE
  //--
  //**var LHalfHeight := GetDefaultSize.Height / 2;
  //**var LMarginsChange := Result.Margins.OnChange;
  //**Result.Margins.OnChange := nil;
  //**Result.Margins.DefaultValue := TrectF.Create(0,LHalfHeight-1,0,LHalfHeight-1); // 2px height
  //**Result.Margins.Rect := Result.Margins.DefaultValue;
  //**Result.Margins.OnChange := LMarginsChange;
  //--
  if Orientation = TOrientation.Horizontal then Result.Align := TALAlignLayout.vertical
  else Result.Align := TALAlignLayout.horizontal;
end;

{****************************************************************************************************************************************************}
function TALDynamicCustomTrack.CreateActiveTrack(const AActiveTrackClass: TActiveTrackClass = nil; Const AName: String = 'ActiveTrack'): TActiveTrack;
begin
  if AActiveTrackClass = nil then Exit(CreateActiveTrack(TActiveTrack, AName));
  //--
  Result := AActiveTrackClass.Create(self);
  //**Result.Parent := self;
  //**Result.Stored := False;
  //**Result.SetSubComponent(True);
  Result.Name := AName; // Useful at design time in the IDE
  //--
  //**var LHalfHeight := GetDefaultSize.Height / 2;
  //**var LMarginsChange := Result.Margins.OnChange;
  //**Result.Margins.OnChange := nil;
  //**Result.Margins.DefaultValue := TrectF.Create(0,LHalfHeight-1,0,LHalfHeight-1); // 2px height
  //**Result.Margins.Rect := Result.Margins.DefaultValue;
  //**Result.Margins.OnChange := LMarginsChange;
  //--
  if Orientation = TOrientation.Horizontal then Result.Align := TALAlignLayout.vertical
  else Result.Align := TALAlignLayout.horizontal;
end;

{**********************************************************************************************************************}
function TALDynamicCustomTrack.CreateThumb(const AThumbClass: TThumbClass = nil; Const AName: String = 'Thumb'): TThumb;
begin
  if AThumbClass = nil then Exit(CreateThumb(TThumb, AName));
  //--
  Result := AThumbClass.Create(self);
  //**Result.Parent := self;
  //**Result.Stored := False;
  //**Result.SetSubComponent(True);
  Result.Name := AName; // Useful at design time in the IDE
  Result.Width := GetDefaultSize.Height; // 32 px width
  //--
  if Orientation = TOrientation.Horizontal then Result.Align := TALAlignLayout.vertical
  else Result.Align := TALAlignLayout.horizontal;
end;

{*******************************************************************************************************************************************************************}
function TALDynamicCustomTrack.CreateValueIndicator(const AValueIndicatorClass: TValueIndicatorClass = nil; Const AName: String = 'ValueIndicator'): TValueIndicator;
begin
  if AValueIndicatorClass = nil then Exit(CreateValueIndicator(TValueIndicator, AName));
  //--
  Result := AValueIndicatorClass.Create(self);
  //**Result.Parent := self;
  //**Result.Stored := False;
  //**Result.SetSubComponent(True);
  Result.Name := AName; // Useful at design time in the IDE
end;

{*******************************************}
procedure TALDynamicCustomTrack.AlignToPixel;
begin
  BeginUpdate;
  Try
    inherited;
    if FInactiveTrack <> nil then FInactiveTrack.AlignToPixel;
    if FActiveTrack <> nil then FActiveTrack.AlignToPixel;
    if FThumb <> nil then FThumb.AlignToPixel;
    if FValueIndicator <> nil then FValueIndicator.AlignToPixel;
  finally
    EndUpdate;
  end;
end;

{***********************************************}
procedure TALDynamicCustomTrack.ApplyColorScheme;
begin
  //BeginUpdate;
  //Try
    inherited;
    //if FInactiveTrack <> nil then FInactiveTrack.ApplyColorScheme;
    //if FActiveTrack <> nil then FActiveTrack.ApplyColorScheme;
    //if FThumb <> nil then FThumb.ApplyColorScheme;
    //if FValueIndicator <> nil then FValueIndicator.ApplyColorScheme;
  //finally
    //EndUpdate;
  //end;
end;

{**********************************************}
procedure TALDynamicCustomTrack.MakeBufDrawable;
begin
  if FInactiveTrack <> nil then FInactiveTrack.MakeBufDrawable;
  if FActiveTrack <> nil then FActiveTrack.MakeBufDrawable;
  if FThumb <> nil then FThumb.MakeBufDrawable;
  //if FValueIndicator <> nil then FValueIndicator.MakeBufDrawable;
end;

{***********************************************}
procedure TALDynamicCustomTrack.ClearBufDrawable;
begin
  if FInactiveTrack <> nil then FInactiveTrack.ClearBufDrawable;
  if FActiveTrack <> nil then FActiveTrack.ClearBufDrawable;
  if FThumb <> nil then FThumb.ClearBufDrawable;
  if FValueIndicator <> nil then FValueIndicator.ClearBufDrawable;
end;

{**************************************************}
function TALDynamicCustomTrack.ValueStored: Boolean;
begin
  Result := not SameValue(Value, 0, Tepsilon.Vector);
end;

{*********************************************************}
function TALDynamicCustomTrack.ViewportSizeStored: Boolean;
begin
  Result := not SameValue(ViewportSize, 0, Tepsilon.Vector);
end;

{******************************************************}
function TALDynamicCustomTrack.FrequencyStored: Boolean;
begin
  Result := not SameValue(Frequency, 0, Tepsilon.Vector);
end;

{************************************************}
function TALDynamicCustomTrack.MaxStored: Boolean;
begin
  Result := not SameValue(Max, FMX.StdActns.DefaultMaxValue, Tepsilon.Vector);
end;

{************************************************}
function TALDynamicCustomTrack.MinStored: Boolean;
begin
  Result := not SameValue(Min, 0, Tepsilon.Vector);
end;

{********************************************}
function TALDynamicCustomTrack.GetMax: Double;
begin
  Result := FThumb.FValueRange.Max;
end;

{**********************************************************}
procedure TALDynamicCustomTrack.SetMax(const Value: Double);
begin
  if not SameValue(GetMax, Value) then begin
    if compareValue(Value, Min) < 0 then min := Value;
    FThumb.FValueRange.Max := Value;
    ClearBufDrawable;
  end;
end;

{********************************************}
function TALDynamicCustomTrack.GetMin: Double;
begin
  Result := FThumb.FValueRange.Min;
end;

{**********************************************************}
procedure TALDynamicCustomTrack.SetMin(const Value: Double);
begin
  if not SameValue(GetMin, Value) then begin
    if compareValue(Value, Max) > 0 then max := Value;
    FThumb.FValueRange.Min := Value;
    ClearBufDrawable;
  end;
end;

{**************************************************}
function TALDynamicCustomTrack.GetFrequency: Double;
begin
  Result := FThumb.FValueRange.Frequency;
end;

{****************************************************************}
procedure TALDynamicCustomTrack.SetFrequency(const Value: Double);
begin
  if not SameValue(GetFrequency, Value) then begin
    FThumb.FValueRange.Frequency := Value;
    ClearBufDrawable;
  end;
end;

{**********************************************}
function TALDynamicCustomTrack.GetValue: Double;
begin
  Result := FThumb.FValueRange.Value;
end;

{******************************************************}
procedure TALDynamicCustomTrack.SetValue(Value: Double);
begin
  if not SameValue(GetValue, Value) then
    FThumb.FValueRange.Value := Value;
end;

{*****************************************************}
function TALDynamicCustomTrack.GetViewportSize: Double;
begin
  Result := FThumb.FValueRange.ViewportSize;
end;

{*******************************************************************}
procedure TALDynamicCustomTrack.SetViewportSize(const Value: Double);
begin
  if not SameValue(GetViewportSize, Value) then
    FThumb.FValueRange.ViewportSize := Value;
end;

{********************************************************}
function TALDynamicCustomTrack.GetDoubleBuffered: boolean;
begin
  result := FThumb.DoubleBuffered;
end;

{***********************************************************************}
procedure TALDynamicCustomTrack.SetDoubleBuffered(const AValue: Boolean);
begin
  FThumb.DoubleBuffered := AValue;
  if FInactiveTrack <> nil then FInactiveTrack.DoubleBuffered := AValue;
  if FActiveTrack <> nil then FActiveTrack.DoubleBuffered := AValue;
  if FValueIndicator <> nil then FValueIndicator.DoubleBuffered := AValue;
end;

{*******************************************************}
//**function TALDynamicCustomTrack._GetCanFocus: Boolean;
//**begin
//**  Result := inherited CanFocus;
//**end;

{*********************************************************************}
//**procedure TALDynamicCustomTrack._SetCanFocus(const Value: Boolean);
//**begin
//**  Inherited CanFocus := Value;
//**  if FThumb <> nil then FThumb.CanFocus := Value;
//**end;

{********************************************************************}
//**procedure TALDynamicCustomTrack._SetTabStop(const Value: Boolean);
//**begin
//**  FTabStop := Value;
//**  if FThumb <> nil then FThumb.TabStop := Value;
//**end;

{*****************************************************}
function TALDynamicCustomTrack.GetLeadingTrack: TTrack;
begin
  Result := FActiveTrack;
end;

{******************************************************}
function TALDynamicCustomTrack.GetTrailingTrack: TTrack;
begin
  Result := FInactiveTrack;
end;

{*****************************************************************}
function TALDynamicCustomTrack.GetLeadingTrackStartPadding: Single;
begin
  var LLeadingTrack := GetLeadingTrack;
  if LLeadingTrack <> nil then begin
    If Orientation = TOrientation.Horizontal then Result := LLeadingTrack.Padding.Left
    else Result := LLeadingTrack.Padding.Top;
  end
  else
    Result := 0;
end;

{****************************************************************}
function TALDynamicCustomTrack.GetTrailingTrackEndPadding: Single;
begin
  var LTrailingTrack := GetTrailingTrack;
  if LTrailingTrack <> nil then begin
    If Orientation = TOrientation.Horizontal then Result := LTrailingTrack.Padding.Right
    else Result := LTrailingTrack.Padding.bottom;
  end
  else
    Result := 0;
end;

{***********************************************************************************************}
function TALDynamicCustomTrack.GetTrackSize(Const AIncludeTrackPadding: Boolean = False): Single;
begin
  if Orientation = TOrientation.Horizontal then begin
    result := Width - Padding.Left - Padding.Right;
    If FThumb <> nil then
      Result := Result - FThumb.Width{FThumb.Width/2 on the left + FThumb.Width/2 on the right};
  end
  else begin
    result := Height - Padding.Top - Padding.Bottom;
    If FThumb <> nil then
      Result := Result - FThumb.Height{FThumb.Height/2 on the left + FThumb.Height/2 on the right};
  end;
  If not AIncludeTrackPadding then
    Result := Result - GetLeadingTrackStartPadding - GetTrailingTrackEndPadding;
end;

{****************************************}
procedure TALDynamicCustomTrack.DoResized;
begin
  inherited;
  if FActiveTrack <> nil then
    FActiveTrack.ClearBufDrawable;
  if FInactiveTrack <> nil then
    FInactiveTrack.ClearBufDrawable;
end;

{****************************************}
procedure TALDynamicCustomTrack.DoRealign;
begin
  inherited;
  var LSaveDisableAlign := FDisableAlign;
  var LSaveIsAligningTracks := FIsAligningTracks;
  FIsAligningTracks := True;
  FDisableAlign := True;
  BeginUpdate;
  Try
    AlignThumb;
    AlignTracks;
  Finally
    EndUpdate;
    FDisableAlign := LSaveDisableAlign;
    FIsAligningTracks := LSaveIsAligningTracks;
  End;
end;

{***********************************************************************}
function TALDynamicCustomTrack.GetThumbPos(const AValue: single): Single;

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  function _ValueToPos(MinValue, MaxValue, ViewportSize: Double; TrackSize, Value: Single): Single;
  begin
    if ViewportSize < 0 then ViewportSize := 0;
    var LValRel: Double := MaxValue - MinValue - ViewportSize;
    if LValRel > 0 then begin
      LValRel := (Value - MinValue) / LValRel;
      Result := TrackSize * LValRel;
    end
    else Result := 0;
  end;

begin
  var LPos := _ValueToPos(
                Min, // MinValue
                Max, // MaxValue
                ViewportSize, // ViewportSize
                GetTrackSize, // TrackSize
                AValue); // Value
  If Orientation = TOrientation.Horizontal then Result := LPos + padding.Left
  else Result := LPos + padding.Top;
  Result := Result + GetLeadingTrackStartPadding;
  Result := ALAlignDimensionToPixelRound(Result, ALGetScreenScale, TEpsilon.Position);
end;

{*****************************************}
procedure TALDynamicCustomTrack.AlignThumb;
begin
  if FThumb = nil then exit;
  var LThumbPos := GetThumbPos(Value);
  If Orientation = TOrientation.Horizontal then
    FThumb.Left := LThumbPos
  else
    FThumb.Top := LThumbPos
end;

{******************************************}
procedure TALDynamicCustomTrack.AlignTracks;
begin
  if FThumb = nil then exit;
  if Orientation = TOrientation.Horizontal then begin
    if FInactiveTrack <> nil then begin
      FInactiveTrack.Left := FThumb.Left + Fthumb.Width + Fthumb.Margins.Right;
      FInactiveTrack.Width := Width - Padding.Right - FInactiveTrack.Left - (Fthumb.Width / 2);
    end;
    if FActiveTrack <> nil then begin
      FActiveTrack.Left := Padding.Left + (Fthumb.Width / 2);
      FActiveTrack.Width := FThumb.Left - Fthumb.Margins.Left - FActiveTrack.Left;
    end;
  end
  else begin
    if FInactiveTrack <> nil then begin
      FInactiveTrack.Top := FThumb.Top + Fthumb.Height + Fthumb.Margins.Bottom;
      FInactiveTrack.Height := Height - Padding.Bottom - FInactiveTrack.Top - (Fthumb.Height / 2);
    end;
    if FActiveTrack <> nil then begin
      FActiveTrack.Top := Padding.Top + (Fthumb.Height / 2);
      FActiveTrack.Height := FThumb.Top - Fthumb.Margins.Top - FActiveTrack.Top;
    end;
  end;
end;

{****************************************}
procedure TALDynamicCustomTrack.DoChanged;
begin
  //**if {not (csLoading in ComponentState) and} Assigned(FOnChange) then
    FOnChange(Self);
end;

{*********************************************}
procedure TALDynamicCustomTrack.EnabledChanged;
begin
  inherited;
  if FInactiveTrack <> nil then FInactiveTrack.enabled := enabled;
  if FActiveTrack <> nil then FActiveTrack.enabled := enabled;
  if FThumb <> nil then FThumb.enabled := enabled;
  if FValueIndicator <> nil then FValueIndicator.enabled := enabled;
end;

{************************************************************************}
procedure TALDynamicCustomTrack.SetOrientation(const Value: TOrientation);

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  function SwapTopBottomWithLeftRight(Const ARect: TrectF): TRectF;
  Begin
    Result.Left := ARect.Top;
    Result.Top := ARect.Left;
    Result.Right := ARect.Bottom;
    Result.Bottom := ARect.Right;
  End;

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  function SwapAlign(Const AAlign: TALAlignLayout): TALAlignLayout;
  Begin
    If AAlign = TALAlignLayout.Vertical then result := TALAlignLayout.Horizontal
    else If AAlign = TALAlignLayout.Horizontal then result := TALAlignLayout.Vertical
    else result := AAlign;
  End;

begin
  if FOrientation <> Value then begin
    FOrientation := Value;
    //**if not (csLoading in ComponentState) then begin
      BeginUpdate;
      Try
        SetBounds(Left, Top, Height, Width);
        Margins.Rect := SwapTopBottomWithLeftRight(Margins.Rect);
        Padding.Rect := SwapTopBottomWithLeftRight(Padding.Rect);
        if FActiveTrack <> nil then begin
          FActiveTrack.Margins.Rect := SwapTopBottomWithLeftRight(FActiveTrack.Margins.Rect);
          FActiveTrack.Padding.Rect := SwapTopBottomWithLeftRight(FActiveTrack.Padding.Rect);
          FActiveTrack.Align := SwapAlign(FActiveTrack.Align);
        end;
        if FInactiveTrack <> nil then begin
          FInactiveTrack.Margins.Rect := SwapTopBottomWithLeftRight(FInactiveTrack.Margins.Rect);
          FInactiveTrack.Padding.Rect := SwapTopBottomWithLeftRight(FInactiveTrack.Padding.Rect);
          FInactiveTrack.Align := SwapAlign(FInactiveTrack.Align);
        end;
        if FThumb <> nil then begin
          FThumb.Margins.Rect := SwapTopBottomWithLeftRight(FThumb.Margins.Rect);
          FThumb.padding.Rect := SwapTopBottomWithLeftRight(FThumb.padding.Rect);
          FThumb.TouchTargetExpansion := SwapTopBottomWithLeftRight(FThumb.TouchTargetExpansion);
          var LThumbWidth := FThumb.Width;
          FThumb.Width := FThumb.Height;
          FThumb.Height := LThumbWidth;
          FThumb.Align := SwapAlign(FThumb.Align);
        end;
      Finally
        EndUpdate;
      End;
    //**end
    //**else begin
    //**  if FActiveTrack <> nil then
    //**    FActiveTrack.Align := SwapAlign(FActiveTrack.Align);
    //**  if FInactiveTrack <> nil then
    //**    FInactiveTrack.Align := SwapAlign(FInactiveTrack.Align);
    //**  if FThumb <> nil then
    //**    FThumb.Align := SwapAlign(FThumb.Align);
    //**end;
  end;
end;

{*************************************************}
function TALDynamicTrackBar.GetDefaultSize: TSizeF;
begin
  Result := TSizeF.Create(150, 32);
end;

{**********************************************************************************}
procedure TALDynamicRangeTrackBar.TMinInactiveTrack.SetXRadius(const Value: Single);
begin
  Inherited;
  var LMaxInactiveTrack := TALDynamicRangeTrackBar(FCustomTrack).FMaxInactiveTrack;
  if LMaxInactiveTrack <> nil then
    LMaxInactiveTrack.SetXRadius(Value);
end;

{**********************************************************************************}
procedure TALDynamicRangeTrackBar.TMinInactiveTrack.SetYRadius(const Value: Single);
begin
  Inherited;
  var LMaxInactiveTrack := TALDynamicRangeTrackBar(FCustomTrack).FMaxInactiveTrack;
  if LMaxInactiveTrack <> nil then
    LMaxInactiveTrack.SetYRadius(Value);
end;

{************************************************************************************}
procedure TALDynamicRangeTrackBar.TMinInactiveTrack.SetCorners(const Value: TCorners);
begin
  Inherited;
  var LMaxInactiveTrack := TALDynamicRangeTrackBar(FCustomTrack).FMaxInactiveTrack;
  if LMaxInactiveTrack <> nil then
    LMaxInactiveTrack.SetCorners(Value);
end;

{*****************************************************************}
procedure TALDynamicRangeTrackBar.TMinInactiveTrack.MarginsChanged;
begin
  Inherited;
  var LMaxInactiveTrack := TALDynamicRangeTrackBar(FCustomTrack).FMaxInactiveTrack;
  if LMaxInactiveTrack <> nil then
    LMaxInactiveTrack.Margins.Rect := Margins.Rect;
end;

{*****************************************************************}
procedure TALDynamicRangeTrackBar.TMinInactiveTrack.PaddingChanged;
begin
  Inherited;
  var LMaxInactiveTrack := TALDynamicRangeTrackBar(FCustomTrack).FMaxInactiveTrack;
  if LMaxInactiveTrack <> nil then
    LMaxInactiveTrack.Padding.Rect := Padding.Rect;
end;

{****************************************************************************************}
procedure TALDynamicRangeTrackBar.TMinInactiveTrack.StopIndicatorChanged(Sender: TObject);
begin
  Inherited;
  var LMaxInactiveTrack := TALDynamicRangeTrackBar(FCustomTrack).FMaxInactiveTrack;
  if LMaxInactiveTrack <> nil then
    LMaxInactiveTrack.StopIndicator.Assign(StopIndicator);
end;

{*******************************************************************************}
procedure TALDynamicRangeTrackBar.TMinInactiveTrack.FillChanged(Sender: TObject);
begin
  Inherited;
  var LMaxInactiveTrack := TALDynamicRangeTrackBar(FCustomTrack).FMaxInactiveTrack;
  if LMaxInactiveTrack <> nil then
    LMaxInactiveTrack.Fill.Assign(Fill);
end;

{*********************************************************************************}
procedure TALDynamicRangeTrackBar.TMinInactiveTrack.StrokeChanged(Sender: TObject);
begin
  Inherited;
  var LMaxInactiveTrack := TALDynamicRangeTrackBar(FCustomTrack).FMaxInactiveTrack;
  if LMaxInactiveTrack <> nil then
    LMaxInactiveTrack.Stroke.Assign(Stroke);
end;

{*********************************************************************}
function TALDynamicRangeTrackBar.TMinInactiveTrack._GetOpacity: Single;
begin
  Result := Inherited Opacity;
end;

{************************************************************************************}
procedure TALDynamicRangeTrackBar.TMinInactiveTrack._SetOpacity(const AValue: Single);
begin
  Inherited Opacity := AValue;
  var LMaxInactiveTrack := TALDynamicRangeTrackBar(FCustomTrack).FMaxInactiveTrack;
  if LMaxInactiveTrack <> nil then
    LMaxInactiveTrack.Opacity := AValue;
end;

{***************************************************************************}
function TALDynamicRangeTrackBar.TMinInactiveTrack._IsOpacityStored: boolean;
begin
  Result := not SameValue(FOpacity, 1);
end;

{*******************************************************************************}
function TALDynamicRangeTrackBar.TMinInactiveTrack.GetBufDrawableSrcRect: TRectF;
begin
  if ALIsDrawableNull(FBufDrawable) then Exit(TRectF.Empty);
  Result := TRectF.Create(0, 0, ALGetDrawableWidth(FBufDrawable), ALGetDrawableHeight(FBufDrawable));
  if FCustomTrack.Orientation = TOrientation.Horizontal then
    Result.Width := Width * Canvas.Scale
  else
    Result.Height := Height * Canvas.Scale;
  Result := ALAlignToPixelRound(Result, TMatrix.Identity, ALGetScreenScale{Scale}, TEpsilon.Position);
end;

{*******************************************************************************}
function TALDynamicRangeTrackBar.TMaxInactiveTrack.GetBufDrawableSrcRect: TRectF;
begin
  if ALIsDrawableNull(FBufDrawable) then Exit(TRectF.Empty);
  Result := TRectF.Create(0, 0, ALGetDrawableWidth(FBufDrawable), ALGetDrawableHeight(FBufDrawable));
  if FCustomTrack.Orientation = TOrientation.Horizontal then begin
    Result.SetLocation(
      Result.width - (Width * Canvas.Scale) - 1{For AddPixelForAlignment in ALCreateSurface},
      Result.Top);
    Result.Width := (Width * Canvas.Scale) + 1{For AddPixelForAlignment in ALCreateSurface};
  end
  else begin
    Result.SetLocation(
      Result.Left,
      Result.Height - (Height * Canvas.Scale) - 1{For AddPixelForAlignment in ALCreateSurface});
    Result.Height := (Height * Canvas.Scale) + 1{For AddPixelForAlignment in ALCreateSurface};
  end;
  Result := ALAlignToPixelRound(Result, TMatrix.Identity, ALGetScreenScale{Scale}, TEpsilon.Position);
end;

{**************************************************************************}
function TALDynamicRangeTrackBar.TActiveTrack.GetBufDrawableSrcRect: TRectF;
begin
  if ALIsDrawableNull(FBufDrawable) then Exit(TRectF.Empty);
  Result := TRectF.Create(0, 0, ALGetDrawableWidth(FBufDrawable), ALGetDrawableHeight(FBufDrawable));
  if FCustomTrack.Orientation = TOrientation.Horizontal then begin
    Var LThumbWidth: Single;
    If FcustomTrack.FThumb <> nil then LThumbWidth := FcustomTrack.FThumb.Width
    else LThumbWidth := 0;
    Result.SetLocation(
      (Left - FcustomTrack.Padding.Left - (LThumbWidth / 2)) * Canvas.Scale,
      Result.Top);
    Result.Width := Width * Canvas.Scale;
  end
  else begin
    Var LThumbHeight: Single;
    If FcustomTrack.FThumb <> nil then LThumbHeight := FcustomTrack.FThumb.Height
    else LThumbHeight := 0;
    Result.SetLocation(
      Result.Left,
      (Top - FcustomTrack.Padding.Top - (LThumbHeight / 2)) * Canvas.Scale);
    Result.Height := Height * Canvas.Scale;
  end;
  Result := ALAlignToPixelRound(Result, TMatrix.Identity, ALGetScreenScale{Scale}, TEpsilon.Position);
end;

{**********************************************************************************************}
constructor TALDynamicRangeTrackBar.TMinThumb.Create(const ACustomTrack: TALDynamicCustomTrack);
begin
  inherited;
  //**FFormerTouchTargetExpansionChangedHandler := TouchTargetExpansion.OnChange;
  //**TouchTargetExpansion.OnChange := TouchTargetExpansionChanged;
end;

{*************************************************************}
function TALDynamicRangeTrackBar.TMinThumb._GetOpacity: Single;
begin
  Result := Inherited Opacity;
end;

{****************************************************************************}
procedure TALDynamicRangeTrackBar.TMinThumb._SetOpacity(const AValue: Single);
begin
  Inherited Opacity := AValue;
  var LMaxThumb := TALDynamicRangeTrackBar(FCustomTrack).FMaxThumb;
  if LMaxThumb <> nil then
    LMaxThumb.Opacity := AValue;
end;

{*************************************************************}
function TALDynamicRangeTrackBar.TMinThumb._GetCursor: TCursor;
begin
  Result := Inherited Cursor;
end;

{****************************************************************************}
procedure TALDynamicRangeTrackBar.TMinThumb._SetCursor(const AValue: TCursor);
begin
  Inherited;
  var LMaxThumb := TALDynamicRangeTrackBar(FCustomTrack).FMaxThumb;
  if LMaxThumb <> nil then
    LMaxThumb.Cursor := AValue;
end;

{*******************************************************************}
function TALDynamicRangeTrackBar.TMinThumb._IsOpacityStored: boolean;
begin
  Result := not SameValue(FOpacity, 1);
end;

{**************************************************************************}
procedure TALDynamicRangeTrackBar.TMinThumb.SetXRadius(const Value: Single);
begin
  Inherited;
  var LMaxThumb := TALDynamicRangeTrackBar(FCustomTrack).FMaxThumb;
  if LMaxThumb <> nil then
    LMaxThumb.XRadius := Value;
end;

{**************************************************************************}
procedure TALDynamicRangeTrackBar.TMinThumb.SetYRadius(const Value: Single);
begin
  Inherited;
  var LMaxThumb := TALDynamicRangeTrackBar(FCustomTrack).FMaxThumb;
  if LMaxThumb <> nil then
    LMaxThumb.YRadius := Value;
end;

{****************************************************************************}
procedure TALDynamicRangeTrackBar.TMinThumb.SetCorners(const Value: TCorners);
begin
  Inherited;
  var LMaxThumb := TALDynamicRangeTrackBar(FCustomTrack).FMaxThumb;
  if LMaxThumb <> nil then
    LMaxThumb.Corners := Value;
end;

{*********************************************************}
procedure TALDynamicRangeTrackBar.TMinThumb.MarginsChanged;
begin
  Inherited;
  var LMaxThumb := TALDynamicRangeTrackBar(FCustomTrack).FMaxThumb;
  if LMaxThumb <> nil then
    LMaxThumb.Margins.rect := Margins.rect;
end;

{*********************************************************}
procedure TALDynamicRangeTrackBar.TMinThumb.PaddingChanged;
begin
  Inherited;
  var LMaxThumb := TALDynamicRangeTrackBar(FCustomTrack).FMaxThumb;
  if LMaxThumb <> nil then
    LMaxThumb.Padding.rect := Padding.rect;
end;

{***********************************************************************}
procedure TALDynamicRangeTrackBar.TMinThumb.FillChanged(Sender: TObject);
begin
  Inherited;
  var LMaxThumb := TALDynamicRangeTrackBar(FCustomTrack).FMaxThumb;
  if LMaxThumb <> nil then
    LMaxThumb.Fill.Assign(Fill);
end;

{*************************************************************************}
procedure TALDynamicRangeTrackBar.TMinThumb.StrokeChanged(Sender: TObject);
begin
  Inherited;
  var LMaxThumb := TALDynamicRangeTrackBar(FCustomTrack).FMaxThumb;
  if LMaxThumb <> nil then
    LMaxThumb.Stroke.Assign(Stroke);
end;

{*************************************************************************}
procedure TALDynamicRangeTrackBar.TMinThumb.ShadowChanged(Sender: TObject);
begin
  Inherited;
  var LMaxThumb := TALDynamicRangeTrackBar(FCustomTrack).FMaxThumb;
  if LMaxThumb <> nil then
    LMaxThumb.Shadow.Assign(Shadow);
end;

{******************************************************************************}
procedure TALDynamicRangeTrackBar.TMinThumb.StateStylesChanged(Sender: TObject);
begin
  Inherited;
  var LMaxThumb := TALDynamicRangeTrackBar(FCustomTrack).FMaxThumb;
  if LMaxThumb <> nil then
    LMaxThumb.StateStyles.Assign(StateStyles);
end;

{****************************************************************************************}
procedure TALDynamicRangeTrackBar.TMinThumb.SetTouchTargetExpansion(const AValue: TRectF);
begin
  Inherited;
  var LMaxThumb := TALDynamicRangeTrackBar(FCustomTrack).FMaxThumb;
  if LMaxThumb <> nil then
    LMaxThumb.TouchTargetExpansion := TouchTargetExpansion;
end;

{****************************************************}
procedure TALDynamicRangeTrackBar.TMinThumb.DoResized;
begin
  Inherited;
  var LMaxThumb := TALDynamicRangeTrackBar(FCustomTrack).FMaxThumb;
  if LMaxThumb <> nil then
    LMaxThumb.SetSize(TSizeF.Create(Width, Height));
end;

{**********************************************************************************************}
constructor TALDynamicRangeTrackBar.TMaxThumb.Create(const ACustomTrack: TALDynamicCustomTrack);
begin
  inherited;
  var LValueRangeChanged := FValueRange.OnChanged;
  FValueRange.OnChanged := nil;
  FValueRange.Value := FValueRange.Max;
  FValueRange.OnChanged := LValueRangeChanged;
end;

{****************************************************************}
constructor TALDynamicRangeTrackBar.Create(const AOwner: TObject);
begin
  //--
  FMaxInactiveTrack := nil;
  FMaxThumb := nil;
  //--
  inherited;
  //--
  FMaxInactiveTrack := CreateInactiveTrack(TMaxInactiveTrack, 'MaxInactiveTrack');
  FMaxThumb := CreateThumb(TMaxThumb, 'MaxThumb');
  //--
  //**FThumb.TabOrder := 0;
  //**FMaxThumb.TabOrder := 1;
end;

{*******************************************}
//**procedure TALDynamicRangeTrackBar.Loaded;
//**begin
//**  if FMaxThumb.FValueRange.IsChanged then
//**    FMaxThumb.FValueRange.Changed(True);
//**  inherited;
//**end;

{*********************************************}
procedure TALDynamicRangeTrackBar.AlignToPixel;
begin
  BeginUpdate;
  Try
    inherited;
    if FMaxInactiveTrack <> nil then FMaxInactiveTrack.AlignToPixel;
    if FMaxThumb <> nil then FMaxThumb.AlignToPixel;
  finally
    EndUpdate;
  end;
end;

{*************************************************}
procedure TALDynamicRangeTrackBar.ApplyColorScheme;
begin
  //BeginUpdate;
  //Try
    inherited;
    //if FMaxInactiveTrack <> nil then FMaxInactiveTrack.ApplyColorScheme;
    //if FMaxThumb <> nil then FMaxThumb.ApplyColorScheme;
  //finally
    //EndUpdate;
  //end;
end;

{***********************************************}
procedure TALDynamicRangeTrackBar.EnabledChanged;
begin
  inherited;
  if FMaxInactiveTrack <> nil then FMaxInactiveTrack.enabled := enabled;
  if FMaxThumb <> nil then FMaxThumb.enabled := enabled;
end;

{************************************************}
procedure TALDynamicRangeTrackBar.MakeBufDrawable;
begin
  inherited;
  if FMaxInactiveTrack <> nil then FMaxInactiveTrack.MakeBufDrawable;
  if FMaxThumb <> nil then FMaxThumb.MakeBufDrawable;
end;

{*************************************************}
procedure TALDynamicRangeTrackBar.ClearBufDrawable;
begin
  inherited;
  if FMaxInactiveTrack <> nil then FMaxInactiveTrack.ClearBufDrawable;
  if FMaxThumb <> nil then FMaxThumb.ClearBufDrawable;
end;

{*****************************************************************************}
function TALDynamicRangeTrackBar.GetLeadingTrack: TALDynamicCustomTrack.TTrack;
begin
  Result := FInactiveTrack;
end;

{******************************************************************************}
function TALDynamicRangeTrackBar.GetTrailingTrack: TALDynamicCustomTrack.TTrack;
begin
  Result := FMaxInactiveTrack;
end;

{******************************************************}
function TALDynamicRangeTrackBar.GetDefaultSize: TSizeF;
begin
  Result := TSizeF.Create(200, 32);
end;

{*******************************************************}
function TALDynamicRangeTrackBar.MaxValueStored: Boolean;
begin
  Result := not SameValue(MaxValue, FMX.StdActns.DefaultMaxValue, Tepsilon.Vector);
end;

{************************************************************}
procedure TALDynamicRangeTrackBar.SetMax(const Value: Double);
begin
  if not SameValue(GetMax, Value) then begin
    inherited;
    FMaxThumb.FValueRange.Max := Value;
  end;
end;

{************************************************************}
procedure TALDynamicRangeTrackBar.SetMin(const Value: Double);
begin
  if not SameValue(GetMin, Value) then begin
    inherited;
    FMaxThumb.FValueRange.Min := Value;
  end;
end;

{******************************************************************}
procedure TALDynamicRangeTrackBar.SetFrequency(const Value: Double);
begin
  if not SameValue(GetFrequency, Value) then begin
    inherited;
    FMaxThumb.FValueRange.Frequency := Value;
  end;
end;

{********************************************************}
procedure TALDynamicRangeTrackBar.SetValue(Value: Double);
begin
  if not SameValue(GetValue, Value) then begin
    inherited;
    if (not fThumb.Pressed) and
       (GetValue > (max - Min) / 2) then fThumb.BringToFront;
  end;
end;

{***************************************************}
function TALDynamicRangeTrackBar.GetMaxValue: Double;
begin
  Result := FMaxThumb.FValueRange.Value;
end;

{***********************************************************}
procedure TALDynamicRangeTrackBar.SetMaxValue(Value: Double);
begin
  if not SameValue(GetMaxValue, Value) then begin
    FMaxThumb.FValueRange.Value := Value;
    if (not fMaxThumb.Pressed) and
       (GetMaxValue < (max - Min) / 2) then fMaxThumb.BringToFront;
  end;
end;

{*********************************************************************}
procedure TALDynamicRangeTrackBar.SetViewportSize(const Value: Double);
begin
  if not SameValue(GetViewportSize, Value) then begin
    inherited;
    FMaxThumb.FValueRange.ViewportSize := Value;
  end;
end;

{*************************************************************************}
procedure TALDynamicRangeTrackBar.SetDoubleBuffered(const AValue: Boolean);
begin
  Inherited;
  if FMaxThumb <> nil then FMaxThumb.DoubleBuffered := AValue;
end;

{***********************************************************************}
//**procedure TALDynamicRangeTrackBar._SetCanFocus(const Value: Boolean);
//**begin
//**  Inherited;
//**  if FMaxThumb <> nil then FMaxThumb.CanFocus := Value;
//**end;

{**********************************************************************}
//**procedure TALDynamicRangeTrackBar._SetTabStop(const Value: Boolean);
//**begin
//**  Inherited;
//**  if FMaxThumb <> nil then FMaxThumb.TabStop := Value;
//**end;

{************************************************************************************************************************************************************************************************************}
function TALDynamicRangeTrackBar.CreateInactiveTrack(const AInactiveTrackClass: TALDynamicCustomTrack.TInactiveTrackClass = nil; Const AName: String = 'InactiveTrack'): TALDynamicCustomTrack.TInactiveTrack;
begin
  if AInactiveTrackClass = nil then Exit(CreateInactiveTrack(TMinInactiveTrack, AName));
  result := Inherited;
end;

{**************************************************************************************************************************************************************************************************}
function TALDynamicRangeTrackBar.CreateActiveTrack(const AActiveTrackClass: TALDynamicCustomTrack.TActiveTrackClass = nil; Const AName: String = 'ActiveTrack'): TALDynamicCustomTrack.TActiveTrack;
begin
  if AActiveTrackClass = nil then Exit(CreateActiveTrack(TActiveTrack, AName));
  result := Inherited;
end;

{********************************************************************************************************************************************************************}
function TALDynamicRangeTrackBar.CreateThumb(const AThumbClass: TALDynamicCustomTrack.TThumbClass = nil; Const AName: String = 'Thumb'): TALDynamicCustomTrack.TThumb;
begin
  if AThumbClass = nil then Exit(CreateThumb(TMinThumb, AName));
  result := Inherited;
end;

{******************************************}
procedure TALDynamicRangeTrackBar.DoResized;
begin
  inherited;
  if FMaxInactiveTrack <> nil then
    FMaxInactiveTrack.ClearBufDrawable;
end;

{******************************************}
procedure TALDynamicRangeTrackBar.DoRealign;
begin
  // Realign is called by TALValueRangeTrack.DoChanged,
  // so we can check here if minValue <= maxValue.
  if (FThumb <> nil) and (FMaxThumb <> nil) and (minValue > MaxValue) then begin
    if fThumb.Pressed then MinValue := MaxValue
    else MaxValue := MinValue;
    exit; // no need to continue, this function will be called again
  end;
  inherited DoRealign;
end;

{*******************************************}
procedure TALDynamicRangeTrackBar.AlignThumb;
begin
  Inherited;
  if FMaxThumb = nil then exit;
  var LMaxThumbPos := GetThumbPos(MaxValue);
  If Orientation = TOrientation.Horizontal then
    FMaxThumb.Left := LMaxThumbPos
  else
    FMaxThumb.Top := LMaxThumbPos
end;

{********************************************}
procedure TALDynamicRangeTrackBar.AlignTracks;
begin
  if (FThumb = nil) or (FMaxThumb = nil) then exit;
  if Orientation = TOrientation.Horizontal then begin
    if FInactiveTrack <> nil then begin
      FInactiveTrack.Left := Padding.Left + (Fthumb.Width / 2);
      FInactiveTrack.Width := FThumb.Left - Fthumb.Margins.Left - FInactiveTrack.Left;
    end;
    if FActiveTrack <> nil then begin
      FActiveTrack.Left := FThumb.Left + Fthumb.Width + Fthumb.Margins.Right;
      FActiveTrack.Width := FMaxThumb.Left - FMaxthumb.Margins.Left - FActiveTrack.Left;
    end;
    if FMaxInactiveTrack <> nil then begin
      FMaxInactiveTrack.Left := FMaxThumb.Left + FMaxthumb.Width + FMaxthumb.Margins.Right;
      FMaxInactiveTrack.Width := Width - Padding.Right - FMaxInactiveTrack.Left - (FMaxthumb.Width / 2);
    end;
  end
  else begin
    if FInactiveTrack <> nil then begin
      FInactiveTrack.Top := Padding.Top + (Fthumb.Height / 2);
      FInactiveTrack.Height := FThumb.Top - Fthumb.Margins.Top - FInactiveTrack.Top;
    end;
    if FActiveTrack <> nil then begin
      FActiveTrack.Top := FThumb.Top + Fthumb.Height + Fthumb.Margins.Bottom;
      FActiveTrack.Height := FMaxThumb.Top - FMaxthumb.Margins.Top - FActiveTrack.Top;
    end;
    if FMaxInactiveTrack <> nil then begin
      FMaxInactiveTrack.Top := FMaxThumb.Top + FMaxthumb.Height + FMaxthumb.Margins.Bottom;
      FMaxInactiveTrack.Height := Height - Padding.Bottom - FMaxInactiveTrack.Top - (FMaxthumb.Height / 2);
    end;
  end;
end;

{**************************************************************************}
procedure TALDynamicRangeTrackBar.SetOrientation(const Value: TOrientation);

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  function SwapTopBottomWithLeftRight(Const ARect: TrectF): TRectF;
  Begin
    Result.Left := ARect.Top;
    Result.Top := ARect.Left;
    Result.Right := ARect.Bottom;
    Result.Bottom := ARect.Right;
  End;

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  function SwapAlign(Const AAlign: TALAlignLayout): TALAlignLayout;
  Begin
    If AAlign = TALAlignLayout.Vertical then result := TALAlignLayout.Horizontal
    else If AAlign = TALAlignLayout.Horizontal then result := TALAlignLayout.Vertical
    else result := AAlign;
  End;

begin
  if FOrientation <> Value then begin
    //**if not (csLoading in ComponentState) then begin
      BeginUpdate;
      Try
        inherited;
        if FMaxInactiveTrack <> nil then begin
          FMaxInactiveTrack.Margins.Rect := SwapTopBottomWithLeftRight(FMaxInactiveTrack.Margins.Rect);
          FMaxInactiveTrack.Padding.Rect := SwapTopBottomWithLeftRight(FMaxInactiveTrack.Padding.Rect);
          FMaxInactiveTrack.Align := SwapAlign(FMaxInactiveTrack.Align);
        end;
        if FMaxThumb <> nil then begin
          FMaxThumb.Margins.Rect := SwapTopBottomWithLeftRight(FMaxThumb.Margins.Rect);
          FMaxThumb.padding.Rect := SwapTopBottomWithLeftRight(FMaxThumb.padding.Rect);
          FMaxThumb.TouchTargetExpansion := SwapTopBottomWithLeftRight(FMaxThumb.TouchTargetExpansion);
          var LMaxThumbWidth := FMaxThumb.Width;
          FMaxThumb.Width := FMaxThumb.Height;
          FMaxThumb.Height := LMaxThumbWidth;
          FMaxThumb.Align := SwapAlign(FMaxThumb.Align);
        end;
      Finally
        EndUpdate;
      End;
    //**end
    //**else begin
    //**  inherited;
    //**  if FMaxInactiveTrack <> nil then
    //**    FMaxInactiveTrack.Align := SwapAlign(FMaxInactiveTrack.Align);
    //**  if FMaxThumb <> nil then
    //**    FMaxThumb.Align := SwapAlign(FMaxThumb.Align);
    //**end;
  end;
end;

{***************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TFill.GetDefaultColor: TAlphaColor;
begin
  Result := $47000000;
end;

{*****************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TStroke.GetDefaultColor: TAlphaColor;
begin
  Result := Talphacolors.Null;
end;

{***********************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TDisabledStateStyle.TFill.GetDefaultColor: TAlphaColor;
begin
  Result := $47000000;
end;

{*************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TDisabledStateStyle.TStroke.GetDefaultColor: TAlphaColor;
begin
  Result := Talphacolors.Null;
end;

{**************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TDisabledStateStyle.TStateLayer.GetDefaultXRadius: Single;
begin
  Result := 0;
end;

{**************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TDisabledStateStyle.TStateLayer.GetDefaultYRadius: Single;
begin
  Result := 0;
end;

{*****************************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TDisabledStateStyle.CreateFill(const AParent: TALBrush): TALInheritBrush;
begin
  Result := TFill.Create(AParent);
end;

{*******************************************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TDisabledStateStyle.CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush;
begin
  Result := TStroke.Create(AParent);
end;

{********************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TDisabledStateStyle.CreateStateLayer: TALStateLayer;
begin
  Result := TStateLayer.Create;
end;

{**********************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.THoveredStateStyle.TFill.GetDefaultColor: TAlphaColor;
begin
  Result := $47000000;
end;

{************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.THoveredStateStyle.TStroke.GetDefaultColor: TAlphaColor;
begin
  Result := Talphacolors.Null;
end;

{*************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.THoveredStateStyle.TStateLayer.GetDefaultXRadius: Single;
begin
  Result := 0;
end;

{*************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.THoveredStateStyle.TStateLayer.GetDefaultYRadius: Single;
begin
  Result := 0;
end;

{****************************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.THoveredStateStyle.CreateFill(const AParent: TALBrush): TALInheritBrush;
begin
  Result := TFill.Create(AParent);
end;

{******************************************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.THoveredStateStyle.CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush;
begin
  Result := TStroke.Create(AParent);
end;

{*******************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.THoveredStateStyle.CreateStateLayer: TALStateLayer;
begin
  Result := TStateLayer.Create;
end;

{**********************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TPressedStateStyle.TFill.GetDefaultColor: TAlphaColor;
begin
  Result := $47000000;
end;

{************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TPressedStateStyle.TStroke.GetDefaultColor: TAlphaColor;
begin
  Result := Talphacolors.Null;
end;

{*************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TPressedStateStyle.TStateLayer.GetDefaultXRadius: Single;
begin
  Result := 0;
end;

{*************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TPressedStateStyle.TStateLayer.GetDefaultYRadius: Single;
begin
  Result := 0;
end;

{****************************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TPressedStateStyle.CreateFill(const AParent: TALBrush): TALInheritBrush;
begin
  Result := TFill.Create(AParent);
end;

{******************************************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TPressedStateStyle.CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush;
begin
  Result := TStroke.Create(AParent);
end;

{*******************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TPressedStateStyle.CreateStateLayer: TALStateLayer;
begin
  Result := TStateLayer.Create;
end;

{**********************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TFocusedStateStyle.TFill.GetDefaultColor: TAlphaColor;
begin
  Result := $47000000;
end;

{************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TFocusedStateStyle.TStroke.GetDefaultColor: TAlphaColor;
begin
  Result := Talphacolors.Null;
end;

{*************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TFocusedStateStyle.TStateLayer.GetDefaultXRadius: Single;
begin
  Result := 0;
end;

{*************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TFocusedStateStyle.TStateLayer.GetDefaultYRadius: Single;
begin
  Result := 0;
end;

{****************************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TFocusedStateStyle.CreateFill(const AParent: TALBrush): TALInheritBrush;
begin
  Result := TFill.Create(AParent);
end;

{******************************************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TFocusedStateStyle.CreateStroke(const AParent: TALStrokeBrush): TALInheritStrokeBrush;
begin
  Result := TStroke.Create(AParent);
end;

{*******************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TFocusedStateStyle.CreateStateLayer: TALStateLayer;
begin
  Result := TStateLayer.Create;
end;

{********************************************************************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TStateStyles.CreateDisabledStateStyle(const AParent: TObject): TALDynamicCustomTrack.TThumb.TDisabledStateStyle;
begin
  Result := TDisabledStateStyle.Create(AParent);
end;

{******************************************************************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TStateStyles.CreateHoveredStateStyle(const AParent: TObject): TALDynamicCustomTrack.TThumb.THoveredStateStyle;
begin
  Result := THoveredStateStyle.Create(AParent);
end;

{******************************************************************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TStateStyles.CreatePressedStateStyle(const AParent: TObject): TALDynamicCustomTrack.TThumb.TPressedStateStyle;
begin
  Result := TPressedStateStyle.Create(AParent);
end;

{******************************************************************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.TStateStyles.CreateFocusedStateStyle(const AParent: TObject): TALDynamicCustomTrack.TThumb.TFocusedStateStyle;
begin
  Result := TFocusedStateStyle.Create(AParent);
end;

{*************************************************************}
function TALDynamicCustomScrollBar.TThumb.CreateFill: TALBrush;
begin
  Result := TFill.Create;
end;

{*********************************************************************}
function TALDynamicCustomScrollBar.TThumb.CreateStroke: TALStrokeBrush;
begin
  Result := TStroke.Create;
end;

{*****************************************************************************************************}
function TALDynamicCustomScrollBar.TThumb.CreateStateStyles: TALDynamicCustomTrack.TThumb.TStateStyles;
begin
  Result := TStateStyles.Create(self);
end;

{******************************************************************}
function TALDynamicCustomScrollBar.TThumb.GetDefaultXRadius: Single;
begin
  Result := 0;
end;

{******************************************************************}
function TALDynamicCustomScrollBar.TThumb.GetDefaultYRadius: Single;
begin
  Result := 0;
end;

{******************************************************************}
constructor TALDynamicCustomScrollBar.Create(const AOwner: TObject);
begin
  inherited;
  //**CanFocus := False;
end;

{********************************************************}
function TALDynamicCustomScrollBar.GetDefaultSize: TSizeF;
begin
  Result := TSizeF.Create(150, 18);
end;

{*********************************************}
procedure TALDynamicCustomScrollBar.AlignThumb;
begin
  if FThumb = nil then exit;
  if ViewportSize > 0 then begin
    If Orientation = TOrientation.Horizontal then begin
      FThumb.Width := ALAlignDimensionToPixelRound(
                        System.Math.Min(
                          System.Math.MaxValue(
                            [ViewportSize / (Max - Min) * Width,
                             Height / 2,
                             5{MinThumbSize}]),
                          Width),
                        ALGetScreenScale,
                        Tepsilon.Position);
    end
    else begin
      FThumb.Height := ALAlignDimensionToPixelRound(
                         System.Math.Min(
                           System.Math.MaxValue(
                             [ViewportSize / (Max - Min) * Height,
                              Width / 2,
                              5{MinThumbSize}]),
                           Height),
                         ALGetScreenScale,
                         Tepsilon.Position);
    end;
  end;
  inherited;
end;

{**********************************************************************************************************************************************************************}
function TALDynamicCustomScrollBar.CreateThumb(const AThumbClass: TALDynamicCustomTrack.TThumbClass = nil; Const AName: String = 'Thumb'): TALDynamicCustomTrack.TThumb;
begin
  if AThumbClass = nil then Exit(CreateThumb(TThumb, AName));
  result := Inherited;
end;

{**************************************************************************************************************************************************************************************************************}
function TALDynamicCustomScrollBar.CreateInactiveTrack(const AInactiveTrackClass: TALDynamicCustomTrack.TInactiveTrackClass = nil; Const AName: String = 'InactiveTrack'): TALDynamicCustomTrack.TInactiveTrack;
begin
  Result := Nil;
end;

{****************************************************************************************************************************************************************************************************}
function TALDynamicCustomScrollBar.CreateActiveTrack(const AActiveTrackClass: TALDynamicCustomTrack.TActiveTrackClass = nil; Const AName: String = 'ActiveTrack'): TALDynamicCustomTrack.TActiveTrack;
begin
  Result := Nil;
end;

{*******************************************************************************************************************************************************************************************************************}
function TALDynamicCustomScrollBar.CreateValueIndicator(const AValueIndicatorClass: TALDynamicCustomTrack.TValueIndicatorClass = nil; Const AName: String = 'ValueIndicator'): TALDynamicCustomTrack.TValueIndicator;
begin
  Result := Nil;
end;

{$ENDREGION 'Auto-generated by <ALCINOE>\Tools\CodeBuilder (2)'}

initialization
  {$IF defined(DEBUG)}
  ALLog('Alcinoe.FMX.Dynamic.StdCtrls','initialization');
  {$ENDIF}
  _ALDummyComponent := TComponent.create(nil);

finalization
  {$IF defined(DEBUG)}
  ALLog('Alcinoe.FMX.Dynamic.StdCtrls','finalization');
  {$ENDIF}
  AlFreeAndNil(_ALDummyComponent);

end.

unit Alcinoe.MongoDB.Wrapper;

//*******************************************************************//
// This unit was automatically generated by CHeaderWrapperGenerator. //
// Do not edit manually.                                             //
//*******************************************************************//

interface

{$I Alcinoe.inc}

{$SCOPEDENUMS OFF}
{$MINENUMSIZE 4}
{$A+}

uses
  WinApi.Windows,
  Winapi.Winsock2;

type
  uint8_t = UInt8;
  Puint8_t = ^uint8_t;
  PPuint8_t = ^Puint8_t;
  uint16_t = UInt16;
  Puint16_t = ^uint16_t;
  uint32_t = UInt32;
  Puint32_t = ^uint32_t;
  uint64_t = UInt64;
  Puint64_t = ^uint64_t;
  int8_t = Int8;
  Pint8_t = ^int8_t;
  int16_t = Int16;
  Pint16_t = ^int16_t;
  int32_t = Int32;
  Pint32_t = ^int32_t;
  int64_t = Int64;
  Pint64_t = ^int64_t;
  size_t = NativeUInt;
  Psize_t = ^size_t;
  socklen_t = Int32;
  Psocklen_t = ^socklen_t;
  Pva_list = ^va_list;
  off_t = LongInt;
  time_t = Int64;
  TCharArray6 = array[0..6-1] of AnsiChar;
  TCharArray25 = array[0..25-1] of AnsiChar;
  P_bson_array_builder_t = pointer; // forward decl
  P_mongoc_client_t = pointer; // forward decl
  P_mongoc_client_session_t = pointer; // forward decl
  P_mongoc_client_pool_t = pointer; // forward decl
  P_mongoc_cursor_t = pointer; // forward decl
  P_mongoc_database_t = pointer; // forward decl
  P_mongoc_collection_t = pointer; // forward decl

////////////
// config //
////////////

// *
// * Define to 1234 for Little Endian, 4321 for Big Endian.
// *
const BSON_BYTE_ORDER = 1234;

// *
// * Define to 1 if you have stdbool.h
// *
const BSON_HAVE_STDBOOL_H = 1;

// *
// * Define to 1 for POSIX-like systems, 2 for Windows.
// *
const BSON_OS = 2;

// *
// * Define to 1 if you have clock_gettime() available.
// *
const BSON_HAVE_CLOCK_GETTIME = 0;

// *
// * Define to 1 if you have strings.h available on your platform.
// *
const BSON_HAVE_STRINGS_H = 0;

// *
// * Define to 1 if you have strnlen available on your platform.
// *
const BSON_HAVE_STRNLEN = 1;

// *
// * Define to 1 if you have snprintf available on your platform.
// *
const BSON_HAVE_SNPRINTF = 1;

// *
// * Define to 1 if you have gmtime_r available on your platform.
// *
const BSON_HAVE_GMTIME_R = 0;

// *
// * Define to 1 if you have struct timespec available on your platform.
// *
const BSON_HAVE_TIMESPEC = 1;

// *
// * Define to 1 if you have rand_r available on your platform.
// *
const BSON_HAVE_RAND_R = 0;

// *
// * Define to 1 if you have strlcpy available on your platform.
// *
const BSON_HAVE_STRLCPY = 0;

// *
// * Define to 1 if you have aligned_alloc available on your platform.
// *
const BSON_HAVE_ALIGNED_ALLOC = 0;

/////////////
// version //
/////////////

// clang-format off

// * *
// * BSON_MAJOR_VERSION:
// *
// * BSON major version component (e.g. 1 if %BSON_VERSION is 1.2.3)
// *
const BSON_MAJOR_VERSION = (2);

// * *
// * BSON_MINOR_VERSION:
// *
// * BSON minor version component (e.g. 2 if %BSON_VERSION is 1.2.3)
// *
const BSON_MINOR_VERSION = (2);

// * *
// * BSON_MICRO_VERSION:
// *
// * BSON micro version component (e.g. 3 if %BSON_VERSION is 1.2.3)
// *
const BSON_MICRO_VERSION = (1);

// * *
// * BSON_PRERELEASE_VERSION:
// *
// * BSON prerelease version component (e.g. pre if %BSON_VERSION is 1.2.3-pre)
// *
// #define BSON_PRERELEASE_VERSION ()

// * *
// * BSON_VERSION:
// *
// * BSON version.
// *
// #define BSON_VERSION (2.2.1)

// * *
// * BSON_VERSION_S:
// *
// * BSON version, encoded as a string, useful for printing and
// * concatenation.
// *
const BSON_VERSION_S = '2.2.1';

// * *
// * BSON_VERSION_HEX:
// *
// * BSON version, encoded as an hexadecimal number, useful for
// * integer comparisons.
// *
const BSON_VERSION_HEX = (BSON_MAJOR_VERSION shl 24 or BSON_MINOR_VERSION shl 16 or BSON_MICRO_VERSION shl 8);

// * *
// * BSON_CHECK_VERSION:
// * @major: required major version
// * @minor: required minor version
// * @micro: required micro version
// *
// * Compile-time version checking. Evaluates to %TRUE if the version
// * of BSON is greater than or equal to the required one.
// *
// #define BSON_CHECK_VERSION(major,minor,micro) (BSON_MAJOR_VERSION > (major) || (BSON_MAJOR_VERSION == (major) && BSON_MINOR_VERSION > (minor)) || (BSON_MAJOR_VERSION == (major) && BSON_MINOR_VERSION == (minor) && BSON_MICRO_VERSION >= (micro)))

////////////
// macros //
////////////

// #define BSON_OS_WIN32

// #define BSON_GNUC_CHECK_VERSION(major, minor) 0

// #define BSON_GNUC_IS_VERSION(major, minor) 0

// * Decorate public functions:
// * - if BSON_STATIC, we're compiling a static libbson or a program
// * that uses libbson as a static library. Don't decorate functions.
// * - else if BSON_COMPILATION, we're compiling a shared libbson, mark
// * public functions for export from the shared lib
// * - else, we're compiling a program that uses libbson as a shared library,
// * mark public functions as DLL imports for Microsoft Visual C
// *

// *
// * Microsoft Visual C
// *
// #define BSON_API __declspec(dllimport)
// #define BSON_CALL __cdecl

// *
// * Other compilers
// *

// #define BSON_MIN(a, b) ((std::min)(a, b))
// #define BSON_MIN(a, b) ((a) < (b) ? (a) : (b))

// #define BSON_MAX(a, b) ((std::max)(a, b))
// #define BSON_MAX(a, b) ((a) > (b) ? (a) : (b))

// #define BSON_ABS(a) (((a) < 0) ? ((a) * -1) : (a))

// #define BSON_ALIGNOF(expr) alignof(expr)
// #define BSON_ALIGNOF(expr) __alignof(expr)

// __declspec (align (_N)) only permits integer literals as _N.
{$if defined(Win64)}
const BSON_ALIGN_OF_PTR = 8;
{$else}
const BSON_ALIGN_OF_PTR = 4;
{$endif}

// #define BSON_ALIGNED_BEGIN(_N) __declspec(align(BSON_ALIGN_OF_PTR))
// #define BSON_ALIGNED_END(_N)

// #define bson_str_empty(s) (!s[0])
// #define bson_str_empty0(s) (!s || !s[0])

// #define BSON_FUNC __FUNCTION__

// #define BSON_INLINE __inline

// #define BSON_NORETURN

// #define BSON_RESTRICT __restrict
// #define BSON_RESTRICT

// BSON_NORETURN static BSON_INLINE void
// _bson_assert_failed_on_line(const char * file, int line, const char * func, const char * test)

// BSON_NORETURN static BSON_INLINE void
// _bson_assert_failed_on_param(const char * param, const char * func)

// #define BSON_ASSERT(test) do { if (!(BSON_LIKELY(test))) { _bson_assert_failed_on_line(__FILE__, (int)(__LINE__), BSON_FUNC, #test); } } while (0)

// * *
// * @brief Assert the expression `Assertion`, and evaluates to `Value` on
// * success.
// *
// #define BSON_ASSERT_INLINE(Assertion, Value) ((void)((Assertion) ? (0) : (_bson_assert_failed_on_line(__FILE__, (int)(__LINE__), BSON_FUNC, #Assertion), 0)), Value)

// * *
// * @brief Assert that the given pointer is non-NULL, while also evaluating to
// * that pointer.
// *
// * Can be used to inline assertions with a pointer dereference:
// *
// * ```
// * foo * f = get_foo();
// * bar * b = BSON_ASSERT_PTR_INLINE(f)->bar_value;
// * ```
// *
// #define BSON_ASSERT_PTR_INLINE(Pointer) BSON_ASSERT_INLINE((Pointer) != NULL, (Pointer))

// * Used for asserting parameters to provide a more precise error message
// #define BSON_ASSERT_PARAM(param) do { if ((BSON_UNLIKELY(param == NULL))) { _bson_assert_failed_on_param(#param, BSON_FUNC); } } while (0)

// `BSON_OPTIONAL_PARAM` is a documentation-only macro to document X may be NULL.
// Useful in combination with `BSON_ASSERT_PARAM` to document and assert pointer parameters.
// #define BSON_OPTIONAL_PARAM(param) ((void)param)

// * obsolete macros, preserved for compatibility
// #define BSON_STATIC_ASSERT(s) BSON_STATIC_ASSERT_(s, __LINE__)
// #define BSON_STATIC_ASSERT_JOIN(a, b) BSON_STATIC_ASSERT_JOIN2(a, b)
// #define BSON_STATIC_ASSERT_JOIN2(a, b) a##b
// #define BSON_STATIC_ASSERT_(s, l) typedef char BSON_STATIC_ASSERT_JOIN(static_assert_test_, __LINE__)[(s) ? 1 : -1]

// * modern macros
// #define BSON_STATIC_ASSERT2(_name, _s) BSON_STATIC_ASSERT2_(_s, __LINE__, _name)
// #define BSON_STATIC_ASSERT_JOIN3(_a, _b, _name) BSON_STATIC_ASSERT_JOIN4(_a, _b, _name)
// #define BSON_STATIC_ASSERT_JOIN4(_a, _b, _name) _a##_b##_name
// #define BSON_STATIC_ASSERT2_(_s, _l, _name) typedef char BSON_STATIC_ASSERT_JOIN3(static_assert_test_, __LINE__, _name)[(_s) ? 1 : -1]

// #define BSON_GNUC_PURE
// #define BSON_GNUC_WARN_UNUSED_RESULT

// #define BSON_GNUC_NULL_TERMINATED
// #define BSON_GNUC_INTERNAL

// #define BSON_LIKELY(v) v
// #define BSON_UNLIKELY(v) v

// #define BSON_GNUC_PRINTF(f, v)

{$if defined(CPUX64) or defined(CPUARM64)}
const BSON_WORD_SIZE = 64;
{$else}
const BSON_WORD_SIZE = 32;
{$endif}

// #define BSON_ENSURE_ARRAY_PARAM_SIZE(_n)
// #define BSON_TYPEOF decltype

// * *
// * @brief Statically annotate an entity as deprecated, including the given deprecation message
// *
// * @param Message The message to be included in a deprecation warning. This
// * should be a string literal.
// *
// #define BSON_DEPRECATED(Message) _bsonDeprecatedImpl(Message)

// Pick the appropriate implementation of a deprecation attribute
// For MSVC, emit __declspec(deprecated(Msg))
// #define _bsonDeprecatedImpl(Msg) __declspec(deprecated(Msg))
// For other compilers, emit nothing
// #define _bsonDeprecatedImpl(Msg)

// #define BSON_DEPRECATED_FOR(F) BSON_DEPRECATED("This API is deprecated. Use " #F " instead.")

// #define BSON_GNUC_DEPRECATED BSON_DEPRECATED("This API is deprecated")
// #define BSON_GNUC_DEPRECATED_FOR(F) BSON_DEPRECATED_FOR(F)

// #define BSON_CONCAT_IMPL(a, ...) a##__VA_ARGS__
// #define BSON_CONCAT(a, ...) BSON_CONCAT_IMPL(a, __VA_ARGS__)
// #define BSON_CONCAT3(a, b, c) BSON_CONCAT(a, BSON_CONCAT(b, c))
// #define BSON_CONCAT4(a, b, c, d) BSON_CONCAT(BSON_CONCAT(a, b), BSON_CONCAT(c, d))

// * *
// * @brief String-ify the given argument
// *
// #define BSON_STR(...) #__VA_ARGS__

// * *
// * @brief Mark the attached declared entity as "possibly-unused."
// *
// * Does nothing on MSVC.
// *
// #define BSON_MAYBE_UNUSED (* Nothing for other compilers

// * *
// * @brief Mark a point in the code as unreachable. If the point is reached, the
// * program will abort with an error message.
// *
// * @param What A string to include in the error message if this point is ever
// * executed.
// *
// #define BSON_UNREACHABLE(What) do { fprintf(stderr, "%s:%d %s(): Unreachable code reached: %s\n", __FILE__, (int)(__LINE__), BSON_FUNC, What); abort(); } while (0)

// * *
// * @brief Silence warnings for deliberately unused variables or parameters.
// *
// * @param expr An unused variable or parameter.
// *
// *
// #define BSON_UNUSED(expr) do { (void)(expr); } while (0)

// Disable the -Wunsafe-buffer-usage warning.
// #define BSON_DISABLE_UNSAFE_BUFFER_USAGE_WARNING_BEGIN
// #define BSON_DISABLE_UNSAFE_BUFFER_USAGE_WARNING_END

////////////
// bson_t //
////////////

// * *
// * bson_t:
// *
// * This structure manages a buffer whose contents are a properly formatted
// * BSON document. You may perform various transforms on the BSON documents.
// * Additionally, it can be iterated over using bson_iter_t.
// *
// * See bson_iter_init() for iterating the contents of a bson_t.
// *
// * When building a bson_t structure using the various append functions,
// * memory allocations may occur. That is performed using power of two
// * allocations and realloc().
// *
// * See http: // bsonspec.org for the BSON document spec.
// *
// * This structure is meant to fit in two sequential 64-byte cachelines.
// *
type
  _bson_t = record
    flags: uint32_t; (* Internal flags for the bson_t. *)
    len: uint32_t; (* Length of BSON data. *)
    padding: array[0..120-1] of uint8_t; (* Padding for stack allocation. *)
  end;
  bson_t = _bson_t;
  Pbson_t = ^bson_t;
  PPbson_t = ^Pbson_t;

// * *
// * BSON_INITIALIZER:
// *
// * This macro can be used to initialize a #bson_t structure on the stack
// * without calling bson_init().
// *
// * |[
// * bson_t b = BSON_INITIALIZER;
// * ]|
// *
// #define BSON_INITIALIZER {3, 5, {5}}

// BSON_STATIC_ASSERT2(bson_t, sizeof(bson_t) == 128);

////////////
// compat //
////////////

// *
// * MSVC++ does not include ssize_t, just size_t.
// * So we need to synthesize that as well.
// *

const PRIi32 = 'd';
const PRId32 = 'd';
const PRIu32 = 'u';
const PRIi64 = 'I64i';
const PRId64 = 'I64i';
const PRIu64 = 'I64u';

// * Derive the maximum representable value of signed_integer type T using the
// * formula 2^(N - 1) - 1 where N is the number of bits in type T. This assumes
// * T is represented using two's complement.
// #define BSON_NUMERIC_LIMITS_MAX_SIGNED(T) ((T)((((size_t)0x01u) << (sizeof(T) * (size_t)CHAR_BIT - 1u)) - 1u))

// * Derive the minimum representable value of signed_integer type T as one less
// * than the negation of its maximum representable value. This assumes T is
// * represented using two's complement.
// #define BSON_NUMERIC_LIMITS_MIN_SIGNED(T, max) ((T)((-(max)) - 1))

// * Derive the maximum representable value of unsigned_integer type T by flipping
// * all its bits to 1.
// #define BSON_NUMERIC_LIMITS_MAX_UNSIGNED(T) ((T)(~((T)0)))

// #define SSIZE_MAX BSON_NUMERIC_LIMITS_MAX_SIGNED(ssize_t)

// #define SSIZE_MIN BSON_NUMERIC_LIMITS_MIN_SIGNED(ssize_t, SSIZE_MAX)

// #define va_copy(dst, src) __va_copy(dst, src)

// #define va_copy(dst, src) ((dst) = (src))

// * * Expands the arguments if compiling with MSVC, otherwise empty
// #define BSON_IF_MSVC(...) __VA_ARGS__
// * * Expands the arguments if compiling with GCC or Clang, otherwise empty
// #define BSON_IF_GNU_LIKE(...)
// * * Unsupported compiler. *
// #define BSON_IF_MSVC(...)
// #define BSON_IF_GNU_LIKE(...)

// * * Expands the arguments if compiling for Windows, otherwise empty
// #define BSON_IF_WINDOWS(...) __VA_ARGS__
// * * Expands the arguments if compiling for POSIX, otherwise empty
// #define BSON_IF_POSIX(...)

///////////
// error //
///////////

const BSON_ERROR_BUFFER_SIZE = 503;

// Aligned for backwards-compatibility.
type
  _bson_error_t = record
    domain: uint32_t;
    code: uint32_t;
    message: array[0..BSON_ERROR_BUFFER_SIZE-1] of AnsiChar;
    reserved: uint8_t; // For internal use only!
  end;
  bson_error_t = _bson_error_t;
  Pbson_error_t = ^bson_error_t;
  PPbson_error_t = ^Pbson_error_t;

// BSON_STATIC_ASSERT2(error_t, sizeof(bson_error_t) == 512);

const BSON_ERROR_JSON = 1;
const BSON_ERROR_READER = 2;
const BSON_ERROR_INVALID = 3;
const BSON_ERROR_VECTOR = 4;

procedure bson_set_error(
            error: Pbson_error_t;
            domain: uint32_t;
            code: uint32_t;
            format: PAnsiChar); cdecl; varargs; external 'bson2.dll';

function bson_strerror_r(
           err_code: Integer;
           buf: PAnsiChar;
           buflen: size_t): PAnsiChar; cdecl; external 'bson2.dll';

// * *
// * @brief Reset the content of a bson_error_t to indicate no error.
// *
// * @param error Pointer to an error to be overwritten. If null, this function
// * has no effect.
// *
// * This is static-inline because it is trivially optimizable as a (conditional)
// * `memset`.
// *
// static inline void
// bson_error_clear(bson_error_t * error)

// * *
// * @brief Given a `bson_error_t` pointer l-value, ensure that it is non-null, and clear any
// * error value that it might hold.
// *
// * @param ErrorPointer An l-value expression of type `bson_error_t * `.
// *
// * If the passed pointer is null, then it will be updated to point to an anonymous
// * `bson_error_t` object that lives in the caller's scope.
// *
// * @note This macro is not valid in C++ because it relies on C99 compound literal semantics
// *
// #define bson_error_reset(ErrorPointer) bson_error_reset(&(ErrorPointer), &(bson_error_t){0})
// static inline void(bson_error_reset)(bson_error_t * * error, bson_error_t * localptr)

////////////
// memory //
////////////

type
  bson_realloc_func = function (
    mem: Pvoid;
    num_bytes: size_t;
    ctx: Pvoid): Pvoid; cdecl;

type
  _bson_mem_vtable_t = record
    malloc: function(num_bytes: size_t): Pvoid; cdecl;
    calloc: function(n_members: size_t; num_bytes: size_t): Pvoid; cdecl;
    realloc: function(mem: Pvoid; num_bytes: size_t): Pvoid; cdecl;
    free: procedure(mem: Pvoid); cdecl;
    aligned_alloc: function(alignment: size_t; num_bytes: size_t): Pvoid; cdecl;
    padding: array[0..3-1] of Pvoid;
  end;
  bson_mem_vtable_t = _bson_mem_vtable_t;
  Pbson_mem_vtable_t = ^bson_mem_vtable_t;

procedure bson_mem_set_vtable(
            vtable: Pbson_mem_vtable_t); cdecl; external 'bson2.dll';
procedure bson_mem_restore_vtable(); cdecl; external 'bson2.dll';
function bson_malloc(
           num_bytes: size_t): Pvoid; cdecl; external 'bson2.dll';
function bson_malloc0(
           num_bytes: size_t): Pvoid; cdecl; external 'bson2.dll';
function bson_aligned_alloc(
           alignment: size_t;
           num_bytes: size_t): Pvoid; cdecl; external 'bson2.dll';
function bson_aligned_alloc0(
           alignment: size_t;
           num_bytes: size_t): Pvoid; cdecl; external 'bson2.dll';
function bson_array_alloc(
           num_elems: size_t;
           elem_size: size_t): Pvoid; cdecl; external 'bson2.dll';
function bson_array_alloc0(
           num_elems: size_t;
           elem_size: size_t): Pvoid; cdecl; external 'bson2.dll';
function bson_realloc(
           mem: Pvoid;
           num_bytes: size_t): Pvoid; cdecl; external 'bson2.dll';
function bson_realloc_ctx(
           mem: Pvoid;
           num_bytes: size_t;
           ctx: Pvoid): Pvoid; cdecl; external 'bson2.dll';
procedure bson_free(
            mem: Pvoid); cdecl; external 'bson2.dll';
procedure bson_zero_free(
            mem: Pvoid;
            size: size_t); cdecl; external 'bson2.dll';

// #define BSON_ALIGNED_ALLOC(T) ((T * )(bson_aligned_alloc(BSON_ALIGNOF(T), sizeof(T))))
// #define BSON_ALIGNED_ALLOC0(T) ((T * )(bson_aligned_alloc0(BSON_ALIGNOF(T), sizeof(T))))
// #define BSON_ARRAY_ALLOC(N, T) ((T * )(bson_array_alloc(N, sizeof(T))))
// #define BSON_ARRAY_ALLOC0(N, T) ((T * )(bson_array_alloc0(N, sizeof(T))))

//////////////////
// bson-prelude //
//////////////////

/////////////////
// bson-endian //
/////////////////

const BSON_BIG_ENDIAN = 4321;
const BSON_LITTLE_ENDIAN = 1234;

// #define BSON_UINT16_FROM_LE(v) ((uint16_t)v)
// #define BSON_UINT16_TO_LE(v) ((uint16_t)v)
// #define BSON_UINT16_FROM_BE(v) BSON_UINT16_SWAP_LE_BE(v)
// #define BSON_UINT16_TO_BE(v) BSON_UINT16_SWAP_LE_BE(v)
// #define BSON_UINT32_FROM_LE(v) ((uint32_t)v)
// #define BSON_UINT32_TO_LE(v) ((uint32_t)v)
// #define BSON_UINT32_FROM_BE(v) BSON_UINT32_SWAP_LE_BE(v)
// #define BSON_UINT32_TO_BE(v) BSON_UINT32_SWAP_LE_BE(v)
// #define BSON_UINT64_FROM_LE(v) ((uint64_t)v)
// #define BSON_UINT64_TO_LE(v) ((uint64_t)v)
// #define BSON_UINT64_FROM_BE(v) BSON_UINT64_SWAP_LE_BE(v)
// #define BSON_UINT64_TO_BE(v) BSON_UINT64_SWAP_LE_BE(v)
// #define BSON_DOUBLE_FROM_LE(v) ((double)v)
// #define BSON_DOUBLE_TO_LE(v) ((double)v)
// #define BSON_FLOAT_FROM_LE(v) ((float)v)
// #define BSON_FLOAT_TO_LE(v) ((float)v)
// #error "The endianness of target architecture is unknown."

// *
// * --------------------------------------------------------------------------
// *
// * __bson_uint16_swap_slow --
// *
// * Fallback endianness conversion for 16-bit integers.
// *
// * Returns:
// * The endian swapped version.
// *
// * Side effects:
// * None.
// *
// * --------------------------------------------------------------------------
// *

// static BSON_INLINE uint16_t
// __bson_uint16_swap_slow(uint16_t v) (* IN

// *
// * --------------------------------------------------------------------------
// *
// * __bson_uint32_swap_slow --
// *
// * Fallback endianness conversion for 32-bit integers.
// *
// * Returns:
// * The endian swapped version.
// *
// * Side effects:
// * None.
// *
// * --------------------------------------------------------------------------
// *

// static BSON_INLINE uint32_t
// __bson_uint32_swap_slow(uint32_t v) (* IN

// *
// * --------------------------------------------------------------------------
// *
// * __bson_uint64_swap_slow --
// *
// * Fallback endianness conversion for 64-bit integers.
// *
// * Returns:
// * The endian swapped version.
// *
// * Side effects:
// * None.
// *
// * --------------------------------------------------------------------------
// *

// static BSON_INLINE uint64_t
// __bson_uint64_swap_slow(uint64_t v) (* IN

// *
// * --------------------------------------------------------------------------
// *
// * __bson_double_swap_slow --
// *
// * Fallback endianness conversion for double floating point.
// *
// * Returns:
// * The endian swapped version.
// *
// * Side effects:
// * None.
// *
// * --------------------------------------------------------------------------
// *

// BSON_STATIC_ASSERT2(sizeof_uint64_t, sizeof(double) == sizeof(uint64_t));

// static BSON_INLINE double
// __bson_double_swap_slow(double v) (* IN

// *
// * --------------------------------------------------------------------------
// *
// * __bson_float_swap_slow --
// *
// * Fallback endianness conversion for single floating point.
// *
// * Returns:
// * The endian swapped version.
// *
// * Side effects:
// * None.
// *
// * --------------------------------------------------------------------------
// *

// BSON_STATIC_ASSERT2(sizeof_uint32_t, sizeof(float) == sizeof(uint32_t));

// static BSON_INLINE float
// __bson_float_swap_slow(float v) (* IN

/////////////////
// bson-writer //
/////////////////

// * *
// * bson_writer_t:
// *
// * The bson_writer_t structure is a helper for writing a series of BSON
// * documents to a single malloc() buffer. You can provide a realloc() style
// * function to grow the buffer as you go.
// *
// * This is useful if you want to build a series of BSON documents right into
// * the target buffer for an outgoing packet. The offset parameter allows you to
// * start at an offset of the target buffer.
// *
type
  _bson_writer_t = record
  end;
  bson_writer_t = _bson_writer_t;
  Pbson_writer_t = ^bson_writer_t;

function bson_writer_new(
           buf: PPuint8_t;
           buflen: Psize_t;
           offset: size_t;
           realloc_func: bson_realloc_func;
           realloc_func_ctx: Pvoid): Pbson_writer_t; cdecl; external 'bson2.dll';
procedure bson_writer_destroy(
            writer: Pbson_writer_t); cdecl; external 'bson2.dll';
function bson_writer_get_length(
           writer: Pbson_writer_t): size_t; cdecl; external 'bson2.dll';
function bson_writer_begin(
           writer: Pbson_writer_t;
           bson: PPbson_t): bool; cdecl; external 'bson2.dll';
procedure bson_writer_end(
            writer: Pbson_writer_t); cdecl; external 'bson2.dll';
procedure bson_writer_rollback(
            writer: Pbson_writer_t); cdecl; external 'bson2.dll';

////////////////
// bson-types //
////////////////

// *
// * --------------------------------------------------------------------------
// *
// * bson_unichar_t --
// *
// * bson_unichar_t provides an unsigned 32-bit type for containing
// * unicode characters. When iterating UTF-8 sequences, this should
// * be used to avoid losing the high-bits of non-ascii characters.
// *
// * --------------------------------------------------------------------------
// *

type bson_unichar_t = uint32_t;

// * *
// * @brief Flags configuring the creation of a bson_context_t
// *
type
  bson_context_flags_t = (
    (* * Use default options *)
    BSON_CONTEXT_NONE = 0,
    (* Deprecated: Generating new OIDs from a bson_context_t is always
    thread-safe *)
    BSON_CONTEXT_THREAD_SAFE = (1 shl 0),
    (* Deprecated: Does nothing and is ignored *)
    BSON_CONTEXT_DISABLE_HOST_CACHE = (1 shl 1),
    (* Call getpid() instead of remembering the result of getpid() when using the
    context *)
    BSON_CONTEXT_DISABLE_PID_CACHE = (1 shl 2),
    (* Deprecated: Does nothing *)
    BSON_CONTEXT_USE_TASK_ID = (1 shl 3));

// * *
// * bson_context_t:
// *
// * This structure manages context for the bson library. It handles
// * configuration for thread-safety and other performance related requirements.
// * Consumers will create a context and may use multiple under a variety of
// * situations.
// *
// * If your program calls fork(), you should initialize a new bson_context_t
// * using bson_context_init().
// *
// * If you are using threading, it is suggested that you use a bson_context_t
// * per thread for best performance. Alternatively, you can initialize the
// * bson_context_t with BSON_CONTEXT_THREAD_SAFE, although a performance penalty
// * will be incurred.
// *
// * Many functions will require that you provide a bson_context_t such as OID
// * generation.
// *
// * This structure is opaque in that you cannot see the contents of the
// * structure. However, it is stack allocatable in that enough padding is
// * provided in _bson_context_t to hold the structure.
// *
type
  _bson_context_t = record
  end;
  bson_context_t = _bson_context_t;
  Pbson_context_t = ^bson_context_t;

// * *
// * bson_json_opts_t:
// *
// * This structure is used to pass options for serializing BSON into extended
// * JSON to the respective serialization methods.
// *
// * max_len can be either a non-negative integer, or BSON_MAX_LEN_UNLIMITED to
// * set no limit for serialization length.
// *
type
  _bson_json_opts_t = record
  end;
  bson_json_opts_t = _bson_json_opts_t;
  Pbson_json_opts_t = ^bson_json_opts_t;

// * *
// * bson_oid_t:
// *
// * This structure contains the binary form of a BSON Object Id as specified
// * on http: // bsonspec.org. If you would like the bson_oid_t in string form
// * see bson_oid_to_string() or bson_oid_to_string_r().
// *
type
  bson_oid_t = record
    bytes: array[0..12-1] of uint8_t;
  end;
  Pbson_oid_t = ^bson_oid_t;
  PPbson_oid_t = ^Pbson_oid_t;

// BSON_STATIC_ASSERT2(oid_t, sizeof(bson_oid_t) == 12);

// * *
// * bson_decimal128_t:
// *
// * @high The high-order bytes of the decimal128. This field contains sign,
// * combination bits, exponent, and part of the coefficient continuation.
// * @low The low-order bytes of the decimal128. This field contains the second
// * part of the coefficient continuation.
// *
// * This structure is a boxed type containing the value for the BSON decimal128
// * type. The structure stores the 128 bits such that they correspond to the
// * native format for the IEEE decimal128 type, if it is implemented.
// *
type
  bson_decimal128_t = record
    low: uint64_t;
    high: uint64_t;
  end;
  Pbson_decimal128_t = ^bson_decimal128_t;

// * *
// * @brief Flags and error codes for BSON validation functions.
// *
// * Pass these flags bits to control the behavior of the `bson_validate` family
// * of functions.
// *
// * Additionally, if validation fails, then the error code set on a `bson_error_t`
// * will have the value corresponding to the reason that validation failed.
// *
type
  bson_validate_flags_t = (
    (* *
    * @brief No special validation behavior specified.
    *)
    BSON_VALIDATE_NONE = 0,
    (* *
    * @brief Check that all text components of the BSON data are valid UTF-8.
    *
    * Note that this will also cause validation to reject valid text that contains
    * a null character. This can be changed by also passing
    * `BSON_VALIDATE_UTF8_ALLOW_NULL`
    *)
    BSON_VALIDATE_UTF8 = (1 shl 0),
    (* *
    * @brief Check that element keys do not begin with an ASCII dollar `$`
    *)
    BSON_VALIDATE_DOLLAR_KEYS = (1 shl 1),
    (* *
    * @brief Check that element keys do not contain an ASCII period `.`
    *)
    BSON_VALIDATE_DOT_KEYS = (1 shl 2),
    (* *
    * @brief If set then it is * not * an error for a UTF-8 string to contain
    * embedded null characters.
    *
    * This has no effect unless `BSON_VALIDATE_UTF8` is also passed.
    *)
    BSON_VALIDATE_UTF8_ALLOW_NULL = (1 shl 3),
    (* *
    * @brief Check that no element key is a zero-length empty string.
    *)
    BSON_VALIDATE_EMPTY_KEYS = (1 shl 4),
    (* *
    * @brief This is not a flag that controls behavior, but is instead used to indicate
    * that a BSON document is corrupted in some way. This is the value that will
    * appear as an error code.
    *
    * Passing this as a flag has no effect.
    *)
    BSON_VALIDATE_CORRUPT = (1 shl 5));

// * *
// * bson_type_t:
// *
// * This enumeration contains all of the possible types within a BSON document.
// * Use bson_iter_type() to fetch the type of a field while iterating over it.
// *
type
  bson_type_t = (
    BSON_TYPE_EOD = $00,
    BSON_TYPE_DOUBLE = $01,
    BSON_TYPE_UTF8 = $02,
    BSON_TYPE_DOCUMENT = $03,
    BSON_TYPE_ARRAY = $04,
    BSON_TYPE_BINARY = $05,
    BSON_TYPE_UNDEFINED = $06,
    BSON_TYPE_OID = $07,
    BSON_TYPE_BOOL = $08,
    BSON_TYPE_DATE_TIME = $09,
    BSON_TYPE_NULL = $0A,
    BSON_TYPE_REGEX = $0B,
    BSON_TYPE_DBPOINTER = $0C,
    BSON_TYPE_CODE = $0D,
    BSON_TYPE_SYMBOL = $0E,
    BSON_TYPE_CODEWSCOPE = $0F,
    BSON_TYPE_INT32 = $10,
    BSON_TYPE_TIMESTAMP = $11,
    BSON_TYPE_INT64 = $12,
    BSON_TYPE_DECIMAL128 = $13,
    BSON_TYPE_MAXKEY = $7F,
    BSON_TYPE_MINKEY = $FF);

// * *
// * bson_subtype_t:
// *
// * This enumeration contains the various subtypes that may be used in a binary
// * field. See http: // bsonspec.org for more information.
// *
type
  bson_subtype_t = (
    BSON_SUBTYPE_BINARY = $00,
    BSON_SUBTYPE_FUNCTION = $01,
    BSON_SUBTYPE_BINARY_DEPRECATED = $02,
    BSON_SUBTYPE_UUID_DEPRECATED = $03,
    BSON_SUBTYPE_UUID = $04,
    BSON_SUBTYPE_MD5 = $05,
    BSON_SUBTYPE_ENCRYPTED = $06,
    BSON_SUBTYPE_COLUMN = $07,
    BSON_SUBTYPE_SENSITIVE = $08,
    BSON_SUBTYPE_VECTOR = $09,
    BSON_SUBTYPE_USER = $80);
  Pbson_subtype_t = ^bson_subtype_t;

// *
// * --------------------------------------------------------------------------
// *
// * bson_value_t --
// *
// * A boxed type to contain various bson_type_t types.
// *
// * See also:
// * bson_value_copy()
// * bson_value_destroy()
// *
// * --------------------------------------------------------------------------
// *

type
  _bson_value_t = record
    value_type: bson_type_t;
    padding: int32_t;
    value: record
      case Integer of
        0:(v_oid: bson_oid_t);
        1:(v_int64: int64_t);
        2:(v_int32: int32_t);
        3:(v_int8: int8_t);
        4:(v_double: double);
        5:(v_bool: bool);
        6:(v_datetime: int64_t);
        7:(
          v_timestamp: record
            timestamp: uint32_t;
            increment: uint32_t;
          end;
        );
        8:(
          v_utf8: record
            str: PAnsiChar;
            len: uint32_t;
          end;
        );
        9:(
          v_doc: record
            data: Puint8_t;
            data_len: uint32_t;
          end;
        );
        10:(
          v_binary: record
            data: Puint8_t;
            data_len: uint32_t;
            subtype: bson_subtype_t;
          end;
        );
        11:(
          v_regex: record
            regex: PAnsiChar;
            options: PAnsiChar;
          end;
        );
        12:(
          v_dbpointer: record
            collection: PAnsiChar;
            collection_len: uint32_t;
            oid: bson_oid_t;
          end;
        );
        13:(
          v_code: record
            code: PAnsiChar;
            code_len: uint32_t;
          end;
        );
        14:(
          v_codewscope: record
            code: PAnsiChar;
            scope_data: Puint8_t;
            code_len: uint32_t;
            scope_len: uint32_t;
          end;
        );
        15:(
          v_symbol: record
            symbol: PAnsiChar;
            len: uint32_t;
          end;
        );
        16:(v_decimal128: bson_decimal128_t);
    end;
  end;
  bson_value_t = _bson_value_t;
  Pbson_value_t = ^bson_value_t;

// * *
// * bson_iter_t:
// *
// * This structure manages iteration over a bson_t structure. It keeps track
// * of the location of the current key and value within the buffer. Using the
// * various functions to get the value of the iter will read from these
// * locations.
// *
// * This structure is safe to discard on the stack. No cleanup is necessary
// * after using it.
// *
type
  bson_iter_t = record
    raw: Puint8_t; (* The raw buffer being iterated. *)
    len: uint32_t; (* The length of raw. *)
    off: uint32_t; (* The offset within the buffer. *)
    &type: uint32_t; (* The offset of the type byte. *)
    key: uint32_t; (* The offset of the key byte. *)
    d1: uint32_t; (* The offset of the first data byte. *)
    d2: uint32_t; (* The offset of the second data byte. *)
    d3: uint32_t; (* The offset of the third data byte. *)
    d4: uint32_t; (* The offset of the fourth data byte. *)
    next_off: uint32_t; (* The offset of the next field. *)
    err_off: uint32_t; (* The offset of the error. *)
    value: bson_value_t; (* Internal value for various state. *)
  end;
  Pbson_iter_t = ^bson_iter_t;

// * *
// * bson_reader_t:
// *
// * This structure is used to iterate over a sequence of BSON documents. It
// * allows for them to be iterated with the possibility of no additional
// * memory allocations under certain circumstances such as reading from an
// * incoming mongo packet.
// *

type
  bson_reader_t = record
    &type: uint32_t;
    // private
  end;
  Pbson_reader_t = ^bson_reader_t;

// * *
// * bson_visitor_t:
// *
// * This structure contains a series of pointers that can be executed for
// * each field of a BSON document based on the field type.
// *
// * For example, if an int32 field is found, visit_int32 will be called.
// *
// * When visiting each field using bson_iter_visit_all(), you may provide a
// * data pointer that will be provided with each callback. This might be useful
// * if you are marshaling to another language.
// *
// * You may pre-maturely stop the visitation of fields by returning true in your
// * visitor. Returning false will continue visitation to further fields.
// *
type
  bson_visitor_t = record
    (* run before / after descending into a document *)
    visit_before: function(iter: Pbson_iter_t; key: PAnsiChar; data: Pvoid): bool; cdecl;
    visit_after: function(iter: Pbson_iter_t; key: PAnsiChar; data: Pvoid): bool; cdecl;
    (* corrupt BSON, or unsupported type and visit_unsupported_type not set *)
    visit_corrupt: procedure(iter: Pbson_iter_t; data: Pvoid); cdecl;
    (* normal bson field callbacks *)
    visit_double: function(iter: Pbson_iter_t; key: PAnsiChar; v_double: double; data: Pvoid): bool; cdecl;
    visit_utf8: function(iter: Pbson_iter_t; key: PAnsiChar; v_utf8_len: size_t; v_utf8: PAnsiChar; data: Pvoid): bool; cdecl;
    visit_document: function(iter: Pbson_iter_t; key: PAnsiChar; v_document: Pbson_t; data: Pvoid): bool; cdecl;
    visit_array: function(iter: Pbson_iter_t; key: PAnsiChar; v_array: Pbson_t; data: Pvoid): bool; cdecl;
    visit_binary: function(iter: Pbson_iter_t; key: PAnsiChar; v_subtype: bson_subtype_t; v_binary_len: size_t; v_binary: Puint8_t; data: Pvoid): bool; cdecl;
    (* normal field with deprecated "Undefined" BSON type *)
    visit_undefined: function(iter: Pbson_iter_t; key: PAnsiChar; data: Pvoid): bool; cdecl;
    visit_oid: function(iter: Pbson_iter_t; key: PAnsiChar; v_oid: Pbson_oid_t; data: Pvoid): bool; cdecl;
    visit_bool: function(iter: Pbson_iter_t; key: PAnsiChar; v_bool: bool; data: Pvoid): bool; cdecl;
    visit_date_time: function(iter: Pbson_iter_t; key: PAnsiChar; msec_since_epoch: int64_t; data: Pvoid): bool; cdecl;
    visit_null: function(iter: Pbson_iter_t; key: PAnsiChar; data: Pvoid): bool; cdecl;
    visit_regex: function(iter: Pbson_iter_t; key: PAnsiChar; v_regex: PAnsiChar; v_options: PAnsiChar; data: Pvoid): bool; cdecl;
    visit_dbpointer: function(iter: Pbson_iter_t; key: PAnsiChar; v_collection_len: size_t; v_collection: PAnsiChar; v_oid: Pbson_oid_t; data: Pvoid): bool; cdecl;
    visit_code: function(iter: Pbson_iter_t; key: PAnsiChar; v_code_len: size_t; v_code: PAnsiChar; data: Pvoid): bool; cdecl;
    visit_symbol: function(iter: Pbson_iter_t; key: PAnsiChar; v_symbol_len: size_t; v_symbol: PAnsiChar; data: Pvoid): bool; cdecl;
    visit_codewscope: function(iter: Pbson_iter_t; key: PAnsiChar; v_code_len: size_t; v_code: PAnsiChar; v_scope: Pbson_t; data: Pvoid): bool; cdecl;
    visit_int32: function(iter: Pbson_iter_t; key: PAnsiChar; v_int32: int32_t; data: Pvoid): bool; cdecl;
    visit_timestamp: function(iter: Pbson_iter_t; key: PAnsiChar; v_timestamp: uint32_t; v_increment: uint32_t; data: Pvoid): bool; cdecl;
    visit_int64: function(iter: Pbson_iter_t; key: PAnsiChar; v_int64: int64_t; data: Pvoid): bool; cdecl;
    visit_maxkey: function(iter: Pbson_iter_t; key: PAnsiChar; data: Pvoid): bool; cdecl;
    visit_minkey: function(iter: Pbson_iter_t; key: PAnsiChar; data: Pvoid): bool; cdecl;
    (* if set, called instead of visit_corrupt when an apparently valid BSON
     * includes an unrecognized field type (reading future version of BSON) *)
    visit_unsupported_type: procedure(iter: Pbson_iter_t; key: PAnsiChar; type_code: uint32_t; data: Pvoid); cdecl;
    visit_decimal128: function(iter: Pbson_iter_t; key: PAnsiChar; v_decimal128: Pbson_decimal128_t; data: Pvoid): bool; cdecl;
    padding: array[0..7-1] of Pvoid;
  end;
  Pbson_visitor_t = ^bson_visitor_t;

// * *
// * bson_next_power_of_two:
// * @v: A 32-bit unsigned_integer of required bytes.
// *
// * Determines the next larger power of two for the value of @v
// * in a constant number of operations.
// *
// * It is up to the caller to guarantee this will not overflow.
// *
// * Returns: The next power of 2 from @v.
// *
// static BSON_INLINE size_t
// bson_next_power_of_two(size_t v)

// static BSON_INLINE bool
// bson_is_power_of_two(uint32_t v)

//////////////////
// bson-context //
//////////////////

// * *
// * @brief Initialize a new context with the given flags
// *
// * @param flags Flags used to configure the behavior of the context. For most
// * cases, this should be BSON_CONTEXT_NONE.
// *
// * @return A newly allocated context. Must be freed with bson_context_destroy()
// *
// * @note If you expect your pid to change without notice, such as from an
// * unexpected call to fork(), then specify BSON_CONTEXT_DISABLE_PID_CACHE in
// * `flags`.
// *
function bson_context_new(
           flags: bson_context_flags_t): Pbson_context_t; cdecl; external 'bson2.dll';

// * *
// * @brief Destroy and free a bson_context_t created by bson_context_new()
// *
procedure bson_context_destroy(
            context: Pbson_context_t); cdecl; external 'bson2.dll';

// * *
// * @brief Obtain a pointer to the application-default bson_context_t
// *
// * @note This context_t MUST NOT be passed to bson_context_destroy()
// *
function bson_context_get_default(): Pbson_context_t; cdecl; external 'bson2.dll';

////////////////
// bson-clock //
////////////////

function bson_get_monotonic_time(): int64_t; cdecl; external 'bson2.dll';
function bson_gettimeofday(
           tv: Ptimeval): Integer; cdecl; external 'bson2.dll';

/////////////////////
// bson-decimal128 //
/////////////////////

// * *
// * BSON_DECIMAL128_STRING:
// *
// * The length of a decimal128 string (with null terminator).
// *
// * 1 for the sign
// * 35 for digits and radix
// * 2 for exponent indicator and sign
// * 4 for exponent digits
// *
const BSON_DECIMAL128_STRING = 43;
const BSON_DECIMAL128_INF = 'Infinity';
const BSON_DECIMAL128_NAN = 'NaN';

procedure bson_decimal128_to_string(
            dec: Pbson_decimal128_t;
            str: PAnsiChar); cdecl; external 'bson2.dll';

// * Note: @string must be ASCII characters only!
function bson_decimal128_from_string(
           &string: PAnsiChar;
           dec: Pbson_decimal128_t): bool; cdecl; external 'bson2.dll';

function bson_decimal128_from_string_w_len(
           &string: PAnsiChar;
           len: Integer;
           dec: Pbson_decimal128_t): bool; cdecl; external 'bson2.dll';

///////////////
// bson-json //
///////////////

type
  _bson_json_reader_t = record
  end;
  bson_json_reader_t = _bson_json_reader_t;
  Pbson_json_reader_t = ^bson_json_reader_t;

type
  bson_json_error_code_t = (
    BSON_JSON_ERROR_READ_CORRUPT_JS = 1,
    BSON_JSON_ERROR_READ_INVALID_PARAM,
    BSON_JSON_ERROR_READ_CB_FAILURE);

// * *
// * BSON_MAX_LEN_UNLIMITED
// *
// * Denotes unlimited length limit when converting BSON to JSON.
// *
const BSON_MAX_LEN_UNLIMITED = -1;

// * *
// * bson_json_mode_t:
// *
// * This enumeration contains the different modes to serialize BSON into extended
// * JSON.
// *
type
  bson_json_mode_t = (
    BSON_JSON_MODE_LEGACY,
    BSON_JSON_MODE_CANONICAL,
    BSON_JSON_MODE_RELAXED);

function bson_json_opts_new(
           mode: bson_json_mode_t;
           max_len: int32_t): Pbson_json_opts_t; cdecl; external 'bson2.dll';
procedure bson_json_opts_destroy(
            opts: Pbson_json_opts_t); cdecl; external 'bson2.dll';
procedure bson_json_opts_set_outermost_array(
            opts: Pbson_json_opts_t;
            is_outermost_array: bool); cdecl; external 'bson2.dll';

type
  bson_json_reader_cb = function (
    handle: Pvoid;
    buf: Puint8_t;
    count: size_t): ssize_t; cdecl;
type
  bson_json_destroy_cb = procedure (
    handle: Pvoid); cdecl;

function bson_json_reader_new(
           data: Pvoid;
           cb: bson_json_reader_cb;
           dcb: bson_json_destroy_cb;
           allow_multiple: bool;
           buf_size: size_t): Pbson_json_reader_t; cdecl; external 'bson2.dll';
function bson_json_reader_new_from_fd(
           fd: Integer;
           close_on_destroy: bool): Pbson_json_reader_t; cdecl; external 'bson2.dll';
function bson_json_reader_new_from_file(
           filename: PAnsiChar;
           error: Pbson_error_t): Pbson_json_reader_t; cdecl; external 'bson2.dll';
procedure bson_json_reader_destroy(
            reader: Pbson_json_reader_t); cdecl; external 'bson2.dll';
function bson_json_reader_read(
           reader: Pbson_json_reader_t;
           bson: Pbson_t;
           error: Pbson_error_t): Integer; cdecl; external 'bson2.dll';
function bson_json_data_reader_new(
           allow_multiple: bool;
           size: size_t): Pbson_json_reader_t; cdecl; external 'bson2.dll';
procedure bson_json_data_reader_ingest(
            reader: Pbson_json_reader_t;
            data: Puint8_t;
            len: size_t); cdecl; external 'bson2.dll';

///////////////
// bson-keys //
///////////////

function bson_uint32_to_string(
           value: uint32_t;
           strptr: PPAnsiChar;
           str: PAnsiChar;
           size: size_t): size_t; cdecl; external 'bson2.dll';

/////////////////
// bson-string //
/////////////////

function bson_strdup(
           str: PAnsiChar): PAnsiChar; cdecl; external 'bson2.dll';

function bson_strdup_printf(
           format: PAnsiChar): PAnsiChar; cdecl; varargs; external 'bson2.dll';

function bson_strdupv_printf(
           format: PAnsiChar;
           args: va_list): PAnsiChar; cdecl; external 'bson2.dll';

function bson_strndup(
           str: PAnsiChar;
           n_bytes: size_t): PAnsiChar; cdecl; external 'bson2.dll';

procedure bson_strncpy(
            dst: PAnsiChar;
            src: PAnsiChar;
            size: size_t); cdecl; external 'bson2.dll';

function bson_vsnprintf(
           str: PAnsiChar;
           size: size_t;
           format: PAnsiChar;
           ap: va_list): Integer; cdecl; external 'bson2.dll';

function bson_snprintf(
           str: PAnsiChar;
           size: size_t;
           format: PAnsiChar): Integer; cdecl; varargs; external 'bson2.dll';

procedure bson_strfreev(
            strv: PPAnsiChar); cdecl; external 'bson2.dll';

function bson_strnlen(
           s: PAnsiChar;
           maxlen: size_t): size_t; cdecl; external 'bson2.dll';

function bson_ascii_strtoll(
           str: PAnsiChar;
           endptr: PPAnsiChar;
           base: Integer): int64_t; cdecl; external 'bson2.dll';

function bson_strcasecmp(
           s1: PAnsiChar;
           s2: PAnsiChar): Integer; cdecl; external 'bson2.dll';

function bson_isspace(
           c: Integer): bool; cdecl; external 'bson2.dll';

///////////////
// bson-utf8 //
///////////////

function bson_utf8_validate(
           utf8: PAnsiChar;
           utf8_len: size_t;
           allow_null: bool): bool; cdecl; external 'bson2.dll';
function bson_utf8_escape_for_json(
           utf8: PAnsiChar;
           utf8_len: ssize_t): PAnsiChar; cdecl; external 'bson2.dll';
function bson_utf8_get_char(
           utf8: PAnsiChar): bson_unichar_t; cdecl; external 'bson2.dll';
function bson_utf8_next_char(
           utf8: PAnsiChar): PAnsiChar; cdecl; external 'bson2.dll';
procedure bson_utf8_from_unichar(
            unichar: bson_unichar_t;
            utf8: TCharArray6;
            len: Puint32_t); cdecl; external 'bson2.dll';

////////////////
// bson-value //
////////////////

procedure bson_value_copy(
            src: Pbson_value_t;
            dst: Pbson_value_t); cdecl; external 'bson2.dll';
procedure bson_value_destroy(
            value: Pbson_value_t); cdecl; external 'bson2.dll';

////////////////////////////
// bson-version-functions //
////////////////////////////

function bson_get_major_version(): Integer; cdecl; external 'bson2.dll';
function bson_get_minor_version(): Integer; cdecl; external 'bson2.dll';
function bson_get_micro_version(): Integer; cdecl; external 'bson2.dll';
function bson_get_version(): PAnsiChar; cdecl; external 'bson2.dll';
function bson_check_version(
           required_major: Integer;
           required_minor: Integer;
           required_micro: Integer): bool; cdecl; external 'bson2.dll';

///////////////
// bson-bcon //
///////////////

// Include specific headers first, because bson.h tries to include this header itself:

// For other APIs, not properly grouped, but needed:

const BCON_STACK_MAX = 100;

// #define BCON_ENSURE_DECLARE(fun, type) static BSON_INLINE type bcon_ensure_##fun(type _t) { return _t; }

// #define BCON_ENSURE(fun, val) bcon_ensure_##fun(val)

// #define BCON_ENSURE_STORAGE(fun, val) bcon_ensure_##fun(&(val))

// BCON_ENSURE_DECLARE(const_char_ptr, const char * )
// BCON_ENSURE_DECLARE(const_char_ptr_ptr, const char * * )
// BCON_ENSURE_DECLARE(double, double)
// BCON_ENSURE_DECLARE(double_ptr, double * )
// BCON_ENSURE_DECLARE(const_bson_ptr, const bson_t * )
// BCON_ENSURE_DECLARE(bson_ptr, bson_t * )
// BCON_ENSURE_DECLARE(subtype, bson_subtype_t)
// BCON_ENSURE_DECLARE(subtype_ptr, bson_subtype_t * )
// BCON_ENSURE_DECLARE(const_uint8_ptr, const uint8_t * )
// BCON_ENSURE_DECLARE(const_uint8_ptr_ptr, const uint8_t * * )
// BCON_ENSURE_DECLARE(uint32, uint32_t)
// BCON_ENSURE_DECLARE(uint32_ptr, uint32_t * )
// BCON_ENSURE_DECLARE(const_oid_ptr, const bson_oid_t * )
// BCON_ENSURE_DECLARE(const_oid_ptr_ptr, const bson_oid_t * * )
// BCON_ENSURE_DECLARE(int32, int32_t)
// BCON_ENSURE_DECLARE(int32_ptr, int32_t * )
// BCON_ENSURE_DECLARE(int64, int64_t)
// BCON_ENSURE_DECLARE(int64_ptr, int64_t * )
// BCON_ENSURE_DECLARE(const_decimal128_ptr, const bson_decimal128_t * )
// BCON_ENSURE_DECLARE(bool, bool)
// BCON_ENSURE_DECLARE(bool_ptr, bool * )
// BCON_ENSURE_DECLARE(bson_type, bson_type_t)
// BCON_ENSURE_DECLARE(bson_iter_ptr, bson_iter_t * )
// BCON_ENSURE_DECLARE(const_bson_iter_ptr, const bson_iter_t * )

// #define BCON_UTF8(_val) BCON_MAGIC, BCON_TYPE_UTF8, BCON_ENSURE(const_char_ptr, (_val))
// #define BCON_DOUBLE(_val) BCON_MAGIC, BCON_TYPE_DOUBLE, BCON_ENSURE(double, (_val))
// #define BCON_DOCUMENT(_val) BCON_MAGIC, BCON_TYPE_DOCUMENT, BCON_ENSURE(const_bson_ptr, (_val))
// #define BCON_ARRAY(_val) BCON_MAGIC, BCON_TYPE_ARRAY, BCON_ENSURE(const_bson_ptr, (_val))
// #define BCON_BIN(_subtype, _binary, _length) BCON_MAGIC, BCON_TYPE_BIN, BCON_ENSURE(subtype, (_subtype)), BCON_ENSURE(const_uint8_ptr, (_binary)), BCON_ENSURE(uint32, (_length))
// #define BCON_UNDEFINED BCON_MAGIC, BCON_TYPE_UNDEFINED
// #define BCON_OID(_val) BCON_MAGIC, BCON_TYPE_OID, BCON_ENSURE(const_oid_ptr, (_val))
// #define BCON_BOOL(_val) BCON_MAGIC, BCON_TYPE_BOOL, BCON_ENSURE(bool, (_val))
// #define BCON_DATE_TIME(_val) BCON_MAGIC, BCON_TYPE_DATE_TIME, BCON_ENSURE(int64, (_val))
// #define BCON_NULL BCON_MAGIC, BCON_TYPE_NULL
// #define BCON_REGEX(_regex, _flags) BCON_MAGIC, BCON_TYPE_REGEX, BCON_ENSURE(const_char_ptr, (_regex)), BCON_ENSURE(const_char_ptr, (_flags))
// #define BCON_DBPOINTER(_collection, _oid) BCON_MAGIC, BCON_TYPE_DBPOINTER, BCON_ENSURE(const_char_ptr, (_collection)), BCON_ENSURE(const_oid_ptr, (_oid))
// #define BCON_CODE(_val) BCON_MAGIC, BCON_TYPE_CODE, BCON_ENSURE(const_char_ptr, (_val))
// #define BCON_SYMBOL(_val) BCON_MAGIC, BCON_TYPE_SYMBOL, BCON_ENSURE(const_char_ptr, (_val))
// #define BCON_CODEWSCOPE(_js, _scope) BCON_MAGIC, BCON_TYPE_CODEWSCOPE, BCON_ENSURE(const_char_ptr, (_js)), BCON_ENSURE(const_bson_ptr, (_scope))
// #define BCON_INT32(_val) BCON_MAGIC, BCON_TYPE_INT32, BCON_ENSURE(int32, (_val))
// #define BCON_TIMESTAMP(_timestamp, _increment) BCON_MAGIC, BCON_TYPE_TIMESTAMP, BCON_ENSURE(int32, (_timestamp)), BCON_ENSURE(int32, (_increment))
// #define BCON_INT64(_val) BCON_MAGIC, BCON_TYPE_INT64, BCON_ENSURE(int64, (_val))
// #define BCON_DECIMAL128(_val) BCON_MAGIC, BCON_TYPE_DECIMAL128, BCON_ENSURE(const_decimal128_ptr, (_val))
// #define BCON_MAXKEY BCON_MAGIC, BCON_TYPE_MAXKEY
// #define BCON_MINKEY BCON_MAGIC, BCON_TYPE_MINKEY
// #define BCON(_val) BCON_MAGIC, BCON_TYPE_BCON, BCON_ENSURE(const_bson_ptr, (_val))
// #define BCON_ITER(_val) BCON_MAGIC, BCON_TYPE_ITER, BCON_ENSURE(const_bson_iter_ptr, (_val))

// #define BCONE_UTF8(_val) BCONE_MAGIC, BCON_TYPE_UTF8, BCON_ENSURE_STORAGE(const_char_ptr_ptr, (_val))
// #define BCONE_DOUBLE(_val) BCONE_MAGIC, BCON_TYPE_DOUBLE, BCON_ENSURE_STORAGE(double_ptr, (_val))
// #define BCONE_DOCUMENT(_val) BCONE_MAGIC, BCON_TYPE_DOCUMENT, BCON_ENSURE_STORAGE(bson_ptr, (_val))
// #define BCONE_ARRAY(_val) BCONE_MAGIC, BCON_TYPE_ARRAY, BCON_ENSURE_STORAGE(bson_ptr, (_val))
// #define BCONE_BIN(subtype, binary, length) BCONE_MAGIC, BCON_TYPE_BIN, BCON_ENSURE_STORAGE(subtype_ptr, (subtype)), BCON_ENSURE_STORAGE(const_uint8_ptr_ptr, (binary)), BCON_ENSURE_STORAGE(uint32_ptr, (length))
// #define BCONE_UNDEFINED BCONE_MAGIC, BCON_TYPE_UNDEFINED
// #define BCONE_OID(_val) BCONE_MAGIC, BCON_TYPE_OID, BCON_ENSURE_STORAGE(const_oid_ptr_ptr, (_val))
// #define BCONE_BOOL(_val) BCONE_MAGIC, BCON_TYPE_BOOL, BCON_ENSURE_STORAGE(bool_ptr, (_val))
// #define BCONE_DATE_TIME(_val) BCONE_MAGIC, BCON_TYPE_DATE_TIME, BCON_ENSURE_STORAGE(int64_ptr, (_val))
// #define BCONE_NULL BCONE_MAGIC, BCON_TYPE_NULL
// #define BCONE_REGEX(_regex, _flags) BCONE_MAGIC, BCON_TYPE_REGEX, BCON_ENSURE_STORAGE(const_char_ptr_ptr, (_regex)), BCON_ENSURE_STORAGE(const_char_ptr_ptr, (_flags))
// #define BCONE_DBPOINTER(_collection, _oid) BCONE_MAGIC, BCON_TYPE_DBPOINTER, BCON_ENSURE_STORAGE(const_char_ptr_ptr, (_collection)), BCON_ENSURE_STORAGE(const_oid_ptr_ptr, (_oid))
// #define BCONE_CODE(_val) BCONE_MAGIC, BCON_TYPE_CODE, BCON_ENSURE_STORAGE(const_char_ptr_ptr, (_val))
// #define BCONE_SYMBOL(_val) BCONE_MAGIC, BCON_TYPE_SYMBOL, BCON_ENSURE_STORAGE(const_char_ptr_ptr, (_val))
// #define BCONE_CODEWSCOPE(_js, _scope) BCONE_MAGIC, BCON_TYPE_CODEWSCOPE, BCON_ENSURE_STORAGE(const_char_ptr_ptr, (_js)), BCON_ENSURE_STORAGE(bson_ptr, (_scope))
// #define BCONE_INT32(_val) BCONE_MAGIC, BCON_TYPE_INT32, BCON_ENSURE_STORAGE(int32_ptr, (_val))
// #define BCONE_TIMESTAMP(_timestamp, _increment) BCONE_MAGIC, BCON_TYPE_TIMESTAMP, BCON_ENSURE_STORAGE(int32_ptr, (_timestamp)), BCON_ENSURE_STORAGE(int32_ptr, (_increment))
// #define BCONE_INT64(_val) BCONE_MAGIC, BCON_TYPE_INT64, BCON_ENSURE_STORAGE(int64_ptr, (_val))
// #define BCONE_DECIMAL128(_val) BCONE_MAGIC, BCON_TYPE_DECIMAL128, BCON_ENSURE_STORAGE(const_decimal128_ptr, (_val))
// #define BCONE_MAXKEY BCONE_MAGIC, BCON_TYPE_MAXKEY
// #define BCONE_MINKEY BCONE_MAGIC, BCON_TYPE_MINKEY
// #define BCONE_SKIP(_val) BCONE_MAGIC, BCON_TYPE_SKIP, BCON_ENSURE(bson_type, (_val))
// #define BCONE_ITER(_val) BCONE_MAGIC, BCON_TYPE_ITER, BCON_ENSURE_STORAGE(bson_iter_ptr, (_val))

// #define BCON_MAGIC bson_bcon_magic()
// #define BCONE_MAGIC bson_bcone_magic()

type
  bcon_type_t = (
    BCON_TYPE_UTF8,
    BCON_TYPE_DOUBLE,
    BCON_TYPE_DOCUMENT,
    BCON_TYPE_ARRAY,
    BCON_TYPE_BIN,
    BCON_TYPE_UNDEFINED,
    BCON_TYPE_OID,
    BCON_TYPE_BOOL,
    BCON_TYPE_DATE_TIME,
    BCON_TYPE_NULL,
    BCON_TYPE_REGEX,
    BCON_TYPE_DBPOINTER,
    BCON_TYPE_CODE,
    BCON_TYPE_SYMBOL,
    BCON_TYPE_CODEWSCOPE,
    BCON_TYPE_INT32,
    BCON_TYPE_TIMESTAMP,
    BCON_TYPE_INT64,
    BCON_TYPE_DECIMAL128,
    BCON_TYPE_MAXKEY,
    BCON_TYPE_MINKEY,
    BCON_TYPE_BCON,
    BCON_TYPE_ARRAY_START,
    BCON_TYPE_ARRAY_END,
    BCON_TYPE_DOC_START,
    BCON_TYPE_DOC_END,
    BCON_TYPE_END,
    BCON_TYPE_RAW,
    BCON_TYPE_SKIP,
    BCON_TYPE_ITER,
    BCON_TYPE_ERROR);

type
  bcon_append_ctx_frame = record
    i: Integer;
    is_array: bool;
    bson: bson_t;
  end;
  bcon_append_ctx_frame_t = bcon_append_ctx_frame;

type
  bcon_extract_ctx_frame = record
    i: Integer;
    is_array: bool;
    iter: bson_iter_t;
  end;
  bcon_extract_ctx_frame_t = bcon_extract_ctx_frame;

type
  _bcon_append_ctx_t = record
    stack: array[0..BCON_STACK_MAX-1] of bcon_append_ctx_frame_t;
    n: Integer;
  end;
  bcon_append_ctx_t = _bcon_append_ctx_t;
  Pbcon_append_ctx_t = ^bcon_append_ctx_t;

type
  _bcon_extract_ctx_t = record
    stack: array[0..BCON_STACK_MAX-1] of bcon_extract_ctx_frame_t;
    n: Integer;
  end;
  bcon_extract_ctx_t = _bcon_extract_ctx_t;
  Pbcon_extract_ctx_t = ^bcon_extract_ctx_t;

procedure bcon_append(
            bson: Pbson_t); cdecl; varargs; external 'bson2.dll';
procedure bcon_append_ctx(
            bson: Pbson_t;
            ctx: Pbcon_append_ctx_t); cdecl; varargs; external 'bson2.dll';
procedure bcon_append_ctx_va(
            bson: Pbson_t;
            ctx: Pbcon_append_ctx_t;
            va: Pva_list); cdecl; external 'bson2.dll';
procedure bcon_append_ctx_init(
            ctx: Pbcon_append_ctx_t); cdecl; external 'bson2.dll';

procedure bcon_extract_ctx_init(
            ctx: Pbcon_extract_ctx_t); cdecl; external 'bson2.dll';

procedure bcon_extract_ctx(
            bson: Pbson_t;
            ctx: Pbcon_extract_ctx_t); cdecl; varargs; external 'bson2.dll';

function bcon_extract_ctx_va(
           bson: Pbson_t;
           ctx: Pbcon_extract_ctx_t;
           ap: Pva_list): bool; cdecl; external 'bson2.dll';

function bcon_extract(
           bson: Pbson_t): bool; cdecl; varargs; external 'bson2.dll';

// bool __CALLCONV__
// bcon_extract_va(bson_t * bson, bcon_extract_ctx_t * ctx, ...);

function bcon_new(
           unused: Pvoid): Pbson_t; cdecl; varargs; external 'bson2.dll';

// * *
// * The bcon_..() functions are all declared with __attribute__((sentinel)).
// *
// * From GCC manual for "sentinel": "A valid NULL in this context is defined as
// * zero with any pointer type. If your system defines the NULL macro with an
// * integer type then you need to add an explicit cast."
// * Case in point: GCC on Solaris (at least)
// *
// #define BCON_APPEND(_bson, ...) bcon_append((_bson), __VA_ARGS__, (void * )NULL)
// #define BCON_APPEND_CTX(_bson, _ctx, ...) bcon_append_ctx((_bson), (_ctx), __VA_ARGS__, (void * )NULL)

// #define BCON_EXTRACT(_bson, ...) bcon_extract((_bson), __VA_ARGS__, (void * )NULL)

// #define BCON_EXTRACT_CTX(_bson, _ctx, ...) bcon_extract((_bson), (_ctx), __VA_ARGS__, (void * )NULL)

// #define BCON_NEW(...) bcon_new(NULL, __VA_ARGS__, (void * )NULL)

function bson_bcon_magic(): PAnsiChar; cdecl; external 'bson2.dll';
function bson_bcone_magic(): PAnsiChar; cdecl; external 'bson2.dll';

/////////////////
// bson-reader //
/////////////////

const BSON_ERROR_READER_BADFD = 1;

// *
// * --------------------------------------------------------------------------
// *
// * bson_reader_read_func_t --
// *
// * This function is a callback used by bson_reader_t to read the
// * next chunk of data from the underlying opaque file descriptor.
// *
// * This function is meant to operate similar to the read() function
// * as part of libc on UNIX-like systems.
// *
// * Parameters:
// * @handle: The handle to read from.
// * @buf: The buffer to read into.
// * @count: The number of bytes to read.
// *
// * Returns:
// * 0 for end of stream.
// * -1 for read failure.
// * Greater than zero for number of bytes read into @buf.
// *
// * Side effects:
// * None.
// *
// * --------------------------------------------------------------------------
// *

type
  bson_reader_read_func_t = function (
    handle: Pvoid;
    (* IN *)
    buf: Pvoid;
    (* IN *)
    count: size_t): ssize_t; cdecl; (* IN *)

// *
// * --------------------------------------------------------------------------
// *
// * bson_reader_destroy_func_t --
// *
// * Destroy callback to release any resources associated with the
// * opaque handle.
// *
// * Parameters:
// * @handle: the handle provided to bson_reader_new_from_handle().
// *
// * Returns:
// * None.
// *
// * Side effects:
// * None.
// *
// * --------------------------------------------------------------------------
// *

type
  bson_reader_destroy_func_t = procedure (
    handle: Pvoid); cdecl; (* IN *)

function bson_reader_new_from_handle(
           handle: Pvoid;
           rf: bson_reader_read_func_t;
           df: bson_reader_destroy_func_t): Pbson_reader_t; cdecl; external 'bson2.dll';
function bson_reader_new_from_fd(
           fd: Integer;
           close_on_destroy: bool): Pbson_reader_t; cdecl; external 'bson2.dll';
function bson_reader_new_from_file(
           path: PAnsiChar;
           error: Pbson_error_t): Pbson_reader_t; cdecl; external 'bson2.dll';
function bson_reader_new_from_data(
           data: Puint8_t;
           length: size_t): Pbson_reader_t; cdecl; external 'bson2.dll';
procedure bson_reader_destroy(
            reader: Pbson_reader_t); cdecl; external 'bson2.dll';
procedure bson_reader_set_read_func(
            reader: Pbson_reader_t;
            func: bson_reader_read_func_t); cdecl; external 'bson2.dll';
procedure bson_reader_set_destroy_func(
            reader: Pbson_reader_t;
            func: bson_reader_destroy_func_t); cdecl; external 'bson2.dll';
function bson_reader_read(
           reader: Pbson_reader_t;
           reached_eof: Pbool): Pbson_t; cdecl; external 'bson2.dll';
function bson_reader_tell(
           reader: Pbson_reader_t): off_t; cdecl; external 'bson2.dll';
procedure bson_reader_reset(
            reader: Pbson_reader_t); cdecl; external 'bson2.dll';

//////////////
// bson-oid //
//////////////

function bson_oid_compare(
           oid1: Pbson_oid_t;
           oid2: Pbson_oid_t): Integer; cdecl; external 'bson2.dll';
procedure bson_oid_copy(
            src: Pbson_oid_t;
            dst: Pbson_oid_t); cdecl; external 'bson2.dll';
function bson_oid_equal(
           oid1: Pbson_oid_t;
           oid2: Pbson_oid_t): bool; cdecl; external 'bson2.dll';
function bson_oid_is_valid(
           str: PAnsiChar;
           length: size_t): bool; cdecl; external 'bson2.dll';
function bson_oid_get_time_t(
           oid: Pbson_oid_t): time_t; cdecl; external 'bson2.dll';
function bson_oid_hash(
           oid: Pbson_oid_t): uint32_t; cdecl; external 'bson2.dll';
procedure bson_oid_init(
            oid: Pbson_oid_t;
            context: Pbson_context_t); cdecl; external 'bson2.dll';
procedure bson_oid_init_from_data(
            oid: Pbson_oid_t;
            data: Puint8_t); cdecl; external 'bson2.dll';
procedure bson_oid_init_from_string(
            oid: Pbson_oid_t;
            str: PAnsiChar); cdecl; external 'bson2.dll';
procedure bson_oid_to_string(
            oid: Pbson_oid_t;
            str: TCharArray25); cdecl; external 'bson2.dll';

// * *
// * bson_oid_compare_unsafe:
// * @oid1: A bson_oid_t.
// * @oid2: A bson_oid_t.
// *
// * Performs a qsort() style comparison between @oid1 and @oid2.
// *
// * This function is meant to be as fast as possible and therefore performs
// * no argument validation. That is the callers responsibility.
// *
// * Returns: An integer < 0 if @oid1 is less than @oid2. Zero if they are equal.
// * An integer > 0 if @oid1 is greater than @oid2.
// *
// static BSON_INLINE int
// bson_oid_compare_unsafe(const bson_oid_t * oid1, const bson_oid_t * oid2)

// * *
// * bson_oid_equal_unsafe:
// * @oid1: A bson_oid_t.
// * @oid2: A bson_oid_t.
// *
// * Checks the equality of @oid1 and @oid2.
// *
// * This function is meant to be as fast as possible and therefore performs
// * no checks for argument validity. That is the callers responsibility.
// *
// * Returns: true if @oid1 and @oid2 are equal; otherwise false.
// *
// static BSON_INLINE bool
// bson_oid_equal_unsafe(const bson_oid_t * oid1, const bson_oid_t * oid2)

// * *
// * bson_oid_hash_unsafe:
// * @oid: A bson_oid_t.
// *
// * This function performs a DJB style hash upon the bytes contained in @oid.
// * The result is a hash key suitable for use in a hashtable.
// *
// * This function is meant to be as fast as possible and therefore performs no
// * validation of arguments. The caller is responsible to ensure they are
// * passing valid arguments.
// *
// * Returns: A uint32_t containing a hash code.
// *
// static BSON_INLINE uint32_t
// bson_oid_hash_unsafe(const bson_oid_t * oid)

// * *
// * bson_oid_copy_unsafe:
// * @src: A bson_oid_t to copy from.
// * @dst: A bson_oid_t to copy into.
// *
// * Copies the contents of @src into @dst. This function is meant to be as
// * fast as possible and therefore performs no argument checking. It is the
// * callers responsibility to ensure they are passing valid data into the
// * function.
// *
// static BSON_INLINE void
// bson_oid_copy_unsafe(const bson_oid_t * src, bson_oid_t * dst)

// * *
// * bson_oid_parse_hex_char:
// * @hex: A character to parse to its integer value.
// *
// * This function contains a jump table to return the integer value for a
// * character containing a hexadecimal value (0-9, a-f, A-F). If the character
// * is not a hexadecimal character then zero is returned.
// *
// * Returns: An integer between 0 and 15.
// *
// static BSON_INLINE uint8_t
// bson_oid_parse_hex_char(char hex)

// * *
// * bson_oid_init_from_string_unsafe:
// * @oid: A bson_oid_t to store the result.
// * @str: A 24-character hexadecimal encoded string.
// *
// * Parses a string containing 24 hexadecimal encoded bytes into a bson_oid_t.
// * This function is meant to be as fast as possible and inlined into your
// * code. For that purpose, the function does not perform any sort of bounds
// * checking and it is the callers responsibility to ensure they are passing
// * valid input to the function.
// *
// static BSON_INLINE void
// bson_oid_init_from_string_unsafe(bson_oid_t * oid, const char * str)

// * *
// * bson_oid_get_time_t_unsafe:
// * @oid: A bson_oid_t.
// *
// * Fetches the time @oid was generated.
// *
// * Returns: A time_t containing the UNIX timestamp of generation.
// *
// static BSON_INLINE time_t
// bson_oid_get_time_t_unsafe(const bson_oid_t * oid)

///////////////
// bson-iter //
///////////////

// #define BSON_ITER_HOLDS_DOUBLE(iter) (bson_iter_type((iter)) == BSON_TYPE_DOUBLE)

// #define BSON_ITER_HOLDS_UTF8(iter) (bson_iter_type((iter)) == BSON_TYPE_UTF8)

// #define BSON_ITER_HOLDS_DOCUMENT(iter) (bson_iter_type((iter)) == BSON_TYPE_DOCUMENT)

// #define BSON_ITER_HOLDS_ARRAY(iter) (bson_iter_type((iter)) == BSON_TYPE_ARRAY)

// #define BSON_ITER_HOLDS_BINARY(iter) (bson_iter_type((iter)) == BSON_TYPE_BINARY)

// #define BSON_ITER_HOLDS_VECTOR(iter) (BSON_ITER_HOLDS_BINARY(iter) && bson_iter_binary_subtype(iter) == BSON_SUBTYPE_VECTOR)

// #define BSON_ITER_HOLDS_VECTOR_INT8(iter) (bson_vector_int8_const_view_from_iter(NULL, iter))

// #define BSON_ITER_HOLDS_VECTOR_FLOAT32(iter) (bson_vector_float32_const_view_from_iter(NULL, iter))

// #define BSON_ITER_HOLDS_VECTOR_PACKED_BIT(iter) (bson_vector_packed_bit_const_view_from_iter(NULL, iter))

// #define BSON_ITER_HOLDS_UNDEFINED(iter) (bson_iter_type((iter)) == BSON_TYPE_UNDEFINED)

// #define BSON_ITER_HOLDS_OID(iter) (bson_iter_type((iter)) == BSON_TYPE_OID)

// #define BSON_ITER_HOLDS_BOOL(iter) (bson_iter_type((iter)) == BSON_TYPE_BOOL)

// #define BSON_ITER_HOLDS_DATE_TIME(iter) (bson_iter_type((iter)) == BSON_TYPE_DATE_TIME)

// #define BSON_ITER_HOLDS_NULL(iter) (bson_iter_type((iter)) == BSON_TYPE_NULL)

// #define BSON_ITER_HOLDS_REGEX(iter) (bson_iter_type((iter)) == BSON_TYPE_REGEX)

// #define BSON_ITER_HOLDS_DBPOINTER(iter) (bson_iter_type((iter)) == BSON_TYPE_DBPOINTER)

// #define BSON_ITER_HOLDS_CODE(iter) (bson_iter_type((iter)) == BSON_TYPE_CODE)

// #define BSON_ITER_HOLDS_SYMBOL(iter) (bson_iter_type((iter)) == BSON_TYPE_SYMBOL)

// #define BSON_ITER_HOLDS_CODEWSCOPE(iter) (bson_iter_type((iter)) == BSON_TYPE_CODEWSCOPE)

// #define BSON_ITER_HOLDS_INT32(iter) (bson_iter_type((iter)) == BSON_TYPE_INT32)

// #define BSON_ITER_HOLDS_TIMESTAMP(iter) (bson_iter_type((iter)) == BSON_TYPE_TIMESTAMP)

// #define BSON_ITER_HOLDS_INT64(iter) (bson_iter_type((iter)) == BSON_TYPE_INT64)

// #define BSON_ITER_HOLDS_DECIMAL128(iter) (bson_iter_type((iter)) == BSON_TYPE_DECIMAL128)

// #define BSON_ITER_HOLDS_MAXKEY(iter) (bson_iter_type((iter)) == BSON_TYPE_MAXKEY)

// #define BSON_ITER_HOLDS_MINKEY(iter) (bson_iter_type((iter)) == BSON_TYPE_MINKEY)

// #define BSON_ITER_HOLDS_INT(iter) (BSON_ITER_HOLDS_INT32(iter) || BSON_ITER_HOLDS_INT64(iter))

// #define BSON_ITER_HOLDS_NUMBER(iter) (BSON_ITER_HOLDS_INT(iter) || BSON_ITER_HOLDS_DOUBLE(iter))

// #define BSON_ITER_IS_KEY(iter, key) (0 == strcmp((key), bson_iter_key((iter))))

function bson_iter_value(
           iter: Pbson_iter_t): Pbson_value_t; cdecl; external 'bson2.dll';

// * *
// * bson_iter_utf8_len_unsafe:
// * @iter: a bson_iter_t.
// *
// * Returns the length of a string currently pointed to by @iter. This performs
// * no validation so the is responsible for knowing the BSON is valid. Calling
// * bson_validate() is one way to do this ahead of time.
// *
// static BSON_INLINE uint32_t
// bson_iter_utf8_len_unsafe(const bson_iter_t * iter)

procedure bson_iter_array(
            iter: Pbson_iter_t;
            array_len: Puint32_t;
            &array: PPuint8_t); cdecl; external 'bson2.dll';

procedure bson_iter_binary(
            iter: Pbson_iter_t;
            subtype: Pbson_subtype_t;
            binary_len: Puint32_t;
            binary: PPuint8_t); cdecl; external 'bson2.dll';

procedure bson_iter_overwrite_binary(
            iter: Pbson_iter_t;
            subtype: bson_subtype_t;
            binary_len: Puint32_t;
            binary: PPuint8_t); cdecl; external 'bson2.dll';

function bson_iter_binary_subtype(
           iter: Pbson_iter_t): bson_subtype_t; cdecl; external 'bson2.dll';

function bson_iter_binary_equal(
           iter_a: Pbson_iter_t;
           iter_b: Pbson_iter_t): bool; cdecl; external 'bson2.dll';

function bson_iter_code(
           iter: Pbson_iter_t;
           length: Puint32_t): PAnsiChar; cdecl; external 'bson2.dll';

// * *
// * bson_iter_code_unsafe:
// * @iter: A bson_iter_t.
// * @length: A location for the length of the resulting string.
// *
// * Like bson_iter_code() but performs no integrity checks.
// *
// * Returns: A string that should not be modified or freed.
// *
// static BSON_INLINE const char *
// bson_iter_code_unsafe(const bson_iter_t * iter, uint32_t * length)

function bson_iter_codewscope(
           iter: Pbson_iter_t;
           length: Puint32_t;
           scope_len: Puint32_t;
           scope: PPuint8_t): PAnsiChar; cdecl; external 'bson2.dll';

procedure bson_iter_dbpointer(
            iter: Pbson_iter_t;
            collection_len: Puint32_t;
            collection: PPAnsiChar;
            oid: PPbson_oid_t); cdecl; external 'bson2.dll';

procedure bson_iter_document(
            iter: Pbson_iter_t;
            document_len: Puint32_t;
            document: PPuint8_t); cdecl; external 'bson2.dll';

function bson_iter_double(
           iter: Pbson_iter_t): double; cdecl; external 'bson2.dll';

function bson_iter_as_double(
           iter: Pbson_iter_t): double; cdecl; external 'bson2.dll';

// * *
// * bson_iter_double_unsafe:
// * @iter: A bson_iter_t.
// *
// * Similar to bson_iter_double() but does not perform an integrity checking.
// *
// * Returns: A double.
// *
// static BSON_INLINE double
// bson_iter_double_unsafe(const bson_iter_t * iter)

function bson_iter_init(
           iter: Pbson_iter_t;
           bson: Pbson_t): bool; cdecl; external 'bson2.dll';

function bson_iter_init_from_data(
           iter: Pbson_iter_t;
           data: Puint8_t;
           length: size_t): bool; cdecl; external 'bson2.dll';

function bson_iter_init_find(
           iter: Pbson_iter_t;
           bson: Pbson_t;
           key: PAnsiChar): bool; cdecl; external 'bson2.dll';

function bson_iter_init_find_w_len(
           iter: Pbson_iter_t;
           bson: Pbson_t;
           key: PAnsiChar;
           keylen: Integer): bool; cdecl; external 'bson2.dll';

function bson_iter_init_find_case(
           iter: Pbson_iter_t;
           bson: Pbson_t;
           key: PAnsiChar): bool; cdecl; external 'bson2.dll';

function bson_iter_init_from_data_at_offset(
           iter: Pbson_iter_t;
           data: Puint8_t;
           length: size_t;
           offset: uint32_t;
           keylen: uint32_t): bool; cdecl; external 'bson2.dll';

function bson_iter_int32(
           iter: Pbson_iter_t): int32_t; cdecl; external 'bson2.dll';

// * *
// * bson_iter_int32_unsafe:
// * @iter: A bson_iter_t.
// *
// * Similar to bson_iter_int32() but with no integrity checking.
// *
// * Returns: A 32-bit signed_integer.
// *
// static BSON_INLINE int32_t
// bson_iter_int32_unsafe(const bson_iter_t * iter)

function bson_iter_int64(
           iter: Pbson_iter_t): int64_t; cdecl; external 'bson2.dll';

function bson_iter_as_int64(
           iter: Pbson_iter_t): int64_t; cdecl; external 'bson2.dll';

// * *
// * bson_iter_int64_unsafe:
// * @iter: a bson_iter_t.
// *
// * Similar to bson_iter_int64() but without integrity checking.
// *
// * Returns: A 64-bit signed_integer.
// *
// static BSON_INLINE int64_t
// bson_iter_int64_unsafe(const bson_iter_t * iter)

function bson_iter_find(
           iter: Pbson_iter_t;
           key: PAnsiChar): bool; cdecl; external 'bson2.dll';

function bson_iter_find_w_len(
           iter: Pbson_iter_t;
           key: PAnsiChar;
           keylen: Integer): bool; cdecl; external 'bson2.dll';

function bson_iter_find_case(
           iter: Pbson_iter_t;
           key: PAnsiChar): bool; cdecl; external 'bson2.dll';

function bson_iter_find_descendant(
           iter: Pbson_iter_t;
           dotkey: PAnsiChar;
           descendant: Pbson_iter_t): bool; cdecl; external 'bson2.dll';

function bson_iter_next(
           iter: Pbson_iter_t): bool; cdecl; external 'bson2.dll';

function bson_iter_oid(
           iter: Pbson_iter_t): Pbson_oid_t; cdecl; external 'bson2.dll';

// * *
// * bson_iter_oid_unsafe:
// * @iter: A #bson_iter_t.
// *
// * Similar to bson_iter_oid() but performs no integrity checks.
// *
// * Returns: A #bson_oid_t that should not be modified or freed.
// *
// static BSON_INLINE const bson_oid_t *
// bson_iter_oid_unsafe(const bson_iter_t * iter)

function bson_iter_decimal128(
           iter: Pbson_iter_t;
           dec: Pbson_decimal128_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_iter_decimal128_unsafe:
// * @iter: A #bson_iter_t.
// *
// * Similar to bson_iter_decimal128() but performs no integrity checks.
// *
// * Returns: A #bson_decimal128_t.
// *
// static BSON_INLINE void
// bson_iter_decimal128_unsafe(const bson_iter_t * iter, bson_decimal128_t * dec)

function bson_iter_key(
           iter: Pbson_iter_t): PAnsiChar; cdecl; external 'bson2.dll';

function bson_iter_key_len(
           iter: Pbson_iter_t): uint32_t; cdecl; external 'bson2.dll';

// * *
// * bson_iter_key_unsafe:
// * @iter: A bson_iter_t.
// *
// * Similar to bson_iter_key() but performs no integrity checking.
// *
// * Returns: A string that should not be modified or freed.
// *
// static BSON_INLINE const char *
// bson_iter_key_unsafe(const bson_iter_t * iter)

function bson_iter_utf8(
           iter: Pbson_iter_t;
           length: Puint32_t): PAnsiChar; cdecl; external 'bson2.dll';

// * *
// * bson_iter_utf8_unsafe:
// *
// * Similar to bson_iter_utf8() but performs no integrity checking.
// *
// * Returns: A string that should not be modified or freed.
// *
// static BSON_INLINE const char *
// bson_iter_utf8_unsafe(const bson_iter_t * iter, size_t * length)

function bson_iter_dup_utf8(
           iter: Pbson_iter_t;
           length: Puint32_t): PAnsiChar; cdecl; external 'bson2.dll';

function bson_iter_date_time(
           iter: Pbson_iter_t): int64_t; cdecl; external 'bson2.dll';

function bson_iter_time_t(
           iter: Pbson_iter_t): time_t; cdecl; external 'bson2.dll';

// * *
// * bson_iter_time_t_unsafe:
// * @iter: A bson_iter_t.
// *
// * Similar to bson_iter_time_t() but performs no integrity checking.
// *
// * Returns: A time_t containing the number of seconds since UNIX epoch
// * in UTC.
// *
// static BSON_INLINE time_t
// bson_iter_time_t_unsafe(const bson_iter_t * iter)

procedure bson_iter_timeval(
            iter: Pbson_iter_t;
            tv: Ptimeval); cdecl; external 'bson2.dll';

// * *
// * bson_iter_timeval_unsafe:
// * @iter: A bson_iter_t.
// * @tv: A struct timeval.
// *
// * Similar to bson_iter_timeval() but performs no integrity checking.
// *
// static BSON_INLINE void
// bson_iter_timeval_unsafe(const bson_iter_t * iter, struct timeval * tv)

procedure bson_iter_timestamp(
            iter: Pbson_iter_t;
            timestamp: Puint32_t;
            increment: Puint32_t); cdecl; external 'bson2.dll';

function bson_iter_bool(
           iter: Pbson_iter_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_iter_bool_unsafe:
// * @iter: A bson_iter_t.
// *
// * Similar to bson_iter_bool() but performs no integrity checking.
// *
// * Returns: true or false.
// *
// static BSON_INLINE bool
// bson_iter_bool_unsafe(const bson_iter_t * iter)

function bson_iter_as_bool(
           iter: Pbson_iter_t): bool; cdecl; external 'bson2.dll';

function bson_iter_regex(
           iter: Pbson_iter_t;
           options: PPAnsiChar): PAnsiChar; cdecl; external 'bson2.dll';

function bson_iter_symbol(
           iter: Pbson_iter_t;
           length: Puint32_t): PAnsiChar; cdecl; external 'bson2.dll';

function bson_iter_type(
           iter: Pbson_iter_t): bson_type_t; cdecl; external 'bson2.dll';

// * *
// * bson_iter_type_unsafe:
// * @iter: A bson_iter_t.
// *
// * Similar to bson_iter_type() but performs no integrity checking.
// *
// * Returns: A bson_type_t.
// *
// static BSON_INLINE bson_type_t
// bson_iter_type_unsafe(const bson_iter_t * iter)

function bson_iter_recurse(
           iter: Pbson_iter_t;
           child: Pbson_iter_t): bool; cdecl; external 'bson2.dll';

procedure bson_iter_overwrite_int32(
            iter: Pbson_iter_t;
            value: int32_t); cdecl; external 'bson2.dll';

procedure bson_iter_overwrite_int64(
            iter: Pbson_iter_t;
            value: int64_t); cdecl; external 'bson2.dll';

procedure bson_iter_overwrite_double(
            iter: Pbson_iter_t;
            value: double); cdecl; external 'bson2.dll';

procedure bson_iter_overwrite_decimal128(
            iter: Pbson_iter_t;
            value: Pbson_decimal128_t); cdecl; external 'bson2.dll';

procedure bson_iter_overwrite_bool(
            iter: Pbson_iter_t;
            value: bool); cdecl; external 'bson2.dll';

procedure bson_iter_overwrite_oid(
            iter: Pbson_iter_t;
            value: Pbson_oid_t); cdecl; external 'bson2.dll';

procedure bson_iter_overwrite_timestamp(
            iter: Pbson_iter_t;
            timestamp: uint32_t;
            increment: uint32_t); cdecl; external 'bson2.dll';

procedure bson_iter_overwrite_date_time(
            iter: Pbson_iter_t;
            value: int64_t); cdecl; external 'bson2.dll';

function bson_iter_visit_all(
           iter: Pbson_iter_t;
           visitor: Pbson_visitor_t;
           data: Pvoid): bool; cdecl; external 'bson2.dll';

function bson_iter_offset(
           iter: Pbson_iter_t): uint32_t; cdecl; external 'bson2.dll';

/////////////////
// bson-vector //
/////////////////

// Length of the required header for BSON_SUBTYPE_VECTOR, in bytes
const BSON_VECTOR_HEADER_LEN = 2;

// Forward declaration (typedef bson_array_builder_t in bson.h)
// struct _bson_array_builder_t;

// * * @brief Error codes for domain BSON_ERROR_VECTOR
type
  bson_vector_error_code_t = (
    BSON_VECTOR_ERROR_ARRAY_ELEMENT_TYPE = 1,
    BSON_VECTOR_ERROR_ARRAY_ELEMENT_VALUE,
    BSON_VECTOR_ERROR_ARRAY_KEY,
    BSON_VECTOR_ERROR_MAX_SIZE);

// * * @brief Implementation detail. A copy of the BSON_SUBTYPE_VECTOR header, suitable for pass-by-value.
type
  bson_vector_binary_header_impl_t = record
    bytes: array[0..BSON_VECTOR_HEADER_LEN-1] of uint8_t;
  end;

// * * @brief Implementation detail. A reference to non-owned const BSON Binary data of subtype BSON_SUBTYPE_VECTOR
type
  bson_vector_binary_const_view_impl_t = record
    data: Puint8_t;
    data_len: uint32_t;
    header_copy: bson_vector_binary_header_impl_t;
  end;

// * * @brief Implementation detail. A reference to non-owned BSON Binary data of subtype BSON_SUBTYPE_VECTOR
type
  bson_vector_binary_view_impl_t = record
    data: Puint8_t;
    data_len: uint32_t;
    header_copy: bson_vector_binary_header_impl_t;
  end;

// * * @brief Implementation detail. Obtain a const reference from a non-const reference without re-validating.
// static BSON_INLINE bson_vector_binary_const_view_impl_t
// bson_vector_binary_view_impl_as_const(bson_vector_binary_view_impl_t view)

// * * @brief A reference to non-owned BSON Binary data holding a valid Vector of int8 element type
type
  bson_vector_int8_view_t = record
    binary: bson_vector_binary_view_impl_t;
  end;
  Pbson_vector_int8_view_t = ^bson_vector_int8_view_t;

// * * @brief A reference to non-owned const BSON Binary data holding a valid Vector of int8 element type
type
  bson_vector_int8_const_view_t = record
    binary: bson_vector_binary_const_view_impl_t;
  end;
  Pbson_vector_int8_const_view_t = ^bson_vector_int8_const_view_t;

// * * @brief A reference to non-owned BSON Binary data holding a valid Vector of float32 element type
type
  bson_vector_float32_view_t = record
    binary: bson_vector_binary_view_impl_t;
  end;
  Pbson_vector_float32_view_t = ^bson_vector_float32_view_t;

// * * @brief A reference to non-owned const BSON Binary data holding a valid Vector of float32 element type
type
  bson_vector_float32_const_view_t = record
    binary: bson_vector_binary_const_view_impl_t;
  end;
  Pbson_vector_float32_const_view_t = ^bson_vector_float32_const_view_t;

// * * @brief A reference to non-owned BSON Binary data holding a valid Vector of packed_bit
type
  bson_vector_packed_bit_view_t = record
    binary: bson_vector_binary_view_impl_t;
  end;
  Pbson_vector_packed_bit_view_t = ^bson_vector_packed_bit_view_t;

// * * @brief A reference to non-owned const BSON Binary data holding a valid Vector of packed_bit
type
  bson_vector_packed_bit_const_view_t = record
    binary: bson_vector_binary_const_view_impl_t;
  end;
  Pbson_vector_packed_bit_const_view_t = ^bson_vector_packed_bit_const_view_t;

// static BSON_INLINE bson_vector_int8_const_view_t
// bson_vector_int8_view_as_const(bson_vector_int8_view_t view)

// static BSON_INLINE bson_vector_float32_const_view_t
// bson_vector_float32_view_as_const(bson_vector_float32_view_t view)

// static BSON_INLINE bson_vector_packed_bit_const_view_t
// bson_vector_packed_bit_view_as_const(bson_vector_packed_bit_view_t view)

function bson_vector_int8_view_init(
           view_out: Pbson_vector_int8_view_t;
           binary_data: Puint8_t;
           binary_data_len: uint32_t): bool; cdecl; external 'bson2.dll';

function bson_vector_int8_const_view_init(
           view_out: Pbson_vector_int8_const_view_t;
           binary_data: Puint8_t;
           binary_data_len: uint32_t): bool; cdecl; external 'bson2.dll';

function bson_vector_float32_view_init(
           view_out: Pbson_vector_float32_view_t;
           binary_data: Puint8_t;
           binary_data_len: uint32_t): bool; cdecl; external 'bson2.dll';

function bson_vector_float32_const_view_init(
           view_out: Pbson_vector_float32_const_view_t;
           binary_data: Puint8_t;
           binary_data_len: uint32_t): bool; cdecl; external 'bson2.dll';

function bson_vector_packed_bit_view_init(
           view_out: Pbson_vector_packed_bit_view_t;
           binary_data: Puint8_t;
           binary_data_len: uint32_t): bool; cdecl; external 'bson2.dll';

function bson_vector_packed_bit_const_view_init(
           view_out: Pbson_vector_packed_bit_const_view_t;
           binary_data: Puint8_t;
           binary_data_len: uint32_t): bool; cdecl; external 'bson2.dll';

function bson_vector_int8_view_from_iter(
           view_out: Pbson_vector_int8_view_t;
           iter: Pbson_iter_t): bool; cdecl; external 'bson2.dll';

function bson_vector_int8_const_view_from_iter(
           view_out: Pbson_vector_int8_const_view_t;
           iter: Pbson_iter_t): bool; cdecl; external 'bson2.dll';

function bson_vector_float32_view_from_iter(
           view_out: Pbson_vector_float32_view_t;
           iter: Pbson_iter_t): bool; cdecl; external 'bson2.dll';

function bson_vector_float32_const_view_from_iter(
           view_out: Pbson_vector_float32_const_view_t;
           iter: Pbson_iter_t): bool; cdecl; external 'bson2.dll';

function bson_vector_packed_bit_view_from_iter(
           view_out: Pbson_vector_packed_bit_view_t;
           iter: Pbson_iter_t): bool; cdecl; external 'bson2.dll';

function bson_vector_packed_bit_const_view_from_iter(
           view_out: Pbson_vector_packed_bit_const_view_t;
           iter: Pbson_iter_t): bool; cdecl; external 'bson2.dll';

function bson_array_builder_append_vector_int8_elements(
           builder: P_bson_array_builder_t;
           view: bson_vector_int8_const_view_t): bool; cdecl; external 'bson2.dll';

function bson_array_builder_append_vector_float32_elements(
           builder: P_bson_array_builder_t;
           view: bson_vector_float32_const_view_t): bool; cdecl; external 'bson2.dll';

function bson_array_builder_append_vector_packed_bit_elements(
           builder: P_bson_array_builder_t;
           view: bson_vector_packed_bit_const_view_t): bool; cdecl; external 'bson2.dll';

function bson_array_builder_append_vector_elements(
           builder: P_bson_array_builder_t;
           iter: Pbson_iter_t): bool; cdecl; external 'bson2.dll';

function bson_append_vector_int8_uninit(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           element_count: size_t;
           view_out: Pbson_vector_int8_view_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_VECTOR_INT8_UNINIT(b, key, count, view) bson_append_vector_int8_uninit(b, key, (int)strlen(key), count, view)

function bson_append_vector_float32_uninit(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           element_count: size_t;
           view_out: Pbson_vector_float32_view_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_VECTOR_FLOAT32_UNINIT(b, key, count, view) bson_append_vector_float32_uninit(b, key, (int)strlen(key), count, view)

function bson_append_vector_packed_bit_uninit(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           element_count: size_t;
           view_out: Pbson_vector_packed_bit_view_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_VECTOR_PACKED_BIT_UNINIT(b, key, count, view) bson_append_vector_packed_bit_uninit(b, key, (int)strlen(key), count, view)

function bson_append_vector_int8_from_array(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           iter: Pbson_iter_t;
           error: Pbson_error_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_VECTOR_INT8_FROM_ARRAY(b, key, iter, err) bson_append_vector_int8_from_array(b, key, (int)strlen(key), iter, err)

function bson_append_vector_float32_from_array(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           iter: Pbson_iter_t;
           error: Pbson_error_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_VECTOR_FLOAT32_FROM_ARRAY(b, key, iter, err) bson_append_vector_float32_from_array(b, key, (int)strlen(key), iter, err)

function bson_append_vector_packed_bit_from_array(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           iter: Pbson_iter_t;
           error: Pbson_error_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_VECTOR_PACKED_BIT_FROM_ARRAY(b, key, iter, err) bson_append_vector_packed_bit_from_array(b, key, (int)strlen(key), iter, err)

function bson_append_array_from_vector_int8(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           view: bson_vector_int8_const_view_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_ARRAY_FROM_VECTOR_INT8(b, key, view) bson_append_array_from_vector_int8(b, key, (int)strlen(key), view)

function bson_append_array_from_vector_float32(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           view: bson_vector_float32_const_view_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_ARRAY_FROM_VECTOR_FLOAT32(b, key, view) bson_append_array_from_vector_float32(b, key, (int)strlen(key), view)

function bson_append_array_from_vector_packed_bit(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           view: bson_vector_packed_bit_const_view_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_ARRAY_FROM_VECTOR_PACKED_BIT(b, key, view) bson_append_array_from_vector_packed_bit(b, key, (int)strlen(key), view)

// static BSON_INLINE const int8_t *
// bson_vector_int8_const_view_pointer(bson_vector_int8_const_view_t view)

// static BSON_INLINE int8_t *
// bson_vector_int8_view_pointer(bson_vector_int8_view_t view)

// static BSON_INLINE uint32_t
// bson_vector_int8_binary_data_length(size_t element_count)

// static BSON_INLINE uint32_t
// bson_vector_float32_binary_data_length(size_t element_count)

// static BSON_INLINE uint32_t
// bson_vector_packed_bit_binary_data_length(size_t element_count)

// static BSON_INLINE size_t
// bson_vector_int8_const_view_length(bson_vector_int8_const_view_t view)

// static BSON_INLINE size_t
// bson_vector_int8_view_length(bson_vector_int8_view_t view)

// static BSON_INLINE size_t
// bson_vector_float32_const_view_length(bson_vector_float32_const_view_t view)

// static BSON_INLINE size_t
// bson_vector_float32_view_length(bson_vector_float32_view_t view)

// static BSON_INLINE size_t
// bson_vector_packed_bit_const_view_length_bytes(bson_vector_packed_bit_const_view_t view)

// static BSON_INLINE size_t
// bson_vector_packed_bit_view_length_bytes(bson_vector_packed_bit_view_t view)

// Implementation detail, not part of documented API.
// static BSON_INLINE size_t
// bson_vector_padding_from_header_byte_1(uint8_t byte_1)

// static BSON_INLINE size_t
// bson_vector_packed_bit_const_view_padding(bson_vector_packed_bit_const_view_t view)

// static BSON_INLINE size_t
// bson_vector_packed_bit_view_padding(bson_vector_packed_bit_view_t view)

// static BSON_INLINE size_t
// bson_vector_packed_bit_const_view_length(bson_vector_packed_bit_const_view_t view)

// static BSON_INLINE size_t
// bson_vector_packed_bit_view_length(bson_vector_packed_bit_view_t view)

// static BSON_INLINE bool
// bson_vector_int8_const_view_read(bson_vector_int8_const_view_t view,
// int8_t * BSON_RESTRICT values_out,
// size_t element_count,
// size_t vector_offset_elements)

// static BSON_INLINE bool
// bson_vector_int8_view_read(bson_vector_int8_view_t view,
// int8_t * BSON_RESTRICT values_out,
// size_t element_count,
// uint32_t vector_offset_elements)

// static BSON_INLINE bool
// bson_vector_int8_view_write(bson_vector_int8_view_t view,
// const int8_t * BSON_RESTRICT values,
// size_t element_count,
// size_t vector_offset_elements)

// BSON_STATIC_ASSERT2(float_is_float32, sizeof(float) == 4);

// static BSON_INLINE bool
// bson_vector_float32_const_view_read(bson_vector_float32_const_view_t view,
// float * BSON_RESTRICT values_out,
// size_t element_count,
// size_t vector_offset_elements)

// static BSON_INLINE bool
// bson_vector_float32_view_read(bson_vector_float32_view_t view,
// float * BSON_RESTRICT values_out,
// size_t element_count,
// size_t vector_offset_elements)

// static BSON_INLINE bool
// bson_vector_float32_view_write(bson_vector_float32_view_t view,
// const float * BSON_RESTRICT values,
// size_t element_count,
// size_t vector_offset_elements)

// static BSON_INLINE bool
// bson_vector_packed_bit_const_view_read_packed(bson_vector_packed_bit_const_view_t view,
// uint8_t * BSON_RESTRICT packed_values_out,
// size_t byte_count,
// size_t vector_offset_bytes)

// static BSON_INLINE bool
// bson_vector_packed_bit_view_read_packed(bson_vector_packed_bit_view_t view,
// uint8_t * BSON_RESTRICT packed_values_out,
// size_t byte_count,
// size_t vector_offset_bytes)

// static BSON_INLINE bool
// bson_vector_packed_bit_view_write_packed(bson_vector_packed_bit_view_t view,
// const uint8_t * BSON_RESTRICT packed_values,
// size_t byte_count,
// size_t vector_offset_bytes)

// static BSON_INLINE bool
// bson_vector_packed_bit_const_view_unpack_bool(bson_vector_packed_bit_const_view_t view,
// bool * BSON_RESTRICT unpacked_values_out,
// size_t element_count,
// size_t vector_offset_elements)

// static BSON_INLINE bool
// bson_vector_packed_bit_view_unpack_bool(bson_vector_packed_bit_view_t view,
// bool * BSON_RESTRICT unpacked_values_out,
// size_t element_count,
// size_t vector_offset_elements)

// static BSON_INLINE bool
// bson_vector_packed_bit_view_pack_bool(bson_vector_packed_bit_view_t view,
// const bool * BSON_RESTRICT unpacked_values,
// size_t element_count,
// size_t vector_offset_elements)

//////////
// bson //
//////////

// #define BSON_INSIDE

// * *
// * bson_empty:
// * @b: a bson_t.
// *
// * Checks to see if @b is an empty BSON document. An empty BSON document is
// * a 5 byte document which contains the length (4 bytes) and a single NUL
// * byte indicating end of fields.
// *
// #define bson_empty(b) (((b)->len == 5) || !bson_get_data((b))[4])

// * *
// * bson_empty0:
// *
// * Like bson_empty() but treats NULL the same as an empty bson_t document.
// *
// #define bson_empty0(b) (!(b) || bson_empty(b))

// * *
// * bson_clear:
// *
// * Easily free a bson document and set it to NULL. Use like:
// *
// * bson_t * doc = bson_new();
// * bson_clear (&doc);
// * BSON_ASSERT (doc == NULL);
// *
// #define bson_clear(bptr) do { if ( * (bptr)) { bson_destroy( * (bptr)); * (bptr) = NULL; } } while (0)

// * *
// * BSON_MAX_SIZE:
// *
// * The maximum size in bytes of a BSON document.
// *
const BSON_MAX_SIZE: size_t = size_t(((NativeUInt(1) shl 31) - 1));

// #define BSON_APPEND_ARRAY(b, key, val) bson_append_array(b, key, (int)strlen(key), val)

// #define BSON_APPEND_ARRAY_BEGIN(b, key, child) bson_append_array_begin(b, key, (int)strlen(key), child)

// #define BSON_APPEND_BINARY(b, key, subtype, val, len) bson_append_binary(b, key, (int)strlen(key), subtype, val, len)

// #define BSON_APPEND_BOOL(b, key, val) bson_append_bool(b, key, (int)strlen(key), val)

// #define BSON_APPEND_CODE(b, key, val) bson_append_code(b, key, (int)strlen(key), val)

// #define BSON_APPEND_CODE_WITH_SCOPE(b, key, val, scope) bson_append_code_with_scope(b, key, (int)strlen(key), val, scope)

// #define BSON_APPEND_DBPOINTER(b, key, coll, oid) bson_append_dbpointer(b, key, (int)strlen(key), coll, oid)

// #define BSON_APPEND_DOCUMENT_BEGIN(b, key, child) bson_append_document_begin(b, key, (int)strlen(key), child)

// #define BSON_APPEND_DOUBLE(b, key, val) bson_append_double(b, key, (int)strlen(key), val)

// #define BSON_APPEND_DOCUMENT(b, key, val) bson_append_document(b, key, (int)strlen(key), val)

// #define BSON_APPEND_INT32(b, key, val) bson_append_int32(b, key, (int)strlen(key), val)

// #define BSON_APPEND_INT64(b, key, val) bson_append_int64(b, key, (int)strlen(key), val)

// #define BSON_APPEND_MINKEY(b, key) bson_append_minkey(b, key, (int)strlen(key))

// #define BSON_APPEND_DECIMAL128(b, key, val) bson_append_decimal128(b, key, (int)strlen(key), val)

// #define BSON_APPEND_MAXKEY(b, key) bson_append_maxkey(b, key, (int)strlen(key))

// #define BSON_APPEND_NULL(b, key) bson_append_null(b, key, (int)strlen(key))

// #define BSON_APPEND_OID(b, key, val) bson_append_oid(b, key, (int)strlen(key), val)

// #define BSON_APPEND_REGEX(b, key, val, opt) bson_append_regex(b, key, (int)strlen(key), val, opt)

// #define BSON_APPEND_UTF8(b, key, val) bson_append_utf8(b, key, (int)strlen(key), val, (int)strlen(val))

// #define BSON_APPEND_SYMBOL(b, key, val) bson_append_symbol(b, key, (int)strlen(key), val, (int)strlen(val))

// #define BSON_APPEND_TIME_T(b, key, val) bson_append_time_t(b, key, (int)strlen(key), val)

// #define BSON_APPEND_TIMEVAL(b, key, val) bson_append_timeval(b, key, (int)strlen(key), val)

// #define BSON_APPEND_DATE_TIME(b, key, val) bson_append_date_time(b, key, (int)strlen(key), val)

// #define BSON_APPEND_TIMESTAMP(b, key, val, inc) bson_append_timestamp(b, key, (int)strlen(key), val, inc)

// #define BSON_APPEND_UNDEFINED(b, key) bson_append_undefined(b, key, (int)strlen(key))

// #define BSON_APPEND_VALUE(b, key, val) bson_append_value(b, key, (int)strlen(key), (val))

// * *
// * bson_new:
// *
// * Allocates a new bson_t structure. Call the various bson_append_ * ()
// * functions to add fields to the bson. You can iterate the bson_t at any
// * time using a bson_iter_t and bson_iter_init().
// *
// * Returns: A newly allocated bson_t that should be freed with bson_destroy().
// *
function bson_new(): Pbson_t; cdecl; external 'bson2.dll';

function bson_new_from_json(
           data: Puint8_t;
           len: ssize_t;
           error: Pbson_error_t): Pbson_t; cdecl; external 'bson2.dll';

function bson_init_from_json(
           bson: Pbson_t;
           data: PAnsiChar;
           len: ssize_t;
           error: Pbson_error_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_init_static:
// * @b: A pointer to a bson_t.
// * @data: The data buffer to use.
// * @length: The length of @data.
// *
// * Initializes a bson_t using @data and @length. This is ideal if you would
// * like to use a stack allocation for your bson and do not need to grow the
// * buffer. @data must be valid for the life of @b.
// *
// * Returns: true if initialized successfully; otherwise false.
// *
function bson_init_static(
           b: Pbson_t;
           data: Puint8_t;
           length: size_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_init:
// * @b: A pointer to a bson_t.
// *
// * Initializes a bson_t for use. This function is useful to those that want a
// * stack allocated bson_t. The usefulness of a stack allocated bson_t is
// * marginal as the target buffer for content will still require heap
// * allocations. It can help reduce heap fragmentation on allocators that do
// * not employ SLAB/magazine semantics.
// *
// * You must call bson_destroy() with @b to release resources when you are done
// * using @b.
// *
procedure bson_init(
            b: Pbson_t); cdecl; external 'bson2.dll';

// * *
// * bson_reinit:
// * @b: (inout): A bson_t.
// *
// * This is equivalent to calling bson_destroy() and bson_init() on a #bson_t.
// * However, it will try to persist the existing malloc'd buffer if one exists.
// * This is useful in cases where you want to reduce malloc overhead while
// * building many documents.
// *
procedure bson_reinit(
            b: Pbson_t); cdecl; external 'bson2.dll';

// * *
// * bson_new_from_data:
// * @data: A buffer containing a serialized bson document.
// * @length: The length of the document in bytes.
// *
// * Creates a new bson_t structure using the data provided. @data should contain
// * at least @length bytes that can be copied into the new bson_t structure.
// *
// * Returns: A newly allocated bson_t that should be freed with bson_destroy().
// * If the first four bytes (little-endian) of data do not match @length,
// * then NULL will be returned.
// *
function bson_new_from_data(
           data: Puint8_t;
           length: size_t): Pbson_t; cdecl; external 'bson2.dll';

// * *
// * bson_new_from_buffer:
// * @buf: A pointer to a buffer containing a serialized bson document.
// * @buf_len: The length of the buffer in bytes.
// * @realloc_fun: a realloc like function
// * @realloc_fun_ctx: a context for the realloc function
// *
// * Creates a new bson_t structure using the data provided. @buf should contain
// * a bson document, or null pointer should be passed for new allocations.
// *
// * Returns: A newly allocated bson_t that should be freed with bson_destroy().
// * The underlying buffer will be used and not be freed in destroy.
// *
function bson_new_from_buffer(
           buf: PPuint8_t;
           buf_len: Psize_t;
           realloc_func: bson_realloc_func;
           realloc_func_ctx: Pvoid): Pbson_t; cdecl; external 'bson2.dll';

// * *
// * bson_sized_new:
// * @size: A size_t containing the number of bytes to allocate.
// *
// * This will allocate a new bson_t with enough bytes to hold a buffer
// * sized @size. @size must be smaller than INT_MAX bytes.
// *
// * Returns: A newly allocated bson_t that should be freed with bson_destroy().
// *
function bson_sized_new(
           size: size_t): Pbson_t; cdecl; external 'bson2.dll';

// * *
// * bson_copy:
// * @bson: A bson_t.
// *
// * Copies @bson into a newly allocated bson_t. You must call bson_destroy()
// * when you are done with the resulting value to free its resources.
// *
// * Returns: A newly allocated bson_t that should be free'd with bson_destroy()
// *
function bson_copy(
           bson: Pbson_t): Pbson_t; cdecl; external 'bson2.dll';

// * *
// * bson_copy_to:
// * @src: The source bson_t.
// * @dst: The destination bson_t.
// *
// * Initializes @dst and copies the content from @src into @dst.
// *
procedure bson_copy_to(
            src: Pbson_t;
            dst: Pbson_t); cdecl; external 'bson2.dll';

// * *
// * bson_copy_to_excluding_noinit:
// * @src: A bson_t.
// * @dst: A bson_t to initialize and copy into.
// * @first_exclude: First field name to exclude.
// *
// * Does not call bson_init() on the dst.
// *
procedure bson_copy_to_excluding_noinit(
            src: Pbson_t;
            dst: Pbson_t;
            first_exclude: PAnsiChar); cdecl; varargs; external 'bson2.dll';

procedure bson_copy_to_excluding_noinit_va(
            src: Pbson_t;
            dst: Pbson_t;
            first_exclude: PAnsiChar;
            args: va_list); cdecl; external 'bson2.dll';

// * *
// * bson_destroy:
// * @bson: A bson_t.
// *
// * Frees the resources associated with @bson.
// *
procedure bson_destroy(
            bson: Pbson_t); cdecl; external 'bson2.dll';

function bson_reserve_buffer(
           bson: Pbson_t;
           total_size: uint32_t): Puint8_t; cdecl; external 'bson2.dll';

function bson_steal(
           dst: Pbson_t;
           src: Pbson_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_destroy_with_steal:
// * @bson: A #bson_t.
// * @steal: If ownership of the data buffer should be transferred to caller.
// * @length: (out): location for the length of the buffer.
// *
// * Destroys @bson similar to calling bson_destroy() except that the underlying
// * buffer will be returned and ownership transferred to the caller if @steal
// * is non-zero.
// *
// * If length is non-NULL, the length of @bson will be stored in @length.
// *
// * It is a programming error to call this function with any bson that has
// * been initialized static, or is being used to create a subdocument with
// * functions such as bson_append_document_begin() or bson_append_array_begin().
// *
// * Returns: a buffer owned by the caller if @steal is true. Otherwise NULL.
// * If there was an error, NULL is returned.
// *
function bson_destroy_with_steal(
           bson: Pbson_t;
           steal: bool;
           length: Puint32_t): Puint8_t; cdecl; external 'bson2.dll';

// * *
// * bson_get_data:
// * @bson: A bson_t.
// *
// * Fetched the data buffer for @bson of @bson->len bytes in length.
// *
// * Returns: A buffer that should not be modified or freed.
// *
function bson_get_data(
           bson: Pbson_t): Puint8_t; cdecl; external 'bson2.dll';

// * *
// * bson_count_keys:
// * @bson: A bson_t.
// *
// * Counts the number of elements found in @bson.
// *
function bson_count_keys(
           bson: Pbson_t): uint32_t; cdecl; external 'bson2.dll';

// * *
// * bson_has_field:
// * @bson: A bson_t.
// * @key: The key to lookup.
// *
// * Checks to see if @bson contains a field named @key.
// *
// * This function is case-sensitive.
// *
// * Returns: true if @key exists in @bson; otherwise false.
// *
function bson_has_field(
           bson: Pbson_t;
           key: PAnsiChar): bool; cdecl; external 'bson2.dll';

// * *
// * bson_compare:
// * @bson: A bson_t.
// * @other: A bson_t.
// *
// * Compares @bson to @other in a qsort() style comparison.
// * See qsort() for information on how this function works.
// *
// * Returns: Less than zero, zero, or greater than zero.
// *
function bson_compare(
           bson: Pbson_t;
           other: Pbson_t): Integer; cdecl; external 'bson2.dll';

// *
// * bson_equal:
// * @bson: A bson_t.
// * @other: A bson_t.
// *
// * Checks to see if @bson and @other are equal.
// *
// * Returns: true if equal; otherwise false.
// *
function bson_equal(
           bson: Pbson_t;
           other: Pbson_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_validate:
// * @bson: A bson_t.
// * @offset: A location for the error offset.
// *
// * Validates a BSON document by walking through the document and inspecting
// * the fields for valid content.
// *
// * Returns: true if @bson is valid; otherwise false and @offset is set.
// *
function bson_validate(
           bson: Pbson_t;
           flags: bson_validate_flags_t;
           offset: Psize_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_validate_with_error:
// * @bson: A bson_t.
// * @error: A location for the error info.
// *
// * Validates a BSON document by walking through the document and inspecting
// * the fields for valid content.
// *
// * Returns: true if @bson is valid; otherwise false and @error is filled out.
// *
function bson_validate_with_error(
           bson: Pbson_t;
           flags: bson_validate_flags_t;
           error: Pbson_error_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_validate_with_error_and_offset:
// * @bson: A bson_t.
// * @offset: A location for the error offset.
// * @error: A location for the error info.
// *
// * Validates a BSON document by walking through the document and inspecting
// * the fields for valid content.
// *
// * Returns: true if @bson is valid; otherwise false, @offset is set
// * and @error is filled out.
// *
function bson_validate_with_error_and_offset(
           bson: Pbson_t;
           flags: bson_validate_flags_t;
           offset: Psize_t;
           error: Pbson_error_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_as_json_with_opts:
// * @bson: A bson_t.
// * @length: A location for the string length, or NULL.
// * @opts: A bson_t_json_opts_t defining options for the conversion
// *
// * Creates a new string containing @bson in the selected JSON format,
// * conforming to the MongoDB Extended JSON Spec:
// *
// * github.com/mongodb/specifications/blob/master/source/extended-json.rst
// *
// * The caller is responsible for freeing the resulting string. If @length is
// * non-NULL, then the length of the resulting string will be placed in @length.
// *
// * See https: // www.mongodb.com/docs/manual/reference/mongodb-extended-json/ for
// * more information on extended JSON.
// *
// * Returns: A newly allocated string that should be freed with bson_free().
// *
function bson_as_json_with_opts(
           bson: Pbson_t;
           length: Psize_t;
           opts: Pbson_json_opts_t): PAnsiChar; cdecl; external 'bson2.dll';

// * *
// * bson_as_canonical_extended_json:
// * @bson: A bson_t.
// * @length: A location for the string length, or NULL.
// *
// * Creates a new string containing @bson in canonical extended JSON format,
// * conforming to the MongoDB Extended JSON Spec:
// *
// * github.com/mongodb/specifications/blob/master/source/extended-json.rst
// *
// * The caller is responsible for freeing the resulting string. If @length is
// * non-NULL, then the length of the resulting string will be placed in @length.
// *
// * See https: // www.mongodb.com/docs/manual/reference/mongodb-extended-json/ for
// * more information on extended JSON.
// *
// * Returns: A newly allocated string that should be freed with bson_free().
// *
function bson_as_canonical_extended_json(
           bson: Pbson_t;
           length: Psize_t): PAnsiChar; cdecl; external 'bson2.dll';

// * *
// * bson_as_legacy_extended_json:
// * @bson: A bson_t.
// * @length: A location for the string length, or NULL.
// *
// * Creates a new string containing @bson in libbson's legacy JSON format.
// * Superseded by bson_as_canonical_extended_json and
// * bson_as_relaxed_extended_json. The caller is
// * responsible for freeing the resulting string. If @length is non-NULL, then
// * the length of the resulting string will be placed in @length.
// *
// * Returns: A newly allocated string that should be freed with bson_free().
// *

function bson_as_legacy_extended_json(
           bson: Pbson_t;
           length: Psize_t): PAnsiChar; cdecl; external 'bson2.dll';

// * *
// * bson_as_relaxed_extended_json:
// * @bson: A bson_t.
// * @length: A location for the string length, or NULL.
// *
// * Creates a new string containing @bson in relaxed extended JSON format,
// * conforming to the MongoDB Extended JSON Spec:
// *
// * github.com/mongodb/specifications/blob/master/source/extended-json.rst
// *
// * The caller is responsible for freeing the resulting string. If @length is
// * non-NULL, then the length of the resulting string will be placed in @length.
// *
// * See https: // www.mongodb.com/docs/manual/reference/mongodb-extended-json/ for
// * more information on extended JSON.
// *
// * Returns: A newly allocated string that should be freed with bson_free().
// *
function bson_as_relaxed_extended_json(
           bson: Pbson_t;
           length: Psize_t): PAnsiChar; cdecl; external 'bson2.dll';

// * like bson_as_legacy_extended_json() but for outermost arrays.
function bson_array_as_legacy_extended_json(
           bson: Pbson_t;
           length: Psize_t): PAnsiChar; cdecl; external 'bson2.dll';

// * like bson_as_relaxed_extended_json() but for outermost arrays.
function bson_array_as_relaxed_extended_json(
           bson: Pbson_t;
           length: Psize_t): PAnsiChar; cdecl; external 'bson2.dll';

// * like bson_as_canonical_extended_json() but for outermost arrays.
function bson_array_as_canonical_extended_json(
           bson: Pbson_t;
           length: Psize_t): PAnsiChar; cdecl; external 'bson2.dll';

// bson_array_builder_t defines an API for building arrays.
// BSON arrays require sequential numeric keys "0", "1", "2", ...
type
  _bson_array_builder_t = record
  end;
  bson_array_builder_t = _bson_array_builder_t;
  Pbson_array_builder_t = ^bson_array_builder_t;
  PPbson_array_builder_t = ^Pbson_array_builder_t;

// bson_array_builder_new may be used to build a top-level BSON array. Example:
// `[1,2,3]`.
// To append an array field to a document (Example: `{ "field":[1,2,3] }`), use
// `bson_append_array_builder_begin`.
function bson_array_builder_new(): Pbson_array_builder_t; cdecl; external 'bson2.dll';

// bson_array_builder_build initializes and moves BSON data to `out`.
// `bab` may be reused and will start appending a new array at index "0".
function bson_array_builder_build(
           bab: Pbson_array_builder_t;
           param1: Pbson_t): bool; cdecl; external 'bson2.dll';

procedure bson_array_builder_destroy(
            bab: Pbson_array_builder_t); cdecl; external 'bson2.dll';

function bson_append_value(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           value: Pbson_value_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_VALUE(b, key, val) bson_append_value(b, key, (int)strlen(key), (val))

function bson_array_builder_append_value(
           bab: Pbson_array_builder_t;
           value: Pbson_value_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_array:
// * @bson: A bson_t.
// * @key: The key for the field.
// * @array: A bson_t containing the array.
// *
// * Appends a BSON array to @bson. BSON arrays are like documents where the
// * key is the string version of the index. For example, the first item of the
// * array would have the key "0". The second item would have the index "1".
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_array(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           &array: Pbson_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_ARRAY(b, key, val) bson_append_array(b, key, (int)strlen(key), val)

function bson_array_builder_append_array(
           bab: Pbson_array_builder_t;
           &array: Pbson_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_array_from_vector:
// * @bson: A bson_t that will be modified.
// * @key: The key for the field.
// * @iter: A bson_iter_t pointing to any supported vector in another bson_t.
// *
// * If @iter points to a supported vector type, converts the vector to a BSON array appended to @bson.
// *
// * Returns: true if successful; false if append would overflow max size or @iter does not point to a vector in a
// * supported format.
// *
function bson_append_array_from_vector(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           iter: Pbson_iter_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_ARRAY_FROM_VECTOR(b, key, iter) bson_append_array_from_vector(b, key, (int)strlen(key), iter)

function bson_array_builder_append_array_from_vector(
           bab: Pbson_array_builder_t;
           iter: Pbson_iter_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_binary:
// * @bson: A bson_t.
// * @key: The key for the field.
// * @key_length: Optional length of 'key' in bytes, or -1 to use strlen(key).
// * @subtype: The bson_subtype_t of the binary item.
// * @binary: The binary buffer to append.
// * @length: The length of @binary.
// *
// * Appends a binary buffer to the BSON document.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_binary(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           subtype: bson_subtype_t;
           binary: Puint8_t;
           length: uint32_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_BINARY(b, key, subtype, val, len) bson_append_binary(b, key, (int)strlen(key), subtype, val, len)

function bson_array_builder_append_binary(
           bab: Pbson_array_builder_t;
           subtype: bson_subtype_t;
           binary: Puint8_t;
           length: uint32_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_binary_uninit:
// * @bson: A bson_t.
// * @key: The key for the field.
// * @key_length: Optional length of 'key' in bytes, or -1 to use strlen(key).
// * @binary: Output parameter, pointer for the binary data within bson_t to be written.
// * @length: Length of the binary field to allocate, in bytes.
// *
// * Returns: true if successful; false if append would overflow max size.
// *

function bson_append_binary_uninit(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           subtype: bson_subtype_t;
           binary: PPuint8_t;
           length: uint32_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_BINARY_UNINIT(b, key, subtype, val, len) bson_append_binary_uninit(b, key, (int)strlen(key), subtype, val, len)

function bson_array_builder_append_binary_uninit(
           bab: Pbson_array_builder_t;
           subtype: bson_subtype_t;
           binary: PPuint8_t;
           length: uint32_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_bool:
// * @bson: A bson_t.
// * @key: The key for the field.
// * @value: The boolean value.
// *
// * Appends a new field to @bson of type BSON_TYPE_BOOL.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_bool(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           value: bool): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_BOOL(b, key, val) bson_append_bool(b, key, (int)strlen(key), val)

function bson_array_builder_append_bool(
           bab: Pbson_array_builder_t;
           value: bool): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_code:
// * @bson: A bson_t.
// * @key: The key for the document.
// * @javascript: JavaScript code to be executed.
// *
// * Appends a field of type BSON_TYPE_CODE to the BSON document. @javascript
// * should contain a script in javascript to be executed.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_code(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           javascript: PAnsiChar): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_CODE(b, key, val) bson_append_code(b, key, (int)strlen(key), val)

function bson_array_builder_append_code(
           bab: Pbson_array_builder_t;
           javascript: PAnsiChar): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_code_with_scope:
// * @bson: A bson_t.
// * @key: The key for the document.
// * @javascript: JavaScript code to be executed.
// * @scope: A bson_t containing the scope for @javascript.
// *
// * Appends a field of type BSON_TYPE_CODEWSCOPE to the BSON document.
// * @javascript should contain a script in javascript to be executed.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_code_with_scope(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           javascript: PAnsiChar;
           scope: Pbson_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_CODE_WITH_SCOPE(b, key, val, scope) bson_append_code_with_scope(b, key, (int)strlen(key), val, scope)

function bson_array_builder_append_code_with_scope(
           bab: Pbson_array_builder_t;
           javascript: PAnsiChar;
           scope: Pbson_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_dbpointer:
// * @bson: A bson_t.
// * @key: The key for the field.
// * @collection: The collection name.
// * @oid: The oid to the reference.
// *
// * Appends a new field of type BSON_TYPE_DBPOINTER. This datum type is
// * deprecated in the BSON spec and should not be used in new code.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_dbpointer(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           collection: PAnsiChar;
           oid: Pbson_oid_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_DBPOINTER(b, key, coll, oid) bson_append_dbpointer(b, key, (int)strlen(key), coll, oid)

function bson_array_builder_append_dbpointer(
           bab: Pbson_array_builder_t;
           collection: PAnsiChar;
           oid: Pbson_oid_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_double:
// * @bson: A bson_t.
// * @key: The key for the field.
// *
// * Appends a new field to @bson of the type BSON_TYPE_DOUBLE.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_double(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           value: double): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_DOUBLE(b, key, val) bson_append_double(b, key, (int)strlen(key), val)

function bson_array_builder_append_double(
           bab: Pbson_array_builder_t;
           value: double): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_document:
// * @bson: A bson_t.
// * @key: The key for the field.
// * @value: A bson_t containing the subdocument.
// *
// * Appends a new field to @bson of the type BSON_TYPE_DOCUMENT.
// * The documents contents will be copied into @bson.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_document(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           value: Pbson_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_DOCUMENT(b, key, val) bson_append_document(b, key, (int)strlen(key), val)

function bson_array_builder_append_document(
           bab: Pbson_array_builder_t;
           value: Pbson_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_document_begin:
// * @bson: A bson_t.
// * @key: The key for the field.
// * @key_length: The length of @key in bytes not including NUL or -1
// * if @key_length is NUL terminated.
// * @child: A location to an uninitialized bson_t.
// *
// * Appends a new field named @key to @bson. The field is, however,
// * incomplete. @child will be initialized so that you may add fields to the
// * child document. Child will use a memory buffer owned by @bson and
// * therefore grow the parent buffer as additional space is used. This allows
// * a single malloc'd buffer to be used when building documents which can help
// * reduce memory fragmentation.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_document_begin(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           child: Pbson_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_DOCUMENT_BEGIN(b, key, child) bson_append_document_begin(b, key, (int)strlen(key), child)

function bson_array_builder_append_document_begin(
           bab: Pbson_array_builder_t;
           child: Pbson_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_document_end:
// * @bson: A bson_t.
// * @child: A bson_t supplied to bson_append_document_begin().
// *
// * Finishes the appending of a document to a @bson. @child is considered
// * disposed after this call and should not be used any further.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_document_end(
           bson: Pbson_t;
           child: Pbson_t): bool; cdecl; external 'bson2.dll';

function bson_array_builder_append_document_end(
           bab: Pbson_array_builder_t;
           child: Pbson_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_array_begin:
// * @bson: A bson_t.
// * @key: The key for the field.
// * @key_length: The length of @key in bytes not including NUL or -1
// * if @key_length is NUL terminated.
// * @child: A location to an uninitialized bson_t.
// *
// * Appends a new field named @key to @bson. The field is, however,
// * incomplete. @child will be initialized so that you may add fields to the
// * child array. Child will use a memory buffer owned by @bson and
// * therefore grow the parent buffer as additional space is used. This allows
// * a single malloc'd buffer to be used when building arrays which can help
// * reduce memory fragmentation.
// *
// * The type of @child will be BSON_TYPE_ARRAY and therefore the keys inside
// * of it MUST be "0", "1", etc.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_array_begin(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           child: Pbson_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_ARRAY_BEGIN(b, key, child) bson_append_array_begin(b, key, (int)strlen(key), child)

// * *
// * bson_append_array_end:
// * @bson: A bson_t.
// * @child: A bson_t supplied to bson_append_array_begin().
// *
// * Finishes the appending of a array to a @bson. @child is considered
// * disposed after this call and should not be used any further.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_array_end(
           bson: Pbson_t;
           child: Pbson_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_int32:
// * @bson: A bson_t.
// * @key: The key for the field.
// * @value: The int32_t 32-bit integer value.
// *
// * Appends a new field of type BSON_TYPE_INT32 to @bson.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_int32(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           value: int32_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_INT32(b, key, val) bson_append_int32(b, key, (int)strlen(key), val)

function bson_array_builder_append_int32(
           bab: Pbson_array_builder_t;
           value: int32_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_int64:
// * @bson: A bson_t.
// * @key: The key for the field.
// * @value: The int64_t 64-bit integer value.
// *
// * Appends a new field of type BSON_TYPE_INT64 to @bson.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_int64(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           value: int64_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_INT64(b, key, val) bson_append_int64(b, key, (int)strlen(key), val)

function bson_array_builder_append_int64(
           bab: Pbson_array_builder_t;
           value: int64_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_decimal128:
// * @bson: A bson_t.
// * @key: The key for the field.
// * @value: The bson_decimal128_t decimal128 value.
// *
// * Appends a new field of type BSON_TYPE_DECIMAL128 to @bson.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_decimal128(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           value: Pbson_decimal128_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_DECIMAL128(b, key, val) bson_append_decimal128(b, key, (int)strlen(key), val)

function bson_array_builder_append_decimal128(
           bab: Pbson_array_builder_t;
           value: Pbson_decimal128_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_iter:
// * @bson: A bson_t to append to.
// * @key: The key name or %NULL to take current key from @iter.
// * @key_length: The key length or -1 to use strlen().
// * @iter: The iter located on the position of the element to append.
// *
// * Appends a new field to @bson that is equivalent to the field currently
// * pointed to by @iter.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_iter(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           iter: Pbson_iter_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_ITER(b, key, val) bson_append_iter(b, key, (int)strlen(key), val)

function bson_array_builder_append_iter(
           bab: Pbson_array_builder_t;
           iter: Pbson_iter_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_minkey:
// * @bson: A bson_t.
// * @key: The key for the field.
// *
// * Appends a new field of type BSON_TYPE_MINKEY to @bson. This is a special
// * type that compares lower than all other possible BSON element values.
// *
// * See http: // bsonspec.org for more information on this type.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_minkey(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_MINKEY(b, key) bson_append_minkey(b, key, (int)strlen(key))

function bson_array_builder_append_minkey(
           bab: Pbson_array_builder_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_maxkey:
// * @bson: A bson_t.
// * @key: The key for the field.
// *
// * Appends a new field of type BSON_TYPE_MAXKEY to @bson. This is a special
// * type that compares higher than all other possible BSON element values.
// *
// * See http: // bsonspec.org for more information on this type.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_maxkey(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_MAXKEY(b, key) bson_append_maxkey(b, key, (int)strlen(key))

function bson_array_builder_append_maxkey(
           bab: Pbson_array_builder_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_null:
// * @bson: A bson_t.
// * @key: The key for the field.
// *
// * Appends a new field to @bson with NULL for the value.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_null(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_NULL(b, key) bson_append_null(b, key, (int)strlen(key))

function bson_array_builder_append_null(
           bab: Pbson_array_builder_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_oid:
// * @bson: A bson_t.
// * @key: The key for the field.
// * @oid: bson_oid_t.
// *
// * Appends a new field to the @bson of type BSON_TYPE_OID using the contents of
// * @oid.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_oid(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           oid: Pbson_oid_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_OID(b, key, val) bson_append_oid(b, key, (int)strlen(key), val)

function bson_array_builder_append_oid(
           bab: Pbson_array_builder_t;
           oid: Pbson_oid_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_regex:
// * @bson: A bson_t.
// * @key: The key of the field.
// * @regex: The regex to append to the bson.
// * @options: Options for @regex.
// *
// * Appends a new field to @bson of type BSON_TYPE_REGEX. @regex should
// * be the regex string. @options should contain the options for the regex.
// *
// * Valid options for @options are:
// *
// * 'i' for case-insensitive.
// * 'm' for multiple matching.
// * 'x' for verbose mode.
// * 'l' to make \w and \W locale dependent.
// * 's' for dotall mode ('.' matches everything)
// * 'u' to make \w and \W match unicode.
// *
// * For more detailed information about BSON regex elements, see bsonspec.org.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_regex(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           regex: PAnsiChar;
           options: PAnsiChar): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_REGEX(b, key, val, opt) bson_append_regex(b, key, (int)strlen(key), val, opt)

function bson_array_builder_append_regex(
           bab: Pbson_array_builder_t;
           regex: PAnsiChar;
           options: PAnsiChar): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_regex:
// * @bson: A bson_t.
// * @key: The key of the field.
// * @key_length: The length of the key string.
// * @regex: The regex to append to the bson.
// * @regex_length: The length of the regex string.
// * @options: Options for @regex.
// *
// * Appends a new field to @bson of type BSON_TYPE_REGEX. @regex should
// * be the regex string. @options should contain the options for the regex.
// *
// * Valid options for @options are:
// *
// * 'i' for case-insensitive.
// * 'm' for multiple matching.
// * 'x' for verbose mode.
// * 'l' to make \w and \W locale dependent.
// * 's' for dotall mode ('.' matches everything)
// * 'u' to make \w and \W match unicode.
// *
// * For more detailed information about BSON regex elements, see bsonspec.org.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_regex_w_len(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           regex: PAnsiChar;
           regex_length: Integer;
           options: PAnsiChar): bool; cdecl; external 'bson2.dll';

function bson_array_builder_append_regex_w_len(
           bab: Pbson_array_builder_t;
           regex: PAnsiChar;
           regex_length: Integer;
           options: PAnsiChar): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_utf8:
// * @bson: A bson_t.
// * @key: The key for the field.
// * @value: A UTF-8 encoded string.
// * @length: The length of @value or -1 if it is NUL terminated.
// *
// * Appends a new field to @bson using @key as the key and @value as the UTF-8
// * encoded value.
// *
// * It is the callers responsibility to ensure @value is valid UTF-8. You can
// * use bson_utf8_validate() to perform this check.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_utf8(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           value: PAnsiChar;
           length: Integer): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_UTF8(b, key, val) bson_append_utf8(b, key, (int)strlen(key), val, (int)strlen(val))

function bson_array_builder_append_utf8(
           bab: Pbson_array_builder_t;
           value: PAnsiChar;
           length: Integer): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_symbol:
// * @bson: A bson_t.
// * @key: The key for the field.
// * @value: The symbol as a string.
// * @length: The length of @value or -1 if NUL-terminated.
// *
// * Appends a new field to @bson of type BSON_TYPE_SYMBOL. This BSON type is
// * deprecated and should not be used in new code.
// *
// * See http: // bsonspec.org for more information on this type.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_symbol(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           value: PAnsiChar;
           length: Integer): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_SYMBOL(b, key, val) bson_append_symbol(b, key, (int)strlen(key), val, (int)strlen(val))

function bson_array_builder_append_symbol(
           bab: Pbson_array_builder_t;
           value: PAnsiChar;
           length: Integer): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_time_t:
// * @bson: A bson_t.
// * @key: The key for the field.
// * @value: A time_t.
// *
// * Appends a BSON_TYPE_DATE_TIME field to @bson using the time_t @value for the
// * number of seconds since UNIX epoch in UTC.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_time_t(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           value: time_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_TIME_T(b, key, val) bson_append_time_t(b, key, (int)strlen(key), val)

function bson_array_builder_append_time_t(
           bab: Pbson_array_builder_t;
           value: time_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_timeval:
// * @bson: A bson_t.
// * @key: The key for the field.
// * @value: A struct timeval containing the date and time.
// *
// * Appends a BSON_TYPE_DATE_TIME field to @bson using the struct timeval
// * provided. The time is persisted in milliseconds since the UNIX epoch in UTC.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_timeval(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           value: Ptimeval): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_TIMEVAL(b, key, val) bson_append_timeval(b, key, (int)strlen(key), val)

function bson_array_builder_append_timeval(
           bab: Pbson_array_builder_t;
           value: Ptimeval): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_date_time:
// * @bson: A bson_t.
// * @key: The key for the field.
// * @key_length: The length of @key in bytes or -1 if \0 terminated.
// * @value: The number of milliseconds elapsed since UNIX epoch.
// *
// * Appends a new field to @bson of type BSON_TYPE_DATE_TIME.
// *
// * Returns: true if successful; otherwise false.
// *
function bson_append_date_time(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           value: int64_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_DATE_TIME(b, key, val) bson_append_date_time(b, key, (int)strlen(key), val)

function bson_array_builder_append_date_time(
           bab: Pbson_array_builder_t;
           value: int64_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_now_utc:
// * @bson: A bson_t.
// * @key: The key for the field.
// * @key_length: The length of @key or -1 if it is NULL terminated.
// *
// * Appends a BSON_TYPE_DATE_TIME field to @bson using the current time in UTC
// * as the field value.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_now_utc(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_NOW_UTC(b, key) bson_append_now_utc(b, key, (int)strlen(key))

function bson_array_builder_append_now_utc(
           bab: Pbson_array_builder_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_timestamp:
// * @bson: A bson_t.
// * @key: The key for the field.
// * @timestamp: 4 byte timestamp.
// * @increment: 4 byte increment for timestamp.
// *
// * Appends a field of type BSON_TYPE_TIMESTAMP to @bson. This is a special type
// * used by MongoDB replication and sharding. If you need generic time and date
// * fields use bson_append_time_t() or bson_append_timeval().
// *
// * Setting @increment and @timestamp to zero has special semantics. See
// * http: // bsonspec.org for more information on this field type.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_timestamp(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           timestamp: uint32_t;
           increment: uint32_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_TIMESTAMP(b, key, val, inc) bson_append_timestamp(b, key, (int)strlen(key), val, inc)

function bson_array_builder_append_timestamp(
           bab: Pbson_array_builder_t;
           timestamp: uint32_t;
           increment: uint32_t): bool; cdecl; external 'bson2.dll';

// * *
// * bson_append_undefined:
// * @bson: A bson_t.
// * @key: The key for the field.
// *
// * Appends a field of type BSON_TYPE_UNDEFINED. This type is deprecated in the
// * spec and should not be used for new code. However, it is provided for those
// * needing to interact with legacy systems.
// *
// * Returns: true if successful; false if append would overflow max size.
// *
function bson_append_undefined(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_UNDEFINED(b, key) bson_append_undefined(b, key, (int)strlen(key))

function bson_array_builder_append_undefined(
           bab: Pbson_array_builder_t): bool; cdecl; external 'bson2.dll';

function bson_concat(
           dst: Pbson_t;
           src: Pbson_t): bool; cdecl; external 'bson2.dll';

function bson_append_array_builder_begin(
           bson: Pbson_t;
           key: PAnsiChar;
           key_length: Integer;
           child: PPbson_array_builder_t): bool; cdecl; external 'bson2.dll';

// #define BSON_APPEND_ARRAY_BUILDER_BEGIN(b, key, child) bson_append_array_builder_begin(b, key, (int)strlen(key), child)

function bson_array_builder_append_array_builder_begin(
           bab: Pbson_array_builder_t;
           child: PPbson_array_builder_t): bool; cdecl; external 'bson2.dll';

function bson_append_array_builder_end(
           bson: Pbson_t;
           child: Pbson_array_builder_t): bool; cdecl; external 'bson2.dll';

function bson_array_builder_append_array_builder_end(
           bab: Pbson_array_builder_t;
           child: Pbson_array_builder_t): bool; cdecl; external 'bson2.dll';

////////////////////
// mongoc-prelude //
////////////////////

///////////////////
// mongoc-macros //
///////////////////

// * Decorate public functions:
// * - if MONGOC_STATIC, we're compiling a static libmongoc or a program
// * that uses libmongoc as a static library. Don't decorate functions
// * - else if MONGOC_COMPILATION, we're compiling a shared libmongoc,
// * mark public functions for export from the shared lib.
// * - else, we're compiling a program that uses libmongoc as a shared library,
// * mark public functions as DLL imports for Microsoft Visual C.
// *

// *
// * Microsoft Visual C
// *
// #define MONGOC_API __declspec(dllimport)
// #define MONGOC_CALL __cdecl

// *
// * Other compilers
// *

///////////////////
// mongoc-config //
///////////////////

// * clang-format off

// *
// * NOTICE:
// * If you're about to update this file and add a config flag, make sure to
// * update:
// * o The bitfield in mongoc-handshake-private.h
// * o _mongoc_handshake_get_config_hex_string() in mongoc-handshake.c
// * o examples/parse_handshake_cfg.py
// * o test_handshake_platform_config in test-mongoc-handshake.c
// *

// * MONGOC_USER_SET_CFLAGS is set from config based on what compiler flags were
// * used to compile mongoc
const MONGOC_USER_SET_CFLAGS = '/DWIN32 /D_WINDOWS';

const MONGOC_USER_SET_LDFLAGS = '/machine:x64';

// * MONGOC_CC is used to determine what C compiler was used to compile mongoc
const MONGOC_CC = 'C:/Program Files/Microsoft Visual Studio/18/Community/VC/Tools/MSVC/14.50.35717/bin/Hostx64/x64/cl.exe';

// *
// * MONGOC_ENABLE_SSL_SECURE_CHANNEL is set from configure to determine if we are
// * compiled with Native SSL support on Windows
// *
const MONGOC_ENABLE_SSL_SECURE_CHANNEL = 1;

// *
// * MONGOC_ENABLE_CRYPTO_CNG is set from configure to determine if we are
// * compiled with Native Crypto support on Windows
// *
const MONGOC_ENABLE_CRYPTO_CNG = 1;

// *
// * MONGOC_HAVE_BCRYPT_PBKDF2 is set from configure to determine if
// * our Bcrypt Windows library supports PBKDF2
// *
const MONGOC_HAVE_BCRYPT_PBKDF2 = 1;

// *
// * MONGOC_ENABLE_SSL_SECURE_TRANSPORT is set from configure to determine if we are
// * compiled with Native SSL support on Darwin
// *
const MONGOC_ENABLE_SSL_SECURE_TRANSPORT = 0;

// *
// * MONGOC_ENABLE_CRYPTO_COMMON_CRYPTO is set from configure to determine if we are
// * compiled with Native Crypto support on Darwin
// *
const MONGOC_ENABLE_CRYPTO_COMMON_CRYPTO = 0;

// *
// * MONGOC_ENABLE_SSL_OPENSSL is set from configure to determine if we are
// * compiled with OpenSSL support.
// *
const MONGOC_ENABLE_SSL_OPENSSL = 0;

// *
// * MONGOC_ENABLE_CRYPTO_LIBCRYPTO is set from configure to determine if we are
// * compiled with OpenSSL support.
// *
const MONGOC_ENABLE_CRYPTO_LIBCRYPTO = 0;

// *
// * MONGOC_ENABLE_SSL is set from configure to determine if we are
// * compiled with any SSL support.
// *
const MONGOC_ENABLE_SSL = 1;

// *
// * MONGOC_ENABLE_CRYPTO is set from configure to determine if we are
// * compiled with any crypto support.
// *
const MONGOC_ENABLE_CRYPTO = 1;

// *
// * Use system crypto profile
// *
const MONGOC_ENABLE_CRYPTO_SYSTEM_PROFILE = 0;

// *
// * Use ASN1_STRING_get0_data () rather than the deprecated ASN1_STRING_data
// *
const MONGOC_HAVE_ASN1_STRING_GET0_DATA = 0;

// *
// * MONGOC_ENABLE_SASL is set from configure to determine if we are
// * compiled with SASL support.
// *
const MONGOC_ENABLE_SASL = 1;

// *
// * MONGOC_ENABLE_SASL_CYRUS is set from configure to determine if we are
// * compiled with Cyrus SASL support.
// *
const MONGOC_ENABLE_SASL_CYRUS = 0;

// *
// * MONGOC_ENABLE_SASL_SSPI is set from configure to determine if we are
// * compiled with SSPI support.
// *
const MONGOC_ENABLE_SASL_SSPI = 1;

// *
// * MONGOC_HAVE_SASL_CLIENT_DONE is set from configure to determine if we
// * have SASL and its version is new enough to use sasl_client_done (),
// * which supersedes sasl_done ().
// *
const MONGOC_HAVE_SASL_CLIENT_DONE = 0;

// *
// * MONGOC_HAVE_SOCKLEN is set from configure to determine if we
// * need to emulate the type.
// *
const MONGOC_HAVE_SOCKLEN = 1;

// * *
// * @brief Defined to 0/1 for whether we were configured with ENABLE_SRV
// *
const MONGOC_ENABLE_SRV = 1;

// *
// * MONGOC_HAVE_DNSAPI is set from configure to determine if we should use the
// * Windows dnsapi for SRV record lookups.
// *
const MONGOC_HAVE_DNSAPI = 1;

// *
// * MONGOC_HAVE_RES_NSEARCH is set from configure to determine if we
// * have thread-safe res_nsearch().
// *
const MONGOC_HAVE_RES_NSEARCH = 0;

// *
// * MONGOC_HAVE_RES_NDESTROY is set from configure to determine if we
// * have BSD / Darwin's res_ndestroy().
// *
const MONGOC_HAVE_RES_NDESTROY = 0;

// *
// * MONGOC_HAVE_RES_NCLOSE is set from configure to determine if we
// * have Linux's res_nclose().
// *
const MONGOC_HAVE_RES_NCLOSE = 0;

// *
// * MONGOC_HAVE_RES_SEARCH is set from configure to determine if we
// * have thread-unsafe res_search(). It's unset if we have the preferred
// * res_nsearch().
// *
const MONGOC_HAVE_RES_SEARCH = 0;

// *
// * Set from configure, see
// * https: // curl.haxx.se/mail/lib-2009-04/0287.html
// *
// #define MONGOC_SOCKET_ARG2 struct sockaddr
type MONGOC_SOCKET_ARG3 = socklen_t;

// *
// * Enable wire protocol compression negotiation
// *
// *
const MONGOC_ENABLE_COMPRESSION = 1;

// *
// * Set if we have snappy compression support
// *
// *
const MONGOC_ENABLE_COMPRESSION_SNAPPY = 0;

// *
// * Set if we have zlib compression support
// *
// *
const MONGOC_ENABLE_COMPRESSION_ZLIB = 1;

// *
// * Set if we have zstd compression support
// *
// *
const MONGOC_ENABLE_COMPRESSION_ZSTD = 0;

// *
// * Set if performance counters are available and not disabled.
// *
// *
const MONGOC_ENABLE_SHM_COUNTERS = 0;

// *
// * Set if we have enabled fast counters on Intel using the RDTSCP instruction
// *
// *
const MONGOC_ENABLE_RDTSCP = 0;

// *
// * Set if we have the sched_getcpu() function for use with counters
// *
// *
const MONGOC_HAVE_SCHED_GETCPU = 0;

// *
// * Set if tracing is enabled. Logs things like network communication and
// * entry/exit of certain functions.
// *
const MONGOC_TRACE = 0;

// *
// * Set if we have Client Side Encryption support.
// *

const MONGOC_ENABLE_CLIENT_SIDE_ENCRYPTION = 0;

// *
// * Set if struct sockaddr_storage has __ss_family (instead of ss_family)
// *

const MONGOC_HAVE_SS_FAMILY = 0;

// *
// * Set if building with AWS IAM support.
// *
const MONGOC_ENABLE_MONGODB_AWS_AUTH = 1;

// enum {
// * *
// * @brief Compile-time constant determining whether the mongoc library was
// * compiled with tracing enabled.
// *
// * Can be controlled with the ENABLE_TRACING configure-time boolean option
// *
// MONGOC_TRACE_ENABLED = MONGOC_TRACE,
// * *
// * @brief Compile-time constant indicating whether the mongoc library was
// * compiled with SRV server discovery support.
// *
// * Can be controled with the ENABLE_SRV configure-time boolean option.
// *
// MONGOC_SRV_ENABLED = MONGOC_ENABLE_SRV,
// };

// * clang-format on

//////////////////////
// mongoc-host-list //
//////////////////////

const BSON_HOST_NAME_MAX = 255;

type
  _mongoc_host_list_t = record
  end;
  mongoc_host_list_t = _mongoc_host_list_t;
  Pmongoc_host_list_t = ^mongoc_host_list_t;

// struct _mongoc_host_list_t {
// mongoc_host_list_t * next;
// char host[BSON_HOST_NAME_MAX + 1];
// char host_and_port[BSON_HOST_NAME_MAX + 7];
// uint16_t port;
// int family;
// void * padding[4];
// };

//////////////////
// mongoc-flags //
//////////////////

// * *
// * mongoc_remove_flags_t:
// * @MONGOC_REMOVE_NONE: Specify no delete flags.
// * @MONGOC_REMOVE_SINGLE_REMOVE: Only remove the first document matching the
// * document selector.
// *
// * #mongoc_remove_flags_t are used when performing a remove operation.
// *
type
  mongoc_remove_flags_t = (
    MONGOC_REMOVE_NONE = 0,
    MONGOC_REMOVE_SINGLE_REMOVE = 1 shl 0);

// * *
// * mongoc_insert_flags_t:
// * @MONGOC_INSERT_NONE: Specify no insert flags.
// * @MONGOC_INSERT_CONTINUE_ON_ERROR: Continue inserting documents from
// * the insertion set even if one fails.
// *
// * #mongoc_insert_flags_t are used when performing an insert operation.
// *
type
  mongoc_insert_flags_t = (
    MONGOC_INSERT_NONE = 0,
    MONGOC_INSERT_CONTINUE_ON_ERROR = 1 shl 0);

const MONGOC_INSERT_NO_VALIDATE = (NativeUInt(1) shl 31);

// * *
// * mongoc_query_flags_t:
// * @MONGOC_QUERY_NONE: No query flags supplied.
// * @MONGOC_QUERY_TAILABLE_CURSOR: Cursor will not be closed when the last
// * data is retrieved. You can resume this cursor later.
// * @MONGOC_QUERY_SECONDARY_OK: Allow query of secondaries in a replica set.
// * @MONGOC_QUERY_OPLOG_REPLAY: Used internally by Mongo.
// * @MONGOC_QUERY_NO_CURSOR_TIMEOUT: The server normally times out idle
// * cursors after an inactivity period (10 minutes). This prevents that.
// * @MONGOC_QUERY_AWAIT_DATA: Use with %MONGOC_QUERY_TAILABLE_CURSOR. Block
// * rather than returning no data. After a period, time out.
// * @MONGOC_QUERY_EXHAUST: Stream the data down full blast in multiple
// * "more" packages. Faster when you are pulling a lot of data and
// * know you want to pull it all down.
// * @MONGOC_QUERY_PARTIAL: Get partial results from mongos if some shards
// * are down (instead of throwing an error).
// *
// * #mongoc_query_flags_t is used for querying a Mongo instance.
// *
type
  mongoc_query_flags_t = (
    MONGOC_QUERY_NONE = 0,
    MONGOC_QUERY_TAILABLE_CURSOR = 1 shl 1,
    MONGOC_QUERY_SECONDARY_OK = 1 shl 2,
    MONGOC_QUERY_OPLOG_REPLAY = 1 shl 3,
    MONGOC_QUERY_NO_CURSOR_TIMEOUT = 1 shl 4,
    MONGOC_QUERY_AWAIT_DATA = 1 shl 5,
    MONGOC_QUERY_EXHAUST = 1 shl 6,
    MONGOC_QUERY_PARTIAL = 1 shl 7);

// * *
// * mongoc_update_flags_t:
// * @MONGOC_UPDATE_NONE: No update flags specified.
// * @MONGOC_UPDATE_UPSERT: Perform an upsert.
// * @MONGOC_UPDATE_MULTI_UPDATE: Continue updating after first match.
// *
// * #mongoc_update_flags_t is used when updating documents found in Mongo.
// *
type
  mongoc_update_flags_t = (
    MONGOC_UPDATE_NONE = 0,
    MONGOC_UPDATE_UPSERT = 1 shl 0,
    MONGOC_UPDATE_MULTI_UPDATE = 1 shl 1);

const MONGOC_UPDATE_NO_VALIDATE = (NativeUInt(1) shl 31);

//////////////////
// mongoc-iovec //
//////////////////

{$if defined(Win32)}
type
  mongoc_iovec_t = record
    iov_len: size_t;
    iov_base: PAnsiChar;
  end;
  Pmongoc_iovec_t = ^mongoc_iovec_t;

// BSON_STATIC_ASSERT2(sizeof_iovect_t, sizeof(mongoc_iovec_t) == sizeof(WSABUF));
// BSON_STATIC_ASSERT2(offsetof_iovec_base, offsetof(mongoc_iovec_t, iov_base) == offsetof(WSABUF, buf));
// BSON_STATIC_ASSERT2(offsetof_iovec_len, offsetof(mongoc_iovec_t, iov_len) == offsetof(WSABUF, len));

{$else}
type
  iovec = record
  end;
  mongoc_iovec_t = iovec;
  Pmongoc_iovec_t = ^mongoc_iovec_t;
{$endif}

///////////////////
// mongoc-opcode //
///////////////////

type
  mongoc_opcode_t = (
    MONGOC_OPCODE_REPLY = 1,
    MONGOC_OPCODE_UPDATE = 2001,
    MONGOC_OPCODE_INSERT = 2002,
    MONGOC_OPCODE_QUERY = 2004,
    MONGOC_OPCODE_GET_MORE = 2005,
    MONGOC_OPCODE_DELETE = 2006,
    MONGOC_OPCODE_KILL_CURSORS = 2007,
    MONGOC_OPCODE_COMPRESSED = 2012,
    MONGOC_OPCODE_MSG = 2013);

////////////////////
// mongoc-version //
////////////////////

// clang-format off

// * *
// * MONGOC_MAJOR_VERSION:
// *
// * MONGOC major version component (e.g. 1 if %MONGOC_VERSION is 1.2.3)
// *
const MONGOC_MAJOR_VERSION = (2);

// * *
// * MONGOC_MINOR_VERSION:
// *
// * MONGOC minor version component (e.g. 2 if %MONGOC_VERSION is 1.2.3)
// *
const MONGOC_MINOR_VERSION = (2);

// * *
// * MONGOC_MICRO_VERSION:
// *
// * MONGOC micro version component (e.g. 3 if %MONGOC_VERSION is 1.2.3)
// *
const MONGOC_MICRO_VERSION = (1);

// * *
// * MONGOC_PRERELEASE_VERSION:
// *
// * MONGOC prerelease version component (e.g. pre if %MONGOC_VERSION is 1.2.3-pre)
// *
// #define MONGOC_PRERELEASE_VERSION ()

// * *
// * MONGOC_VERSION:
// *
// * MONGOC version.
// *
// #define MONGOC_VERSION (2.2.1)

// * *
// * MONGOC_VERSION_S:
// *
// * MONGOC version, encoded as a string, useful for printing and
// * concatenation.
// *
const MONGOC_VERSION_S = '2.2.1';

// * *
// * MONGOC_VERSION_HEX:
// *
// * MONGOC version, encoded as an hexadecimal number, useful for
// * integer comparisons.
// *
const MONGOC_VERSION_HEX = (MONGOC_MAJOR_VERSION shl 24 or MONGOC_MINOR_VERSION shl 16 or MONGOC_MICRO_VERSION shl 8);

// * *
// * MONGOC_CHECK_VERSION:
// * @major: required major version
// * @minor: required minor version
// * @micro: required micro version
// *
// * Compile-time version checking. Evaluates to %TRUE if the version
// * of MONGOC is greater than or equal to the required one.
// *
// #define MONGOC_CHECK_VERSION(major,minor,micro) (MONGOC_MAJOR_VERSION > (major) || (MONGOC_MAJOR_VERSION == (major) && MONGOC_MINOR_VERSION > (minor)) || (MONGOC_MAJOR_VERSION == (major) && MONGOC_MINOR_VERSION == (minor) && MONGOC_MICRO_VERSION >= (micro)))

//////////////////////////
// mongoc-write-concern //
//////////////////////////

const MONGOC_WRITE_CONCERN_W_UNACKNOWLEDGED = 0;
const MONGOC_WRITE_CONCERN_W_DEFAULT = -2;
const MONGOC_WRITE_CONCERN_W_MAJORITY = -3;
const MONGOC_WRITE_CONCERN_W_TAG = -4;

type
  _mongoc_write_concern_t = record
  end;
  mongoc_write_concern_t = _mongoc_write_concern_t;
  Pmongoc_write_concern_t = ^mongoc_write_concern_t;

function mongoc_write_concern_new(): Pmongoc_write_concern_t; cdecl; external 'mongoc2.dll';

function mongoc_write_concern_copy(
           write_concern: Pmongoc_write_concern_t): Pmongoc_write_concern_t; cdecl; external 'mongoc2.dll';

procedure mongoc_write_concern_destroy(
            write_concern: Pmongoc_write_concern_t); cdecl; external 'mongoc2.dll';

function mongoc_write_concern_get_journal(
           write_concern: Pmongoc_write_concern_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_write_concern_journal_is_set(
           write_concern: Pmongoc_write_concern_t): bool; cdecl; external 'mongoc2.dll';

procedure mongoc_write_concern_set_journal(
            write_concern: Pmongoc_write_concern_t;
            journal: bool); cdecl; external 'mongoc2.dll';

function mongoc_write_concern_get_w(
           write_concern: Pmongoc_write_concern_t): int32_t; cdecl; external 'mongoc2.dll';

procedure mongoc_write_concern_set_w(
            write_concern: Pmongoc_write_concern_t;
            w: int32_t); cdecl; external 'mongoc2.dll';

function mongoc_write_concern_get_wtag(
           write_concern: Pmongoc_write_concern_t): PAnsiChar; cdecl; external 'mongoc2.dll';

procedure mongoc_write_concern_set_wtag(
            write_concern: Pmongoc_write_concern_t;
            tag: PAnsiChar); cdecl; external 'mongoc2.dll';

function mongoc_write_concern_get_wtimeout(
           write_concern: Pmongoc_write_concern_t): int32_t; cdecl; external 'mongoc2.dll';

function mongoc_write_concern_get_wtimeout_int64(
           write_concern: Pmongoc_write_concern_t): int64_t; cdecl; external 'mongoc2.dll';

procedure mongoc_write_concern_set_wtimeout(
            write_concern: Pmongoc_write_concern_t;
            wtimeout_msec: int32_t); cdecl; external 'mongoc2.dll';

procedure mongoc_write_concern_set_wtimeout_int64(
            write_concern: Pmongoc_write_concern_t;
            wtimeout_msec: int64_t); cdecl; external 'mongoc2.dll';

function mongoc_write_concern_get_wmajority(
           write_concern: Pmongoc_write_concern_t): bool; cdecl; external 'mongoc2.dll';

procedure mongoc_write_concern_set_wmajority(
            write_concern: Pmongoc_write_concern_t;
            wtimeout_msec: int32_t); cdecl; external 'mongoc2.dll';

function mongoc_write_concern_is_acknowledged(
           write_concern: Pmongoc_write_concern_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_write_concern_is_valid(
           write_concern: Pmongoc_write_concern_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_write_concern_append(
           write_concern: Pmongoc_write_concern_t;
           doc: Pbson_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_write_concern_is_default(
           write_concern: Pmongoc_write_concern_t): bool; cdecl; external 'mongoc2.dll';

/////////////////////////
// mongoc-read-concern //
/////////////////////////

const MONGOC_READ_CONCERN_LEVEL_AVAILABLE = 'available';
const MONGOC_READ_CONCERN_LEVEL_LOCAL = 'local';
const MONGOC_READ_CONCERN_LEVEL_MAJORITY = 'majority';
const MONGOC_READ_CONCERN_LEVEL_LINEARIZABLE = 'linearizable';
const MONGOC_READ_CONCERN_LEVEL_SNAPSHOT = 'snapshot';

type
  _mongoc_read_concern_t = record
  end;
  mongoc_read_concern_t = _mongoc_read_concern_t;
  Pmongoc_read_concern_t = ^mongoc_read_concern_t;

function mongoc_read_concern_new(): Pmongoc_read_concern_t; cdecl; external 'mongoc2.dll';
function mongoc_read_concern_copy(
           read_concern: Pmongoc_read_concern_t): Pmongoc_read_concern_t; cdecl; external 'mongoc2.dll';
procedure mongoc_read_concern_destroy(
            read_concern: Pmongoc_read_concern_t); cdecl; external 'mongoc2.dll';
function mongoc_read_concern_get_level(
           read_concern: Pmongoc_read_concern_t): PAnsiChar; cdecl; external 'mongoc2.dll';
function mongoc_read_concern_set_level(
           read_concern: Pmongoc_read_concern_t;
           level: PAnsiChar): bool; cdecl; external 'mongoc2.dll';
function mongoc_read_concern_append(
           read_concern: Pmongoc_read_concern_t;
           doc: Pbson_t): bool; cdecl; external 'mongoc2.dll';
function mongoc_read_concern_is_default(
           read_concern: Pmongoc_read_concern_t): bool; cdecl; external 'mongoc2.dll';

/////////////////////
// mongoc-optional //
/////////////////////

type
  mongoc_optional_t = record
    value: bool;
    is_set: bool;
  end;
  Pmongoc_optional_t = ^mongoc_optional_t;

procedure mongoc_optional_init(
            opt: Pmongoc_optional_t); cdecl; external 'mongoc2.dll';

function mongoc_optional_is_set(
           opt: Pmongoc_optional_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_optional_value(
           opt: Pmongoc_optional_t): bool; cdecl; external 'mongoc2.dll';

procedure mongoc_optional_set_value(
            opt: Pmongoc_optional_t;
            val: bool); cdecl; external 'mongoc2.dll';

procedure mongoc_optional_copy(
            source: Pmongoc_optional_t;
            copy: Pmongoc_optional_t); cdecl; external 'mongoc2.dll';

//////////////////
// mongoc-error //
//////////////////

const MONGOC_ERROR_API_VERSION_LEGACY = 1;
const MONGOC_ERROR_API_VERSION_2 = 2;

type
  mongoc_error_domain_t = (
    MONGOC_ERROR_CLIENT = 1,
    MONGOC_ERROR_STREAM,
    MONGOC_ERROR_PROTOCOL,
    MONGOC_ERROR_CURSOR,
    MONGOC_ERROR_QUERY,
    MONGOC_ERROR_INSERT,
    MONGOC_ERROR_SASL,
    MONGOC_ERROR_BSON,
    MONGOC_ERROR_MATCHER,
    MONGOC_ERROR_NAMESPACE,
    MONGOC_ERROR_COMMAND,
    MONGOC_ERROR_COLLECTION,
    MONGOC_ERROR_GRIDFS,
    MONGOC_ERROR_SCRAM,
    MONGOC_ERROR_SERVER_SELECTION,
    MONGOC_ERROR_WRITE_CONCERN,
    MONGOC_ERROR_SERVER, (* Error API Version 2 only *)
    MONGOC_ERROR_TRANSACTION,
    MONGOC_ERROR_CLIENT_SIDE_ENCRYPTION, (* An error coming from libmongocrypt *)
    MONGOC_ERROR_POOL,
    MONGOC_ERROR_AZURE,
    MONGOC_ERROR_GCP);

type
  mongoc_error_code_t = (
    MONGOC_ERROR_STREAM_INVALID_TYPE = 1,
    MONGOC_ERROR_STREAM_INVALID_STATE,
    MONGOC_ERROR_STREAM_NAME_RESOLUTION,
    MONGOC_ERROR_STREAM_SOCKET,
    MONGOC_ERROR_STREAM_CONNECT,
    MONGOC_ERROR_STREAM_NOT_ESTABLISHED,
    MONGOC_ERROR_CLIENT_NOT_READY,
    MONGOC_ERROR_CLIENT_TOO_BIG,
    MONGOC_ERROR_CLIENT_TOO_SMALL,
    MONGOC_ERROR_CLIENT_GETNONCE,
    MONGOC_ERROR_CLIENT_AUTHENTICATE,
    MONGOC_ERROR_CLIENT_NO_ACCEPTABLE_PEER,
    MONGOC_ERROR_CLIENT_IN_EXHAUST,
    MONGOC_ERROR_PROTOCOL_INVALID_REPLY,
    MONGOC_ERROR_PROTOCOL_BAD_WIRE_VERSION,
    MONGOC_ERROR_CURSOR_INVALID_CURSOR,
    MONGOC_ERROR_QUERY_FAILURE,
    MONGOC_ERROR_BSON_INVALID,
    MONGOC_ERROR_MATCHER_INVALID,
    MONGOC_ERROR_NAMESPACE_INVALID,
    MONGOC_ERROR_NAMESPACE_INVALID_FILTER_TYPE,
    MONGOC_ERROR_COMMAND_INVALID_ARG,
    MONGOC_ERROR_COLLECTION_INSERT_FAILED,
    MONGOC_ERROR_COLLECTION_UPDATE_FAILED,
    MONGOC_ERROR_COLLECTION_DELETE_FAILED,
    MONGOC_ERROR_COLLECTION_DOES_NOT_EXIST = 26,
    MONGOC_ERROR_GRIDFS_INVALID_FILENAME,
    MONGOC_ERROR_SCRAM_NOT_DONE,
    MONGOC_ERROR_SCRAM_PROTOCOL_ERROR,
    MONGOC_ERROR_QUERY_COMMAND_NOT_FOUND = 59,
    MONGOC_ERROR_QUERY_NOT_TAILABLE = 13051,
    MONGOC_ERROR_SERVER_SELECTION_BAD_WIRE_VERSION,
    MONGOC_ERROR_SERVER_SELECTION_FAILURE,
    MONGOC_ERROR_SERVER_SELECTION_INVALID_ID,
    MONGOC_ERROR_GRIDFS_CHUNK_MISSING,
    MONGOC_ERROR_GRIDFS_PROTOCOL_ERROR,
    (* Dup with query failure. *)
    MONGOC_ERROR_PROTOCOL_ERROR = 17,
    MONGOC_ERROR_WRITE_CONCERN_ERROR = 64,
    MONGOC_ERROR_DUPLICATE_KEY = 11000,
    MONGOC_ERROR_MAX_TIME_MS_EXPIRED = 50,
    MONGOC_ERROR_CHANGE_STREAM_NO_RESUME_TOKEN,
    MONGOC_ERROR_CLIENT_SESSION_FAILURE,
    MONGOC_ERROR_TRANSACTION_INVALID_STATE,
    MONGOC_ERROR_GRIDFS_CORRUPT,
    MONGOC_ERROR_GRIDFS_BUCKET_FILE_NOT_FOUND,
    MONGOC_ERROR_GRIDFS_BUCKET_STREAM,
    (* An error related to initializing client side encryption. *)
    MONGOC_ERROR_CLIENT_INVALID_ENCRYPTION_STATE,
    MONGOC_ERROR_CLIENT_INVALID_ENCRYPTION_ARG,
    (* An error related to server version api *)
    MONGOC_ERROR_CLIENT_API_ALREADY_SET,
    MONGOC_ERROR_CLIENT_API_FROM_POOL,
    MONGOC_ERROR_POOL_API_ALREADY_SET,
    MONGOC_ERROR_POOL_API_TOO_LATE,
    MONGOC_ERROR_CLIENT_INVALID_LOAD_BALANCER,
    (* An error related to either GCP metadata or Azure IMDS server *)
    MONGOC_ERROR_KMS_SERVER_HTTP,
    MONGOC_ERROR_KMS_SERVER_BAD_JSON);

function mongoc_error_has_label(
           reply: Pbson_t;
           &label: PAnsiChar): bool; cdecl; external 'mongoc2.dll';

////////////////////////////
// mongoc-find-and-modify //
////////////////////////////

type
  mongoc_find_and_modify_flags_t = (
    MONGOC_FIND_AND_MODIFY_NONE = 0,
    MONGOC_FIND_AND_MODIFY_REMOVE = 1 shl 0,
    MONGOC_FIND_AND_MODIFY_UPSERT = 1 shl 1,
    MONGOC_FIND_AND_MODIFY_RETURN_NEW = 1 shl 2);

type
  _mongoc_find_and_modify_opts_t = record
  end;
  mongoc_find_and_modify_opts_t = _mongoc_find_and_modify_opts_t;
  Pmongoc_find_and_modify_opts_t = ^mongoc_find_and_modify_opts_t;

function mongoc_find_and_modify_opts_new(): Pmongoc_find_and_modify_opts_t; cdecl; external 'mongoc2.dll';

function mongoc_find_and_modify_opts_set_sort(
           opts: Pmongoc_find_and_modify_opts_t;
           sort: Pbson_t): bool; cdecl; external 'mongoc2.dll';

procedure mongoc_find_and_modify_opts_get_sort(
            opts: Pmongoc_find_and_modify_opts_t;
            sort: Pbson_t); cdecl; external 'mongoc2.dll';

function mongoc_find_and_modify_opts_set_update(
           opts: Pmongoc_find_and_modify_opts_t;
           update: Pbson_t): bool; cdecl; external 'mongoc2.dll';

procedure mongoc_find_and_modify_opts_get_update(
            opts: Pmongoc_find_and_modify_opts_t;
            update: Pbson_t); cdecl; external 'mongoc2.dll';

function mongoc_find_and_modify_opts_set_fields(
           opts: Pmongoc_find_and_modify_opts_t;
           fields: Pbson_t): bool; cdecl; external 'mongoc2.dll';

procedure mongoc_find_and_modify_opts_get_fields(
            opts: Pmongoc_find_and_modify_opts_t;
            fields: Pbson_t); cdecl; external 'mongoc2.dll';

function mongoc_find_and_modify_opts_set_flags(
           opts: Pmongoc_find_and_modify_opts_t;
           flags: mongoc_find_and_modify_flags_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_find_and_modify_opts_get_flags(
           opts: Pmongoc_find_and_modify_opts_t): mongoc_find_and_modify_flags_t; cdecl; external 'mongoc2.dll';

function mongoc_find_and_modify_opts_set_bypass_document_validation(
           opts: Pmongoc_find_and_modify_opts_t;
           bypass: bool): bool; cdecl; external 'mongoc2.dll';

function mongoc_find_and_modify_opts_get_bypass_document_validation(
           opts: Pmongoc_find_and_modify_opts_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_find_and_modify_opts_set_max_time_ms(
           opts: Pmongoc_find_and_modify_opts_t;
           max_time_ms: uint32_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_find_and_modify_opts_get_max_time_ms(
           opts: Pmongoc_find_and_modify_opts_t): uint32_t; cdecl; external 'mongoc2.dll';

function mongoc_find_and_modify_opts_append(
           opts: Pmongoc_find_and_modify_opts_t;
           extra: Pbson_t): bool; cdecl; external 'mongoc2.dll';

procedure mongoc_find_and_modify_opts_get_extra(
            opts: Pmongoc_find_and_modify_opts_t;
            extra: Pbson_t); cdecl; external 'mongoc2.dll';

procedure mongoc_find_and_modify_opts_destroy(
            opts: Pmongoc_find_and_modify_opts_t); cdecl; external 'mongoc2.dll';

//////////////////////
// mongoc-handshake //
//////////////////////

const MONGOC_HANDSHAKE_APPNAME_MAX = 128;

function mongoc_handshake_data_append(
           driver_name: PAnsiChar;
           driver_version: PAnsiChar;
           platform: PAnsiChar): bool; cdecl; external 'mongoc2.dll';

/////////////////
// mongoc-init //
/////////////////

procedure mongoc_init(); cdecl; external 'mongoc2.dll';
procedure mongoc_cleanup(); cdecl; external 'mongoc2.dll';

////////////////
// mongoc-log //
////////////////

const MONGOC_LOG_DOMAIN = 'mongoc';

// #define MONGOC_ERROR(...) mongoc_log(MONGOC_LOG_LEVEL_ERROR, MONGOC_LOG_DOMAIN, __VA_ARGS__)
// #define MONGOC_CRITICAL(...) mongoc_log(MONGOC_LOG_LEVEL_CRITICAL, MONGOC_LOG_DOMAIN, __VA_ARGS__)
// #define MONGOC_WARNING(...) mongoc_log(MONGOC_LOG_LEVEL_WARNING, MONGOC_LOG_DOMAIN, __VA_ARGS__)
// #define MONGOC_MESSAGE(...) mongoc_log(MONGOC_LOG_LEVEL_MESSAGE, MONGOC_LOG_DOMAIN, __VA_ARGS__)
// #define MONGOC_INFO(...) mongoc_log(MONGOC_LOG_LEVEL_INFO, MONGOC_LOG_DOMAIN, __VA_ARGS__)
// #define MONGOC_DEBUG(...) mongoc_log(MONGOC_LOG_LEVEL_DEBUG, MONGOC_LOG_DOMAIN, __VA_ARGS__)

type
  mongoc_log_level_t = (
    MONGOC_LOG_LEVEL_ERROR,
    MONGOC_LOG_LEVEL_CRITICAL,
    MONGOC_LOG_LEVEL_WARNING,
    MONGOC_LOG_LEVEL_MESSAGE,
    MONGOC_LOG_LEVEL_INFO,
    MONGOC_LOG_LEVEL_DEBUG,
    MONGOC_LOG_LEVEL_TRACE);

// * *
// * mongoc_log_func_t:
// * @log_level: The level of the log message.
// * @log_domain: The domain of the log message, such as "client".
// * @message: The message generated.
// * @user_data: User data provided to mongoc_log_set_handler().
// *
// * This function prototype can be used to set a custom log handler for the
// * libmongoc library. This is useful if you would like to show them in a
// * user interface or alternate storage.
// *
type
  mongoc_log_func_t = procedure (
    log_level: mongoc_log_level_t;
    log_domain: PAnsiChar;
    message: PAnsiChar;
    user_data: Pvoid); cdecl;

// * *
// * mongoc_log_set_handler:
// * @log_func: A function to handle log messages.
// * @user_data: User data for @log_func.
// *
// * Sets the function to be called to handle logging.
// *
procedure mongoc_log_set_handler(
            log_func: mongoc_log_func_t;
            user_data: Pvoid); cdecl; external 'mongoc2.dll';

// * *
// * mongoc_log:
// * @log_level: The log level.
// * @log_domain: The log domain (such as "client").
// * @format: The format string for the log message.
// *
// * Logs a message using the currently configured logger.
// *
// * This method will hold a logging lock to prevent concurrent calls to the
// * logging infrastructure. It is important that your configured log function
// * does not re-enter the logging system or deadlock will occur.
// *
// *
procedure mongoc_log(
            log_level: mongoc_log_level_t;
            log_domain: PAnsiChar;
            format: PAnsiChar); cdecl; varargs; external 'mongoc2.dll';

procedure mongoc_log_default_handler(
            log_level: mongoc_log_level_t;
            log_domain: PAnsiChar;
            message: PAnsiChar;
            user_data: Pvoid); cdecl; external 'mongoc2.dll';

// * *
// * mongoc_log_level_str:
// * @log_level: The log level.
// *
// * Returns: The string representation of log_level
// *
function mongoc_log_level_str(
           log_level: mongoc_log_level_t): PAnsiChar; cdecl; external 'mongoc2.dll';

// * *
// * mongoc_log_trace_enable:
// *
// * Enables tracing at runtime (if it has been enabled at compile time).
// *
procedure mongoc_log_trace_enable(); cdecl; external 'mongoc2.dll';

// * *
// * mongoc_log_trace_disable:
// *
// * Disables tracing at runtime (if it has been enabled at compile time).
// *
procedure mongoc_log_trace_disable(); cdecl; external 'mongoc2.dll';

//////////////////////////
// mongoc-oidc-callback //
//////////////////////////

type
  _mongoc_oidc_callback_t = record
  end;
  mongoc_oidc_callback_t = _mongoc_oidc_callback_t;
  Pmongoc_oidc_callback_t = ^mongoc_oidc_callback_t;
type
  _mongoc_oidc_callback_params_t = record
  end;
  mongoc_oidc_callback_params_t = _mongoc_oidc_callback_params_t;
  Pmongoc_oidc_callback_params_t = ^mongoc_oidc_callback_params_t;
type
  _mongoc_oidc_credential_t = record
  end;
  mongoc_oidc_credential_t = _mongoc_oidc_credential_t;
  Pmongoc_oidc_credential_t = ^mongoc_oidc_credential_t;

type
  mongoc_oidc_callback_fn_t = function (
    params: Pmongoc_oidc_callback_params_t): Pmongoc_oidc_credential_t; cdecl;

function mongoc_oidc_callback_new(
           fn: mongoc_oidc_callback_fn_t): Pmongoc_oidc_callback_t; cdecl; external 'mongoc2.dll';

function mongoc_oidc_callback_new_with_user_data(
           fn: mongoc_oidc_callback_fn_t;
           user_data: Pvoid): Pmongoc_oidc_callback_t; cdecl; external 'mongoc2.dll';

procedure mongoc_oidc_callback_destroy(
            callback: Pmongoc_oidc_callback_t); cdecl; external 'mongoc2.dll';

function mongoc_oidc_callback_get_fn(
           callback: Pmongoc_oidc_callback_t): mongoc_oidc_callback_fn_t; cdecl; external 'mongoc2.dll';

function mongoc_oidc_callback_get_user_data(
           callback: Pmongoc_oidc_callback_t): Pvoid; cdecl; external 'mongoc2.dll';

procedure mongoc_oidc_callback_set_user_data(
            callback: Pmongoc_oidc_callback_t;
            user_data: Pvoid); cdecl; external 'mongoc2.dll';

function mongoc_oidc_callback_params_get_version(
           params: Pmongoc_oidc_callback_params_t): int32_t; cdecl; external 'mongoc2.dll';

function mongoc_oidc_callback_params_get_user_data(
           params: Pmongoc_oidc_callback_params_t): Pvoid; cdecl; external 'mongoc2.dll';

function mongoc_oidc_callback_params_get_timeout(
           params: Pmongoc_oidc_callback_params_t): Pint64_t; cdecl; external 'mongoc2.dll';

function mongoc_oidc_callback_params_get_username(
           params: Pmongoc_oidc_callback_params_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_oidc_callback_params_cancel_with_timeout(
           params: Pmongoc_oidc_callback_params_t): Pmongoc_oidc_credential_t; cdecl; external 'mongoc2.dll';

function mongoc_oidc_credential_new(
           access_token: PAnsiChar): Pmongoc_oidc_credential_t; cdecl; external 'mongoc2.dll';

function mongoc_oidc_credential_new_with_expires_in(
           access_token: PAnsiChar;
           expires_in: int64_t): Pmongoc_oidc_credential_t; cdecl; external 'mongoc2.dll';

procedure mongoc_oidc_credential_destroy(
            cred: Pmongoc_oidc_credential_t); cdecl; external 'mongoc2.dll';

function mongoc_oidc_credential_get_access_token(
           cred: Pmongoc_oidc_credential_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_oidc_credential_get_expires_in(
           cred: Pmongoc_oidc_credential_t): Pint64_t; cdecl; external 'mongoc2.dll';

/////////////////
// mongoc-rand //
/////////////////

procedure mongoc_rand_seed(
            buf: Pvoid;
            num: Integer); cdecl; external 'mongoc2.dll';
procedure mongoc_rand_add(
            buf: Pvoid;
            num: Integer;
            entropy: double); cdecl; external 'mongoc2.dll';
function mongoc_rand_status(): Integer; cdecl; external 'mongoc2.dll';

///////////////////////
// mongoc-read-prefs //
///////////////////////

const MONGOC_NO_MAX_STALENESS = -1;
const MONGOC_SMALLEST_MAX_STALENESS_SECONDS = 90;

type
  _mongoc_read_prefs_t = record
  end;
  mongoc_read_prefs_t = _mongoc_read_prefs_t;
  Pmongoc_read_prefs_t = ^mongoc_read_prefs_t;

type
  mongoc_read_mode_t = (
    (* * Represents $readPreference.mode of 'primary' *)
    MONGOC_READ_PRIMARY = (1 shl 0),
    (* * Represents $readPreference.mode of 'secondary' *)
    MONGOC_READ_SECONDARY = (1 shl 1),
    (* * Represents $readPreference.mode of 'primaryPreferred' *)
    MONGOC_READ_PRIMARY_PREFERRED = (1 shl 2) or MONGOC_READ_PRIMARY,
    (* * Represents $readPreference.mode of 'secondaryPreferred' *)
    MONGOC_READ_SECONDARY_PREFERRED = (1 shl 2) or MONGOC_READ_SECONDARY,
    (* * Represents $readPreference.mode of 'nearest' *)
    MONGOC_READ_NEAREST = (1 shl 3) or MONGOC_READ_SECONDARY);

function mongoc_read_prefs_new(
           read_mode: mongoc_read_mode_t): Pmongoc_read_prefs_t; cdecl; external 'mongoc2.dll';

function mongoc_read_prefs_copy(
           read_prefs: Pmongoc_read_prefs_t): Pmongoc_read_prefs_t; cdecl; external 'mongoc2.dll';

procedure mongoc_read_prefs_destroy(
            read_prefs: Pmongoc_read_prefs_t); cdecl; external 'mongoc2.dll';

function mongoc_read_prefs_get_mode(
           read_prefs: Pmongoc_read_prefs_t): mongoc_read_mode_t; cdecl; external 'mongoc2.dll';

procedure mongoc_read_prefs_set_mode(
            read_prefs: Pmongoc_read_prefs_t;
            mode: mongoc_read_mode_t); cdecl; external 'mongoc2.dll';

function mongoc_read_prefs_get_tags(
           read_prefs: Pmongoc_read_prefs_t): Pbson_t; cdecl; external 'mongoc2.dll';

procedure mongoc_read_prefs_set_tags(
            read_prefs: Pmongoc_read_prefs_t;
            tags: Pbson_t); cdecl; external 'mongoc2.dll';

procedure mongoc_read_prefs_add_tag(
            read_prefs: Pmongoc_read_prefs_t;
            tag: Pbson_t); cdecl; external 'mongoc2.dll';

function mongoc_read_prefs_get_max_staleness_seconds(
           read_prefs: Pmongoc_read_prefs_t): int64_t; cdecl; external 'mongoc2.dll';

procedure mongoc_read_prefs_set_max_staleness_seconds(
            read_prefs: Pmongoc_read_prefs_t;
            max_staleness_seconds: int64_t); cdecl; external 'mongoc2.dll';

// BSON_DEPRECATED("Hedged reads are deprecated in MongoDB 8.0 and will be removed in a future release")
function mongoc_read_prefs_get_hedge(
           read_prefs: Pmongoc_read_prefs_t): Pbson_t; cdecl; external 'mongoc2.dll';

// BSON_DEPRECATED("Hedged reads are deprecated in MongoDB 8.0 and will be removed in a future release")
procedure mongoc_read_prefs_set_hedge(
            read_prefs: Pmongoc_read_prefs_t;
            hedge: Pbson_t); cdecl; external 'mongoc2.dll';

function mongoc_read_prefs_is_valid(
           read_prefs: Pmongoc_read_prefs_t): bool; cdecl; external 'mongoc2.dll';

///////////////////////
// mongoc-server-api //
///////////////////////

type
  mongoc_server_api_version_t = (
    MONGOC_SERVER_API_V1);
  Pmongoc_server_api_version_t = ^mongoc_server_api_version_t;

type
  _mongoc_server_api_t = record
  end;
  mongoc_server_api_t = _mongoc_server_api_t;
  Pmongoc_server_api_t = ^mongoc_server_api_t;

function mongoc_server_api_version_to_string(
           version: mongoc_server_api_version_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_server_api_version_from_string(
           version: PAnsiChar;
           param1: Pmongoc_server_api_version_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_server_api_new(
           version: mongoc_server_api_version_t): Pmongoc_server_api_t; cdecl; external 'mongoc2.dll';

function mongoc_server_api_copy(
           api: Pmongoc_server_api_t): Pmongoc_server_api_t; cdecl; external 'mongoc2.dll';

procedure mongoc_server_api_destroy(
            api: Pmongoc_server_api_t); cdecl; external 'mongoc2.dll';

procedure mongoc_server_api_strict(
            api: Pmongoc_server_api_t;
            strict: bool); cdecl; external 'mongoc2.dll';

procedure mongoc_server_api_deprecation_errors(
            api: Pmongoc_server_api_t;
            deprecation_errors: bool); cdecl; external 'mongoc2.dll';

function mongoc_server_api_get_deprecation_errors(
           api: Pmongoc_server_api_t): Pmongoc_optional_t; cdecl; external 'mongoc2.dll';

function mongoc_server_api_get_strict(
           api: Pmongoc_server_api_t): Pmongoc_optional_t; cdecl; external 'mongoc2.dll';

function mongoc_server_api_get_version(
           api: Pmongoc_server_api_t): mongoc_server_api_version_t; cdecl; external 'mongoc2.dll';

///////////////////////////////
// mongoc-server-description //
///////////////////////////////

type
  _mongoc_server_description_t = record
  end;
  mongoc_server_description_t = _mongoc_server_description_t;
  Pmongoc_server_description_t = ^mongoc_server_description_t;
  PPmongoc_server_description_t = ^Pmongoc_server_description_t;

procedure mongoc_server_description_destroy(
            description: Pmongoc_server_description_t); cdecl; external 'mongoc2.dll';

function mongoc_server_description_new_copy(
           description: Pmongoc_server_description_t): Pmongoc_server_description_t; cdecl; external 'mongoc2.dll';

function mongoc_server_description_id(
           description: Pmongoc_server_description_t): uint32_t; cdecl; external 'mongoc2.dll';

function mongoc_server_description_host(
           description: Pmongoc_server_description_t): Pmongoc_host_list_t; cdecl; external 'mongoc2.dll';

function mongoc_server_description_last_update_time(
           description: Pmongoc_server_description_t): int64_t; cdecl; external 'mongoc2.dll';

function mongoc_server_description_round_trip_time(
           description: Pmongoc_server_description_t): int64_t; cdecl; external 'mongoc2.dll';

function mongoc_server_description_type(
           description: Pmongoc_server_description_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_server_description_hello_response(
           description: Pmongoc_server_description_t): Pbson_t; cdecl; external 'mongoc2.dll';

function mongoc_server_description_compressor_id(
           description: Pmongoc_server_description_t): int32_t; cdecl; external 'mongoc2.dll';

////////////////
// mongoc-ssl //
////////////////

type
  _mongoc_ssl_opt_t = record
  end;
  mongoc_ssl_opt_t = _mongoc_ssl_opt_t;
  Pmongoc_ssl_opt_t = ^mongoc_ssl_opt_t;

// struct _mongoc_ssl_opt_t {
// const char * pem_file;
// const char * pem_pwd;
// const char * ca_file;
// const char * ca_dir;
// const char * crl_file;
// bool weak_cert_validation;
// bool allow_invalid_hostname;
// void * internal;
// void * padding[6];
// };

function mongoc_ssl_opt_get_default(): Pmongoc_ssl_opt_t; cdecl; external 'mongoc2.dll';

///////////////////
// mongoc-socket //
///////////////////

type mongoc_socklen_t = MONGOC_SOCKET_ARG3;
type Pmongoc_socklen_t = ^mongoc_socklen_t;

type
  _mongoc_socket_t = record
  end;
  mongoc_socket_t = _mongoc_socket_t;
  Pmongoc_socket_t = ^mongoc_socket_t;

type
  mongoc_socket_poll_t = record
    socket: Pmongoc_socket_t;
    events: Integer;
    revents: Integer;
  end;
  Pmongoc_socket_poll_t = ^mongoc_socket_poll_t;

function mongoc_socket_accept(
           sock: Pmongoc_socket_t;
           expire_at: int64_t): Pmongoc_socket_t; cdecl; external 'mongoc2.dll';
function mongoc_socket_bind(
           sock: Pmongoc_socket_t;
           addr: Psockaddr;
           addrlen: mongoc_socklen_t): Integer; cdecl; external 'mongoc2.dll';
function mongoc_socket_close(
           socket: Pmongoc_socket_t): Integer; cdecl; external 'mongoc2.dll';
function mongoc_socket_connect(
           sock: Pmongoc_socket_t;
           addr: Psockaddr;
           addrlen: mongoc_socklen_t;
           expire_at: int64_t): Integer; cdecl; external 'mongoc2.dll';
function mongoc_socket_getnameinfo(
           sock: Pmongoc_socket_t): PAnsiChar; cdecl; external 'mongoc2.dll';
procedure mongoc_socket_destroy(
            sock: Pmongoc_socket_t); cdecl; external 'mongoc2.dll';
function mongoc_socket_errno(
           sock: Pmongoc_socket_t): Integer; cdecl; external 'mongoc2.dll';
function mongoc_socket_getsockname(
           sock: Pmongoc_socket_t;
           addr: Psockaddr;
           addrlen: Pmongoc_socklen_t): Integer; cdecl; external 'mongoc2.dll';
function mongoc_socket_listen(
           sock: Pmongoc_socket_t;
           backlog: UINT): Integer; cdecl; external 'mongoc2.dll';
function mongoc_socket_new(
           domain: Integer;
           &type: Integer;
           protocol: Integer): Pmongoc_socket_t; cdecl; external 'mongoc2.dll';
function mongoc_socket_recv(
           sock: Pmongoc_socket_t;
           buf: Pvoid;
           buflen: size_t;
           flags: Integer;
           expire_at: int64_t): ssize_t; cdecl; external 'mongoc2.dll';
function mongoc_socket_setsockopt(
           sock: Pmongoc_socket_t;
           level: Integer;
           optname: Integer;
           optval: Pvoid;
           optlen: mongoc_socklen_t): Integer; cdecl; external 'mongoc2.dll';
function mongoc_socket_send(
           sock: Pmongoc_socket_t;
           buf: Pvoid;
           buflen: size_t;
           expire_at: int64_t): ssize_t; cdecl; external 'mongoc2.dll';
function mongoc_socket_sendv(
           sock: Pmongoc_socket_t;
           iov: Pmongoc_iovec_t;
           iovcnt: size_t;
           expire_at: int64_t): ssize_t; cdecl; external 'mongoc2.dll';
function mongoc_socket_check_closed(
           sock: Pmongoc_socket_t): bool; cdecl; external 'mongoc2.dll';
procedure mongoc_socket_inet_ntop(
            rp: Paddrinfo;
            buf: PAnsiChar;
            buflen: size_t); cdecl; external 'mongoc2.dll';
function mongoc_socket_poll(
           sds: Pmongoc_socket_poll_t;
           nsds: size_t;
           timeout: int32_t): ssize_t; cdecl; external 'mongoc2.dll';

///////////////////
// mongoc-stream //
///////////////////

type
  _mongoc_stream_t = record
  end;
  mongoc_stream_t = _mongoc_stream_t;
  Pmongoc_stream_t = ^mongoc_stream_t;

type
  _mongoc_stream_poll_t = record
    stream: Pmongoc_stream_t;
    events: Integer;
    revents: Integer;
  end;
  mongoc_stream_poll_t = _mongoc_stream_poll_t;
  Pmongoc_stream_poll_t = ^mongoc_stream_poll_t;

// struct _mongoc_stream_t {
// int type;
// void
// (__CALLCONV__ * destroy)(mongoc_stream_t * stream);
// int
// (__CALLCONV__ * close)(mongoc_stream_t * stream);
// int
// (__CALLCONV__ * flush)(mongoc_stream_t * stream);
// ssize_t
// (__CALLCONV__ * writev)(mongoc_stream_t * stream, mongoc_iovec_t * iov, size_t iovcnt, int32_t timeout_msec);
// ssize_t
// (__CALLCONV__ * readv)(
// mongoc_stream_t * stream, mongoc_iovec_t * iov, size_t iovcnt, size_t min_bytes, int32_t timeout_msec);
// int
// (__CALLCONV__ * setsockopt)(mongoc_stream_t * stream, int level, int optname, void * optval, mongoc_socklen_t optlen);
// mongoc_stream_t *
// (__CALLCONV__ * get_base_stream)(mongoc_stream_t * stream);
// bool
// (__CALLCONV__ * check_closed)(mongoc_stream_t * stream);
// ssize_t
// (__CALLCONV__ * poll)(mongoc_stream_poll_t * streams, size_t nstreams, int32_t timeout);
// void
// (__CALLCONV__ * failed)(mongoc_stream_t * stream);
// bool
// (__CALLCONV__ * timed_out)(mongoc_stream_t * stream);
// bool
// (__CALLCONV__ * should_retry)(mongoc_stream_t * stream);
// void * padding[3];
// };

function mongoc_stream_get_base_stream(
           stream: Pmongoc_stream_t): Pmongoc_stream_t; cdecl; external 'mongoc2.dll';
function mongoc_stream_get_tls_stream(
           stream: Pmongoc_stream_t): Pmongoc_stream_t; cdecl; external 'mongoc2.dll';
function mongoc_stream_close(
           stream: Pmongoc_stream_t): Integer; cdecl; external 'mongoc2.dll';
procedure mongoc_stream_destroy(
            stream: Pmongoc_stream_t); cdecl; external 'mongoc2.dll';
procedure mongoc_stream_failed(
            stream: Pmongoc_stream_t); cdecl; external 'mongoc2.dll';
function mongoc_stream_flush(
           stream: Pmongoc_stream_t): Integer; cdecl; external 'mongoc2.dll';
function mongoc_stream_writev(
           stream: Pmongoc_stream_t;
           iov: Pmongoc_iovec_t;
           iovcnt: size_t;
           timeout_msec: int32_t): ssize_t; cdecl; external 'mongoc2.dll';
function mongoc_stream_write(
           stream: Pmongoc_stream_t;
           buf: Pvoid;
           count: size_t;
           timeout_msec: int32_t): ssize_t; cdecl; external 'mongoc2.dll';
function mongoc_stream_readv(
           stream: Pmongoc_stream_t;
           iov: Pmongoc_iovec_t;
           iovcnt: size_t;
           min_bytes: size_t;
           timeout_msec: int32_t): ssize_t; cdecl; external 'mongoc2.dll';
function mongoc_stream_read(
           stream: Pmongoc_stream_t;
           buf: Pvoid;
           count: size_t;
           min_bytes: size_t;
           timeout_msec: int32_t): ssize_t; cdecl; external 'mongoc2.dll';
function mongoc_stream_setsockopt(
           stream: Pmongoc_stream_t;
           level: Integer;
           optname: Integer;
           optval: Pvoid;
           optlen: mongoc_socklen_t): Integer; cdecl; external 'mongoc2.dll';
function mongoc_stream_check_closed(
           stream: Pmongoc_stream_t): bool; cdecl; external 'mongoc2.dll';
function mongoc_stream_timed_out(
           stream: Pmongoc_stream_t): bool; cdecl; external 'mongoc2.dll';
function mongoc_stream_should_retry(
           stream: Pmongoc_stream_t): bool; cdecl; external 'mongoc2.dll';

// * *
// * @brief Poll a set of streams
// *
// * @param streams Pointer to an array of streams to be polled
// * @param nstreams The number of streams in the array pointed-to by `streams`
// * @param timeout_ms The maximum number of milliseconds to poll
// *
// *
function mongoc_stream_poll(
           streams: Pmongoc_stream_poll_t;
           nstreams: size_t;
           timeout_ms: int32_t): ssize_t; cdecl; external 'mongoc2.dll';

////////////////////////////
// mongoc-stream-buffered //
////////////////////////////

function mongoc_stream_buffered_new(
           base_stream: Pmongoc_stream_t;
           buffer_size: size_t): Pmongoc_stream_t; cdecl; external 'mongoc2.dll';

////////////////////////
// mongoc-stream-file //
////////////////////////

type
  _mongoc_stream_file_t = record
  end;
  mongoc_stream_file_t = _mongoc_stream_file_t;
  Pmongoc_stream_file_t = ^mongoc_stream_file_t;

function mongoc_stream_file_new(
           fd: Integer): Pmongoc_stream_t; cdecl; external 'mongoc2.dll';
function mongoc_stream_file_new_for_path(
           path: PAnsiChar;
           flags: Integer;
           mode: Integer): Pmongoc_stream_t; cdecl; external 'mongoc2.dll';
function mongoc_stream_file_get_fd(
           stream: Pmongoc_stream_file_t): Integer; cdecl; external 'mongoc2.dll';

//////////////////////////
// mongoc-stream-socket //
//////////////////////////

type
  _mongoc_stream_socket_t = record
  end;
  mongoc_stream_socket_t = _mongoc_stream_socket_t;
  Pmongoc_stream_socket_t = ^mongoc_stream_socket_t;

function mongoc_stream_socket_new(
           socket: Pmongoc_socket_t): Pmongoc_stream_t; cdecl; external 'mongoc2.dll';
function mongoc_stream_socket_get_socket(
           stream: Pmongoc_stream_socket_t): Pmongoc_socket_t; cdecl; external 'mongoc2.dll';

///////////////////////////
// mongoc-structured-log //
///////////////////////////

type
  mongoc_structured_log_level_t = (
    MONGOC_STRUCTURED_LOG_LEVEL_EMERGENCY = 0,
    MONGOC_STRUCTURED_LOG_LEVEL_ALERT = 1,
    MONGOC_STRUCTURED_LOG_LEVEL_CRITICAL = 2,
    MONGOC_STRUCTURED_LOG_LEVEL_ERROR = 3,
    MONGOC_STRUCTURED_LOG_LEVEL_WARNING = 4,
    MONGOC_STRUCTURED_LOG_LEVEL_NOTICE = 5,
    MONGOC_STRUCTURED_LOG_LEVEL_INFO = 6,
    MONGOC_STRUCTURED_LOG_LEVEL_DEBUG = 7,
    MONGOC_STRUCTURED_LOG_LEVEL_TRACE = 8);
  Pmongoc_structured_log_level_t = ^mongoc_structured_log_level_t;

type
  mongoc_structured_log_component_t = (
    MONGOC_STRUCTURED_LOG_COMPONENT_COMMAND = 0,
    MONGOC_STRUCTURED_LOG_COMPONENT_TOPOLOGY = 1,
    MONGOC_STRUCTURED_LOG_COMPONENT_SERVER_SELECTION = 2,
    MONGOC_STRUCTURED_LOG_COMPONENT_CONNECTION = 3);
  Pmongoc_structured_log_component_t = ^mongoc_structured_log_component_t;

type
  mongoc_structured_log_entry_t = record
  end;
  Pmongoc_structured_log_entry_t = ^mongoc_structured_log_entry_t;

type
  mongoc_structured_log_opts_t = record
  end;
  Pmongoc_structured_log_opts_t = ^mongoc_structured_log_opts_t;

type
  mongoc_structured_log_func_t = procedure (
    entry: Pmongoc_structured_log_entry_t;
    user_data: Pvoid); cdecl;

function mongoc_structured_log_opts_new(): Pmongoc_structured_log_opts_t; cdecl; external 'mongoc2.dll';

procedure mongoc_structured_log_opts_destroy(
            opts: Pmongoc_structured_log_opts_t); cdecl; external 'mongoc2.dll';

procedure mongoc_structured_log_opts_set_handler(
            opts: Pmongoc_structured_log_opts_t;
            log_func: mongoc_structured_log_func_t;
            user_data: Pvoid); cdecl; external 'mongoc2.dll';

function mongoc_structured_log_opts_set_max_level_for_component(
           opts: Pmongoc_structured_log_opts_t;
           component: mongoc_structured_log_component_t;
           level: mongoc_structured_log_level_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_structured_log_opts_set_max_level_for_all_components(
           opts: Pmongoc_structured_log_opts_t;
           level: mongoc_structured_log_level_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_structured_log_opts_set_max_levels_from_env(
           opts: Pmongoc_structured_log_opts_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_structured_log_opts_get_max_level_for_component(
           opts: Pmongoc_structured_log_opts_t;
           component: mongoc_structured_log_component_t): mongoc_structured_log_level_t; cdecl; external 'mongoc2.dll';

function mongoc_structured_log_opts_get_max_document_length(
           opts: Pmongoc_structured_log_opts_t): size_t; cdecl; external 'mongoc2.dll';

function mongoc_structured_log_opts_set_max_document_length_from_env(
           opts: Pmongoc_structured_log_opts_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_structured_log_opts_set_max_document_length(
           opts: Pmongoc_structured_log_opts_t;
           max_document_length: size_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_structured_log_entry_message_as_bson(
           entry: Pmongoc_structured_log_entry_t): Pbson_t; cdecl; external 'mongoc2.dll';

function mongoc_structured_log_entry_get_level(
           entry: Pmongoc_structured_log_entry_t): mongoc_structured_log_level_t; cdecl; external 'mongoc2.dll';

function mongoc_structured_log_entry_get_component(
           entry: Pmongoc_structured_log_entry_t): mongoc_structured_log_component_t; cdecl; external 'mongoc2.dll';

function mongoc_structured_log_entry_get_message_string(
           entry: Pmongoc_structured_log_entry_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_structured_log_get_level_name(
           level: mongoc_structured_log_level_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_structured_log_get_named_level(
           name: PAnsiChar;
           param1: Pmongoc_structured_log_level_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_structured_log_get_component_name(
           component: mongoc_structured_log_component_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_structured_log_get_named_component(
           name: PAnsiChar;
           param1: Pmongoc_structured_log_component_t): bool; cdecl; external 'mongoc2.dll';

//////////////////////////////
// mongoc-version-functions //
//////////////////////////////

function mongoc_get_major_version(): Integer; cdecl; external 'mongoc2.dll';
function mongoc_get_minor_version(): Integer; cdecl; external 'mongoc2.dll';
function mongoc_get_micro_version(): Integer; cdecl; external 'mongoc2.dll';
function mongoc_get_version(): PAnsiChar; cdecl; external 'mongoc2.dll';
function mongoc_check_version(
           required_major: Integer;
           required_minor: Integer;
           required_micro: Integer): bool; cdecl; external 'mongoc2.dll';

///////////////////
// mongoc-cursor //
///////////////////

type
  _mongoc_cursor_t = record
  end;
  mongoc_cursor_t = _mongoc_cursor_t;
  Pmongoc_cursor_t = ^mongoc_cursor_t;

// * forward decl
// struct _mongoc_client_t;

function mongoc_cursor_clone(
           cursor: Pmongoc_cursor_t): Pmongoc_cursor_t; cdecl; external 'mongoc2.dll';

procedure mongoc_cursor_destroy(
            cursor: Pmongoc_cursor_t); cdecl; external 'mongoc2.dll';

function mongoc_cursor_more(
           cursor: Pmongoc_cursor_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_cursor_next(
           cursor: Pmongoc_cursor_t;
           bson: PPbson_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_cursor_error(
           cursor: Pmongoc_cursor_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_cursor_error_document(
           cursor: Pmongoc_cursor_t;
           error: Pbson_error_t;
           doc: PPbson_t): bool; cdecl; external 'mongoc2.dll';

procedure mongoc_cursor_get_host(
            cursor: Pmongoc_cursor_t;
            host: Pmongoc_host_list_t); cdecl; external 'mongoc2.dll';

function mongoc_cursor_current(
           cursor: Pmongoc_cursor_t): Pbson_t; cdecl; external 'mongoc2.dll';

procedure mongoc_cursor_set_batch_size(
            cursor: Pmongoc_cursor_t;
            batch_size: uint32_t); cdecl; external 'mongoc2.dll';

function mongoc_cursor_get_batch_size(
           cursor: Pmongoc_cursor_t): uint32_t; cdecl; external 'mongoc2.dll';

function mongoc_cursor_set_limit(
           cursor: Pmongoc_cursor_t;
           limit: int64_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_cursor_get_limit(
           cursor: Pmongoc_cursor_t): int64_t; cdecl; external 'mongoc2.dll';

// `mongoc_cursor_set_hint` is deprecated for more aptly named `mongoc_cursor_set_server_id`.
// BSON_DEPRECATED_FOR(mongoc_cursor_set_server_id)
// bool __CALLCONV__ mongoc_cursor_set_hint(mongoc_cursor_t * cursor, uint32_t server_id);

function mongoc_cursor_set_server_id(
           cursor: Pmongoc_cursor_t;
           server_id: uint32_t): bool; cdecl; external 'mongoc2.dll';

// `mongoc_cursor_get_hint` is deprecated for more aptly named `mongoc_cursor_get_server_id`.
// BSON_DEPRECATED_FOR(mongoc_cursor_get_server_id)
// uint32_t __CALLCONV__ mongoc_cursor_get_hint(const mongoc_cursor_t * cursor);

function mongoc_cursor_get_server_id(
           cursor: Pmongoc_cursor_t): uint32_t; cdecl; external 'mongoc2.dll';

function mongoc_cursor_get_id(
           cursor: Pmongoc_cursor_t): int64_t; cdecl; external 'mongoc2.dll';

procedure mongoc_cursor_set_max_await_time_ms(
            cursor: Pmongoc_cursor_t;
            max_await_time_ms: uint32_t); cdecl; external 'mongoc2.dll';

function mongoc_cursor_get_max_await_time_ms(
           cursor: Pmongoc_cursor_t): uint32_t; cdecl; external 'mongoc2.dll';

function mongoc_cursor_new_from_command_reply_with_opts(
           client: P_mongoc_client_t;
           reply: Pbson_t;
           opts: Pbson_t): Pmongoc_cursor_t; cdecl; external 'mongoc2.dll';

//////////////////////////
// mongoc-change-stream //
//////////////////////////

type
  _mongoc_change_stream_t = record
  end;
  mongoc_change_stream_t = _mongoc_change_stream_t;
  Pmongoc_change_stream_t = ^mongoc_change_stream_t;

procedure mongoc_change_stream_destroy(
            param0: Pmongoc_change_stream_t); cdecl; external 'mongoc2.dll';

function mongoc_change_stream_get_resume_token(
           param0: Pmongoc_change_stream_t): Pbson_t; cdecl; external 'mongoc2.dll';

function mongoc_change_stream_next(
           param0: Pmongoc_change_stream_t;
           param1: PPbson_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_change_stream_error_document(
           param0: Pmongoc_change_stream_t;
           param1: Pbson_error_t;
           param2: PPbson_t): bool; cdecl; external 'mongoc2.dll';

///////////////////////////
// mongoc-bulk-operation //
///////////////////////////

// * ordered, bypass_document_validation, has_collation, multi
// #define MONGOC_BULK_WRITE_FLAGS_INIT {true, false, 0}

// * forward decl
// struct _mongoc_client_session_t;

type
  _mongoc_bulk_operation_t = record
  end;
  mongoc_bulk_operation_t = _mongoc_bulk_operation_t;
  Pmongoc_bulk_operation_t = ^mongoc_bulk_operation_t;
type
  _mongoc_bulk_write_flags_t = record
  end;
  mongoc_bulk_write_flags_t = _mongoc_bulk_write_flags_t;

procedure mongoc_bulk_operation_destroy(
            bulk: Pmongoc_bulk_operation_t); cdecl; external 'mongoc2.dll';

function mongoc_bulk_operation_execute(
           bulk: Pmongoc_bulk_operation_t;
           reply: Pbson_t;
           error: Pbson_error_t): uint32_t; cdecl; external 'mongoc2.dll';

procedure mongoc_bulk_operation_insert(
            bulk: Pmongoc_bulk_operation_t;
            document: Pbson_t); cdecl; external 'mongoc2.dll';

function mongoc_bulk_operation_insert_with_opts(
           bulk: Pmongoc_bulk_operation_t;
           document: Pbson_t;
           opts: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll'; (* OUT *)

procedure mongoc_bulk_operation_remove(
            bulk: Pmongoc_bulk_operation_t;
            selector: Pbson_t); cdecl; external 'mongoc2.dll';

function mongoc_bulk_operation_remove_many_with_opts(
           bulk: Pmongoc_bulk_operation_t;
           selector: Pbson_t;
           opts: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll'; (* OUT *)

procedure mongoc_bulk_operation_remove_one(
            bulk: Pmongoc_bulk_operation_t;
            selector: Pbson_t); cdecl; external 'mongoc2.dll';

function mongoc_bulk_operation_remove_one_with_opts(
           bulk: Pmongoc_bulk_operation_t;
           selector: Pbson_t;
           opts: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll'; (* OUT *)

procedure mongoc_bulk_operation_replace_one(
            bulk: Pmongoc_bulk_operation_t;
            selector: Pbson_t;
            document: Pbson_t;
            upsert: bool); cdecl; external 'mongoc2.dll';

function mongoc_bulk_operation_replace_one_with_opts(
           bulk: Pmongoc_bulk_operation_t;
           selector: Pbson_t;
           document: Pbson_t;
           opts: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll'; (* OUT *)

procedure mongoc_bulk_operation_update(
            bulk: Pmongoc_bulk_operation_t;
            selector: Pbson_t;
            document: Pbson_t;
            upsert: bool); cdecl; external 'mongoc2.dll';

function mongoc_bulk_operation_update_many_with_opts(
           bulk: Pmongoc_bulk_operation_t;
           selector: Pbson_t;
           document: Pbson_t;
           opts: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll'; (* OUT *)

procedure mongoc_bulk_operation_update_one(
            bulk: Pmongoc_bulk_operation_t;
            selector: Pbson_t;
            document: Pbson_t;
            upsert: bool); cdecl; external 'mongoc2.dll';

function mongoc_bulk_operation_update_one_with_opts(
           bulk: Pmongoc_bulk_operation_t;
           selector: Pbson_t;
           document: Pbson_t;
           opts: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll'; (* OUT *)

procedure mongoc_bulk_operation_set_bypass_document_validation(
            bulk: Pmongoc_bulk_operation_t;
            bypass: bool); cdecl; external 'mongoc2.dll';

procedure mongoc_bulk_operation_set_comment(
            bulk: Pmongoc_bulk_operation_t;
            comment: Pbson_value_t); cdecl; external 'mongoc2.dll';

procedure mongoc_bulk_operation_set_let(
            bulk: Pmongoc_bulk_operation_t;
            let: Pbson_t); cdecl; external 'mongoc2.dll';

// *
// * The following functions are really only useful by language bindings and
// * those wanting to replay a bulk operation to a number of clients or
// * collections.
// *

function mongoc_bulk_operation_new(
           ordered: bool): Pmongoc_bulk_operation_t; cdecl; external 'mongoc2.dll';

procedure mongoc_bulk_operation_set_write_concern(
            bulk: Pmongoc_bulk_operation_t;
            write_concern: Pmongoc_write_concern_t); cdecl; external 'mongoc2.dll';

procedure mongoc_bulk_operation_set_database(
            bulk: Pmongoc_bulk_operation_t;
            database: PAnsiChar); cdecl; external 'mongoc2.dll';

procedure mongoc_bulk_operation_set_collection(
            bulk: Pmongoc_bulk_operation_t;
            collection: PAnsiChar); cdecl; external 'mongoc2.dll';

procedure mongoc_bulk_operation_set_client(
            bulk: Pmongoc_bulk_operation_t;
            client: Pvoid); cdecl; external 'mongoc2.dll';

procedure mongoc_bulk_operation_set_client_session(
            bulk: Pmongoc_bulk_operation_t;
            client_session: P_mongoc_client_session_t); cdecl; external 'mongoc2.dll';

procedure mongoc_bulk_operation_set_server_id(
            bulk: Pmongoc_bulk_operation_t;
            server_id: uint32_t); cdecl; external 'mongoc2.dll';

function mongoc_bulk_operation_get_server_id(
           bulk: Pmongoc_bulk_operation_t): uint32_t; cdecl; external 'mongoc2.dll';

function mongoc_bulk_operation_get_write_concern(
           bulk: Pmongoc_bulk_operation_t): Pmongoc_write_concern_t; cdecl; external 'mongoc2.dll';

///////////////////////////////////
// mongoc-client-side-encryption //
///////////////////////////////////

// * Forward declare
// struct _mongoc_client_t;
// struct _mongoc_client_pool_t;
// struct _mongoc_cursor_t;

// struct _mongoc_collection_t;
// struct _mongoc_database_t;

const MONGOC_AEAD_AES_256_CBC_HMAC_SHA_512_RANDOM = 'AEAD_AES_256_CBC_HMAC_SHA_512-Random';
const MONGOC_AEAD_AES_256_CBC_HMAC_SHA_512_DETERMINISTIC = 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic';
const MONGOC_ENCRYPT_ALGORITHM_INDEXED = 'Indexed';
const MONGOC_ENCRYPT_ALGORITHM_UNINDEXED = 'Unindexed';
const MONGOC_ENCRYPT_ALGORITHM_RANGE = 'Range';
const MONGOC_ENCRYPT_ALGORITHM_RANGEPREVIEW = 'RangePreview';
const MONGOC_ENCRYPT_ALGORITHM_TEXTPREVIEW = 'TextPreview';

const MONGOC_ENCRYPT_QUERY_TYPE_EQUALITY = 'equality';
const MONGOC_ENCRYPT_QUERY_TYPE_RANGE = 'range';
const MONGOC_ENCRYPT_QUERY_TYPE_RANGEPREVIEW = 'rangePreview';
const MONGOC_ENCRYPT_QUERY_TYPE_SUBSTRINGPREVIEW = 'substringPreview';
const MONGOC_ENCRYPT_QUERY_TYPE_PREFIXPREVIEW = 'prefixPreview';
const MONGOC_ENCRYPT_QUERY_TYPE_SUFFIXPREVIEW = 'suffixPreview';

type
  _mongoc_auto_encryption_opts_t = record
  end;
  mongoc_auto_encryption_opts_t = _mongoc_auto_encryption_opts_t;
  Pmongoc_auto_encryption_opts_t = ^mongoc_auto_encryption_opts_t;

type
  mongoc_kms_credentials_provider_callback_fn = function (
    userdata: Pvoid;
    params: Pbson_t;
    param2: Pbson_t;
    error: Pbson_error_t): bool; cdecl;

function mongoc_auto_encryption_opts_new(): Pmongoc_auto_encryption_opts_t; cdecl; external 'mongoc2.dll';

procedure mongoc_auto_encryption_opts_destroy(
            opts: Pmongoc_auto_encryption_opts_t); cdecl; external 'mongoc2.dll';

procedure mongoc_auto_encryption_opts_set_keyvault_client(
            opts: Pmongoc_auto_encryption_opts_t;
            client: P_mongoc_client_t); cdecl; external 'mongoc2.dll';

procedure mongoc_auto_encryption_opts_set_keyvault_client_pool(
            opts: Pmongoc_auto_encryption_opts_t;
            pool: P_mongoc_client_pool_t); cdecl; external 'mongoc2.dll';

procedure mongoc_auto_encryption_opts_set_keyvault_namespace(
            opts: Pmongoc_auto_encryption_opts_t;
            db: PAnsiChar;
            coll: PAnsiChar); cdecl; external 'mongoc2.dll';

procedure mongoc_auto_encryption_opts_set_kms_providers(
            opts: Pmongoc_auto_encryption_opts_t;
            kms_providers: Pbson_t); cdecl; external 'mongoc2.dll';

procedure mongoc_auto_encryption_opts_set_key_expiration(
            opts: Pmongoc_auto_encryption_opts_t;
            expiration: uint64_t); cdecl; external 'mongoc2.dll';

procedure mongoc_auto_encryption_opts_set_tls_opts(
            opts: Pmongoc_auto_encryption_opts_t;
            tls_opts: Pbson_t); cdecl; external 'mongoc2.dll';

procedure mongoc_auto_encryption_opts_set_schema_map(
            opts: Pmongoc_auto_encryption_opts_t;
            schema_map: Pbson_t); cdecl; external 'mongoc2.dll';

procedure mongoc_auto_encryption_opts_set_encrypted_fields_map(
            opts: Pmongoc_auto_encryption_opts_t;
            encrypted_fields_map: Pbson_t); cdecl; external 'mongoc2.dll';

procedure mongoc_auto_encryption_opts_set_bypass_auto_encryption(
            opts: Pmongoc_auto_encryption_opts_t;
            bypass_auto_encryption: bool); cdecl; external 'mongoc2.dll';

procedure mongoc_auto_encryption_opts_set_bypass_query_analysis(
            opts: Pmongoc_auto_encryption_opts_t;
            bypass_query_analysis: bool); cdecl; external 'mongoc2.dll';

procedure mongoc_auto_encryption_opts_set_extra(
            opts: Pmongoc_auto_encryption_opts_t;
            extra: Pbson_t); cdecl; external 'mongoc2.dll';

procedure mongoc_auto_encryption_opts_set_kms_credential_provider_callback(
            opts: Pmongoc_auto_encryption_opts_t;
            fn: mongoc_kms_credentials_provider_callback_fn;
            userdata: Pvoid); cdecl; external 'mongoc2.dll';

type
  _mongoc_client_encryption_opts_t = record
  end;
  mongoc_client_encryption_opts_t = _mongoc_client_encryption_opts_t;
  Pmongoc_client_encryption_opts_t = ^mongoc_client_encryption_opts_t;
type
  _mongoc_client_encryption_t = record
  end;
  mongoc_client_encryption_t = _mongoc_client_encryption_t;
  Pmongoc_client_encryption_t = ^mongoc_client_encryption_t;
type
  _mongoc_client_encryption_encrypt_range_opts_t = record
  end;
  mongoc_client_encryption_encrypt_range_opts_t = _mongoc_client_encryption_encrypt_range_opts_t;
  Pmongoc_client_encryption_encrypt_range_opts_t = ^mongoc_client_encryption_encrypt_range_opts_t;
type
  _encrypt_text_prefix_opts_t = record
  end;
  mongoc_client_encryption_encrypt_text_prefix_opts_t = _encrypt_text_prefix_opts_t;
  Pmongoc_client_encryption_encrypt_text_prefix_opts_t = ^mongoc_client_encryption_encrypt_text_prefix_opts_t;
type
  _encrypt_text_suffix_opts_t = record
  end;
  mongoc_client_encryption_encrypt_text_suffix_opts_t = _encrypt_text_suffix_opts_t;
  Pmongoc_client_encryption_encrypt_text_suffix_opts_t = ^mongoc_client_encryption_encrypt_text_suffix_opts_t;
type
  _encrypt_text_substring_opts_t = record
  end;
  mongoc_client_encryption_encrypt_text_substring_opts_t = _encrypt_text_substring_opts_t;
  Pmongoc_client_encryption_encrypt_text_substring_opts_t = ^mongoc_client_encryption_encrypt_text_substring_opts_t;
type
  _mongoc_client_encryption_encrypt_text_opts_t = record
  end;
  mongoc_client_encryption_encrypt_text_opts_t = _mongoc_client_encryption_encrypt_text_opts_t;
  Pmongoc_client_encryption_encrypt_text_opts_t = ^mongoc_client_encryption_encrypt_text_opts_t;
type
  _mongoc_client_encryption_encrypt_opts_t = record
  end;
  mongoc_client_encryption_encrypt_opts_t = _mongoc_client_encryption_encrypt_opts_t;
  Pmongoc_client_encryption_encrypt_opts_t = ^mongoc_client_encryption_encrypt_opts_t;
type
  _mongoc_client_encryption_datakey_opts_t = record
  end;
  mongoc_client_encryption_datakey_opts_t = _mongoc_client_encryption_datakey_opts_t;
  Pmongoc_client_encryption_datakey_opts_t = ^mongoc_client_encryption_datakey_opts_t;
type
  _mongoc_client_encryption_rewrap_many_datakey_result_t = record
  end;
  mongoc_client_encryption_rewrap_many_datakey_result_t = _mongoc_client_encryption_rewrap_many_datakey_result_t;
  Pmongoc_client_encryption_rewrap_many_datakey_result_t = ^mongoc_client_encryption_rewrap_many_datakey_result_t;

function mongoc_client_encryption_opts_new(): Pmongoc_client_encryption_opts_t; cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_opts_destroy(
            opts: Pmongoc_client_encryption_opts_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_opts_set_keyvault_client(
            opts: Pmongoc_client_encryption_opts_t;
            keyvault_client: P_mongoc_client_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_opts_set_keyvault_namespace(
            opts: Pmongoc_client_encryption_opts_t;
            db: PAnsiChar;
            coll: PAnsiChar); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_opts_set_kms_providers(
            opts: Pmongoc_client_encryption_opts_t;
            kms_providers: Pbson_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_opts_set_tls_opts(
            opts: Pmongoc_client_encryption_opts_t;
            tls_opts: Pbson_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_opts_set_kms_credential_provider_callback(
            opts: Pmongoc_client_encryption_opts_t;
            fn: mongoc_kms_credentials_provider_callback_fn;
            userdata: Pvoid); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_opts_set_key_expiration(
            opts: Pmongoc_client_encryption_opts_t;
            cache_expiration_ms: uint64_t); cdecl; external 'mongoc2.dll';

function mongoc_client_encryption_rewrap_many_datakey_result_new(): Pmongoc_client_encryption_rewrap_many_datakey_result_t; cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_rewrap_many_datakey_result_destroy(
            result: Pmongoc_client_encryption_rewrap_many_datakey_result_t); cdecl; external 'mongoc2.dll';

function mongoc_client_encryption_rewrap_many_datakey_result_get_bulk_write_result(
           result: Pmongoc_client_encryption_rewrap_many_datakey_result_t): Pbson_t; cdecl; external 'mongoc2.dll';

function mongoc_client_encryption_new(
           opts: Pmongoc_client_encryption_opts_t;
           error: Pbson_error_t): Pmongoc_client_encryption_t; cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_destroy(
            client_encryption: Pmongoc_client_encryption_t); cdecl; external 'mongoc2.dll';

function mongoc_client_encryption_create_datakey(
           client_encryption: Pmongoc_client_encryption_t;
           kms_provider: PAnsiChar;
           opts: Pmongoc_client_encryption_datakey_opts_t;
           keyid: Pbson_value_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_encryption_rewrap_many_datakey(
           client_encryption: Pmongoc_client_encryption_t;
           filter: Pbson_t;
           provider: PAnsiChar;
           master_key: Pbson_t;
           result: Pmongoc_client_encryption_rewrap_many_datakey_result_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_encryption_delete_key(
           client_encryption: Pmongoc_client_encryption_t;
           keyid: Pbson_value_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_encryption_get_key(
           client_encryption: Pmongoc_client_encryption_t;
           keyid: Pbson_value_t;
           key_doc: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_encryption_encrypt_text_prefix_opts_new(): Pmongoc_client_encryption_encrypt_text_prefix_opts_t; cdecl; external 'mongoc2.dll';

function mongoc_client_encryption_encrypt_text_suffix_opts_new(): Pmongoc_client_encryption_encrypt_text_suffix_opts_t; cdecl; external 'mongoc2.dll';

function mongoc_client_encryption_encrypt_text_substring_opts_new(): Pmongoc_client_encryption_encrypt_text_substring_opts_t; cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_text_prefix_opts_destroy(
            param0: Pmongoc_client_encryption_encrypt_text_prefix_opts_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_text_suffix_opts_destroy(
            param0: Pmongoc_client_encryption_encrypt_text_suffix_opts_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_text_substring_opts_destroy(
            param0: Pmongoc_client_encryption_encrypt_text_substring_opts_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_text_prefix_opts_set_str_max_query_length(
            opts: Pmongoc_client_encryption_encrypt_text_prefix_opts_t;
            str_max_query_length: int32_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_text_prefix_opts_set_str_min_query_length(
            opts: Pmongoc_client_encryption_encrypt_text_prefix_opts_t;
            str_min_query_length: int32_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_text_suffix_opts_set_str_max_query_length(
            opts: Pmongoc_client_encryption_encrypt_text_suffix_opts_t;
            str_max_query_length: int32_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_text_suffix_opts_set_str_min_query_length(
            opts: Pmongoc_client_encryption_encrypt_text_suffix_opts_t;
            str_min_query_length: int32_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_text_substring_opts_set_str_max_length(
            opts: Pmongoc_client_encryption_encrypt_text_substring_opts_t;
            str_max_length: int32_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_text_substring_opts_set_str_max_query_length(
            opts: Pmongoc_client_encryption_encrypt_text_substring_opts_t;
            str_max_query_length: int32_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_text_substring_opts_set_str_min_query_length(
            opts: Pmongoc_client_encryption_encrypt_text_substring_opts_t;
            str_min_query_length: int32_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_text_opts_set_prefix(
            opts: Pmongoc_client_encryption_encrypt_text_opts_t;
            popts: Pmongoc_client_encryption_encrypt_text_prefix_opts_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_text_opts_set_suffix(
            opts: Pmongoc_client_encryption_encrypt_text_opts_t;
            sopts: Pmongoc_client_encryption_encrypt_text_suffix_opts_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_text_opts_set_substring(
            opts: Pmongoc_client_encryption_encrypt_text_opts_t;
            ssopts: Pmongoc_client_encryption_encrypt_text_substring_opts_t); cdecl; external 'mongoc2.dll';

function mongoc_client_encryption_encrypt_text_opts_new(): Pmongoc_client_encryption_encrypt_text_opts_t; cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_text_opts_destroy(
            topts: Pmongoc_client_encryption_encrypt_text_opts_t); cdecl; external 'mongoc2.dll';

function mongoc_client_encryption_get_keys(
           client_encryption: Pmongoc_client_encryption_t;
           error: Pbson_error_t): P_mongoc_cursor_t; cdecl; external 'mongoc2.dll';

function mongoc_client_encryption_add_key_alt_name(
           client_encryption: Pmongoc_client_encryption_t;
           keyid: Pbson_value_t;
           keyaltname: PAnsiChar;
           key_doc: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_encryption_remove_key_alt_name(
           client_encryption: Pmongoc_client_encryption_t;
           keyid: Pbson_value_t;
           keyaltname: PAnsiChar;
           key_doc: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_encryption_get_key_by_alt_name(
           client_encryption: Pmongoc_client_encryption_t;
           keyaltname: PAnsiChar;
           key_doc: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_encryption_encrypt(
           client_encryption: Pmongoc_client_encryption_t;
           value: Pbson_value_t;
           opts: Pmongoc_client_encryption_encrypt_opts_t;
           ciphertext: Pbson_value_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_encryption_encrypt_expression(
           client_encryption: Pmongoc_client_encryption_t;
           expr: Pbson_t;
           opts: Pmongoc_client_encryption_encrypt_opts_t;
           expr_out: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_encryption_decrypt(
           client_encryption: Pmongoc_client_encryption_t;
           ciphertext: Pbson_value_t;
           value: Pbson_value_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_encryption_encrypt_opts_new(): Pmongoc_client_encryption_encrypt_opts_t; cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_opts_destroy(
            opts: Pmongoc_client_encryption_encrypt_opts_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_opts_set_keyid(
            opts: Pmongoc_client_encryption_encrypt_opts_t;
            keyid: Pbson_value_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_opts_set_keyaltname(
            opts: Pmongoc_client_encryption_encrypt_opts_t;
            keyaltname: PAnsiChar); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_opts_set_algorithm(
            opts: Pmongoc_client_encryption_encrypt_opts_t;
            algorithm: PAnsiChar); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_opts_set_contention_factor(
            opts: Pmongoc_client_encryption_encrypt_opts_t;
            contention_factor: int64_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_opts_set_text_opts(
            opts: Pmongoc_client_encryption_encrypt_opts_t;
            text_opts: Pmongoc_client_encryption_encrypt_text_opts_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_text_opts_set_case_sensitive(
            opts: Pmongoc_client_encryption_encrypt_text_opts_t;
            case_sensitive: bool); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_text_opts_set_diacritic_sensitive(
            opts: Pmongoc_client_encryption_encrypt_text_opts_t;
            diacritic_sensitive: bool); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_opts_set_query_type(
            opts: Pmongoc_client_encryption_encrypt_opts_t;
            query_type: PAnsiChar); cdecl; external 'mongoc2.dll';

function mongoc_client_encryption_encrypt_range_opts_new(): Pmongoc_client_encryption_encrypt_range_opts_t; cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_range_opts_destroy(
            range_opts: Pmongoc_client_encryption_encrypt_range_opts_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_range_opts_set_trim_factor(
            range_opts: Pmongoc_client_encryption_encrypt_range_opts_t;
            trim_factor: int32_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_range_opts_set_sparsity(
            range_opts: Pmongoc_client_encryption_encrypt_range_opts_t;
            sparsity: int64_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_range_opts_set_min(
            range_opts: Pmongoc_client_encryption_encrypt_range_opts_t;
            min: Pbson_value_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_range_opts_set_max(
            range_opts: Pmongoc_client_encryption_encrypt_range_opts_t;
            max: Pbson_value_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_range_opts_set_precision(
            range_opts: Pmongoc_client_encryption_encrypt_range_opts_t;
            precision: int32_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_encrypt_opts_set_range_opts(
            opts: Pmongoc_client_encryption_encrypt_opts_t;
            range_opts: Pmongoc_client_encryption_encrypt_range_opts_t); cdecl; external 'mongoc2.dll';

function mongoc_client_encryption_datakey_opts_new(): Pmongoc_client_encryption_datakey_opts_t; cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_datakey_opts_destroy(
            opts: Pmongoc_client_encryption_datakey_opts_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_datakey_opts_set_masterkey(
            opts: Pmongoc_client_encryption_datakey_opts_t;
            masterkey: Pbson_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_datakey_opts_set_keyaltnames(
            opts: Pmongoc_client_encryption_datakey_opts_t;
            keyaltnames: PPAnsiChar;
            keyaltnames_count: uint32_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_encryption_datakey_opts_set_keymaterial(
            opts: Pmongoc_client_encryption_datakey_opts_t;
            data: Puint8_t;
            len: uint32_t); cdecl; external 'mongoc2.dll';

function mongoc_client_encryption_get_crypt_shared_version(
           enc: Pmongoc_client_encryption_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_client_encryption_create_encrypted_collection(
           enc: Pmongoc_client_encryption_t;
           database: P_mongoc_database_t;
           name: PAnsiChar;
           in_options: Pbson_t;
           opt_out_options: Pbson_t;
           kms_provider: PAnsiChar;
           opt_masterkey: Pbson_t;
           error: Pbson_error_t): P_mongoc_collection_t; cdecl; external 'mongoc2.dll';

///////////////////////
// mongoc-stream-tls //
///////////////////////

type
  _mongoc_stream_tls_t = record
  end;
  mongoc_stream_tls_t = _mongoc_stream_tls_t;

function mongoc_stream_tls_handshake(
           stream: Pmongoc_stream_t;
           host: PAnsiChar;
           timeout_msec: int32_t;
           events: PInteger;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_stream_tls_handshake_block(
           stream: Pmongoc_stream_t;
           host: PAnsiChar;
           timeout_msec: int32_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_stream_tls_new_with_hostname(
           base_stream: Pmongoc_stream_t;
           host: PAnsiChar;
           opt: Pmongoc_ssl_opt_t;
           client: Integer): Pmongoc_stream_t; cdecl; external 'mongoc2.dll';

///////////////////////////////
// mongoc-stream-tls-openssl //
///////////////////////////////

// mongoc_stream_t * __CALLCONV__
// mongoc_stream_tls_openssl_new(mongoc_stream_t * base_stream, const char * host, mongoc_ssl_opt_t * opt, int client);

/////////////////////////////////
// mongoc-topology-description //
/////////////////////////////////

type
  _mongoc_topology_description_t = record
  end;
  mongoc_topology_description_t = _mongoc_topology_description_t;
  Pmongoc_topology_description_t = ^mongoc_topology_description_t;

procedure mongoc_topology_description_destroy(
            description: Pmongoc_topology_description_t); cdecl; external 'mongoc2.dll';

function mongoc_topology_description_new_copy(
           description: Pmongoc_topology_description_t): Pmongoc_topology_description_t; cdecl; external 'mongoc2.dll';

function mongoc_topology_description_has_readable_server(
           td: Pmongoc_topology_description_t;
           prefs: Pmongoc_read_prefs_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_topology_description_has_writable_server(
           td: Pmongoc_topology_description_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_topology_description_type(
           td: Pmongoc_topology_description_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_topology_description_get_servers(
           td: Pmongoc_topology_description_t;
           n: Psize_t): PPmongoc_server_description_t; cdecl; external 'mongoc2.dll';

////////////////
// mongoc-apm //
////////////////

// *
// * Application Performance Management (APM) interface, complies with two specs.
// * MongoDB's Command Logging and Monitoring Spec:
// *
// * https: // github.com/mongodb/specifications/tree/master/source/command-logging-and-monitoring
// *
// * MongoDB's Spec for Monitoring Server Discovery and Monitoring (SDAM) events:
// *
// * https: // github.com/mongodb/specifications/tree/master/source/server-discovery-and-monitoring
// *
// *

// *
// * callbacks to receive APM events
// *

type
  _mongoc_apm_callbacks_t = record
  end;
  mongoc_apm_callbacks_t = _mongoc_apm_callbacks_t;
  Pmongoc_apm_callbacks_t = ^mongoc_apm_callbacks_t;

// *
// * command monitoring events
// *

type
  _mongoc_apm_command_started_t = record
  end;
  mongoc_apm_command_started_t = _mongoc_apm_command_started_t;
  Pmongoc_apm_command_started_t = ^mongoc_apm_command_started_t;
type
  _mongoc_apm_command_succeeded_t = record
  end;
  mongoc_apm_command_succeeded_t = _mongoc_apm_command_succeeded_t;
  Pmongoc_apm_command_succeeded_t = ^mongoc_apm_command_succeeded_t;
type
  _mongoc_apm_command_failed_t = record
  end;
  mongoc_apm_command_failed_t = _mongoc_apm_command_failed_t;
  Pmongoc_apm_command_failed_t = ^mongoc_apm_command_failed_t;

// *
// * SDAM monitoring events
// *

type
  _mongoc_apm_server_changed_t = record
  end;
  mongoc_apm_server_changed_t = _mongoc_apm_server_changed_t;
  Pmongoc_apm_server_changed_t = ^mongoc_apm_server_changed_t;
type
  _mongoc_apm_server_opening_t = record
  end;
  mongoc_apm_server_opening_t = _mongoc_apm_server_opening_t;
  Pmongoc_apm_server_opening_t = ^mongoc_apm_server_opening_t;
type
  _mongoc_apm_server_closed_t = record
  end;
  mongoc_apm_server_closed_t = _mongoc_apm_server_closed_t;
  Pmongoc_apm_server_closed_t = ^mongoc_apm_server_closed_t;
type
  _mongoc_apm_topology_changed_t = record
  end;
  mongoc_apm_topology_changed_t = _mongoc_apm_topology_changed_t;
  Pmongoc_apm_topology_changed_t = ^mongoc_apm_topology_changed_t;
type
  _mongoc_apm_topology_opening_t = record
  end;
  mongoc_apm_topology_opening_t = _mongoc_apm_topology_opening_t;
  Pmongoc_apm_topology_opening_t = ^mongoc_apm_topology_opening_t;
type
  _mongoc_apm_topology_closed_t = record
  end;
  mongoc_apm_topology_closed_t = _mongoc_apm_topology_closed_t;
  Pmongoc_apm_topology_closed_t = ^mongoc_apm_topology_closed_t;
type
  _mongoc_apm_server_heartbeat_started_t = record
  end;
  mongoc_apm_server_heartbeat_started_t = _mongoc_apm_server_heartbeat_started_t;
  Pmongoc_apm_server_heartbeat_started_t = ^mongoc_apm_server_heartbeat_started_t;
type
  _mongoc_apm_server_heartbeat_succeeded_t = record
  end;
  mongoc_apm_server_heartbeat_succeeded_t = _mongoc_apm_server_heartbeat_succeeded_t;
  Pmongoc_apm_server_heartbeat_succeeded_t = ^mongoc_apm_server_heartbeat_succeeded_t;
type
  _mongoc_apm_server_heartbeat_failed_t = record
  end;
  mongoc_apm_server_heartbeat_failed_t = _mongoc_apm_server_heartbeat_failed_t;
  Pmongoc_apm_server_heartbeat_failed_t = ^mongoc_apm_server_heartbeat_failed_t;

// *
// * event field accessors
// *

// * command-started event fields

function mongoc_apm_command_started_get_command(
           event: Pmongoc_apm_command_started_t): Pbson_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_started_get_database_name(
           event: Pmongoc_apm_command_started_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_started_get_command_name(
           event: Pmongoc_apm_command_started_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_started_get_request_id(
           event: Pmongoc_apm_command_started_t): int64_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_started_get_operation_id(
           event: Pmongoc_apm_command_started_t): int64_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_started_get_host(
           event: Pmongoc_apm_command_started_t): Pmongoc_host_list_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_started_get_server_id(
           event: Pmongoc_apm_command_started_t): uint32_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_started_get_service_id(
           event: Pmongoc_apm_command_started_t): Pbson_oid_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_started_get_server_connection_id_int64(
           event: Pmongoc_apm_command_started_t): int64_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_started_get_context(
           event: Pmongoc_apm_command_started_t): Pvoid; cdecl; external 'mongoc2.dll';

// * command-succeeded event fields

function mongoc_apm_command_succeeded_get_duration(
           event: Pmongoc_apm_command_succeeded_t): int64_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_succeeded_get_reply(
           event: Pmongoc_apm_command_succeeded_t): Pbson_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_succeeded_get_command_name(
           event: Pmongoc_apm_command_succeeded_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_succeeded_get_database_name(
           event: Pmongoc_apm_command_succeeded_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_succeeded_get_request_id(
           event: Pmongoc_apm_command_succeeded_t): int64_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_succeeded_get_operation_id(
           event: Pmongoc_apm_command_succeeded_t): int64_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_succeeded_get_host(
           event: Pmongoc_apm_command_succeeded_t): Pmongoc_host_list_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_succeeded_get_server_id(
           event: Pmongoc_apm_command_succeeded_t): uint32_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_succeeded_get_service_id(
           event: Pmongoc_apm_command_succeeded_t): Pbson_oid_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_succeeded_get_server_connection_id_int64(
           event: Pmongoc_apm_command_succeeded_t): int64_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_succeeded_get_context(
           event: Pmongoc_apm_command_succeeded_t): Pvoid; cdecl; external 'mongoc2.dll';

// * command-failed event fields

function mongoc_apm_command_failed_get_duration(
           event: Pmongoc_apm_command_failed_t): int64_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_failed_get_command_name(
           event: Pmongoc_apm_command_failed_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_failed_get_database_name(
           event: Pmongoc_apm_command_failed_t): PAnsiChar; cdecl; external 'mongoc2.dll';
// * retrieve the error by filling out the passed-in "error" struct

procedure mongoc_apm_command_failed_get_error(
            event: Pmongoc_apm_command_failed_t;
            error: Pbson_error_t); cdecl; external 'mongoc2.dll';

function mongoc_apm_command_failed_get_reply(
           event: Pmongoc_apm_command_failed_t): Pbson_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_failed_get_request_id(
           event: Pmongoc_apm_command_failed_t): int64_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_failed_get_operation_id(
           event: Pmongoc_apm_command_failed_t): int64_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_failed_get_host(
           event: Pmongoc_apm_command_failed_t): Pmongoc_host_list_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_failed_get_server_id(
           event: Pmongoc_apm_command_failed_t): uint32_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_failed_get_service_id(
           event: Pmongoc_apm_command_failed_t): Pbson_oid_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_failed_get_server_connection_id_int64(
           event: Pmongoc_apm_command_failed_t): int64_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_command_failed_get_context(
           event: Pmongoc_apm_command_failed_t): Pvoid; cdecl; external 'mongoc2.dll';

// * server-changed event fields

function mongoc_apm_server_changed_get_host(
           event: Pmongoc_apm_server_changed_t): Pmongoc_host_list_t; cdecl; external 'mongoc2.dll';

procedure mongoc_apm_server_changed_get_topology_id(
            event: Pmongoc_apm_server_changed_t;
            topology_id: Pbson_oid_t); cdecl; external 'mongoc2.dll';

function mongoc_apm_server_changed_get_previous_description(
           event: Pmongoc_apm_server_changed_t): Pmongoc_server_description_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_server_changed_get_new_description(
           event: Pmongoc_apm_server_changed_t): Pmongoc_server_description_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_server_changed_get_context(
           event: Pmongoc_apm_server_changed_t): Pvoid; cdecl; external 'mongoc2.dll';

// * server-opening event fields

function mongoc_apm_server_opening_get_host(
           event: Pmongoc_apm_server_opening_t): Pmongoc_host_list_t; cdecl; external 'mongoc2.dll';

procedure mongoc_apm_server_opening_get_topology_id(
            event: Pmongoc_apm_server_opening_t;
            topology_id: Pbson_oid_t); cdecl; external 'mongoc2.dll';

function mongoc_apm_server_opening_get_context(
           event: Pmongoc_apm_server_opening_t): Pvoid; cdecl; external 'mongoc2.dll';

// * server-closed event fields

function mongoc_apm_server_closed_get_host(
           event: Pmongoc_apm_server_closed_t): Pmongoc_host_list_t; cdecl; external 'mongoc2.dll';

procedure mongoc_apm_server_closed_get_topology_id(
            event: Pmongoc_apm_server_closed_t;
            topology_id: Pbson_oid_t); cdecl; external 'mongoc2.dll';

function mongoc_apm_server_closed_get_context(
           event: Pmongoc_apm_server_closed_t): Pvoid; cdecl; external 'mongoc2.dll';

// * topology-changed event fields

procedure mongoc_apm_topology_changed_get_topology_id(
            event: Pmongoc_apm_topology_changed_t;
            topology_id: Pbson_oid_t); cdecl; external 'mongoc2.dll';

function mongoc_apm_topology_changed_get_previous_description(
           event: Pmongoc_apm_topology_changed_t): Pmongoc_topology_description_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_topology_changed_get_new_description(
           event: Pmongoc_apm_topology_changed_t): Pmongoc_topology_description_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_topology_changed_get_context(
           event: Pmongoc_apm_topology_changed_t): Pvoid; cdecl; external 'mongoc2.dll';

// * topology-opening event field

procedure mongoc_apm_topology_opening_get_topology_id(
            event: Pmongoc_apm_topology_opening_t;
            topology_id: Pbson_oid_t); cdecl; external 'mongoc2.dll';

function mongoc_apm_topology_opening_get_context(
           event: Pmongoc_apm_topology_opening_t): Pvoid; cdecl; external 'mongoc2.dll';

// * topology-closed event field

procedure mongoc_apm_topology_closed_get_topology_id(
            event: Pmongoc_apm_topology_closed_t;
            topology_id: Pbson_oid_t); cdecl; external 'mongoc2.dll';

function mongoc_apm_topology_closed_get_context(
           event: Pmongoc_apm_topology_closed_t): Pvoid; cdecl; external 'mongoc2.dll';

// * heartbeat-started event field

function mongoc_apm_server_heartbeat_started_get_host(
           event: Pmongoc_apm_server_heartbeat_started_t): Pmongoc_host_list_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_server_heartbeat_started_get_context(
           event: Pmongoc_apm_server_heartbeat_started_t): Pvoid; cdecl; external 'mongoc2.dll';

function mongoc_apm_server_heartbeat_started_get_awaited(
           event: Pmongoc_apm_server_heartbeat_started_t): bool; cdecl; external 'mongoc2.dll';

// * heartbeat-succeeded event fields

function mongoc_apm_server_heartbeat_succeeded_get_duration(
           event: Pmongoc_apm_server_heartbeat_succeeded_t): int64_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_server_heartbeat_succeeded_get_reply(
           event: Pmongoc_apm_server_heartbeat_succeeded_t): Pbson_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_server_heartbeat_succeeded_get_host(
           event: Pmongoc_apm_server_heartbeat_succeeded_t): Pmongoc_host_list_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_server_heartbeat_succeeded_get_context(
           event: Pmongoc_apm_server_heartbeat_succeeded_t): Pvoid; cdecl; external 'mongoc2.dll';

function mongoc_apm_server_heartbeat_succeeded_get_awaited(
           event: Pmongoc_apm_server_heartbeat_succeeded_t): bool; cdecl; external 'mongoc2.dll';

// * heartbeat-failed event fields

function mongoc_apm_server_heartbeat_failed_get_duration(
           event: Pmongoc_apm_server_heartbeat_failed_t): int64_t; cdecl; external 'mongoc2.dll';

procedure mongoc_apm_server_heartbeat_failed_get_error(
            event: Pmongoc_apm_server_heartbeat_failed_t;
            error: Pbson_error_t); cdecl; external 'mongoc2.dll';

function mongoc_apm_server_heartbeat_failed_get_host(
           event: Pmongoc_apm_server_heartbeat_failed_t): Pmongoc_host_list_t; cdecl; external 'mongoc2.dll';

function mongoc_apm_server_heartbeat_failed_get_context(
           event: Pmongoc_apm_server_heartbeat_failed_t): Pvoid; cdecl; external 'mongoc2.dll';

function mongoc_apm_server_heartbeat_failed_get_awaited(
           event: Pmongoc_apm_server_heartbeat_failed_t): bool; cdecl; external 'mongoc2.dll';

// *
// * callbacks
// *

type
  mongoc_apm_command_started_cb_t = procedure (
    event: Pmongoc_apm_command_started_t); cdecl;
type
  mongoc_apm_command_succeeded_cb_t = procedure (
    event: Pmongoc_apm_command_succeeded_t); cdecl;
type
  mongoc_apm_command_failed_cb_t = procedure (
    event: Pmongoc_apm_command_failed_t); cdecl;
type
  mongoc_apm_server_changed_cb_t = procedure (
    event: Pmongoc_apm_server_changed_t); cdecl;
type
  mongoc_apm_server_opening_cb_t = procedure (
    event: Pmongoc_apm_server_opening_t); cdecl;
type
  mongoc_apm_server_closed_cb_t = procedure (
    event: Pmongoc_apm_server_closed_t); cdecl;
type
  mongoc_apm_topology_changed_cb_t = procedure (
    event: Pmongoc_apm_topology_changed_t); cdecl;
type
  mongoc_apm_topology_opening_cb_t = procedure (
    event: Pmongoc_apm_topology_opening_t); cdecl;
type
  mongoc_apm_topology_closed_cb_t = procedure (
    event: Pmongoc_apm_topology_closed_t); cdecl;
type
  mongoc_apm_server_heartbeat_started_cb_t = procedure (
    event: Pmongoc_apm_server_heartbeat_started_t); cdecl;
type
  mongoc_apm_server_heartbeat_succeeded_cb_t = procedure (
    event: Pmongoc_apm_server_heartbeat_succeeded_t); cdecl;
type
  mongoc_apm_server_heartbeat_failed_cb_t = procedure (
    event: Pmongoc_apm_server_heartbeat_failed_t); cdecl;

// *
// * registering callbacks
// *

function mongoc_apm_callbacks_new(): Pmongoc_apm_callbacks_t; cdecl; external 'mongoc2.dll';

procedure mongoc_apm_callbacks_destroy(
            callbacks: Pmongoc_apm_callbacks_t); cdecl; external 'mongoc2.dll';

procedure mongoc_apm_set_command_started_cb(
            callbacks: Pmongoc_apm_callbacks_t;
            cb: mongoc_apm_command_started_cb_t); cdecl; external 'mongoc2.dll';

procedure mongoc_apm_set_command_succeeded_cb(
            callbacks: Pmongoc_apm_callbacks_t;
            cb: mongoc_apm_command_succeeded_cb_t); cdecl; external 'mongoc2.dll';

procedure mongoc_apm_set_command_failed_cb(
            callbacks: Pmongoc_apm_callbacks_t;
            cb: mongoc_apm_command_failed_cb_t); cdecl; external 'mongoc2.dll';

procedure mongoc_apm_set_server_changed_cb(
            callbacks: Pmongoc_apm_callbacks_t;
            cb: mongoc_apm_server_changed_cb_t); cdecl; external 'mongoc2.dll';

procedure mongoc_apm_set_server_opening_cb(
            callbacks: Pmongoc_apm_callbacks_t;
            cb: mongoc_apm_server_opening_cb_t); cdecl; external 'mongoc2.dll';

procedure mongoc_apm_set_server_closed_cb(
            callbacks: Pmongoc_apm_callbacks_t;
            cb: mongoc_apm_server_closed_cb_t); cdecl; external 'mongoc2.dll';

procedure mongoc_apm_set_topology_changed_cb(
            callbacks: Pmongoc_apm_callbacks_t;
            cb: mongoc_apm_topology_changed_cb_t); cdecl; external 'mongoc2.dll';

procedure mongoc_apm_set_topology_opening_cb(
            callbacks: Pmongoc_apm_callbacks_t;
            cb: mongoc_apm_topology_opening_cb_t); cdecl; external 'mongoc2.dll';

procedure mongoc_apm_set_topology_closed_cb(
            callbacks: Pmongoc_apm_callbacks_t;
            cb: mongoc_apm_topology_closed_cb_t); cdecl; external 'mongoc2.dll';

procedure mongoc_apm_set_server_heartbeat_started_cb(
            callbacks: Pmongoc_apm_callbacks_t;
            cb: mongoc_apm_server_heartbeat_started_cb_t); cdecl; external 'mongoc2.dll';

procedure mongoc_apm_set_server_heartbeat_succeeded_cb(
            callbacks: Pmongoc_apm_callbacks_t;
            cb: mongoc_apm_server_heartbeat_succeeded_cb_t); cdecl; external 'mongoc2.dll';

procedure mongoc_apm_set_server_heartbeat_failed_cb(
            callbacks: Pmongoc_apm_callbacks_t;
            cb: mongoc_apm_server_heartbeat_failed_cb_t); cdecl; external 'mongoc2.dll';

////////////////
// mongoc-uri //
////////////////

const MONGOC_DEFAULT_PORT = 27017;

const MONGOC_URI_APPNAME = 'appname';
const MONGOC_URI_AUTHMECHANISM = 'authmechanism';
const MONGOC_URI_AUTHMECHANISMPROPERTIES = 'authmechanismproperties';
const MONGOC_URI_AUTHSOURCE = 'authsource';
const MONGOC_URI_CANONICALIZEHOSTNAME = 'canonicalizehostname';
const MONGOC_URI_CONNECTTIMEOUTMS = 'connecttimeoutms';
const MONGOC_URI_COMPRESSORS = 'compressors';
const MONGOC_URI_DIRECTCONNECTION = 'directconnection';
const MONGOC_URI_GSSAPISERVICENAME = 'gssapiservicename';
const MONGOC_URI_HEARTBEATFREQUENCYMS = 'heartbeatfrequencyms';
const MONGOC_URI_JOURNAL = 'journal';
const MONGOC_URI_LOADBALANCED = 'loadbalanced';
const MONGOC_URI_LOCALTHRESHOLDMS = 'localthresholdms';
const MONGOC_URI_MAXPOOLSIZE = 'maxpoolsize';
const MONGOC_URI_MAXSTALENESSSECONDS = 'maxstalenessseconds';
const MONGOC_URI_READCONCERNLEVEL = 'readconcernlevel';
const MONGOC_URI_READPREFERENCE = 'readpreference';
const MONGOC_URI_READPREFERENCETAGS = 'readpreferencetags';
const MONGOC_URI_REPLICASET = 'replicaset';
const MONGOC_URI_RETRYREADS = 'retryreads';
const MONGOC_URI_RETRYWRITES = 'retrywrites';
const MONGOC_URI_SAFE = 'safe';
const MONGOC_URI_SERVERMONITORINGMODE = 'servermonitoringmode';
const MONGOC_URI_SERVERSELECTIONTIMEOUTMS = 'serverselectiontimeoutms';
const MONGOC_URI_SERVERSELECTIONTRYONCE = 'serverselectiontryonce';
const MONGOC_URI_SOCKETCHECKINTERVALMS = 'socketcheckintervalms';
const MONGOC_URI_SOCKETTIMEOUTMS = 'sockettimeoutms';
const MONGOC_URI_SRVSERVICENAME = 'srvservicename';
const MONGOC_URI_SRVMAXHOSTS = 'srvmaxhosts';
const MONGOC_URI_TLS = 'tls';
const MONGOC_URI_TLSCERTIFICATEKEYFILE = 'tlscertificatekeyfile';
const MONGOC_URI_TLSCERTIFICATEKEYFILEPASSWORD = 'tlscertificatekeyfilepassword';
const MONGOC_URI_TLSCAFILE = 'tlscafile';
const MONGOC_URI_TLSALLOWINVALIDCERTIFICATES = 'tlsallowinvalidcertificates';
const MONGOC_URI_TLSALLOWINVALIDHOSTNAMES = 'tlsallowinvalidhostnames';
const MONGOC_URI_TLSINSECURE = 'tlsinsecure';
const MONGOC_URI_TLSDISABLECERTIFICATEREVOCATIONCHECK = 'tlsdisablecertificaterevocationcheck';
const MONGOC_URI_TLSDISABLEOCSPENDPOINTCHECK = 'tlsdisableocspendpointcheck';
const MONGOC_URI_W = 'w';
const MONGOC_URI_WAITQUEUETIMEOUTMS = 'waitqueuetimeoutms';
const MONGOC_URI_WTIMEOUTMS = 'wtimeoutms';
const MONGOC_URI_ZLIBCOMPRESSIONLEVEL = 'zlibcompressionlevel';

// * Deprecated in MongoDB 4.2, use "tls" variants instead.
const MONGOC_URI_SSL = 'ssl';
const MONGOC_URI_SSLCLIENTCERTIFICATEKEYFILE = 'sslclientcertificatekeyfile';
const MONGOC_URI_SSLCLIENTCERTIFICATEKEYPASSWORD = 'sslclientcertificatekeypassword';
const MONGOC_URI_SSLCERTIFICATEAUTHORITYFILE = 'sslcertificateauthorityfile';
const MONGOC_URI_SSLALLOWINVALIDCERTIFICATES = 'sslallowinvalidcertificates';
const MONGOC_URI_SSLALLOWINVALIDHOSTNAMES = 'sslallowinvalidhostnames';

type
  _mongoc_uri_t = record
  end;
  mongoc_uri_t = _mongoc_uri_t;
  Pmongoc_uri_t = ^mongoc_uri_t;

function mongoc_uri_copy(
           uri: Pmongoc_uri_t): Pmongoc_uri_t; cdecl; external 'mongoc2.dll';

procedure mongoc_uri_destroy(
            uri: Pmongoc_uri_t); cdecl; external 'mongoc2.dll';

function mongoc_uri_new(
           uri_string: PAnsiChar): Pmongoc_uri_t; cdecl; external 'mongoc2.dll';

function mongoc_uri_new_with_error(
           uri_string: PAnsiChar;
           error: Pbson_error_t): Pmongoc_uri_t; cdecl; external 'mongoc2.dll';

function mongoc_uri_new_for_host_port(
           hostname: PAnsiChar;
           port: uint16_t): Pmongoc_uri_t; cdecl; external 'mongoc2.dll';

function mongoc_uri_get_hosts(
           uri: Pmongoc_uri_t): Pmongoc_host_list_t; cdecl; external 'mongoc2.dll';

function mongoc_uri_get_srv_hostname(
           uri: Pmongoc_uri_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_uri_get_srv_service_name(
           uri: Pmongoc_uri_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_uri_get_database(
           uri: Pmongoc_uri_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_uri_set_database(
           uri: Pmongoc_uri_t;
           database: PAnsiChar): bool; cdecl; external 'mongoc2.dll';

function mongoc_uri_get_compressors(
           uri: Pmongoc_uri_t): Pbson_t; cdecl; external 'mongoc2.dll';

function mongoc_uri_get_options(
           uri: Pmongoc_uri_t): Pbson_t; cdecl; external 'mongoc2.dll';

function mongoc_uri_get_password(
           uri: Pmongoc_uri_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_uri_set_password(
           uri: Pmongoc_uri_t;
           password: PAnsiChar): bool; cdecl; external 'mongoc2.dll';

function mongoc_uri_has_option(
           uri: Pmongoc_uri_t;
           key: PAnsiChar): bool; cdecl; external 'mongoc2.dll';

function mongoc_uri_option_is_int32(
           key: PAnsiChar): bool; cdecl; external 'mongoc2.dll';

function mongoc_uri_option_is_int64(
           key: PAnsiChar): bool; cdecl; external 'mongoc2.dll';

function mongoc_uri_option_is_bool(
           key: PAnsiChar): bool; cdecl; external 'mongoc2.dll';

function mongoc_uri_option_is_utf8(
           key: PAnsiChar): bool; cdecl; external 'mongoc2.dll';

function mongoc_uri_get_option_as_int32(
           uri: Pmongoc_uri_t;
           option: PAnsiChar;
           fallback: int32_t): int32_t; cdecl; external 'mongoc2.dll';

function mongoc_uri_get_option_as_int64(
           uri: Pmongoc_uri_t;
           option: PAnsiChar;
           fallback: int64_t): int64_t; cdecl; external 'mongoc2.dll';

function mongoc_uri_get_option_as_bool(
           uri: Pmongoc_uri_t;
           option: PAnsiChar;
           fallback: bool): bool; cdecl; external 'mongoc2.dll';

function mongoc_uri_get_option_as_utf8(
           uri: Pmongoc_uri_t;
           option: PAnsiChar;
           fallback: PAnsiChar): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_uri_set_option_as_int32(
           uri: Pmongoc_uri_t;
           option: PAnsiChar;
           value: int32_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_uri_set_option_as_int64(
           uri: Pmongoc_uri_t;
           option: PAnsiChar;
           value: int64_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_uri_set_option_as_bool(
           uri: Pmongoc_uri_t;
           option: PAnsiChar;
           value: bool): bool; cdecl; external 'mongoc2.dll';

function mongoc_uri_set_option_as_utf8(
           uri: Pmongoc_uri_t;
           option: PAnsiChar;
           value: PAnsiChar): bool; cdecl; external 'mongoc2.dll';

function mongoc_uri_get_replica_set(
           uri: Pmongoc_uri_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_uri_get_string(
           uri: Pmongoc_uri_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_uri_get_username(
           uri: Pmongoc_uri_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_uri_set_username(
           uri: Pmongoc_uri_t;
           username: PAnsiChar): bool; cdecl; external 'mongoc2.dll';

function mongoc_uri_get_credentials(
           uri: Pmongoc_uri_t): Pbson_t; cdecl; external 'mongoc2.dll';

function mongoc_uri_get_auth_source(
           uri: Pmongoc_uri_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_uri_set_auth_source(
           uri: Pmongoc_uri_t;
           value: PAnsiChar): bool; cdecl; external 'mongoc2.dll';

function mongoc_uri_get_appname(
           uri: Pmongoc_uri_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_uri_set_appname(
           uri: Pmongoc_uri_t;
           value: PAnsiChar): bool; cdecl; external 'mongoc2.dll';

function mongoc_uri_set_compressors(
           uri: Pmongoc_uri_t;
           value: PAnsiChar): bool; cdecl; external 'mongoc2.dll';

function mongoc_uri_get_auth_mechanism(
           uri: Pmongoc_uri_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_uri_set_auth_mechanism(
           uri: Pmongoc_uri_t;
           value: PAnsiChar): bool; cdecl; external 'mongoc2.dll';

function mongoc_uri_get_mechanism_properties(
           uri: Pmongoc_uri_t;
           properties: Pbson_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_uri_set_mechanism_properties(
           uri: Pmongoc_uri_t;
           properties: Pbson_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_uri_get_tls(
           uri: Pmongoc_uri_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_uri_unescape(
           escaped_string: PAnsiChar): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_uri_get_read_prefs_t(
           uri: Pmongoc_uri_t): Pmongoc_read_prefs_t; cdecl; external 'mongoc2.dll';

procedure mongoc_uri_set_read_prefs_t(
            uri: Pmongoc_uri_t;
            prefs: Pmongoc_read_prefs_t); cdecl; external 'mongoc2.dll';

function mongoc_uri_get_write_concern(
           uri: Pmongoc_uri_t): Pmongoc_write_concern_t; cdecl; external 'mongoc2.dll';

procedure mongoc_uri_set_write_concern(
            uri: Pmongoc_uri_t;
            wc: Pmongoc_write_concern_t); cdecl; external 'mongoc2.dll';

function mongoc_uri_get_read_concern(
           uri: Pmongoc_uri_t): Pmongoc_read_concern_t; cdecl; external 'mongoc2.dll';

procedure mongoc_uri_set_read_concern(
            uri: Pmongoc_uri_t;
            rc: Pmongoc_read_concern_t); cdecl; external 'mongoc2.dll';

function mongoc_uri_get_server_monitoring_mode(
           uri: Pmongoc_uri_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_uri_set_server_monitoring_mode(
           uri: Pmongoc_uri_t;
           value: PAnsiChar): bool; cdecl; external 'mongoc2.dll';

///////////////////////
// mongoc-collection //
///////////////////////

type
  _mongoc_collection_t = record
  end;
  mongoc_collection_t = _mongoc_collection_t;
  Pmongoc_collection_t = ^mongoc_collection_t;

function mongoc_collection_aggregate(
           collection: Pmongoc_collection_t;
           flags: mongoc_query_flags_t;
           pipeline: Pbson_t;
           opts: Pbson_t;
           read_prefs: Pmongoc_read_prefs_t): Pmongoc_cursor_t; cdecl; external 'mongoc2.dll';

procedure mongoc_collection_destroy(
            collection: Pmongoc_collection_t); cdecl; external 'mongoc2.dll';

function mongoc_collection_copy(
           collection: Pmongoc_collection_t): Pmongoc_collection_t; cdecl; external 'mongoc2.dll';

function mongoc_collection_read_command_with_opts(
           collection: Pmongoc_collection_t;
           command: Pbson_t;
           read_prefs: Pmongoc_read_prefs_t;
           opts: Pbson_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_write_command_with_opts(
           collection: Pmongoc_collection_t;
           command: Pbson_t;
           opts: Pbson_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_read_write_command_with_opts(
           collection: Pmongoc_collection_t;
           command: Pbson_t;
           read_prefs: Pmongoc_read_prefs_t; // IGNORED
           opts: Pbson_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_command_with_opts(
           collection: Pmongoc_collection_t;
           command: Pbson_t;
           read_prefs: Pmongoc_read_prefs_t;
           opts: Pbson_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_command_simple(
           collection: Pmongoc_collection_t;
           command: Pbson_t;
           read_prefs: Pmongoc_read_prefs_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_drop(
           collection: Pmongoc_collection_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_drop_with_opts(
           collection: Pmongoc_collection_t;
           opts: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_drop_index(
           collection: Pmongoc_collection_t;
           index_name: PAnsiChar;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_drop_index_with_opts(
           collection: Pmongoc_collection_t;
           index_name: PAnsiChar;
           opts: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_find_indexes_with_opts(
           collection: Pmongoc_collection_t;
           opts: Pbson_t): Pmongoc_cursor_t; cdecl; external 'mongoc2.dll';

type
  _mongoc_index_model_t = record
  end;
  mongoc_index_model_t = _mongoc_index_model_t;
  Pmongoc_index_model_t = ^mongoc_index_model_t;
  PPmongoc_index_model_t = ^Pmongoc_index_model_t;

function mongoc_index_model_new(
           keys: Pbson_t;
           opts: Pbson_t): Pmongoc_index_model_t; cdecl; external 'mongoc2.dll';

procedure mongoc_index_model_destroy(
            model: Pmongoc_index_model_t); cdecl; external 'mongoc2.dll';

function mongoc_collection_create_indexes_with_opts(
           collection: Pmongoc_collection_t;
           models: PPmongoc_index_model_t;
           n_models: size_t;
           opts: Pbson_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_find_with_opts(
           collection: Pmongoc_collection_t;
           filter: Pbson_t;
           opts: Pbson_t;
           read_prefs: Pmongoc_read_prefs_t): Pmongoc_cursor_t; cdecl; external 'mongoc2.dll';

function mongoc_collection_insert(
           collection: Pmongoc_collection_t;
           flags: mongoc_insert_flags_t;
           document: Pbson_t;
           write_concern: Pmongoc_write_concern_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_insert_one(
           collection: Pmongoc_collection_t;
           document: Pbson_t;
           opts: Pbson_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_insert_many(
           collection: Pmongoc_collection_t;
           documents: PPbson_t;
           n_documents: size_t;
           opts: Pbson_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_update(
           collection: Pmongoc_collection_t;
           flags: mongoc_update_flags_t;
           selector: Pbson_t;
           update: Pbson_t;
           write_concern: Pmongoc_write_concern_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_update_one(
           collection: Pmongoc_collection_t;
           selector: Pbson_t;
           update: Pbson_t;
           opts: Pbson_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_update_many(
           collection: Pmongoc_collection_t;
           selector: Pbson_t;
           update: Pbson_t;
           opts: Pbson_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_replace_one(
           collection: Pmongoc_collection_t;
           selector: Pbson_t;
           replacement: Pbson_t;
           opts: Pbson_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_remove(
           collection: Pmongoc_collection_t;
           flags: mongoc_remove_flags_t;
           selector: Pbson_t;
           write_concern: Pmongoc_write_concern_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_delete_one(
           collection: Pmongoc_collection_t;
           selector: Pbson_t;
           opts: Pbson_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_delete_many(
           collection: Pmongoc_collection_t;
           selector: Pbson_t;
           opts: Pbson_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_rename(
           collection: Pmongoc_collection_t;
           new_db: PAnsiChar;
           new_name: PAnsiChar;
           drop_target_before_rename: bool;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_rename_with_opts(
           collection: Pmongoc_collection_t;
           new_db: PAnsiChar;
           new_name: PAnsiChar;
           drop_target_before_rename: bool;
           opts: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_find_and_modify_with_opts(
           collection: Pmongoc_collection_t;
           query: Pbson_t;
           opts: Pmongoc_find_and_modify_opts_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_find_and_modify(
           collection: Pmongoc_collection_t;
           query: Pbson_t;
           sort: Pbson_t;
           update: Pbson_t;
           fields: Pbson_t;
           _remove: bool;
           upsert: bool;
           _new: bool;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_collection_create_bulk_operation_with_opts(
           collection: Pmongoc_collection_t;
           opts: Pbson_t): Pmongoc_bulk_operation_t; cdecl; external 'mongoc2.dll';

function mongoc_collection_get_read_prefs(
           collection: Pmongoc_collection_t): Pmongoc_read_prefs_t; cdecl; external 'mongoc2.dll';

procedure mongoc_collection_set_read_prefs(
            collection: Pmongoc_collection_t;
            read_prefs: Pmongoc_read_prefs_t); cdecl; external 'mongoc2.dll';

function mongoc_collection_get_read_concern(
           collection: Pmongoc_collection_t): Pmongoc_read_concern_t; cdecl; external 'mongoc2.dll';

procedure mongoc_collection_set_read_concern(
            collection: Pmongoc_collection_t;
            read_concern: Pmongoc_read_concern_t); cdecl; external 'mongoc2.dll';

function mongoc_collection_get_write_concern(
           collection: Pmongoc_collection_t): Pmongoc_write_concern_t; cdecl; external 'mongoc2.dll';

procedure mongoc_collection_set_write_concern(
            collection: Pmongoc_collection_t;
            write_concern: Pmongoc_write_concern_t); cdecl; external 'mongoc2.dll';

function mongoc_collection_get_name(
           collection: Pmongoc_collection_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_collection_keys_to_index_string(
           keys: Pbson_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_collection_watch(
           coll: Pmongoc_collection_t;
           pipeline: Pbson_t;
           opts: Pbson_t): Pmongoc_change_stream_t; cdecl; external 'mongoc2.dll';

function mongoc_collection_count_documents(
           coll: Pmongoc_collection_t;
           filter: Pbson_t;
           opts: Pbson_t;
           read_prefs: Pmongoc_read_prefs_t;
           reply: Pbson_t;
           error: Pbson_error_t): int64_t; cdecl; external 'mongoc2.dll';

function mongoc_collection_estimated_document_count(
           coll: Pmongoc_collection_t;
           opts: Pbson_t;
           read_prefs: Pmongoc_read_prefs_t;
           reply: Pbson_t;
           error: Pbson_error_t): int64_t; cdecl; external 'mongoc2.dll';

/////////////////////
// mongoc-database //
/////////////////////

type
  _mongoc_database_t = record
  end;
  mongoc_database_t = _mongoc_database_t;
  Pmongoc_database_t = ^mongoc_database_t;

function mongoc_database_get_name(
           database: Pmongoc_database_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_database_remove_user(
           database: Pmongoc_database_t;
           username: PAnsiChar;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_database_remove_all_users(
           database: Pmongoc_database_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_database_add_user(
           database: Pmongoc_database_t;
           username: PAnsiChar;
           password: PAnsiChar;
           roles: Pbson_t;
           custom_data: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

procedure mongoc_database_destroy(
            database: Pmongoc_database_t); cdecl; external 'mongoc2.dll';

function mongoc_database_aggregate(
           db: Pmongoc_database_t;
           pipeline: Pbson_t;
           opts: Pbson_t;
           read_prefs: Pmongoc_read_prefs_t): Pmongoc_cursor_t; cdecl; external 'mongoc2.dll';

function mongoc_database_copy(
           database: Pmongoc_database_t): Pmongoc_database_t; cdecl; external 'mongoc2.dll';

function mongoc_database_read_command_with_opts(
           database: Pmongoc_database_t;
           command: Pbson_t;
           read_prefs: Pmongoc_read_prefs_t;
           opts: Pbson_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_database_write_command_with_opts(
           database: Pmongoc_database_t;
           command: Pbson_t;
           opts: Pbson_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_database_read_write_command_with_opts(
           database: Pmongoc_database_t;
           command: Pbson_t;
           read_prefs: Pmongoc_read_prefs_t; // IGNORED
           opts: Pbson_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_database_command_with_opts(
           database: Pmongoc_database_t;
           command: Pbson_t;
           read_prefs: Pmongoc_read_prefs_t;
           opts: Pbson_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_database_command_simple(
           database: Pmongoc_database_t;
           command: Pbson_t;
           read_prefs: Pmongoc_read_prefs_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_database_drop(
           database: Pmongoc_database_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_database_drop_with_opts(
           database: Pmongoc_database_t;
           opts: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_database_has_collection(
           database: Pmongoc_database_t;
           name: PAnsiChar;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_database_create_collection(
           database: Pmongoc_database_t;
           name: PAnsiChar;
           options: Pbson_t;
           error: Pbson_error_t): Pmongoc_collection_t; cdecl; external 'mongoc2.dll';

function mongoc_database_get_read_prefs(
           database: Pmongoc_database_t): Pmongoc_read_prefs_t; cdecl; external 'mongoc2.dll';

procedure mongoc_database_set_read_prefs(
            database: Pmongoc_database_t;
            read_prefs: Pmongoc_read_prefs_t); cdecl; external 'mongoc2.dll';

function mongoc_database_get_write_concern(
           database: Pmongoc_database_t): Pmongoc_write_concern_t; cdecl; external 'mongoc2.dll';

procedure mongoc_database_set_write_concern(
            database: Pmongoc_database_t;
            write_concern: Pmongoc_write_concern_t); cdecl; external 'mongoc2.dll';

function mongoc_database_get_read_concern(
           database: Pmongoc_database_t): Pmongoc_read_concern_t; cdecl; external 'mongoc2.dll';

procedure mongoc_database_set_read_concern(
            database: Pmongoc_database_t;
            read_concern: Pmongoc_read_concern_t); cdecl; external 'mongoc2.dll';

function mongoc_database_find_collections_with_opts(
           database: Pmongoc_database_t;
           opts: Pbson_t): Pmongoc_cursor_t; cdecl; external 'mongoc2.dll';

function mongoc_database_get_collection_names_with_opts(
           database: Pmongoc_database_t;
           opts: Pbson_t;
           error: Pbson_error_t): PPAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_database_get_collection(
           database: Pmongoc_database_t;
           name: PAnsiChar): Pmongoc_collection_t; cdecl; external 'mongoc2.dll';

function mongoc_database_watch(
           db: Pmongoc_database_t;
           pipeline: Pbson_t;
           opts: Pbson_t): Pmongoc_change_stream_t; cdecl; external 'mongoc2.dll';

////////////////////////
// mongoc-gridfs-file //
////////////////////////

// #define MONGOC_GRIDFS_FILE_STR_HEADER(name) char * __CALLCONV__ mongoc_gridfs_file_get_##name(mongoc_gridfs_file_t * file); void __CALLCONV__ mongoc_gridfs_file_set_##name(mongoc_gridfs_file_t * file, const char * str);

// #define MONGOC_GRIDFS_FILE_BSON_HEADER(name) bson_t * __CALLCONV__ mongoc_gridfs_file_get_##name(mongoc_gridfs_file_t * file); void __CALLCONV__ mongoc_gridfs_file_set_##name(mongoc_gridfs_file_t * file, const bson_t * bson);

type
  _mongoc_gridfs_file_t = record
  end;
  mongoc_gridfs_file_t = _mongoc_gridfs_file_t;
  Pmongoc_gridfs_file_t = ^mongoc_gridfs_file_t;
type
  _mongoc_gridfs_file_opt_t = record
  end;
  mongoc_gridfs_file_opt_t = _mongoc_gridfs_file_opt_t;
  Pmongoc_gridfs_file_opt_t = ^mongoc_gridfs_file_opt_t;

// struct _mongoc_gridfs_file_opt_t {
// const char * md5;
// const char * filename;
// const char * content_type;
// const bson_t * aliases;
// const bson_t * metadata;
// uint32_t chunk_size;
// };

// MONGOC_GRIDFS_FILE_STR_HEADER(md5)
// MONGOC_GRIDFS_FILE_STR_HEADER(filename)
// MONGOC_GRIDFS_FILE_STR_HEADER(content_type)
// MONGOC_GRIDFS_FILE_BSON_HEADER(aliases)
// MONGOC_GRIDFS_FILE_BSON_HEADER(metadata)

function mongoc_gridfs_file_get_id(
           &file: Pmongoc_gridfs_file_t): Pbson_value_t; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_file_get_length(
           &file: Pmongoc_gridfs_file_t): int64_t; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_file_get_chunk_size(
           &file: Pmongoc_gridfs_file_t): int32_t; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_file_get_upload_date(
           &file: Pmongoc_gridfs_file_t): int64_t; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_file_writev(
           &file: Pmongoc_gridfs_file_t;
           iov: Pmongoc_iovec_t;
           iovcnt: size_t;
           timeout_msec: uint32_t): ssize_t; cdecl; external 'mongoc2.dll';
function mongoc_gridfs_file_readv(
           &file: Pmongoc_gridfs_file_t;
           iov: Pmongoc_iovec_t;
           iovcnt: size_t;
           min_bytes: size_t;
           timeout_msec: uint32_t): ssize_t; cdecl; external 'mongoc2.dll';
function mongoc_gridfs_file_seek(
           &file: Pmongoc_gridfs_file_t;
           delta: int64_t;
           whence: Integer): Integer; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_file_tell(
           &file: Pmongoc_gridfs_file_t): uint64_t; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_file_set_id(
           &file: Pmongoc_gridfs_file_t;
           id: Pbson_value_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_file_save(
           &file: Pmongoc_gridfs_file_t): bool; cdecl; external 'mongoc2.dll';

procedure mongoc_gridfs_file_destroy(
            &file: Pmongoc_gridfs_file_t); cdecl; external 'mongoc2.dll';

function mongoc_gridfs_file_error(
           &file: Pmongoc_gridfs_file_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_file_remove(
           &file: Pmongoc_gridfs_file_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

/////////////////////////////
// mongoc-gridfs-file-list //
/////////////////////////////

type
  _mongoc_gridfs_file_list_t = record
  end;
  mongoc_gridfs_file_list_t = _mongoc_gridfs_file_list_t;
  Pmongoc_gridfs_file_list_t = ^mongoc_gridfs_file_list_t;

function mongoc_gridfs_file_list_next(
           list: Pmongoc_gridfs_file_list_t): Pmongoc_gridfs_file_t; cdecl; external 'mongoc2.dll';
procedure mongoc_gridfs_file_list_destroy(
            list: Pmongoc_gridfs_file_list_t); cdecl; external 'mongoc2.dll';
function mongoc_gridfs_file_list_error(
           list: Pmongoc_gridfs_file_list_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

/////////////////////////////
// mongoc-gridfs-file-page //
/////////////////////////////

type
  _mongoc_gridfs_file_page_t = record
  end;
  mongoc_gridfs_file_page_t = _mongoc_gridfs_file_page_t;

//////////////////////////
// mongoc-gridfs-bucket //
//////////////////////////

type
  _mongoc_gridfs_bucket_t = record
  end;
  mongoc_gridfs_bucket_t = _mongoc_gridfs_bucket_t;
  Pmongoc_gridfs_bucket_t = ^mongoc_gridfs_bucket_t;

function mongoc_gridfs_bucket_new(
           db: Pmongoc_database_t;
           opts: Pbson_t;
           read_prefs: Pmongoc_read_prefs_t;
           error: Pbson_error_t): Pmongoc_gridfs_bucket_t; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_bucket_open_upload_stream(
           bucket: Pmongoc_gridfs_bucket_t;
           filename: PAnsiChar;
           opts: Pbson_t;
           file_id: Pbson_value_t;
           error: Pbson_error_t): Pmongoc_stream_t; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_bucket_open_upload_stream_with_id(
           bucket: Pmongoc_gridfs_bucket_t;
           file_id: Pbson_value_t;
           filename: PAnsiChar;
           opts: Pbson_t;
           error: Pbson_error_t): Pmongoc_stream_t; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_bucket_upload_from_stream(
           bucket: Pmongoc_gridfs_bucket_t;
           filename: PAnsiChar;
           source: Pmongoc_stream_t;
           opts: Pbson_t;
           file_id: Pbson_value_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_bucket_upload_from_stream_with_id(
           bucket: Pmongoc_gridfs_bucket_t;
           file_id: Pbson_value_t;
           filename: PAnsiChar;
           source: Pmongoc_stream_t;
           opts: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_bucket_open_download_stream(
           bucket: Pmongoc_gridfs_bucket_t;
           file_id: Pbson_value_t;
           error: Pbson_error_t): Pmongoc_stream_t; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_bucket_download_to_stream(
           bucket: Pmongoc_gridfs_bucket_t;
           file_id: Pbson_value_t;
           destination: Pmongoc_stream_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_bucket_delete_by_id(
           bucket: Pmongoc_gridfs_bucket_t;
           file_id: Pbson_value_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_bucket_find(
           bucket: Pmongoc_gridfs_bucket_t;
           filter: Pbson_t;
           opts: Pbson_t): Pmongoc_cursor_t; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_bucket_stream_error(
           stream: Pmongoc_stream_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

procedure mongoc_gridfs_bucket_destroy(
            bucket: Pmongoc_gridfs_bucket_t); cdecl; external 'mongoc2.dll';

function mongoc_gridfs_bucket_abort_upload(
           stream: Pmongoc_stream_t): bool; cdecl; external 'mongoc2.dll';

///////////////////
// mongoc-gridfs //
///////////////////

type
  _mongoc_gridfs_t = record
  end;
  mongoc_gridfs_t = _mongoc_gridfs_t;
  Pmongoc_gridfs_t = ^mongoc_gridfs_t;

function mongoc_gridfs_create_file_from_stream(
           gridfs: Pmongoc_gridfs_t;
           stream: Pmongoc_stream_t;
           opt: Pmongoc_gridfs_file_opt_t): Pmongoc_gridfs_file_t; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_create_file(
           gridfs: Pmongoc_gridfs_t;
           opt: Pmongoc_gridfs_file_opt_t): Pmongoc_gridfs_file_t; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_find_with_opts(
           gridfs: Pmongoc_gridfs_t;
           filter: Pbson_t;
           opts: Pbson_t): Pmongoc_gridfs_file_list_t; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_find_one_with_opts(
           gridfs: Pmongoc_gridfs_t;
           filter: Pbson_t;
           opts: Pbson_t;
           error: Pbson_error_t): Pmongoc_gridfs_file_t; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_find_one_by_filename(
           gridfs: Pmongoc_gridfs_t;
           filename: PAnsiChar;
           error: Pbson_error_t): Pmongoc_gridfs_file_t; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_drop(
           gridfs: Pmongoc_gridfs_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

procedure mongoc_gridfs_destroy(
            gridfs: Pmongoc_gridfs_t); cdecl; external 'mongoc2.dll';

function mongoc_gridfs_get_files(
           gridfs: Pmongoc_gridfs_t): Pmongoc_collection_t; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_get_chunks(
           gridfs: Pmongoc_gridfs_t): Pmongoc_collection_t; cdecl; external 'mongoc2.dll';

function mongoc_gridfs_remove_by_filename(
           gridfs: Pmongoc_gridfs_t;
           filename: PAnsiChar;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

//////////////////////////
// mongoc-stream-gridfs //
//////////////////////////

function mongoc_stream_gridfs_new(
           &file: Pmongoc_gridfs_file_t): Pmongoc_stream_t; cdecl; external 'mongoc2.dll';

///////////////////
// mongoc-client //
///////////////////

// * This define is part of our public API. But per MongoDB 4.4, there is no
// * longer a size limit on collection names.
const MONGOC_NAMESPACE_MAX = 128;

const MONGOC_DEFAULT_CONNECTTIMEOUTMS = (10 * 1000);

// *
// * NOTE: The default socket timeout for connections is 5 minutes. This
// * means that if your MongoDB server dies or becomes unavailable
// * it will take 5 minutes to detect this.
// *
// * You can change this by providing sockettimeoutms= in your
// * connection URI.
// *
const MONGOC_DEFAULT_SOCKETTIMEOUTMS = (1000 * 60 * 5);

// * *
// * mongoc_client_t:
// *
// * The mongoc_client_t structure maintains information about a connection to
// * a MongoDB server.
// *
type
  _mongoc_client_t = record
  end;
  mongoc_client_t = _mongoc_client_t;
  Pmongoc_client_t = ^mongoc_client_t;

type
  _mongoc_client_session_t = record
  end;
  mongoc_client_session_t = _mongoc_client_session_t;
  Pmongoc_client_session_t = ^mongoc_client_session_t;
type
  _mongoc_session_opt_t = record
  end;
  mongoc_session_opt_t = _mongoc_session_opt_t;
  Pmongoc_session_opt_t = ^mongoc_session_opt_t;
type
  _mongoc_transaction_opt_t = record
  end;
  mongoc_transaction_opt_t = _mongoc_transaction_opt_t;
  Pmongoc_transaction_opt_t = ^mongoc_transaction_opt_t;

// * *
// * mongoc_stream_initiator_t:
// * @uri: The uri and options for the stream.
// * @host: The host and port (or UNIX domain socket path) to connect to.
// * @user_data: The pointer passed to mongoc_client_set_stream_initiator.
// * @error: A location for an error.
// *
// * Creates a new mongoc_stream_t for the host and port. Begin a
// * non-blocking connect and return immediately.
// *
// * This can be used by language bindings to create network transports other
// * than those built into libmongoc. An example of such would be the streams
// * API provided by PHP.
// *
// * Returns: A newly allocated mongoc_stream_t or NULL on failure.
// *
type
  mongoc_stream_initiator_t = function (
    uri: Pmongoc_uri_t;
    host: Pmongoc_host_list_t;
    user_data: Pvoid;
    error: Pbson_error_t): Pmongoc_stream_t; cdecl;

function mongoc_client_new(
           uri_string: PAnsiChar): Pmongoc_client_t; cdecl; external 'mongoc2.dll';

function mongoc_client_new_from_uri(
           uri: Pmongoc_uri_t): Pmongoc_client_t; cdecl; external 'mongoc2.dll';

function mongoc_client_new_from_uri_with_error(
           uri: Pmongoc_uri_t;
           error: Pbson_error_t): Pmongoc_client_t; cdecl; external 'mongoc2.dll';

procedure mongoc_client_set_sockettimeoutms(
            client: Pmongoc_client_t;
            timeoutms: int32_t); cdecl; external 'mongoc2.dll';

function mongoc_client_get_uri(
           client: Pmongoc_client_t): Pmongoc_uri_t; cdecl; external 'mongoc2.dll';

procedure mongoc_client_set_stream_initiator(
            client: Pmongoc_client_t;
            initiator: mongoc_stream_initiator_t;
            user_data: Pvoid); cdecl; external 'mongoc2.dll';

function mongoc_client_command_simple(
           client: Pmongoc_client_t;
           db_name: PAnsiChar;
           command: Pbson_t;
           read_prefs: Pmongoc_read_prefs_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_read_command_with_opts(
           client: Pmongoc_client_t;
           db_name: PAnsiChar;
           command: Pbson_t;
           read_prefs: Pmongoc_read_prefs_t;
           opts: Pbson_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_write_command_with_opts(
           client: Pmongoc_client_t;
           db_name: PAnsiChar;
           command: Pbson_t;
           opts: Pbson_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_read_write_command_with_opts(
           client: Pmongoc_client_t;
           db_name: PAnsiChar;
           command: Pbson_t;
           read_prefs: Pmongoc_read_prefs_t; // IGNORED
           opts: Pbson_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_command_with_opts(
           client: Pmongoc_client_t;
           db_name: PAnsiChar;
           command: Pbson_t;
           read_prefs: Pmongoc_read_prefs_t;
           opts: Pbson_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_command_simple_with_server_id(
           client: Pmongoc_client_t;
           db_name: PAnsiChar;
           command: Pbson_t;
           read_prefs: Pmongoc_read_prefs_t;
           server_id: uint32_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

procedure mongoc_client_destroy(
            client: Pmongoc_client_t); cdecl; external 'mongoc2.dll';

function mongoc_client_start_session(
           client: Pmongoc_client_t;
           opts: Pmongoc_session_opt_t;
           error: Pbson_error_t): Pmongoc_client_session_t; cdecl; external 'mongoc2.dll';

function mongoc_client_get_database(
           client: Pmongoc_client_t;
           name: PAnsiChar): Pmongoc_database_t; cdecl; external 'mongoc2.dll';

function mongoc_client_get_default_database(
           client: Pmongoc_client_t): Pmongoc_database_t; cdecl; external 'mongoc2.dll';

function mongoc_client_get_gridfs(
           client: Pmongoc_client_t;
           db: PAnsiChar;
           prefix: PAnsiChar;
           error: Pbson_error_t): Pmongoc_gridfs_t; cdecl; external 'mongoc2.dll';

function mongoc_client_get_collection(
           client: Pmongoc_client_t;
           db: PAnsiChar;
           collection: PAnsiChar): Pmongoc_collection_t; cdecl; external 'mongoc2.dll';

// BSON_DEPRECATED_FOR(mongoc_client_get_database_names_with_opts)
function mongoc_client_get_database_names(
           client: Pmongoc_client_t;
           error: Pbson_error_t): PPAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_client_get_database_names_with_opts(
           client: Pmongoc_client_t;
           opts: Pbson_t;
           error: Pbson_error_t): PPAnsiChar; cdecl; external 'mongoc2.dll';

// BSON_DEPRECATED_FOR(mongoc_client_find_databases_with_opts)
function mongoc_client_find_databases(
           client: Pmongoc_client_t;
           error: Pbson_error_t): Pmongoc_cursor_t; cdecl; external 'mongoc2.dll';

function mongoc_client_find_databases_with_opts(
           client: Pmongoc_client_t;
           opts: Pbson_t): Pmongoc_cursor_t; cdecl; external 'mongoc2.dll';

function mongoc_client_get_write_concern(
           client: Pmongoc_client_t): Pmongoc_write_concern_t; cdecl; external 'mongoc2.dll';

procedure mongoc_client_set_write_concern(
            client: Pmongoc_client_t;
            write_concern: Pmongoc_write_concern_t); cdecl; external 'mongoc2.dll';

function mongoc_client_get_read_concern(
           client: Pmongoc_client_t): Pmongoc_read_concern_t; cdecl; external 'mongoc2.dll';

procedure mongoc_client_set_read_concern(
            client: Pmongoc_client_t;
            read_concern: Pmongoc_read_concern_t); cdecl; external 'mongoc2.dll';

function mongoc_client_get_read_prefs(
           client: Pmongoc_client_t): Pmongoc_read_prefs_t; cdecl; external 'mongoc2.dll';

procedure mongoc_client_set_read_prefs(
            client: Pmongoc_client_t;
            read_prefs: Pmongoc_read_prefs_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_set_ssl_opts(
            client: Pmongoc_client_t;
            opts: Pmongoc_ssl_opt_t); cdecl; external 'mongoc2.dll';

function mongoc_client_set_apm_callbacks(
           client: Pmongoc_client_t;
           callbacks: Pmongoc_apm_callbacks_t;
           context: Pvoid): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_set_structured_log_opts(
           client: Pmongoc_client_t;
           opts: Pmongoc_structured_log_opts_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_get_server_description(
           client: Pmongoc_client_t;
           server_id: uint32_t): Pmongoc_server_description_t; cdecl; external 'mongoc2.dll';

function mongoc_client_get_server_descriptions(
           client: Pmongoc_client_t;
           n: Psize_t): PPmongoc_server_description_t; cdecl; external 'mongoc2.dll';

procedure mongoc_server_descriptions_destroy_all(
            sds: PPmongoc_server_description_t;
            n: size_t); cdecl; external 'mongoc2.dll';

function mongoc_client_select_server(
           client: Pmongoc_client_t;
           for_writes: bool;
           prefs: Pmongoc_read_prefs_t;
           error: Pbson_error_t): Pmongoc_server_description_t; cdecl; external 'mongoc2.dll';

function mongoc_client_set_error_api(
           client: Pmongoc_client_t;
           version: int32_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_set_appname(
           client: Pmongoc_client_t;
           appname: PAnsiChar): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_watch(
           client: Pmongoc_client_t;
           pipeline: Pbson_t;
           opts: Pbson_t): Pmongoc_change_stream_t; cdecl; external 'mongoc2.dll';

procedure mongoc_client_reset(
            client: Pmongoc_client_t); cdecl; external 'mongoc2.dll';

function mongoc_client_enable_auto_encryption(
           client: Pmongoc_client_t;
           opts: Pmongoc_auto_encryption_opts_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_get_crypt_shared_version(
           client: Pmongoc_client_t): PAnsiChar; cdecl; external 'mongoc2.dll';

function mongoc_client_set_server_api(
           client: Pmongoc_client_t;
           api: Pmongoc_server_api_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_get_handshake_description(
           client: Pmongoc_client_t;
           server_id: uint32_t;
           opts: Pbson_t;
           error: Pbson_error_t): Pmongoc_server_description_t; cdecl; external 'mongoc2.dll';

function mongoc_client_set_oidc_callback(
           client: Pmongoc_client_t;
           callback: Pmongoc_oidc_callback_t): bool; cdecl; external 'mongoc2.dll';

////////////////////////
// mongoc-client-pool //
////////////////////////

type
  _mongoc_client_pool_t = record
  end;
  mongoc_client_pool_t = _mongoc_client_pool_t;
  Pmongoc_client_pool_t = ^mongoc_client_pool_t;

function mongoc_client_pool_new(
           uri: Pmongoc_uri_t): Pmongoc_client_pool_t; cdecl; external 'mongoc2.dll';

function mongoc_client_pool_new_with_error(
           uri: Pmongoc_uri_t;
           error: Pbson_error_t): Pmongoc_client_pool_t; cdecl; external 'mongoc2.dll';

procedure mongoc_client_pool_destroy(
            pool: Pmongoc_client_pool_t); cdecl; external 'mongoc2.dll';

function mongoc_client_pool_pop(
           pool: Pmongoc_client_pool_t): Pmongoc_client_t; cdecl; external 'mongoc2.dll';

procedure mongoc_client_pool_push(
            pool: Pmongoc_client_pool_t;
            client: Pmongoc_client_t); cdecl; external 'mongoc2.dll';

function mongoc_client_pool_try_pop(
           pool: Pmongoc_client_pool_t): Pmongoc_client_t; cdecl; external 'mongoc2.dll';

procedure mongoc_client_pool_max_size(
            pool: Pmongoc_client_pool_t;
            max_pool_size: uint32_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_pool_set_ssl_opts(
            pool: Pmongoc_client_pool_t;
            opts: Pmongoc_ssl_opt_t); cdecl; external 'mongoc2.dll';

function mongoc_client_pool_set_apm_callbacks(
           pool: Pmongoc_client_pool_t;
           callbacks: Pmongoc_apm_callbacks_t;
           context: Pvoid): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_pool_set_error_api(
           pool: Pmongoc_client_pool_t;
           version: int32_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_pool_set_appname(
           pool: Pmongoc_client_pool_t;
           appname: PAnsiChar): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_pool_enable_auto_encryption(
           pool: Pmongoc_client_pool_t;
           opts: Pmongoc_auto_encryption_opts_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_pool_set_server_api(
           pool: Pmongoc_client_pool_t;
           api: Pmongoc_server_api_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_pool_set_structured_log_opts(
           pool: Pmongoc_client_pool_t;
           opts: Pmongoc_structured_log_opts_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_pool_set_oidc_callback(
           pool: Pmongoc_client_pool_t;
           callback: Pmongoc_oidc_callback_t): bool; cdecl; external 'mongoc2.dll';

///////////////////////////
// mongoc-client-session //
///////////////////////////

// * mongoc_client_session_t, mongoc_transaction_opt_t, and
// mongoc_session_opt_t are typedef'ed here

type
  mongoc_client_session_with_transaction_cb_t = function (
    session: Pmongoc_client_session_t;
    ctx: Pvoid;
    reply: PPbson_t;
    error: Pbson_error_t): bool; cdecl;

type
  mongoc_transaction_state_t = (
    MONGOC_TRANSACTION_NONE = 0,
    MONGOC_TRANSACTION_STARTING = 1,
    MONGOC_TRANSACTION_IN_PROGRESS = 2,
    MONGOC_TRANSACTION_COMMITTED = 3,
    MONGOC_TRANSACTION_ABORTED = 4);

// * these options types are named "opt_t" but their functions are named with
// * "opts", for consistency with the older mongoc_ssl_opt_t
function mongoc_transaction_opts_new(): Pmongoc_transaction_opt_t; cdecl; external 'mongoc2.dll';

function mongoc_transaction_opts_clone(
           opts: Pmongoc_transaction_opt_t): Pmongoc_transaction_opt_t; cdecl; external 'mongoc2.dll';

procedure mongoc_transaction_opts_destroy(
            opts: Pmongoc_transaction_opt_t); cdecl; external 'mongoc2.dll';

procedure mongoc_transaction_opts_set_max_commit_time_ms(
            opts: Pmongoc_transaction_opt_t;
            max_commit_time_ms: int64_t); cdecl; external 'mongoc2.dll';

function mongoc_transaction_opts_get_max_commit_time_ms(
           opts: Pmongoc_transaction_opt_t): int64_t; cdecl; external 'mongoc2.dll';

procedure mongoc_transaction_opts_set_read_concern(
            opts: Pmongoc_transaction_opt_t;
            read_concern: Pmongoc_read_concern_t); cdecl; external 'mongoc2.dll';

function mongoc_transaction_opts_get_read_concern(
           opts: Pmongoc_transaction_opt_t): Pmongoc_read_concern_t; cdecl; external 'mongoc2.dll';

procedure mongoc_transaction_opts_set_write_concern(
            opts: Pmongoc_transaction_opt_t;
            write_concern: Pmongoc_write_concern_t); cdecl; external 'mongoc2.dll';

function mongoc_transaction_opts_get_write_concern(
           opts: Pmongoc_transaction_opt_t): Pmongoc_write_concern_t; cdecl; external 'mongoc2.dll';

procedure mongoc_transaction_opts_set_read_prefs(
            opts: Pmongoc_transaction_opt_t;
            read_prefs: Pmongoc_read_prefs_t); cdecl; external 'mongoc2.dll';

function mongoc_transaction_opts_get_read_prefs(
           opts: Pmongoc_transaction_opt_t): Pmongoc_read_prefs_t; cdecl; external 'mongoc2.dll';

function mongoc_session_opts_new(): Pmongoc_session_opt_t; cdecl; external 'mongoc2.dll';

procedure mongoc_session_opts_set_causal_consistency(
            opts: Pmongoc_session_opt_t;
            causal_consistency: bool); cdecl; external 'mongoc2.dll';

function mongoc_session_opts_get_causal_consistency(
           opts: Pmongoc_session_opt_t): bool; cdecl; external 'mongoc2.dll';

procedure mongoc_session_opts_set_snapshot(
            opts: Pmongoc_session_opt_t;
            snapshot: bool); cdecl; external 'mongoc2.dll';

function mongoc_session_opts_get_snapshot(
           opts: Pmongoc_session_opt_t): bool; cdecl; external 'mongoc2.dll';

procedure mongoc_session_opts_set_default_transaction_opts(
            opts: Pmongoc_session_opt_t;
            txn_opts: Pmongoc_transaction_opt_t); cdecl; external 'mongoc2.dll';

function mongoc_session_opts_get_default_transaction_opts(
           opts: Pmongoc_session_opt_t): Pmongoc_transaction_opt_t; cdecl; external 'mongoc2.dll';

function mongoc_session_opts_get_transaction_opts(
           session: Pmongoc_client_session_t): Pmongoc_transaction_opt_t; cdecl; external 'mongoc2.dll';

function mongoc_session_opts_clone(
           opts: Pmongoc_session_opt_t): Pmongoc_session_opt_t; cdecl; external 'mongoc2.dll';

procedure mongoc_session_opts_destroy(
            opts: Pmongoc_session_opt_t); cdecl; external 'mongoc2.dll';

function mongoc_client_session_get_client(
           session: Pmongoc_client_session_t): Pmongoc_client_t; cdecl; external 'mongoc2.dll';

function mongoc_client_session_get_opts(
           session: Pmongoc_client_session_t): Pmongoc_session_opt_t; cdecl; external 'mongoc2.dll';

function mongoc_client_session_get_lsid(
           session: Pmongoc_client_session_t): Pbson_t; cdecl; external 'mongoc2.dll';

function mongoc_client_session_get_cluster_time(
           session: Pmongoc_client_session_t): Pbson_t; cdecl; external 'mongoc2.dll';

procedure mongoc_client_session_advance_cluster_time(
            session: Pmongoc_client_session_t;
            cluster_time: Pbson_t); cdecl; external 'mongoc2.dll';

procedure mongoc_client_session_get_operation_time(
            session: Pmongoc_client_session_t;
            timestamp: Puint32_t;
            increment: Puint32_t); cdecl; external 'mongoc2.dll';

function mongoc_client_session_get_server_id(
           session: Pmongoc_client_session_t): uint32_t; cdecl; external 'mongoc2.dll';

procedure mongoc_client_session_advance_operation_time(
            session: Pmongoc_client_session_t;
            timestamp: uint32_t;
            increment: uint32_t); cdecl; external 'mongoc2.dll';

function mongoc_client_session_with_transaction(
           session: Pmongoc_client_session_t;
           cb: mongoc_client_session_with_transaction_cb_t;
           opts: Pmongoc_transaction_opt_t;
           ctx: Pvoid;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_session_start_transaction(
           session: Pmongoc_client_session_t;
           opts: Pmongoc_transaction_opt_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_session_in_transaction(
           session: Pmongoc_client_session_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_session_get_transaction_state(
           session: Pmongoc_client_session_t): mongoc_transaction_state_t; cdecl; external 'mongoc2.dll';

function mongoc_client_session_commit_transaction(
           session: Pmongoc_client_session_t;
           reply: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_session_abort_transaction(
           session: Pmongoc_client_session_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

function mongoc_client_session_append(
           client_session: Pmongoc_client_session_t;
           opts: Pbson_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

// * There is no mongoc_client_session_end, only mongoc_client_session_destroy.
// * Driver Sessions Spec: "In languages that have idiomatic ways of disposing of
// * resources, drivers SHOULD support that in addition to or instead of
// * endSession."
// *

procedure mongoc_client_session_destroy(
            session: Pmongoc_client_session_t); cdecl; external 'mongoc2.dll';

function mongoc_client_session_get_dirty(
           session: Pmongoc_client_session_t): bool; cdecl; external 'mongoc2.dll';

//////////////////////
// mongoc-bulkwrite //
//////////////////////

type
  _mongoc_bulkwriteopts_t = record
  end;
  mongoc_bulkwriteopts_t = _mongoc_bulkwriteopts_t;
  Pmongoc_bulkwriteopts_t = ^mongoc_bulkwriteopts_t;
function mongoc_bulkwriteopts_new(): Pmongoc_bulkwriteopts_t; cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwriteopts_set_ordered(
            self: Pmongoc_bulkwriteopts_t;
            ordered: bool); cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwriteopts_set_bypassdocumentvalidation(
            self: Pmongoc_bulkwriteopts_t;
            bypassdocumentvalidation: bool); cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwriteopts_set_let(
            self: Pmongoc_bulkwriteopts_t;
            let: Pbson_t); cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwriteopts_set_writeconcern(
            self: Pmongoc_bulkwriteopts_t;
            writeconcern: Pmongoc_write_concern_t); cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwriteopts_set_comment(
            self: Pmongoc_bulkwriteopts_t;
            comment: Pbson_value_t); cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwriteopts_set_verboseresults(
            self: Pmongoc_bulkwriteopts_t;
            verboseresults: bool); cdecl; external 'mongoc2.dll';
// `mongoc_bulkwriteopts_set_extra` appends `extra` to bulkWrite command.
// It is intended to support future server options.
procedure mongoc_bulkwriteopts_set_extra(
            self: Pmongoc_bulkwriteopts_t;
            extra: Pbson_t); cdecl; external 'mongoc2.dll';
// `mongoc_bulkwriteopts_set_serverid` identifies which server to perform the operation. This is intended for use by
// wrapping drivers that select a server before running the operation.
procedure mongoc_bulkwriteopts_set_serverid(
            self: Pmongoc_bulkwriteopts_t;
            serverid: uint32_t); cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwriteopts_destroy(
            self: Pmongoc_bulkwriteopts_t); cdecl; external 'mongoc2.dll';

type
  _mongoc_bulkwriteresult_t = record
  end;
  mongoc_bulkwriteresult_t = _mongoc_bulkwriteresult_t;
  Pmongoc_bulkwriteresult_t = ^mongoc_bulkwriteresult_t;
function mongoc_bulkwriteresult_insertedcount(
           self: Pmongoc_bulkwriteresult_t): int64_t; cdecl; external 'mongoc2.dll';
function mongoc_bulkwriteresult_upsertedcount(
           self: Pmongoc_bulkwriteresult_t): int64_t; cdecl; external 'mongoc2.dll';
function mongoc_bulkwriteresult_matchedcount(
           self: Pmongoc_bulkwriteresult_t): int64_t; cdecl; external 'mongoc2.dll';
function mongoc_bulkwriteresult_modifiedcount(
           self: Pmongoc_bulkwriteresult_t): int64_t; cdecl; external 'mongoc2.dll';
function mongoc_bulkwriteresult_deletedcount(
           self: Pmongoc_bulkwriteresult_t): int64_t; cdecl; external 'mongoc2.dll';
// `mongoc_bulkwriteresult_insertresults` returns a BSON document mapping model indexes to insert results.
// Example:
// {
// "0" : { "insertedId" : "foo" },
// "1" : { "insertedId" : "bar" }
// }
// Returns NULL if verbose results were not requested.
function mongoc_bulkwriteresult_insertresults(
           self: Pmongoc_bulkwriteresult_t): Pbson_t; cdecl; external 'mongoc2.dll';
// `mongoc_bulkwriteresult_updateresults` returns a BSON document mapping model indexes to update results.
// Example:
// {
// "0" : { "matchedCount" : 2, "modifiedCount" : 2 },
// "1" : { "matchedCount" : 1, "modifiedCount" : 0, "upsertedId" : "foo" }
// }
// Returns NULL if verbose results were not requested.
function mongoc_bulkwriteresult_updateresults(
           self: Pmongoc_bulkwriteresult_t): Pbson_t; cdecl; external 'mongoc2.dll';
// `mongoc_bulkwriteresult_deleteresults` returns a BSON document mapping model indexes to delete results.
// Example:
// {
// "0" : { "deletedCount" : 1 },
// "1" : { "deletedCount" : 2 }
// }
// Returns NULL if verbose results were not requested.
function mongoc_bulkwriteresult_deleteresults(
           self: Pmongoc_bulkwriteresult_t): Pbson_t; cdecl; external 'mongoc2.dll';
// `mongoc_bulkwriteresult_serverid` identifies the most recently selected server. This may differ from a
// previously set serverid if a retry occurred. A server ID of 0 indicates that no server was successfully selected.
// This is intended for use by wrapping drivers that select a server before running the operation.
function mongoc_bulkwriteresult_serverid(
           self: Pmongoc_bulkwriteresult_t): uint32_t; cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwriteresult_destroy(
            self: Pmongoc_bulkwriteresult_t); cdecl; external 'mongoc2.dll';

type
  _mongoc_bulkwriteexception_t = record
  end;
  mongoc_bulkwriteexception_t = _mongoc_bulkwriteexception_t;
  Pmongoc_bulkwriteexception_t = ^mongoc_bulkwriteexception_t;
// Returns true if there was a top-level error.
function mongoc_bulkwriteexception_error(
           self: Pmongoc_bulkwriteexception_t;
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';
// `mongoc_bulkwriteexception_writeerrors` returns a BSON document mapping model indexes to write errors.
// Example:
// {
// "0" : { "code" : 123, "message" : "foo", "details" : { } },
// "1" : { "code" : 456, "message" : "bar", "details" : { } }
// }
// Returns an empty document if there are no write errors.
function mongoc_bulkwriteexception_writeerrors(
           self: Pmongoc_bulkwriteexception_t): Pbson_t; cdecl; external 'mongoc2.dll';
// `mongoc_bulkwriteexception_writeconcernerrors` returns a BSON array of write concern errors.
// Example:
// [
// { "code" : 123, "message" : "foo", "details" : { } },
// { "code" : 456, "message" : "bar", "details" : { } }
// ]
// Returns an empty array if there are no write concern errors.
function mongoc_bulkwriteexception_writeconcernerrors(
           self: Pmongoc_bulkwriteexception_t): Pbson_t; cdecl; external 'mongoc2.dll';
// `mongoc_bulkwriteexception_errorreply` returns a possible server reply related to the error, or an empty document.
function mongoc_bulkwriteexception_errorreply(
           self: Pmongoc_bulkwriteexception_t): Pbson_t; cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwriteexception_destroy(
            self: Pmongoc_bulkwriteexception_t); cdecl; external 'mongoc2.dll';

type
  _mongoc_bulkwrite_t = record
  end;
  mongoc_bulkwrite_t = _mongoc_bulkwrite_t;
  Pmongoc_bulkwrite_t = ^mongoc_bulkwrite_t;
function mongoc_client_bulkwrite_new(
           self: Pmongoc_client_t): Pmongoc_bulkwrite_t; cdecl; external 'mongoc2.dll';

type
  _mongoc_bulkwrite_insertoneopts_t = record
  end;
  mongoc_bulkwrite_insertoneopts_t = _mongoc_bulkwrite_insertoneopts_t;
  Pmongoc_bulkwrite_insertoneopts_t = ^mongoc_bulkwrite_insertoneopts_t;
function mongoc_bulkwrite_insertoneopts_new(): Pmongoc_bulkwrite_insertoneopts_t; cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_insertoneopts_destroy(
            self: Pmongoc_bulkwrite_insertoneopts_t); cdecl; external 'mongoc2.dll';
function mongoc_bulkwrite_append_insertone(
           self: Pmongoc_bulkwrite_t;
           ns: PAnsiChar;
           document: Pbson_t;
           opts: Pmongoc_bulkwrite_insertoneopts_t; // May be NULL
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

type
  _mongoc_bulkwrite_updateoneopts_t = record
  end;
  mongoc_bulkwrite_updateoneopts_t = _mongoc_bulkwrite_updateoneopts_t;
  Pmongoc_bulkwrite_updateoneopts_t = ^mongoc_bulkwrite_updateoneopts_t;
function mongoc_bulkwrite_updateoneopts_new(): Pmongoc_bulkwrite_updateoneopts_t; cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_updateoneopts_set_arrayfilters(
            self: Pmongoc_bulkwrite_updateoneopts_t;
            arrayfilters: Pbson_t); cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_updateoneopts_set_collation(
            self: Pmongoc_bulkwrite_updateoneopts_t;
            collation: Pbson_t); cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_updateoneopts_set_hint(
            self: Pmongoc_bulkwrite_updateoneopts_t;
            hint: Pbson_value_t); cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_updateoneopts_set_upsert(
            self: Pmongoc_bulkwrite_updateoneopts_t;
            upsert: bool); cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_updateoneopts_set_sort(
            self: Pmongoc_bulkwrite_updateoneopts_t;
            sort: Pbson_t); cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_updateoneopts_destroy(
            self: Pmongoc_bulkwrite_updateoneopts_t); cdecl; external 'mongoc2.dll';
function mongoc_bulkwrite_append_updateone(
           self: Pmongoc_bulkwrite_t;
           ns: PAnsiChar;
           filter: Pbson_t;
           update: Pbson_t;
           opts: Pmongoc_bulkwrite_updateoneopts_t; // May be NULL
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

type
  _mongoc_bulkwrite_updatemanyopts_t = record
  end;
  mongoc_bulkwrite_updatemanyopts_t = _mongoc_bulkwrite_updatemanyopts_t;
  Pmongoc_bulkwrite_updatemanyopts_t = ^mongoc_bulkwrite_updatemanyopts_t;
function mongoc_bulkwrite_updatemanyopts_new(): Pmongoc_bulkwrite_updatemanyopts_t; cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_updatemanyopts_set_arrayfilters(
            self: Pmongoc_bulkwrite_updatemanyopts_t;
            arrayfilters: Pbson_t); cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_updatemanyopts_set_collation(
            self: Pmongoc_bulkwrite_updatemanyopts_t;
            collation: Pbson_t); cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_updatemanyopts_set_hint(
            self: Pmongoc_bulkwrite_updatemanyopts_t;
            hint: Pbson_value_t); cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_updatemanyopts_set_upsert(
            self: Pmongoc_bulkwrite_updatemanyopts_t;
            upsert: bool); cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_updatemanyopts_destroy(
            self: Pmongoc_bulkwrite_updatemanyopts_t); cdecl; external 'mongoc2.dll';
function mongoc_bulkwrite_append_updatemany(
           self: Pmongoc_bulkwrite_t;
           ns: PAnsiChar;
           filter: Pbson_t;
           update: Pbson_t;
           opts: Pmongoc_bulkwrite_updatemanyopts_t; // May be NULL
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

type
  _mongoc_bulkwrite_replaceoneopts_t = record
  end;
  mongoc_bulkwrite_replaceoneopts_t = _mongoc_bulkwrite_replaceoneopts_t;
  Pmongoc_bulkwrite_replaceoneopts_t = ^mongoc_bulkwrite_replaceoneopts_t;
function mongoc_bulkwrite_replaceoneopts_new(): Pmongoc_bulkwrite_replaceoneopts_t; cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_replaceoneopts_set_collation(
            self: Pmongoc_bulkwrite_replaceoneopts_t;
            collation: Pbson_t); cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_replaceoneopts_set_hint(
            self: Pmongoc_bulkwrite_replaceoneopts_t;
            hint: Pbson_value_t); cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_replaceoneopts_set_upsert(
            self: Pmongoc_bulkwrite_replaceoneopts_t;
            upsert: bool); cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_replaceoneopts_set_sort(
            self: Pmongoc_bulkwrite_replaceoneopts_t;
            sort: Pbson_t); cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_replaceoneopts_destroy(
            self: Pmongoc_bulkwrite_replaceoneopts_t); cdecl; external 'mongoc2.dll';
function mongoc_bulkwrite_append_replaceone(
           self: Pmongoc_bulkwrite_t;
           ns: PAnsiChar;
           filter: Pbson_t;
           replacement: Pbson_t;
           opts: Pmongoc_bulkwrite_replaceoneopts_t; // May be NULL
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

type
  _mongoc_bulkwrite_deleteoneopts_t = record
  end;
  mongoc_bulkwrite_deleteoneopts_t = _mongoc_bulkwrite_deleteoneopts_t;
  Pmongoc_bulkwrite_deleteoneopts_t = ^mongoc_bulkwrite_deleteoneopts_t;
function mongoc_bulkwrite_deleteoneopts_new(): Pmongoc_bulkwrite_deleteoneopts_t; cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_deleteoneopts_set_collation(
            self: Pmongoc_bulkwrite_deleteoneopts_t;
            collation: Pbson_t); cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_deleteoneopts_set_hint(
            self: Pmongoc_bulkwrite_deleteoneopts_t;
            hint: Pbson_value_t); cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_deleteoneopts_destroy(
            self: Pmongoc_bulkwrite_deleteoneopts_t); cdecl; external 'mongoc2.dll';
function mongoc_bulkwrite_append_deleteone(
           self: Pmongoc_bulkwrite_t;
           ns: PAnsiChar;
           filter: Pbson_t;
           opts: Pmongoc_bulkwrite_deleteoneopts_t; // May be NULL
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

type
  _mongoc_bulkwrite_deletemanyopts_t = record
  end;
  mongoc_bulkwrite_deletemanyopts_t = _mongoc_bulkwrite_deletemanyopts_t;
  Pmongoc_bulkwrite_deletemanyopts_t = ^mongoc_bulkwrite_deletemanyopts_t;
function mongoc_bulkwrite_deletemanyopts_new(): Pmongoc_bulkwrite_deletemanyopts_t; cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_deletemanyopts_set_collation(
            self: Pmongoc_bulkwrite_deletemanyopts_t;
            collation: Pbson_t); cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_deletemanyopts_set_hint(
            self: Pmongoc_bulkwrite_deletemanyopts_t;
            hint: Pbson_value_t); cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_deletemanyopts_destroy(
            self: Pmongoc_bulkwrite_deletemanyopts_t); cdecl; external 'mongoc2.dll';
function mongoc_bulkwrite_append_deletemany(
           self: Pmongoc_bulkwrite_t;
           ns: PAnsiChar;
           filter: Pbson_t;
           opts: Pmongoc_bulkwrite_deletemanyopts_t; // May be NULL
           error: Pbson_error_t): bool; cdecl; external 'mongoc2.dll';

// `mongoc_bulkwritereturn_t` may outlive `mongoc_bulkwrite_t`.
type
  mongoc_bulkwritereturn_t = record
    res: Pmongoc_bulkwriteresult_t; // NULL if no known successful writes or write was unacknowledged.
    exc: Pmongoc_bulkwriteexception_t; // NULL if no error.
  end;

// `mongoc_bulkwrite_new` and `mongoc_bulkwrite_set_client` may be used by
// language bindings that want to assemble a `mongoc_bulkwrite_t` and defer
// `mongoc_client_t` assignment to execution time.
function mongoc_bulkwrite_new(): Pmongoc_bulkwrite_t; cdecl; external 'mongoc2.dll';
procedure mongoc_bulkwrite_set_client(
            self: Pmongoc_bulkwrite_t;
            client: Pmongoc_client_t); cdecl; external 'mongoc2.dll';
// `mongoc_bulkwrite_set_session` sets an optional explicit session.
// ` * session` may be modified when `mongoc_bulkwrite_execute` is called.
procedure mongoc_bulkwrite_set_session(
            self: Pmongoc_bulkwrite_t;
            session: Pmongoc_client_session_t); cdecl; external 'mongoc2.dll';
// `mongoc_bulkwrite_execute` executes a bulk write operation.
function mongoc_bulkwrite_execute(
           self: Pmongoc_bulkwrite_t;
           opts: Pmongoc_bulkwriteopts_t): mongoc_bulkwritereturn_t; cdecl; external 'mongoc2.dll';

type
  mongoc_bulkwrite_check_acknowledged_t = record
    is_ok: bool; // true if no error
    is_acknowledged: bool; // true if the previous call to `mongoc_bulkwrite_execute` used an acknowledged write concern
  end;

// `mongoc_bulkwrite_check_acknowledged` checks whether or not the previous call to `mongoc_bulkwrite_execute` used an
// acknowledged write concern.
function mongoc_bulkwrite_check_acknowledged(
           self: Pmongoc_bulkwrite_t;
           error: Pbson_error_t): mongoc_bulkwrite_check_acknowledged_t; cdecl; external 'mongoc2.dll';

type
  mongoc_bulkwrite_serverid_t = record
    is_ok: bool; // true if no error
    serverid: uint32_t; // the server ID last used in `mongoc_bulkwrite_execute`
  end;

// `mongoc_bulkwrite_serverid` identifies the most recently selected server. This may differ from a previously set
// serverid if a retry occurred. Unlike `mongoc_bulkwriteresult_serverid`, this can be used for unacknowledged writes.
// For acknowledged writes, `mongoc_bulkwrite_serverid` and `mongoc_bulkwriteresult_serverid` report the same server
// ID.
function mongoc_bulkwrite_serverid(
           self: Pmongoc_bulkwrite_t;
           error: Pbson_error_t): mongoc_bulkwrite_serverid_t; cdecl; external 'mongoc2.dll';

procedure mongoc_bulkwrite_destroy(
            self: Pmongoc_bulkwrite_t); cdecl; external 'mongoc2.dll';

//////////////////
// mongoc-sleep //
//////////////////

// * *
// * mongoc_usleep_func_t:
// * @usec: Number of microseconds to sleep for.
// * @user_data: User data provided to mongoc_client_set_usleep_impl().
// *
type
  mongoc_usleep_func_t = procedure (
    usec: int64_t;
    user_data: Pvoid); cdecl;

// * *
// * mongoc_client_set_usleep_impl:
// * @usleep_func: A function to perform microsecond sleep.
// *
// * Sets the function to be called to perform sleep during scanning.
// * Returns the old function.
// * If old_user_data is not NULL, * old_user_data is set to the old user_data.
// * Not thread-safe.
// * Providing a `usleep_func` that does not sleep (e.g. coroutine suspension) is
// * not supported. Doing so is at the user's own risk.
// *
procedure mongoc_client_set_usleep_impl(
            client: Pmongoc_client_t;
            usleep_func: mongoc_usleep_func_t;
            user_data: Pvoid); cdecl; external 'mongoc2.dll';

procedure mongoc_usleep_default_impl(
            usec: int64_t;
            user_data: Pvoid); cdecl; external 'mongoc2.dll';

////////////
// mongoc //
////////////

// #define MONGOC_INSIDE

implementation

end.
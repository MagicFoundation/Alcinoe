unit Alcinoe.WinApi.Http;

//*******************************************************************//
// This unit was automatically generated by CHeaderWrapperGenerator. //
// Do not edit manually.                                             //
//*******************************************************************//

interface

{$I Alcinoe.inc}

{$WARN SYMBOL_PLATFORM OFF}
{$SCOPEDENUMS OFF}
{$MINENUMSIZE 4}
{$A+}

uses
  WinApi.Windows,
  Winapi.Winsock2,
  Alcinoe.WinApi.Windows;

// #define __HTTP_H__

//
// HTTPAPI is available on
//
// a) WinXP SP2 and higher
// b) Windows 2003 and higher
// c) Vista and higher.
//

//
// Flags for HttpInitialize() and HttpTerminate().
//
//
// HTTP_INITIALIZE_SERVER - Initializes the HTTP API layer and driver for
// applications using server APIs.
//
// HTTP_INITIALIZE_CONFIG - Initializes the HTTP API layer and driver for
// applications using HTTP configuration APIs.
//
// HTTP_DEMAND_CBT - Pre-Win7, it checks HTTP API layer and driver for
// Extended Protection capabilities.
// On Win7 and above, this flag has no use and is
// present only for app-compat reasons.
// It must be combined with HTTP_INITIALIZE_SERVER.
//
// Notes -
//
// 1. These flags can be used in combination.
//
// 2. HttpTerminate() must be called for each call to HttpInitialize() made
// with each flag set when invoking HttpInitialize. For example, one
// could make two calls to HttpInitialize() setting HTTP_INITIALIZE_SERVER
// the first time and HTTP_INITIALIZE_CONFIG the second time. One call
// to HttpTerminate() with both flags set suffices to clean up both
// calls to HttpInitialize().
//

const HTTP_INITIALIZE_SERVER = $00000001;
const HTTP_INITIALIZE_CONFIG = $00000002;
const HTTP_DEMAND_CBT = $00000004;

//
// Following section defines the properties supported by the
// server side HTTP API.
//

type
  _HTTP_SERVER_PROPERTY = (
    // Used for enabling server side authentication.
    HttpServerAuthenticationProperty = 0,
    // Used for enabling logging.
    HttpServerLoggingProperty = 1,
    // Used for setting QoS properties.
    HttpServerQosProperty = 2,
    // Used for configuring timeouts.
    HttpServerTimeoutsProperty = 3,
    // Used for limiting request queue lengths.
    HttpServerQueueLengthProperty = 4,
    // Used for manipulating the state.
    HttpServerStateProperty = 5,
    // Used for modifying the verbosity level of 503 type responses
    // generated by server side API.
    HttpServer503VerbosityProperty = 6,
    // Used for manipulating Url Group to Request Queue association.
    HttpServerBindingProperty = 7,
    // Extended authentication property.
    HttpServerExtendedAuthenticationProperty = 8,
    // Listening endpoint property.
    HttpServerListenEndpointProperty = 9,
    // Authentication channel binding property
    HttpServerChannelBindProperty = 10,
    // IP Protection level policy for a Url Group.
    HttpServerProtectionLevelProperty = 11,
    // Used for manipulating Url Group to Delegate Request Queue association.
    HttpServerDelegationProperty = 16,
    // Used to configure fast forwarding support.
    HttpServerFastForwardingProperty = 18);
  HTTP_SERVER_PROPERTY = _HTTP_SERVER_PROPERTY;
  PHTTP_SERVER_PROPERTY = ^_HTTP_SERVER_PROPERTY;

const HTTP_MAX_SERVER_QUEUE_LENGTH = $7FFFFFFF;
const HTTP_MIN_SERVER_QUEUE_LENGTH = 1;

//
// Generic property flags. Each structure defining a property info typically
// contain an element of this type.
//

type
  _HTTP_PROPERTY_FLAGS = record
    Present: ULONG;
  end;
  HTTP_PROPERTY_FLAGS = _HTTP_PROPERTY_FLAGS;
  PHTTP_PROPERTY_FLAGS = ^_HTTP_PROPERTY_FLAGS;

//
// Enabled state.
//

type
  _HTTP_ENABLED_STATE = (
    HttpEnabledStateActive,
    HttpEnabledStateInactive);
  HTTP_ENABLED_STATE = _HTTP_ENABLED_STATE;
  PHTTP_ENABLED_STATE = ^_HTTP_ENABLED_STATE;

type
  _HTTP_STATE_INFO = record
    Flags: HTTP_PROPERTY_FLAGS;
    State: HTTP_ENABLED_STATE;
  end;
  HTTP_STATE_INFO = _HTTP_STATE_INFO;
  PHTTP_STATE_INFO = ^_HTTP_STATE_INFO;

//
// Defines the verbosity level for a request queue which will be used
// when sending "503 - Service Unavailable" type error responses. Note that
// this setting only affects the error responses generated internally
// by HTTPAPI.
//

type
  _HTTP_503_RESPONSE_VERBOSITY = (
    // Instead of sending a 503 response, the connection will be reset.
    // This is the default behavior.
    Http503ResponseVerbosityBasic,
    // Will send a 503 w/ a generic reason phrase.
    Http503ResponseVerbosityLimited,
    // Will send a 503 w/ a detailed reason phrase.
    Http503ResponseVerbosityFull);
  HTTP_503_RESPONSE_VERBOSITY = _HTTP_503_RESPONSE_VERBOSITY;
  PHTTP_503_RESPONSE_VERBOSITY = ^_HTTP_503_RESPONSE_VERBOSITY;

//
// Network QoS related.
//

type
  _HTTP_QOS_SETTING_TYPE = (
    HttpQosSettingTypeBandwidth,
    HttpQosSettingTypeConnectionLimit,
    HttpQosSettingTypeFlowRate);
  HTTP_QOS_SETTING_TYPE = _HTTP_QOS_SETTING_TYPE;
  PHTTP_QOS_SETTING_TYPE = ^_HTTP_QOS_SETTING_TYPE;

type
  _HTTP_QOS_SETTING_INFO = record
    QosType: HTTP_QOS_SETTING_TYPE;
    QosSetting: PVOID;
  end;
  HTTP_QOS_SETTING_INFO = _HTTP_QOS_SETTING_INFO;
  PHTTP_QOS_SETTING_INFO = ^_HTTP_QOS_SETTING_INFO;

type
  _HTTP_CONNECTION_LIMIT_INFO = record
    Flags: HTTP_PROPERTY_FLAGS;
    MaxConnections: ULONG;
  end;
  HTTP_CONNECTION_LIMIT_INFO = _HTTP_CONNECTION_LIMIT_INFO;
  PHTTP_CONNECTION_LIMIT_INFO = ^_HTTP_CONNECTION_LIMIT_INFO;

type
  _HTTP_BANDWIDTH_LIMIT_INFO = record
    Flags: HTTP_PROPERTY_FLAGS;
    MaxBandwidth: ULONG;
  end;
  HTTP_BANDWIDTH_LIMIT_INFO = _HTTP_BANDWIDTH_LIMIT_INFO;
  PHTTP_BANDWIDTH_LIMIT_INFO = ^_HTTP_BANDWIDTH_LIMIT_INFO;

type
  _HTTP_FLOWRATE_INFO = record
    Flags: HTTP_PROPERTY_FLAGS;
    MaxBandwidth: ULONG;
    MaxPeakBandwidth: ULONG;
    BurstSize: ULONG;
  end;
  HTTP_FLOWRATE_INFO = _HTTP_FLOWRATE_INFO;
  PHTTP_FLOWRATE_INFO = ^_HTTP_FLOWRATE_INFO;

//
// Bandwidth throttling limit can not be set lower than the following
// number. The value is in bytes/sec.
//

const HTTP_MIN_ALLOWED_BANDWIDTH_THROTTLING_RATE: ULONG = ULONG(1024);

//
// Distinguished value for bandwidth, connection limits and logging rollover
// size indicating "no limit".
//

const HTTP_LIMIT_INFINITE: ULONG = ULONG(-1);

//
// Timeout information.
//

//
// For manipulating global timeout settings.
// These timers run when connection does not belong to any application.
// Value zero is not allowed for driver wide timeout settings.
//

type
  _HTTP_SERVICE_CONFIG_TIMEOUT_KEY = (
    IdleConnectionTimeout = 0,
    HeaderWaitTimeout);
  HTTP_SERVICE_CONFIG_TIMEOUT_KEY = _HTTP_SERVICE_CONFIG_TIMEOUT_KEY;
  PHTTP_SERVICE_CONFIG_TIMEOUT_KEY = ^_HTTP_SERVICE_CONFIG_TIMEOUT_KEY;

type HTTP_SERVICE_CONFIG_TIMEOUT_PARAM = USHORT;
type PHTTP_SERVICE_CONFIG_TIMEOUT_PARAM = ^USHORT;

//
// To set a timeout value use the set structure. To query/delete use the key
// directly. When you query a timeout value the output buffer must be exactly
// the sizeof param.
//

type
  _HTTP_SERVICE_CONFIG_TIMEOUT_SET = record
    KeyDesc: HTTP_SERVICE_CONFIG_TIMEOUT_KEY;
    ParamDesc: HTTP_SERVICE_CONFIG_TIMEOUT_PARAM;
  end;
  HTTP_SERVICE_CONFIG_TIMEOUT_SET = _HTTP_SERVICE_CONFIG_TIMEOUT_SET;
  PHTTP_SERVICE_CONFIG_TIMEOUT_SET = ^_HTTP_SERVICE_CONFIG_TIMEOUT_SET;

//
// For manipulating application specific timeout settings.
// These timers run when there's a request being processed on a connection
// and HTTPAPI has already associated the request with an application.
// Setting a timeout value to zero will cause HTTPAPI to revert to default.
//

type
  _HTTP_TIMEOUT_LIMIT_INFO = record
    Flags: HTTP_PROPERTY_FLAGS;
    // Timeouts configured in seconds.
    EntityBody: USHORT;
    DrainEntityBody: USHORT;
    RequestQueue: USHORT;
    // Following two timeouts are only enforced after first request on
    // connection is routed to the application. These will not manipulate
    // the driver wide timeouts.
    IdleConnection: USHORT;
    HeaderWait: USHORT;
    // Timeouts configured in bytes/second.
    // This timer can be turned off by setting it to MAXULONG.
    MinSendRate: ULONG;
  end;
  HTTP_TIMEOUT_LIMIT_INFO = _HTTP_TIMEOUT_LIMIT_INFO;
  PHTTP_TIMEOUT_LIMIT_INFO = ^_HTTP_TIMEOUT_LIMIT_INFO;

//
// Controls config settings
//

type
  _HTTP_SERVICE_CONFIG_SETTING_KEY = (
    HttpNone = 0,
    HttpTlsThrottle);
  HTTP_SERVICE_CONFIG_SETTING_KEY = _HTTP_SERVICE_CONFIG_SETTING_KEY;
  PHTTP_SERVICE_CONFIG_SETTING_KEY = ^_HTTP_SERVICE_CONFIG_SETTING_KEY;

type HTTP_SERVICE_CONFIG_SETTING_PARAM = ULONG;
type PHTTP_SERVICE_CONFIG_SETTING_PARAM = ^ULONG;

type
  _HTTP_SERVICE_CONFIG_SETTING_SET = record
    KeyDesc: HTTP_SERVICE_CONFIG_SETTING_KEY;
    ParamDesc: HTTP_SERVICE_CONFIG_SETTING_PARAM;
  end;
  HTTP_SERVICE_CONFIG_SETTING_SET = _HTTP_SERVICE_CONFIG_SETTING_SET;
  PHTTP_SERVICE_CONFIG_SETTING_SET = ^_HTTP_SERVICE_CONFIG_SETTING_SET;

//
// Controls whether IP-based URLs should listen on the specific IP or wildcard.
//

type
  _HTTP_LISTEN_ENDPOINT_INFO = record
    Flags: HTTP_PROPERTY_FLAGS;
    EnableSharing: ByteBool;
  end;
  HTTP_LISTEN_ENDPOINT_INFO = _HTTP_LISTEN_ENDPOINT_INFO;
  PHTTP_LISTEN_ENDPOINT_INFO = ^_HTTP_LISTEN_ENDPOINT_INFO;

type
  _HTTP_FAST_FORWARD_INFO = record
    Flags: HTTP_PROPERTY_FLAGS;
    EnableFastForwarding: ByteBool;
  end;
  HTTP_FAST_FORWARD_INFO = _HTTP_FAST_FORWARD_INFO;
  PHTTP_FAST_FORWARD_INFO = ^_HTTP_FAST_FORWARD_INFO;

type
  _HTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS = record
    DomainNameLength: USHORT;
    DomainName: PWSTR;
    RealmLength: USHORT;
    Realm: PWSTR;
  end;
  HTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS = _HTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS;
  PHTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS = ^_HTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS;

type
  _HTTP_SERVER_AUTHENTICATION_BASIC_PARAMS = record
    RealmLength: USHORT;
    Realm: PWSTR;
  end;
  HTTP_SERVER_AUTHENTICATION_BASIC_PARAMS = _HTTP_SERVER_AUTHENTICATION_BASIC_PARAMS;
  PHTTP_SERVER_AUTHENTICATION_BASIC_PARAMS = ^_HTTP_SERVER_AUTHENTICATION_BASIC_PARAMS;

//
// Definitions used for setting server side authentication property.
//

const HTTP_AUTH_ENABLE_BASIC = ($00000001);
const HTTP_AUTH_ENABLE_DIGEST = ($00000002);
const HTTP_AUTH_ENABLE_NTLM = ($00000004);
const HTTP_AUTH_ENABLE_NEGOTIATE = ($00000008);
const HTTP_AUTH_ENABLE_KERBEROS = ($00000010);

const HTTP_AUTH_ENABLE_ALL = (HTTP_AUTH_ENABLE_BASIC or HTTP_AUTH_ENABLE_DIGEST or HTTP_AUTH_ENABLE_NTLM or HTTP_AUTH_ENABLE_NEGOTIATE or HTTP_AUTH_ENABLE_KERBEROS);

// C_ASSERT(HTTP_AUTH_ENABLE_NEGOTIATE > HTTP_AUTH_ENABLE_NTLM);
// C_ASSERT(HTTP_AUTH_ENABLE_NTLM > HTTP_AUTH_ENABLE_DIGEST);
// C_ASSERT(HTTP_AUTH_ENABLE_DIGEST > HTTP_AUTH_ENABLE_BASIC);

const HTTP_AUTH_EX_FLAG_ENABLE_KERBEROS_CREDENTIAL_CACHING = ($01);
const HTTP_AUTH_EX_FLAG_CAPTURE_CREDENTIAL = ($02);

type
  _HTTP_SERVER_AUTHENTICATION_INFO = record
    Flags: HTTP_PROPERTY_FLAGS;
    AuthSchemes: ULONG;
    ReceiveMutualAuth: ByteBool;
    ReceiveContextHandle: ByteBool;
    DisableNTLMCredentialCaching: ByteBool;
    ExFlags: UCHAR;
    DigestParams: HTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS;
    BasicParams: HTTP_SERVER_AUTHENTICATION_BASIC_PARAMS;
  end;
  HTTP_SERVER_AUTHENTICATION_INFO = _HTTP_SERVER_AUTHENTICATION_INFO;
  PHTTP_SERVER_AUTHENTICATION_INFO = ^_HTTP_SERVER_AUTHENTICATION_INFO;

//
// Definitions for setting authentication channel binding properties
//

type
  _HTTP_SERVICE_BINDING_TYPE = (
    HttpServiceBindingTypeNone = 0,
    HttpServiceBindingTypeW,
    HttpServiceBindingTypeA);
  HTTP_SERVICE_BINDING_TYPE = _HTTP_SERVICE_BINDING_TYPE;

type
  _HTTP_SERVICE_BINDING_BASE = record
    &Type: HTTP_SERVICE_BINDING_TYPE;
  end;
  HTTP_SERVICE_BINDING_BASE = _HTTP_SERVICE_BINDING_BASE;
  PHTTP_SERVICE_BINDING_BASE = ^_HTTP_SERVICE_BINDING_BASE;
  PPHTTP_SERVICE_BINDING_BASE = ^PHTTP_SERVICE_BINDING_BASE;

type
  _HTTP_SERVICE_BINDING_A = record
    Base: HTTP_SERVICE_BINDING_BASE;
    Buffer: PAnsiChar;
    BufferSize: ULONG;
  end;
  HTTP_SERVICE_BINDING_A = _HTTP_SERVICE_BINDING_A;
  PHTTP_SERVICE_BINDING_A = ^_HTTP_SERVICE_BINDING_A;

type
  _HTTP_SERVICE_BINDING_W = record
    Base: HTTP_SERVICE_BINDING_BASE;
    Buffer: PWCHAR;
    BufferSize: ULONG;
  end;
  HTTP_SERVICE_BINDING_W = _HTTP_SERVICE_BINDING_W;
  PHTTP_SERVICE_BINDING_W = ^_HTTP_SERVICE_BINDING_W;

type
  _HTTP_AUTHENTICATION_HARDENING_LEVELS = (
    HttpAuthenticationHardeningLegacy = 0,
    HttpAuthenticationHardeningMedium,
    HttpAuthenticationHardeningStrict);
  HTTP_AUTHENTICATION_HARDENING_LEVELS = _HTTP_AUTHENTICATION_HARDENING_LEVELS;

//
// Channel binding token verification flags.
//

const HTTP_CHANNEL_BIND_PROXY = $1;
const HTTP_CHANNEL_BIND_PROXY_COHOSTING = $20;

//
// Service bind verification flags
//

const HTTP_CHANNEL_BIND_NO_SERVICE_NAME_CHECK = $2;
const HTTP_CHANNEL_BIND_DOTLESS_SERVICE = $4;

//
// Flags triggering channel bind parameters retrieval
//

const HTTP_CHANNEL_BIND_SECURE_CHANNEL_TOKEN = $8;
const HTTP_CHANNEL_BIND_CLIENT_SERVICE = $10;

//
// All valid flags (mask for internal checks)
//

type
  _HTTP_CHANNEL_BIND_INFO = record
    Hardening: HTTP_AUTHENTICATION_HARDENING_LEVELS;
    Flags: ULONG;
    ServiceNames: PPHTTP_SERVICE_BINDING_BASE;
    NumberOfServiceNames: ULONG;
  end;
  HTTP_CHANNEL_BIND_INFO = _HTTP_CHANNEL_BIND_INFO;
  PHTTP_CHANNEL_BIND_INFO = ^_HTTP_CHANNEL_BIND_INFO;

type
  _HTTP_REQUEST_CHANNEL_BIND_STATUS = record
    ServiceName: PHTTP_SERVICE_BINDING_BASE;
    ChannelToken: PUCHAR;
    ChannelTokenSize: ULONG;
    Flags: ULONG;
  end;
  HTTP_REQUEST_CHANNEL_BIND_STATUS = _HTTP_REQUEST_CHANNEL_BIND_STATUS;
  PHTTP_REQUEST_CHANNEL_BIND_STATUS = ^_HTTP_REQUEST_CHANNEL_BIND_STATUS;

type
  _HTTP_REQUEST_TOKEN_BINDING_INFO = record
    TokenBinding: PUCHAR;
    TokenBindingSize: ULONG;
    EKM: PUCHAR;
    EKMSize: ULONG;
    KeyType: UCHAR;
  end;
  HTTP_REQUEST_TOKEN_BINDING_INFO = _HTTP_REQUEST_TOKEN_BINDING_INFO;
  PHTTP_REQUEST_TOKEN_BINDING_INFO = ^_HTTP_REQUEST_TOKEN_BINDING_INFO;

//
// Definitions used for setting logging property.
//

//
// The known log fields recognized/supported by HTTPAPI. Following fields
// are used for W3C logging. Subset of them are also used for error
// logging.
//

const HTTP_LOG_FIELD_DATE = $00000001;
const HTTP_LOG_FIELD_TIME = $00000002;
const HTTP_LOG_FIELD_CLIENT_IP = $00000004;
const HTTP_LOG_FIELD_USER_NAME = $00000008;
const HTTP_LOG_FIELD_SITE_NAME = $00000010;
const HTTP_LOG_FIELD_COMPUTER_NAME = $00000020;
const HTTP_LOG_FIELD_SERVER_IP = $00000040;
const HTTP_LOG_FIELD_METHOD = $00000080;
const HTTP_LOG_FIELD_URI_STEM = $00000100;
const HTTP_LOG_FIELD_URI_QUERY = $00000200;
const HTTP_LOG_FIELD_STATUS = $00000400;
const HTTP_LOG_FIELD_WIN32_STATUS = $00000800;
const HTTP_LOG_FIELD_BYTES_SENT = $00001000;
const HTTP_LOG_FIELD_BYTES_RECV = $00002000;
const HTTP_LOG_FIELD_TIME_TAKEN = $00004000;
const HTTP_LOG_FIELD_SERVER_PORT = $00008000;
const HTTP_LOG_FIELD_USER_AGENT = $00010000;
const HTTP_LOG_FIELD_COOKIE = $00020000;
const HTTP_LOG_FIELD_REFERER = $00040000;
const HTTP_LOG_FIELD_VERSION = $00080000;
const HTTP_LOG_FIELD_HOST = $00100000;
const HTTP_LOG_FIELD_SUB_STATUS = $00200000;
const HTTP_LOG_FIELD_STREAM_ID = $08000000;
const HTTP_LOG_FIELD_STREAM_ID_EX = $10000000;
const HTTP_LOG_FIELD_TRANSPORT_TYPE = $20000000;

//
// Fields that are used only for error logging.
//

const HTTP_LOG_FIELD_CLIENT_PORT = $00400000;
const HTTP_LOG_FIELD_URI = $00800000;
const HTTP_LOG_FIELD_SITE_ID = $01000000;
const HTTP_LOG_FIELD_REASON = $02000000;
const HTTP_LOG_FIELD_QUEUE_NAME = $04000000;
const HTTP_LOG_FIELD_CORRELATION_ID = $40000000;
const HTTP_LOG_FIELD_FAULT_CODE = $80000000;

const HTTP_LOG_FIELD_EXT_FAULT_CODE_EXT = $0000000000000001;

//
// Defines the logging type.
//

type
  _HTTP_LOGGING_TYPE = (
    HttpLoggingTypeW3C,
    HttpLoggingTypeIIS,
    HttpLoggingTypeNCSA,
    HttpLoggingTypeRaw);
  HTTP_LOGGING_TYPE = _HTTP_LOGGING_TYPE;
  PHTTP_LOGGING_TYPE = ^_HTTP_LOGGING_TYPE;

//
// Defines the rollover type for log files.
//

type
  _HTTP_LOGGING_ROLLOVER_TYPE = (
    HttpLoggingRolloverSize,
    HttpLoggingRolloverDaily,
    HttpLoggingRolloverWeekly,
    HttpLoggingRolloverMonthly,
    HttpLoggingRolloverHourly);
  HTTP_LOGGING_ROLLOVER_TYPE = _HTTP_LOGGING_ROLLOVER_TYPE;
  PHTTP_LOGGING_ROLLOVER_TYPE = ^_HTTP_LOGGING_ROLLOVER_TYPE;

//
// Log file rollover size can not be set lower than the following
// limit. The value is in bytes.
//

const HTTP_MIN_ALLOWED_LOG_FILE_ROLLOVER_SIZE: ULONG = ULONG((1 * 1024 * 1024));

//
// Logging option flags. When used in the logging configuration alters
// some default logging behaviour.
//
// HTTP_LOGGING_FLAG_LOCAL_TIME_ROLLOVER - This flag is used to change
// the log file rollover to happen by local time based. By default
// log file rollovers happen by GMT time.
//
// HTTP_LOGGING_FLAG_USE_UTF8_CONVERSION - When set the unicode fields
// will be converted to UTF8 multibytes when writting to the log
// files. When this flag is not present, the local code page
// conversion happens.
//
// HTTP_LOGGING_FLAG_LOG_ERRORS_ONLY -
// HTTP_LOGGING_FLAG_LOG_SUCCESS_ONLY - These two flags are used to
// to do selective logging. If neither of them are present both
// types of requests will be logged. Only one these flags can be
// set at a time. They are mutually exclusive.
//

const HTTP_LOGGING_FLAG_LOCAL_TIME_ROLLOVER = ($00000001);
const HTTP_LOGGING_FLAG_USE_UTF8_CONVERSION = ($00000002);
const HTTP_LOGGING_FLAG_LOG_ERRORS_ONLY = ($00000004);
const HTTP_LOGGING_FLAG_LOG_SUCCESS_ONLY = ($00000008);

//
// Configuration structure used for setting the logging property.
//

type
  _HTTP_LOGGING_INFO = record
    // Specifies whether this property exists or not.
    Flags: HTTP_PROPERTY_FLAGS;
    // Optional logging flags.
    LoggingFlags: ULONG;
    // Optional informatonal software directive string for W3C type logging. Not
    // used for other types of logging. If nothing is provided here HTTPAPI will
    // log a default string. Any arbitrary string could be used here to identify
    // the application. Length cannot be greater than MAX_PATH. Lenght is in
    // bytes.
    SoftwareName: PCWSTR;
    SoftwareNameLength: USHORT;
    // Log file directory must be a fully qualified path.
    // Length must be in number of bytes.
    DirectoryNameLength: USHORT;
    DirectoryName: PCWSTR;
    // Specifies the format for the log files.
    Format: HTTP_LOGGING_TYPE;
    // Bitmask value indicates which fields to be logged
    // if the log format is set to W3C. This must be the 'bitwise or'
    // of the HTTP_LOG_FIELD_... values.
    Fields: ULONG;
    // Following fields are reserved they must be NULL and zero..
    pExtFields: PVOID;
    NumOfExtFields: USHORT;
    // Reserved must be zero.
    MaxRecordSize: USHORT;
    // Defines the rollover type for the log files.
    RolloverType: HTTP_LOGGING_ROLLOVER_TYPE;
    // Indicates the maximum size (in bytes) after which
    // the log files should be rolled over. A value of -1
    // (HTTP_LIMIT_INFINITE) indicates an unlimited size.
    // This value is discarded if rollover type is not set to
    // HttpLoggingRolloverSize.
    RolloverSize: ULONG;
    // Specifies the security descriptor to be applied to
    // the log files and the sub-directories. If null we will
    // inherit the system default. This security descriptor must
    // be self-relative.
    pSecurityDescriptor: PSECURITY_DESCRIPTOR;
  end;
  HTTP_LOGGING_INFO = _HTTP_LOGGING_INFO;
  PHTTP_LOGGING_INFO = ^_HTTP_LOGGING_INFO;

//
// Binding information.
//

type
  _HTTP_BINDING_INFO = record
    Flags: HTTP_PROPERTY_FLAGS;
    RequestQueueHandle: HANDLE;
  end;
  HTTP_BINDING_INFO = _HTTP_BINDING_INFO;
  PHTTP_BINDING_INFO = ^_HTTP_BINDING_INFO;

//
// Defines the protection level types for UrlGroups.
//

type
  _HTTP_PROTECTION_LEVEL_TYPE = (
    // This option will allow edge (NAT) traversed traffic, i.e. Teredo
    // for the UrlGroup, unless there is an admin rule that overwrites the
    // application's intend.
    HttpProtectionLevelUnrestricted,
    // This setting will ensure that edge (NAT) traversed traffic
    // will not be allowed.
    HttpProtectionLevelEdgeRestricted,
    // Below type is not supported by HTTP API.
    HttpProtectionLevelRestricted);
  HTTP_PROTECTION_LEVEL_TYPE = _HTTP_PROTECTION_LEVEL_TYPE;
  PHTTP_PROTECTION_LEVEL_TYPE = ^_HTTP_PROTECTION_LEVEL_TYPE;

//
// Controls whether the associated UrlGroup Namespace should receive
// edge traversed traffic. By default this parameter is unspecified.
//

type
  _HTTP_PROTECTION_LEVEL_INFO = record
    Flags: HTTP_PROPERTY_FLAGS;
    Level: HTTP_PROTECTION_LEVEL_TYPE;
  end;
  HTTP_PROTECTION_LEVEL_INFO = _HTTP_PROTECTION_LEVEL_INFO;
  PHTTP_PROTECTION_LEVEL_INFO = ^_HTTP_PROTECTION_LEVEL_INFO;

//
// Definitions for request queue manipulation.
//
// These flags are used with HttpCreateRequestQueue() API.
//
// HTTP_CREATE_REQUEST_QUEUE_FLAG_OPEN_EXISTING - To open an existing request
// queue. The request queue name must be supplied.
//
// HTTP_CREATE_REQUEST_QUEUE_FLAG_CONTROLLER - Creates the request queue and
// marks that the caller process is not willing to do send/receive (HTTP I/O)on
// the handle directly.
//

const HTTP_CREATE_REQUEST_QUEUE_FLAG_OPEN_EXISTING = ($00000001);
const HTTP_CREATE_REQUEST_QUEUE_FLAG_CONTROLLER = ($00000002);
const HTTP_CREATE_REQUEST_QUEUE_FLAG_DELEGATION = ($00000008);

//
// Flags for HttpReceiveHttpRequest().
//
// HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY - Specifies that the caller would like
// any available entity body to be copied along with the protocol headers.
//
// HTTP_RECEIVE_REQUEST_FLAG_FLUSH_BODY - Specifies that the caller would like
// all of the entity bodies to be copied along with the protocol headers.
//

const HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY = $00000001;
const HTTP_RECEIVE_REQUEST_FLAG_FLUSH_BODY = $00000002;

//
// Flags for HttpReceiveRequestEntityBody().
//
// HTTP_RECEIVE_REQUEST_ENTITY_BODY_FLAG_FILL_BUFFER - Specifies that the
// caller would like the buffer to get filled up with entity bodies unless
// there are no more entity bodies to be copied.
//

const HTTP_RECEIVE_REQUEST_ENTITY_BODY_FLAG_FILL_BUFFER = $00000001;

//
// Flags for HttpSendHttpResponse() and HttpSendResponseEntityBody().
//
// HTTP_SEND_RESPONSE_FLAG_DISCONNECT - Specifies that the network connection
// should be disconnected immediately after sending the response, overriding
// the HTTP protocol's persistent connection features, such as
// "Connection: keep-alive".
//
// HTTP_SEND_RESPONSE_FLAG_MORE_DATA - Specifies that additional entity body
// data will be sent by the caller.
//
// HTTP_SEND_RESPONSE_FLAG_BUFFER_DATA - Specifies that a caller wants the
// response to complete as soon as possible at the cost of buffering partial
// or the entire response.
//
// HTTP_SEND_RESPONSE_FLAG_ENABLE_NAGLING - Specifies that a caller wants to
// enable the TCP nagling algorithm for this particular send.
//
// HTTP_SEND_RESPONSE_FLAG_PROCESS_RANGES - Specifies that for a range request
// a full response content is passed and a caller wants HTTP API to process
// ranges properly.
//
// HTTP_SEND_RESPONSE_FLAG_OPAQUE - Specifies that the request/response is not
// HTTP compliant and all subsequent bytes should be treated as entity-body.
//
// HTTP_SEND_RESPONSE_FLAG_GOAWAY - A flag that must always be specified with
// HTTP_SEND_RESPONSE_FLAG_DISCONNECT. For pure HTTP/1.x connections, that is
// connections that don't do HTTP/2 and HTTP/3, this behaves the same as
// HTTP_SEND_RESPONSE_FLAG_DISCONNECT. For HTTP/2 and HTTP/3, this results in
// sending a GOAWAY frame and will cause the client to move to a different
// connection.
//
// HTTP_SEND_RESPONSE_FLAG_AUTOMATIC_CHUNKING - This flag instructs the
// http.sys to add chunk encoding automatically.
// HTTP_SEND_RESPONSE_FLAG_MORE_DATA must be specified as well. The caller
// must not add Transfer-Encoding: Chunked header.
//

const HTTP_SEND_RESPONSE_FLAG_DISCONNECT = $00000001;
const HTTP_SEND_RESPONSE_FLAG_MORE_DATA = $00000002;
const HTTP_SEND_RESPONSE_FLAG_BUFFER_DATA = $00000004;
const HTTP_SEND_RESPONSE_FLAG_ENABLE_NAGLING = $00000008;
const HTTP_SEND_RESPONSE_FLAG_PROCESS_RANGES = $00000020;
const HTTP_SEND_RESPONSE_FLAG_OPAQUE = $00000040;
const HTTP_SEND_RESPONSE_FLAG_GOAWAY = $00000100;
const HTTP_SEND_RESPONSE_FLAG_AUTOMATIC_CHUNKING = $00000200;

//
// Flags for HttpFlushResponseCache().
//
// HTTP_FLUSH_RESPONSE_FLAG_RECURSIVE - Flushes the specified URL and all
// hierarchally-related sub-URLs from the response or fragment cache.
//

const HTTP_FLUSH_RESPONSE_FLAG_RECURSIVE = $00000001;

//
// Opaque identifiers for various HTTPAPI objects.
//

type HTTP_OPAQUE_ID = ULONGLONG;
type PHTTP_OPAQUE_ID = ^ULONGLONG;

type HTTP_REQUEST_ID = HTTP_OPAQUE_ID;
type PHTTP_REQUEST_ID = ^HTTP_OPAQUE_ID;
type HTTP_CONNECTION_ID = HTTP_OPAQUE_ID;
type PHTTP_CONNECTION_ID = ^HTTP_OPAQUE_ID;
type HTTP_RAW_CONNECTION_ID = HTTP_OPAQUE_ID;
type PHTTP_RAW_CONNECTION_ID = ^HTTP_OPAQUE_ID;

type HTTP_URL_GROUP_ID = HTTP_OPAQUE_ID;
type PHTTP_URL_GROUP_ID = ^HTTP_OPAQUE_ID;
type HTTP_SERVER_SESSION_ID = HTTP_OPAQUE_ID;
type PHTTP_SERVER_SESSION_ID = ^HTTP_OPAQUE_ID;

// #if _WIN32_WINNT >= Somevalue
type HTTP_CLIENT_REQUEST_ID = HTTP_OPAQUE_ID;
type PHTTP_CLIENT_REQUEST_ID = ^HTTP_OPAQUE_ID;
type HTTP_CLIENT_CONNECTION_ID = HTTP_OPAQUE_ID;
type PHTTP_CLIENT_CONNECTION_ID = ^HTTP_OPAQUE_ID;
type HTTP_CLIENT_STREAM_ID = HTTP_OPAQUE_ID;
type PHTTP_CLIENT_STREAM_ID = ^HTTP_OPAQUE_ID;
type HTTP_CLIENT_CREDENTIAL_ID = HTTP_OPAQUE_ID;
type PHTTP_CLIENT_CREDENTIAL_ID = ^HTTP_OPAQUE_ID;

//
// Macros for opaque identifier manipulations.
//

const HTTP_NULL_ID: UInt64 = UInt64(0);
// #define HTTP_IS_NULL_ID(pid) (HTTP_NULL_ID == * (pid))
// #define HTTP_SET_NULL_ID(pid) ( * (pid) = HTTP_NULL_ID)

//
// This structure defines a file byte range.
//
// If the Length field is HTTP_BYTE_RANGE_TO_EOF then the remainder of the
// file (everything after StartingOffset) is sent.
//

const HTTP_BYTE_RANGE_TO_EOF: ULONGLONG = ULONGLONG(-1);

type
  _HTTP_BYTE_RANGE = record
    StartingOffset: ULARGE_INTEGER;
    Length: ULARGE_INTEGER;
  end;
  HTTP_BYTE_RANGE = _HTTP_BYTE_RANGE;
  PHTTP_BYTE_RANGE = ^_HTTP_BYTE_RANGE;

//
// The type for HTTP protocol version numbers.
//

type
  _HTTP_VERSION = record
    MajorVersion: USHORT;
    MinorVersion: USHORT;
  end;
  HTTP_VERSION = _HTTP_VERSION;
  PHTTP_VERSION = ^_HTTP_VERSION;

//
// Some useful macros for HTTP protocol version manipulation.
//

// #define HTTP_VERSION_UNKNOWN { 0, 0 }
// #define HTTP_VERSION_0_9 { 0, 9 }
// #define HTTP_VERSION_1_0 { 1, 0 }
// #define HTTP_VERSION_1_1 { 1, 1 }
// #define HTTP_VERSION_2_0 { 2, 0 }
// #define HTTP_VERSION_3_0 { 3, 0 }

// #define HTTP_SET_VERSION(version, major, minor) do { (version).MajorVersion = (major); (version).MinorVersion = (minor); } while (0)

// #define HTTP_EQUAL_VERSION(version, major, minor) ((version).MajorVersion == (major) && (version).MinorVersion == (minor))

// #define HTTP_GREATER_VERSION(version, major, minor) ((version).MajorVersion > (major) || ((version).MajorVersion == (major) && (version).MinorVersion > (minor)))

// #define HTTP_LESS_VERSION(version, major, minor) ((version).MajorVersion < (major) || ((version).MajorVersion == (major) && (version).MinorVersion < (minor)))

// #define HTTP_NOT_EQUAL_VERSION(version, major, minor) (!HTTP_EQUAL_VERSION(version, major, minor))

// #define HTTP_GREATER_EQUAL_VERSION(version, major, minor) (!HTTP_LESS_VERSION(version, major, minor))

// #define HTTP_LESS_EQUAL_VERSION(version, major, minor) (!HTTP_GREATER_VERSION(version, major, minor))

//
// The enum type for HTTP Scheme.
//

type
  _HTTP_URI_SCHEME = (
    HttpSchemeHttp,
    HttpSchemeHttps,
    HttpSchemeMaximum);
  HTTP_SCHEME = _HTTP_URI_SCHEME;
  PHTTP_URI_SCHEME = ^_HTTP_URI_SCHEME;

//
// The enum type for HTTP verbs.
//

type
  _HTTP_VERB = (
    HttpVerbUnparsed,
    HttpVerbUnknown,
    HttpVerbInvalid,
    HttpVerbOPTIONS,
    HttpVerbGET,
    HttpVerbHEAD,
    HttpVerbPOST,
    HttpVerbPUT,
    HttpVerbDELETE,
    HttpVerbTRACE,
    HttpVerbCONNECT,
    HttpVerbTRACK, // used by Microsoft Cluster Server for a non-logged trace
    HttpVerbMOVE,
    HttpVerbCOPY,
    HttpVerbPROPFIND,
    HttpVerbPROPPATCH,
    HttpVerbMKCOL,
    HttpVerbLOCK,
    HttpVerbUNLOCK,
    HttpVerbSEARCH,
    HttpVerbMaximum);
  HTTP_VERB = _HTTP_VERB;
  PHTTP_VERB = ^_HTTP_VERB;

//
// Symbols for all HTTP/1.1 headers and other tokens. Notice request +
// response values overlap. Make sure you know which type of header array
// you are indexing.
//
// These values are used as offsets into arrays and as token values in
// HTTP_KNOWN_HEADER arrays in HTTP_REQUEST_HEADERS and HTTP_RESPONSE_HEADERS.
//
// See RFC 2616, HTTP/1.1, for further explanation of most of these headers.
//

type
  _HTTP_HEADER_ID = (
    HttpHeaderCacheControl = 0, // general-header[section 4.5]
    HttpHeaderConnection = 1, // general-header[section 4.5]
    HttpHeaderDate = 2, // general-header[section 4.5]
    HttpHeaderKeepAlive = 3, // general-header[not in rfc]
    HttpHeaderPragma = 4, // general-header[section 4.5]
    HttpHeaderTrailer = 5, // general-header[section 4.5]
    HttpHeaderTransferEncoding = 6, // general-header[section 4.5]
    HttpHeaderUpgrade = 7, // general-header[section 4.5]
    HttpHeaderVia = 8, // general-header[section 4.5]
    HttpHeaderWarning = 9, // general-header[section 4.5]
    HttpHeaderAllow = 10, // entity-header[section 7.1]
    HttpHeaderContentLength = 11, // entity-header[section 7.1]
    HttpHeaderContentType = 12, // entity-header[section 7.1]
    HttpHeaderContentEncoding = 13, // entity-header[section 7.1]
    HttpHeaderContentLanguage = 14, // entity-header[section 7.1]
    HttpHeaderContentLocation = 15, // entity-header[section 7.1]
    HttpHeaderContentMd5 = 16, // entity-header[section 7.1]
    HttpHeaderContentRange = 17, // entity-header[section 7.1]
    HttpHeaderExpires = 18, // entity-header[section 7.1]
    HttpHeaderLastModified = 19, // entity-header[section 7.1]
    // Request Headers
    HttpHeaderAccept = 20, // request-header[section 5.3]
    HttpHeaderAcceptCharset = 21, // request-header[section 5.3]
    HttpHeaderAcceptEncoding = 22, // request-header[section 5.3]
    HttpHeaderAcceptLanguage = 23, // request-header[section 5.3]
    HttpHeaderAuthorization = 24, // request-header[section 5.3]
    HttpHeaderCookie = 25, // request-header[not in rfc]
    HttpHeaderExpect = 26, // request-header[section 5.3]
    HttpHeaderFrom = 27, // request-header[section 5.3]
    HttpHeaderHost = 28, // request-header[section 5.3]
    HttpHeaderIfMatch = 29, // request-header[section 5.3]
    HttpHeaderIfModifiedSince = 30, // request-header[section 5.3]
    HttpHeaderIfNoneMatch = 31, // request-header[section 5.3]
    HttpHeaderIfRange = 32, // request-header[section 5.3]
    HttpHeaderIfUnmodifiedSince = 33, // request-header[section 5.3]
    HttpHeaderMaxForwards = 34, // request-header[section 5.3]
    HttpHeaderProxyAuthorization = 35, // request-header[section 5.3]
    HttpHeaderReferer = 36, // request-header[section 5.3]
    HttpHeaderRange = 37, // request-header[section 5.3]
    HttpHeaderTe = 38, // request-header[section 5.3]
    HttpHeaderTranslate = 39, // request-header[webDAV, not in rfc 2518]
    HttpHeaderUserAgent = 40, // request-header[section 5.3]
    HttpHeaderRequestMaximum = 41,
    // Response Headers
    HttpHeaderAcceptRanges = 20, // response-header[section 6.2]
    HttpHeaderAge = 21, // response-header[section 6.2]
    HttpHeaderEtag = 22, // response-header[section 6.2]
    HttpHeaderLocation = 23, // response-header[section 6.2]
    HttpHeaderProxyAuthenticate = 24, // response-header[section 6.2]
    HttpHeaderRetryAfter = 25, // response-header[section 6.2]
    HttpHeaderServer = 26, // response-header[section 6.2]
    HttpHeaderSetCookie = 27, // response-header[not in rfc]
    HttpHeaderVary = 28, // response-header[section 6.2]
    HttpHeaderWwwAuthenticate = 29, // response-header[section 6.2]
    HttpHeaderResponseMaximum = 30,
    HttpHeaderMaximum = 41);
  HTTP_HEADER_ID = _HTTP_HEADER_ID;
  PHTTP_HEADER_ID = ^_HTTP_HEADER_ID;

//
// Structure defining format of a known HTTP header.
// Name is from HTTP_HEADER_ID.
//

type
  _HTTP_KNOWN_HEADER = record
    RawValueLength: USHORT; // in bytes not including the NUL
    pRawValue: PCSTR;
  end;
  HTTP_KNOWN_HEADER = _HTTP_KNOWN_HEADER;
  PHTTP_KNOWN_HEADER = ^_HTTP_KNOWN_HEADER;

//
// Structure defining format of an unknown header.
//

type
  _HTTP_UNKNOWN_HEADER = record
    NameLength: USHORT; // in bytes not including the NUL
    RawValueLength: USHORT; // in bytes not including the NUL
    pName: PCSTR; // The header name (minus the ':' character)
    pRawValue: PCSTR; // The header value
  end;
  HTTP_UNKNOWN_HEADER = _HTTP_UNKNOWN_HEADER;
  PHTTP_UNKNOWN_HEADER = ^_HTTP_UNKNOWN_HEADER;

//
// Log fields data structure is used for logging a request. This structure must
// be provided along with an HttpSendHttpResponse or HttpSendResponseEntityBody
// call that concludes the send.
//

// Base structure is for future versioning.

type
  _HTTP_LOG_DATA_TYPE = (
    HttpLogDataTypeFields = 0);
  HTTP_LOG_DATA_TYPE = _HTTP_LOG_DATA_TYPE;
  PHTTP_LOG_DATA_TYPE = ^_HTTP_LOG_DATA_TYPE;

// should we DECLSPEC_ALIGN(4 or 8) == DECLSPEC_POINTERALIGN?
type
  _HTTP_LOG_DATA = record
    &Type: HTTP_LOG_DATA_TYPE;
  end;
  HTTP_LOG_DATA = _HTTP_LOG_DATA;
  PHTTP_LOG_DATA = ^_HTTP_LOG_DATA;

// Current log fields data structure for of type HttpLogDataTypeFields.

type
  _HTTP_LOG_FIELDS_DATA = record
    Base: HTTP_LOG_DATA;
    UserNameLength: USHORT;
    UriStemLength: USHORT;
    ClientIpLength: USHORT;
    ServerNameLength: USHORT;
    ServiceNameLength: USHORT;
    ServerIpLength: USHORT;
    MethodLength: USHORT;
    UriQueryLength: USHORT;
    HostLength: USHORT;
    UserAgentLength: USHORT;
    CookieLength: USHORT;
    ReferrerLength: USHORT;
    UserName: PWCHAR;
    UriStem: PWCHAR;
    ClientIp: PAnsiChar;
    ServerName: PAnsiChar;
    ServiceName: PAnsiChar;
    ServerIp: PAnsiChar;
    Method: PAnsiChar;
    UriQuery: PAnsiChar;
    Host: PAnsiChar;
    UserAgent: PAnsiChar;
    Cookie: PAnsiChar;
    Referrer: PAnsiChar;
    ServerPort: USHORT;
    ProtocolStatus: USHORT;
    Win32Status: ULONG;
    MethodNum: HTTP_VERB;
    SubStatus: USHORT;
  end;
  HTTP_LOG_FIELDS_DATA = _HTTP_LOG_FIELDS_DATA;
  PHTTP_LOG_FIELDS_DATA = ^_HTTP_LOG_FIELDS_DATA;

type
  _HTTP_WINHTTP_FAST_FORWARDING_DATA = record
    Reserved: array[0..16-1] of UCHAR;
  end;
  HTTP_WINHTTP_FAST_FORWARDING_DATA = _HTTP_WINHTTP_FAST_FORWARDING_DATA;
  PHTTP_WINHTTP_FAST_FORWARDING_DATA = ^_HTTP_WINHTTP_FAST_FORWARDING_DATA;

//
// This enum defines a data source for a particular chunk of data.
//

type
  _HTTP_DATA_CHUNK_TYPE = (
    HttpDataChunkFromMemory,
    HttpDataChunkFromFileHandle,
    HttpDataChunkFromFragmentCache,
    HttpDataChunkFromFragmentCacheEx,
    HttpDataChunkTrailers,
    HttpDataChunkFromWinHttpFastForwarding,
    HttpDataChunkMaximum);
  HTTP_DATA_CHUNK_TYPE = _HTTP_DATA_CHUNK_TYPE;
  PHTTP_DATA_CHUNK_TYPE = ^_HTTP_DATA_CHUNK_TYPE;

//
// This structure describes an individual data chunk.
//

type
  _HTTP_DATA_CHUNK = record
    // The type of this data chunk.
    DataChunkType: HTTP_DATA_CHUNK_TYPE;
    // The data chunk structures, one per supported data chunk type.
    case Integer of
      // From-memory data chunk.
      0:(
        FromMemory: record
          pBuffer: PVOID;
          BufferLength: ULONG;
        end;
      );
      // From-file handle data chunk.
      1:(
        FromFileHandle: record
          ByteRange: HTTP_BYTE_RANGE;
          FileHandle: HANDLE;
        end;
      );
      // From-fragment cache data chunk.
      2:(
        FromFragmentCache: record
          FragmentNameLength: USHORT; // in bytes not including the NUL
          pFragmentName: PCWSTR;
        end;
      );
      // From-fragment cache data chunk that specifies a byte range.
      3:(
        FromFragmentCacheEx: record
          ByteRange: HTTP_BYTE_RANGE;
          pFragmentName: PCWSTR; // NULL-terminated string
        end;
      );
      // Trailer data chunk that specifies Trailer headers.
      4:(
        Trailers: record
          TrailerCount: USHORT;
          pTrailers: PHTTP_UNKNOWN_HEADER;
        end;
      );
      5:(
        FromWinHttpFastForwarding: record
          WhFastForwardingData: HTTP_WINHTTP_FAST_FORWARDING_DATA;
        end;
      );
  end;
  HTTP_DATA_CHUNK = _HTTP_DATA_CHUNK;
  PHTTP_DATA_CHUNK = ^_HTTP_DATA_CHUNK;

//
// HTTP API doesn't support 16 bit applications.
// Neither WIN32 nor _WIN64 was defined.
//

// C_ASSERT(TYPE_ALIGNMENT(HTTP_DATA_CHUNK) == sizeof(ULONGLONG));

//
// Structure defining format of request headers.
//

type
  _HTTP_REQUEST_HEADERS = record
    // The array of unknown HTTP headers and the number of
    // entries in the array.
    UnknownHeaderCount: USHORT;
    pUnknownHeaders: PHTTP_UNKNOWN_HEADER;
    // Trailers - we don't use these currently, reserved for a future release
    TrailerCount: USHORT; // Reserved, must be 0
    pTrailers: PHTTP_UNKNOWN_HEADER; // Reserved, must be NULL
    // Known headers.
    KnownHeaders: array[0..Ord(HttpHeaderRequestMaximum)-1] of HTTP_KNOWN_HEADER;
  end;
  HTTP_REQUEST_HEADERS = _HTTP_REQUEST_HEADERS;
  PHTTP_REQUEST_HEADERS = ^_HTTP_REQUEST_HEADERS;

//
// Structure defining format of response headers.
//

type
  _HTTP_RESPONSE_HEADERS = record
    // The array of unknown HTTP headers and the number of
    // entries in the array.
    UnknownHeaderCount: USHORT;
    pUnknownHeaders: PHTTP_UNKNOWN_HEADER;
    // Trailers - we don't use these currently, reserved for a future release
    TrailerCount: USHORT; // Reserved, must be 0
    pTrailers: PHTTP_UNKNOWN_HEADER; // Reserved, must be NULL
    // Known headers.
    KnownHeaders: array[0..Ord(HttpHeaderResponseMaximum)-1] of HTTP_KNOWN_HEADER;
  end;
  HTTP_RESPONSE_HEADERS = _HTTP_RESPONSE_HEADERS;
  PHTTP_RESPONSE_HEADERS = ^_HTTP_RESPONSE_HEADERS;

//
// Properties that can be passed down with IOCTL_HTTP_DELEGATE_REQUEST_EX
//

type
  _HTTP_DELEGATE_REQUEST_PROPERTY_ID = (
    DelegateRequestReservedProperty,
    DelegateRequestDelegateUrlProperty);
  HTTP_DELEGATE_REQUEST_PROPERTY_ID = _HTTP_DELEGATE_REQUEST_PROPERTY_ID;
  PHTTP_DELEGATE_REQUEST_PROPERTY_ID = ^_HTTP_DELEGATE_REQUEST_PROPERTY_ID;

type
  _HTTP_DELEGATE_REQUEST_PROPERTY_INFO = record
    PropertyId: HTTP_DELEGATE_REQUEST_PROPERTY_ID;
    PropertyInfoLength: ULONG;
    PropertyInfo: PVOID;
  end;
  HTTP_DELEGATE_REQUEST_PROPERTY_INFO = _HTTP_DELEGATE_REQUEST_PROPERTY_INFO;
  PHTTP_DELEGATE_REQUEST_PROPERTY_INFO = ^_HTTP_DELEGATE_REQUEST_PROPERTY_INFO;

//
// Properties that can be passed down with IOCTL_HTTP_CREATE_REQUEST_QUEUE_EX
//

type
  _HTTP_CREATE_REQUEST_QUEUE_PROPERTY_ID = (
    CreateRequestQueueExternalIdProperty = 1,
    CreateRequestQueueMax);
  HTTP_CREATE_REQUEST_QUEUE_PROPERTY_ID = _HTTP_CREATE_REQUEST_QUEUE_PROPERTY_ID;
  PHTTP_CREATE_REQUEST_QUEUE_PROPERTY_ID = ^_HTTP_CREATE_REQUEST_QUEUE_PROPERTY_ID;

type
  _HTTP_CREATE_REQUEST_QUEUE_PROPERTY_INFO = record
    PropertyId: HTTP_CREATE_REQUEST_QUEUE_PROPERTY_ID;
    PropertyInfoLength: ULONG;
    PropertyInfo: PVOID;
  end;
  HTTP_CREATE_REQUEST_QUEUE_PROPERTY_INFO = _HTTP_CREATE_REQUEST_QUEUE_PROPERTY_INFO;
  PHTTP_CREATE_REQUEST_QUEUE_PROPERTY_INFO = ^_HTTP_CREATE_REQUEST_QUEUE_PROPERTY_INFO;

//
// Structure defining format of transport address. Use pLocalAddress->sa_family
// to determine whether this is an IPv4 address (AF_INET) or IPv6 (AF_INET6).
//
// pRemoteAddress->sa_family will be the same as pLocalAddress->sa_family.
//
// SOCKADDRs are always in network order, not host order.
//

type
  _HTTP_TRANSPORT_ADDRESS = record
    pRemoteAddress: PSOCKADDR;
    pLocalAddress: PSOCKADDR;
  end;
  HTTP_TRANSPORT_ADDRESS = _HTTP_TRANSPORT_ADDRESS;
  PHTTP_TRANSPORT_ADDRESS = ^_HTTP_TRANSPORT_ADDRESS;

//
// Structure defining format of cooked URL.
//

type
  _HTTP_COOKED_URL = record
    // Pointers overlap and point into pFullUrl. NULL if not present.
    FullUrlLength: USHORT; // in bytes not including the NUL
    HostLength: USHORT; // in bytes (no NUL)
    AbsPathLength: USHORT; // in bytes (no NUL)
    QueryStringLength: USHORT; // in bytes (no NUL)
    pFullUrl: PCWSTR; // points to "http: // hostname:port/abs/.../path?query"
    pHost: PCWSTR; // points to the first char in the hostname
    pAbsPath: PCWSTR; // Points to the 3rd '/' char
    pQueryString: PCWSTR; // Points to the 1st '?' char or NULL
  end;
  HTTP_COOKED_URL = _HTTP_COOKED_URL;
  PHTTP_COOKED_URL = ^_HTTP_COOKED_URL;

//
// An opaque context for URL manipulation.
//

type HTTP_URL_CONTEXT = ULONGLONG;

//
// Optional flags for URL manipulation functions.
//
// HTTP_URL_FLAG_REMOVE_ALL : When this flag is used
// when removing a Url from a url group, regardless of
// the passed URL, all of the Urls from the url group
// will be removed.
//

const HTTP_URL_FLAG_REMOVE_ALL = $00000001;

//
// Request Authentication related.
//

type
  _HTTP_AUTH_STATUS = (
    HttpAuthStatusSuccess,
    HttpAuthStatusNotAuthenticated,
    HttpAuthStatusFailure);
  HTTP_AUTH_STATUS = _HTTP_AUTH_STATUS;
  PHTTP_AUTH_STATUS = ^_HTTP_AUTH_STATUS;

type
  _HTTP_REQUEST_AUTH_TYPE = (
    HttpRequestAuthTypeNone = 0,
    HttpRequestAuthTypeBasic,
    HttpRequestAuthTypeDigest,
    HttpRequestAuthTypeNTLM,
    HttpRequestAuthTypeNegotiate,
    HttpRequestAuthTypeKerberos);
  HTTP_REQUEST_AUTH_TYPE = _HTTP_REQUEST_AUTH_TYPE;
  PHTTP_REQUEST_AUTH_TYPE = ^_HTTP_REQUEST_AUTH_TYPE;

//
// SSL Client certificate information.
//

type
  _HTTP_SSL_CLIENT_CERT_INFO = record
    CertFlags: ULONG;
    CertEncodedSize: ULONG;
    pCertEncoded: PUCHAR;
    Token: HANDLE;
    CertDeniedByMapper: ByteBool;
  end;
  HTTP_SSL_CLIENT_CERT_INFO = _HTTP_SSL_CLIENT_CERT_INFO;
  PHTTP_SSL_CLIENT_CERT_INFO = ^_HTTP_SSL_CLIENT_CERT_INFO;

//
// Flag to retrieve secure channel binding with HttpReceiveClientCertificate
//

const HTTP_RECEIVE_SECURE_CHANNEL_TOKEN = $1;

//
// Flag to retrieve full certificate chain with HttpReceiveClientCertificate
//

const HTTP_RECEIVE_FULL_CHAIN = $2;

//
// Data computed during SSL handshake.
//

type
  _HTTP_SSL_INFO = record
    ServerCertKeySize: USHORT;
    ConnectionKeySize: USHORT;
    ServerCertIssuerSize: ULONG;
    ServerCertSubjectSize: ULONG;
    pServerCertIssuer: PCSTR;
    pServerCertSubject: PCSTR;
    pClientCertInfo: PHTTP_SSL_CLIENT_CERT_INFO;
    SslClientCertNegotiated: ULONG;
  end;
  HTTP_SSL_INFO = _HTTP_SSL_INFO;
  PHTTP_SSL_INFO = ^_HTTP_SSL_INFO;

//
// HttpRequestInfoTypeSslProtocol payload. Contains basic information about the
// SSL/TLS protocol and cipher. See SecPkgContext_ConnectionInfo documentation
// for details. This information is meant for statistics. Do not use this for
// security enforcement because by the time you check this the client may
// already have transmitted the information being protected (e.g. HTTP request
// headers).
//

type
  _HTTP_SSL_PROTOCOL_INFO = record
    Protocol: ULONG;
    CipherType: ULONG;
    CipherStrength: ULONG;
    HashType: ULONG;
    HashStrength: ULONG;
    KeyExchangeType: ULONG;
    KeyExchangeStrength: ULONG;
  end;
  HTTP_SSL_PROTOCOL_INFO = _HTTP_SSL_PROTOCOL_INFO;
  PHTTP_SSL_PROTOCOL_INFO = ^_HTTP_SSL_PROTOCOL_INFO;

//
// List of possible sizes for which information will be retured in HTTP_REQUEST_SIZING_INFO.
//

type
  _HTTP_REQUEST_SIZING_TYPE = (
    HttpRequestSizingTypeTlsHandshakeLeg1ClientData, // Inbound/outbound data?
    HttpRequestSizingTypeTlsHandshakeLeg1ServerData,
    HttpRequestSizingTypeTlsHandshakeLeg2ClientData,
    HttpRequestSizingTypeTlsHandshakeLeg2ServerData,
    HttpRequestSizingTypeHeaders,
    HttpRequestSizingTypeMax);
  HTTP_REQUEST_SIZING_TYPE = _HTTP_REQUEST_SIZING_TYPE;
  PHTTP_REQUEST_SIZING_TYPE = ^_HTTP_REQUEST_SIZING_TYPE;

//
// Flag values for HTTP_REQUEST_SIZING_INFO
//

const HTTP_REQUEST_SIZING_INFO_FLAG_TCP_FAST_OPEN = $00000001;
const HTTP_REQUEST_SIZING_INFO_FLAG_TLS_SESSION_RESUMPTION = $00000002;
const HTTP_REQUEST_SIZING_INFO_FLAG_TLS_FALSE_START = $00000004;
const HTTP_REQUEST_SIZING_INFO_FLAG_FIRST_REQUEST = $00000008;

//
// HttpRequestInfoTypeSizeInfo payload. Contains size information filled by
// each processsing stage.
//

type
  _HTTP_REQUEST_SIZING_INFO = record
    Flags: ULONGLONG;
    RequestIndex: ULONG;
    RequestSizingCount: ULONG;
    RequestSizing: array[0..Ord(HttpRequestSizingTypeMax)-1] of ULONGLONG;
  end;
  HTTP_REQUEST_SIZING_INFO = _HTTP_REQUEST_SIZING_INFO;
  PHTTP_REQUEST_SIZING_INFO = ^_HTTP_REQUEST_SIZING_INFO;

//
// List of possible request timings for which information will be retured in
// HTTP_REQUEST_TIMING_INFO. Not all timings apply for every request.
//

type
  _HTTP_REQUEST_TIMING_TYPE = (
    HttpRequestTimingTypeConnectionStart,
    HttpRequestTimingTypeDataStart,
    HttpRequestTimingTypeTlsCertificateLoadStart,
    HttpRequestTimingTypeTlsCertificateLoadEnd,
    HttpRequestTimingTypeTlsHandshakeLeg1Start,
    HttpRequestTimingTypeTlsHandshakeLeg1End,
    HttpRequestTimingTypeTlsHandshakeLeg2Start,
    HttpRequestTimingTypeTlsHandshakeLeg2End,
    HttpRequestTimingTypeTlsAttributesQueryStart,
    HttpRequestTimingTypeTlsAttributesQueryEnd,
    HttpRequestTimingTypeTlsClientCertQueryStart,
    HttpRequestTimingTypeTlsClientCertQueryEnd,
    HttpRequestTimingTypeHttp2StreamStart,
    HttpRequestTimingTypeHttp2HeaderDecodeStart,
    HttpRequestTimingTypeHttp2HeaderDecodeEnd,
    HttpRequestTimingTypeRequestHeaderParseStart,
    HttpRequestTimingTypeRequestHeaderParseEnd,
    HttpRequestTimingTypeRequestRoutingStart,
    HttpRequestTimingTypeRequestRoutingEnd,
    HttpRequestTimingTypeRequestQueuedForInspection,
    HttpRequestTimingTypeRequestDeliveredForInspection,
    HttpRequestTimingTypeRequestReturnedAfterInspection,
    HttpRequestTimingTypeRequestQueuedForDelegation,
    HttpRequestTimingTypeRequestDeliveredForDelegation,
    HttpRequestTimingTypeRequestReturnedAfterDelegation,
    HttpRequestTimingTypeRequestQueuedForIO,
    HttpRequestTimingTypeRequestDeliveredForIO,
    HttpRequestTimingTypeHttp3StreamStart,
    HttpRequestTimingTypeHttp3HeaderDecodeStart,
    HttpRequestTimingTypeHttp3HeaderDecodeEnd,
    HttpRequestTimingTypeMax);
  HTTP_REQUEST_TIMING_TYPE = _HTTP_REQUEST_TIMING_TYPE;
  PHTTP_REQUEST_TIMING_TYPE = ^_HTTP_REQUEST_TIMING_TYPE;

//
// HttpRequestInfoTypeTiming payload. Contains information about how much
// time was spent at each request processing stage.
//

type
  _HTTP_REQUEST_TIMING_INFO = record
    RequestTimingCount: ULONG;
    RequestTiming: array[0..Ord(HttpRequestTimingTypeMax)-1] of ULONGLONG;
  end;
  HTTP_REQUEST_TIMING_INFO = _HTTP_REQUEST_TIMING_INFO;
  PHTTP_REQUEST_TIMING_INFO = ^_HTTP_REQUEST_TIMING_INFO;

type
  _HTTP_REQUEST_TRANSPORT_IDLE_CONNECTION_TIMEOUT_INFO = record
    TransportIdleConnectionTimeout: USHORT;
  end;
  HTTP_REQUEST_TRANSPORT_IDLE_CONNECTION_TIMEOUT_INFO = _HTTP_REQUEST_TRANSPORT_IDLE_CONNECTION_TIMEOUT_INFO;
  PHTTP_REQUEST_TRANSPORT_IDLE_CONNECTION_TIMEOUT_INFO = ^_HTTP_REQUEST_TRANSPORT_IDLE_CONNECTION_TIMEOUT_INFO;

type
  _HTTP_REQUEST_DSCP_INFO = record
    DscpTag: BYTE;
  end;
  HTTP_REQUEST_DSCP_INFO = _HTTP_REQUEST_DSCP_INFO;
  PHTTP_REQUEST_DSCP_INFO = ^_HTTP_REQUEST_DSCP_INFO;

type
  _HTTP_REQUEST_INITIAL_PACKET_TTL_INFO = record
    InitialPacketTtl: BYTE;
  end;
  HTTP_REQUEST_INITIAL_PACKET_TTL_INFO = _HTTP_REQUEST_INITIAL_PACKET_TTL_INFO;
  PHTTP_REQUEST_INITIAL_PACKET_TTL_INFO = ^_HTTP_REQUEST_INITIAL_PACKET_TTL_INFO;

//
// Generic request information type.
//

type
  _HTTP_REQUEST_INFO_TYPE = (
    HttpRequestInfoTypeAuth,
    HttpRequestInfoTypeChannelBind,
    HttpRequestInfoTypeSslProtocol,
    HttpRequestInfoTypeSslTokenBindingDraft,
    HttpRequestInfoTypeSslTokenBinding,
    HttpRequestInfoTypeRequestTiming,
    HttpRequestInfoTypeTcpInfoV0,
    HttpRequestInfoTypeRequestSizing,
    HttpRequestInfoTypeQuicStats,
    HttpRequestInfoTypeTcpInfoV1,
    HttpRequestInfoTypeQuicStatsV2,
    HttpRequestInfoTypeTcpInfoV2,
    HttpRequestInfoTypeTransportIdleConnectionTimeout,
    HttpRequestInfoTypeDscpTag,
    HttpRequestInfoTypeInitialPacketTtl);
  HTTP_REQUEST_INFO_TYPE = _HTTP_REQUEST_INFO_TYPE;
  PHTTP_REQUEST_INFO_TYPE = ^_HTTP_REQUEST_INFO_TYPE;

type
  _HTTP_REQUEST_INFO = record
    InfoType: HTTP_REQUEST_INFO_TYPE;
    InfoLength: ULONG;
    pInfo: PVOID;
  end;
  HTTP_REQUEST_INFO = _HTTP_REQUEST_INFO;
  PHTTP_REQUEST_INFO = ^_HTTP_REQUEST_INFO;

type SECURITY_STATUS = LONG;
// #define __SECSTATUS_DEFINED__

//
// Authentication request info structure
//

const HTTP_REQUEST_AUTH_FLAG_TOKEN_FOR_CACHED_CRED = ($00000001);

type
  _HTTP_REQUEST_AUTH_INFO = record
    AuthStatus: HTTP_AUTH_STATUS;
    SecStatus: SECURITY_STATUS;
    Flags: ULONG;
    AuthType: HTTP_REQUEST_AUTH_TYPE;
    AccessToken: HANDLE;
    ContextAttributes: ULONG;
    // Optional serialized context.
    PackedContextLength: ULONG;
    PackedContextType: ULONG;
    PackedContext: PVOID;
    // Optional mutual authentication data and its length in bytes.
    MutualAuthDataLength: ULONG;
    pMutualAuthData: PAnsiChar;
    // For SSPI based schemes the package name is returned. Length does
    // not include the terminating null and it is in bytes.
    PackageNameLength: USHORT;
    pPackageName: PWSTR;
  end;
  HTTP_REQUEST_AUTH_INFO = _HTTP_REQUEST_AUTH_INFO;
  PHTTP_REQUEST_AUTH_INFO = ^_HTTP_REQUEST_AUTH_INFO;

//
// The structure of an HTTP request for downlevel OS
//

type
  _HTTP_REQUEST_V1 = record
    // Request flags (see HTTP_REQUEST_FLAG_ * definitions below).
    Flags: ULONG;
    // An opaque request identifier. These values are used by the driver
    // to correlate outgoing responses with incoming requests.
    ConnectionId: HTTP_CONNECTION_ID;
    RequestId: HTTP_REQUEST_ID;
    // The context associated with the URL prefix.
    UrlContext: HTTP_URL_CONTEXT;
    // The HTTP version number.
    Version: HTTP_VERSION;
    // The request verb.
    Verb: HTTP_VERB;
    // The length of the verb string if the Verb field is HttpVerbUnknown.
    UnknownVerbLength: USHORT; // in bytes not including the NUL
    // The length of the raw (uncooked) URL
    RawUrlLength: USHORT; // in bytes not including the NUL
    // Pointer to the verb string if the Verb field is HttpVerbUnknown.
    pUnknownVerb: PCSTR;
    // Pointer to the raw (uncooked) URL
    pRawUrl: PCSTR;
    // The canonicalized Unicode URL
    CookedUrl: HTTP_COOKED_URL;
    // Local and remote transport addresses for the connection.
    Address: HTTP_TRANSPORT_ADDRESS;
    // The request headers.
    Headers: HTTP_REQUEST_HEADERS;
    // The total number of bytes received from network for this request.
    BytesReceived: ULONGLONG;
    // pEntityChunks is an array of EntityChunkCount HTTP_DATA_CHUNKs. The
    // entity body is copied only if HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY
    // was passed to HttpReceiveHttpRequest().
    EntityChunkCount: USHORT;
    pEntityChunks: PHTTP_DATA_CHUNK;
    // SSL connection information.
    RawConnectionId: HTTP_RAW_CONNECTION_ID;
    pSslInfo: PHTTP_SSL_INFO;
  end;
  HTTP_REQUEST_V1 = _HTTP_REQUEST_V1;
  PHTTP_REQUEST_V1 = ^_HTTP_REQUEST_V1;

// Vista

//
// Version 2.0 members are defined here
// N.B. One must define V2 elements in two places :(
// This is due to the fact that C++ doesn't allow anonymous
// structure declarations and one must use structure
// inheritance instead.
//

type
  _HTTP_REQUEST_V2 = record
    // Request flags (see HTTP_REQUEST_FLAG_ * definitions below).
    Flags: ULONG;
    // An opaque request identifier. These values are used by the driver
    // to correlate outgoing responses with incoming requests.
    ConnectionId: HTTP_CONNECTION_ID;
    RequestId: HTTP_REQUEST_ID;
    // The context associated with the URL prefix.
    UrlContext: HTTP_URL_CONTEXT;
    // The HTTP version number.
    Version: HTTP_VERSION;
    // The request verb.
    Verb: HTTP_VERB;
    // The length of the verb string if the Verb field is HttpVerbUnknown.
    UnknownVerbLength: USHORT; // in bytes not including the NUL
    // The length of the raw (uncooked) URL
    RawUrlLength: USHORT; // in bytes not including the NUL
    // Pointer to the verb string if the Verb field is HttpVerbUnknown.
    pUnknownVerb: PCSTR;
    // Pointer to the raw (uncooked) URL
    pRawUrl: PCSTR;
    // The canonicalized Unicode URL
    CookedUrl: HTTP_COOKED_URL;
    // Local and remote transport addresses for the connection.
    Address: HTTP_TRANSPORT_ADDRESS;
    // The request headers.
    Headers: HTTP_REQUEST_HEADERS;
    // The total number of bytes received from network for this request.
    BytesReceived: ULONGLONG;
    // pEntityChunks is an array of EntityChunkCount HTTP_DATA_CHUNKs. The
    // entity body is copied only if HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY
    // was passed to HttpReceiveHttpRequest().
    EntityChunkCount: USHORT;
    pEntityChunks: PHTTP_DATA_CHUNK;
    // SSL connection information.
    RawConnectionId: HTTP_RAW_CONNECTION_ID;
    pSslInfo: PHTTP_SSL_INFO;
    // Version 1.0 members are inherited
    // Version 2.0 members are declared below
    // Additional Request Informations.
    RequestInfoCount: USHORT;
    pRequestInfo: PHTTP_REQUEST_INFO;
  end;
  HTTP_REQUEST_V2 = _HTTP_REQUEST_V2;
  PHTTP_REQUEST_V2 = ^_HTTP_REQUEST_V2;

type HTTP_REQUEST = HTTP_REQUEST_V2;

type PHTTP_REQUEST = ^HTTP_REQUEST;

//
// Values for HTTP_REQUEST::Flags. Zero or more of these may be ORed together.
//
// HTTP_REQUEST_FLAG_MORE_ENTITY_BODY_EXISTS - there is more entity body
// to be read for this request. Otherwise, there is no entity body or
// all of the entity body was copied into pEntityChunks.
// HTTP_REQUEST_FLAG_IP_ROUTED - This flag indicates that the request has been
// routed based on host plus ip or ip binding.This is a hint for the application
// to include the local ip while flushing kernel cache entries build for this
// request if any.
// HTTP_REQUEST_FLAG_HTTP2 - Indicates the request was received over HTTP/2.
// HTTP_REQUEST_FLAG_HTTP3 - Indicates the request was received over HTTP/3.
// HTTP_REQUEST_FLAG_FAST_FORWARDING_RESPONSE_ALLOWED - Indicates the response
// is eligible for
// fast-forwarding.
// HTTP_REQUEST_FLAG_FAST_FORWARDING_ALLOWED - This should not be used, it is
// the old flag.
// It has been used first, but the flag
// was split into request and response
// side. This old flag has the same
// value as the response-side flag.
//

const HTTP_REQUEST_FLAG_MORE_ENTITY_BODY_EXISTS = $00000001;
const HTTP_REQUEST_FLAG_IP_ROUTED = $00000002;
const HTTP_REQUEST_FLAG_HTTP2 = $00000004;
const HTTP_REQUEST_FLAG_HTTP3 = $00000008;
const HTTP_REQUEST_FLAG_FAST_FORWARDING_ALLOWED = $00000010;
const HTTP_REQUEST_FLAG_FAST_FORWARDING_RESPONSE_ALLOWED = HTTP_REQUEST_FLAG_FAST_FORWARDING_ALLOWED;

//
// This structure describes an HTTP response.
//

type
  _HTTP_RESPONSE_V1 = record
    // Response flags (see HTTP_RESPONSE_FLAG_ * definitions below).
    Flags: ULONG;
    // The raw HTTP protocol version number.
    Version: HTTP_VERSION;
    // The HTTP status code (e.g., 200).
    StatusCode: USHORT;
    // The HTTP reason (e.g., "OK"). This MUST not contain
    // non-ASCII characters (i.e., all chars must be in range 0x20-0x7E).
    ReasonLength: USHORT; // in bytes not including the '\0'
    pReason: PCSTR;
    // The response headers.
    Headers: HTTP_RESPONSE_HEADERS;
    // pEntityChunks points to an array of EntityChunkCount HTTP_DATA_CHUNKs.
    EntityChunkCount: USHORT;
    pEntityChunks: PHTTP_DATA_CHUNK;
  end;
  HTTP_RESPONSE_V1 = _HTTP_RESPONSE_V1;
  PHTTP_RESPONSE_V1 = ^_HTTP_RESPONSE_V1;

//
// Values for HTTP_RESPONSE::Flags.
//
// HTTP_RESPONSE_FLAG_MULTIPLE_ENCODINGS_AVAILABLE - Set this flag if encodings
// other than identity form are available for this resource.This flag is ignored
// if application has not asked for response to be cached. It's used as a hint
// to the Http Server API for content negotiation used when serving from the
// the kernel response cache.
//
// HTTP_RESPONSE_FLAG_MORE_ENTITY_BODY_EXISTS - there is more entity body
// to be read for this response. Otherwise, there is no entity body or
// all of the entity body was copied into pEntityChunks.
//

const HTTP_RESPONSE_FLAG_MULTIPLE_ENCODINGS_AVAILABLE = $00000001;
const HTTP_RESPONSE_FLAG_MORE_ENTITY_BODY_EXISTS = $00000002;

type
  _HTTP_RESPONSE_INFO_TYPE = (
    HttpResponseInfoTypeMultipleKnownHeaders,
    HttpResponseInfoTypeAuthenticationProperty,
    HttpResponseInfoTypeQoSProperty,
    HttpResponseInfoTypeChannelBind);
  HTTP_RESPONSE_INFO_TYPE = _HTTP_RESPONSE_INFO_TYPE;
  PHTTP_RESPONSE_INFO_TYPE = ^_HTTP_RESPONSE_INFO_TYPE;

type
  _HTTP_RESPONSE_INFO = record
    &Type: HTTP_RESPONSE_INFO_TYPE;
    Length: ULONG;
    pInfo: PVOID;
  end;
  HTTP_RESPONSE_INFO = _HTTP_RESPONSE_INFO;
  PHTTP_RESPONSE_INFO = ^_HTTP_RESPONSE_INFO;

const HTTP_RESPONSE_INFO_FLAGS_PRESERVE_ORDER = $00000001;

//
// This structure allows the provision of providing multiple known headers.
//

type
  _HTTP_MULTIPLE_KNOWN_HEADERS = record
    // Known header id.
    HeaderId: HTTP_HEADER_ID;
    Flags: ULONG;
    // Number of headers of the same category.
    KnownHeaderCount: USHORT;
    // Array of known header structures.
    KnownHeaders: PHTTP_KNOWN_HEADER;
  end;
  HTTP_MULTIPLE_KNOWN_HEADERS = _HTTP_MULTIPLE_KNOWN_HEADERS;
  PHTTP_MULTIPLE_KNOWN_HEADERS = ^_HTTP_MULTIPLE_KNOWN_HEADERS;

//
// Version 2.0 members are defined here
// N.B. One must define V2 elements in two places :(
// This is due to the fact that C++ doesn't allow anonymous
// structure declarations and one must use structure
// inheritance instead.
//

type
  _HTTP_RESPONSE_V2 = record
    // Response flags (see HTTP_RESPONSE_FLAG_ * definitions below).
    Flags: ULONG;
    // The raw HTTP protocol version number.
    Version: HTTP_VERSION;
    // The HTTP status code (e.g., 200).
    StatusCode: USHORT;
    // The HTTP reason (e.g., "OK"). This MUST not contain
    // non-ASCII characters (i.e., all chars must be in range 0x20-0x7E).
    ReasonLength: USHORT; // in bytes not including the '\0'
    pReason: PCSTR;
    // The response headers.
    Headers: HTTP_RESPONSE_HEADERS;
    // pEntityChunks points to an array of EntityChunkCount HTTP_DATA_CHUNKs.
    EntityChunkCount: USHORT;
    pEntityChunks: PHTTP_DATA_CHUNK;
    // Version 1.0 members are inherited
    // Version 2.0 members are declared below
    ResponseInfoCount: USHORT;
    pResponseInfo: PHTTP_RESPONSE_INFO;
  end;
  HTTP_RESPONSE_V2 = _HTTP_RESPONSE_V2;
  PHTTP_RESPONSE_V2 = ^_HTTP_RESPONSE_V2;

type HTTP_RESPONSE = HTTP_RESPONSE_V2;

type PHTTP_RESPONSE = ^HTTP_RESPONSE;

//
// Api Version. This is used to ensure compatibility between applications and
// httpapi.dll and http.sys.
//
// This must not be confused with the HTTP Protocol version.
//

type
  _HTTPAPI_VERSION = record
    HttpApiMajorVersion: USHORT;
    HttpApiMinorVersion: USHORT;
  end;
  HTTPAPI_VERSION = _HTTPAPI_VERSION;
  PHTTPAPI_VERSION = ^_HTTPAPI_VERSION;

// Vista

const HTTPAPI_VERSION_2: HTTPAPI_VERSION = (HttpApiMajorVersion:2; HttpApiMinorVersion:0);

const HTTPAPI_VERSION_1: HTTPAPI_VERSION = (HttpApiMajorVersion:1; HttpApiMinorVersion:0);

// #define HTTPAPI_EQUAL_VERSION(version, major, minor) ((version).HttpApiMajorVersion == (major) && (version).HttpApiMinorVersion == (minor))

// #define HTTPAPI_GREATER_VERSION(version, major, minor) ((version).HttpApiMajorVersion > (major) || ((version).HttpApiMajorVersion == (major) && (version).HttpApiMinorVersion > (minor)))

// #define HTTPAPI_LESS_VERSION(version, major, minor) ((version).HttpApiMajorVersion < (major) || ((version).HttpApiMajorVersion == (major) && (version).HttpApiMinorVersion < (minor)))

// #define HTTPAPI_VERSION_GREATER_OR_EQUAL( version, major, minor) (!HTTPAPI_LESS_VERSION(version, major, minor))

//
// Cache control.
//

//
// This enum defines the available cache policies.
//

type
  _HTTP_CACHE_POLICY_TYPE = (
    HttpCachePolicyNocache,
    HttpCachePolicyUserInvalidates,
    HttpCachePolicyTimeToLive,
    HttpCachePolicyMaximum);
  HTTP_CACHE_POLICY_TYPE = _HTTP_CACHE_POLICY_TYPE;
  PHTTP_CACHE_POLICY_TYPE = ^_HTTP_CACHE_POLICY_TYPE;

//
// Only cache unauthorized GETs + HEADs.
//

type
  _HTTP_CACHE_POLICY = record
    Policy: HTTP_CACHE_POLICY_TYPE;
    SecondsToLive: ULONG;
  end;
  HTTP_CACHE_POLICY = _HTTP_CACHE_POLICY;
  PHTTP_CACHE_POLICY = ^_HTTP_CACHE_POLICY;

//
// Enum that is used with HttpSetServiceConfiguration(),
// HttpQueryServiceConfiguration(), and HttpDeleteServiceConfiguration() APIs.
//

type
  _HTTP_SERVICE_CONFIG_ID = (
    HttpServiceConfigIPListenList, // Set, Query & Delete.
    HttpServiceConfigSSLCertInfo, // Set, Update, Query & Delete.
    HttpServiceConfigUrlAclInfo, // Set, Query & Delete.
    HttpServiceConfigTimeout, // Set, Query & Delete.
    HttpServiceConfigCache, // Set, Query & Delete.
    HttpServiceConfigSslSniCertInfo, // Set, Update, Query & Delete.
    HttpServiceConfigSslCcsCertInfo, // Set, Update, Query & Delete.
    HttpServiceConfigSetting, // Set, Query & Delete.
    HttpServiceConfigSslCertInfoEx,
    HttpServiceConfigSslSniCertInfoEx,
    HttpServiceConfigSslCcsCertInfoEx,
    HttpServiceConfigSslScopedCcsCertInfo,
    HttpServiceConfigSslScopedCcsCertInfoEx,
    HttpServiceConfigMax);
  HTTP_SERVICE_CONFIG_ID = _HTTP_SERVICE_CONFIG_ID;
  PHTTP_SERVICE_CONFIG_ID = ^_HTTP_SERVICE_CONFIG_ID;

//
// Generic Query enum that can be used with HttpQueryServiceConfiguration()
//

type
  _HTTP_SERVICE_CONFIG_QUERY_TYPE = (
    HttpServiceConfigQueryExact,
    HttpServiceConfigQueryNext,
    HttpServiceConfigQueryMax);
  HTTP_SERVICE_CONFIG_QUERY_TYPE = _HTTP_SERVICE_CONFIG_QUERY_TYPE;
  PHTTP_SERVICE_CONFIG_QUERY_TYPE = ^_HTTP_SERVICE_CONFIG_QUERY_TYPE;

//
// These data structures are used to define the key types of the various SSL
// bindings.
//

type
  _HTTP_SERVICE_CONFIG_SSL_KEY = record
    pIpPort: PSOCKADDR;
  end;
  HTTP_SERVICE_CONFIG_SSL_KEY = _HTTP_SERVICE_CONFIG_SSL_KEY;
  PHTTP_SERVICE_CONFIG_SSL_KEY = ^_HTTP_SERVICE_CONFIG_SSL_KEY;

type
  _HTTP_SERVICE_CONFIG_SSL_KEY_EX = record
    IpPort: SOCKADDR_STORAGE;
  end;
  HTTP_SERVICE_CONFIG_SSL_KEY_EX = _HTTP_SERVICE_CONFIG_SSL_KEY_EX;
  PHTTP_SERVICE_CONFIG_SSL_KEY_EX = ^_HTTP_SERVICE_CONFIG_SSL_KEY_EX;

type
  _HTTP_SERVICE_CONFIG_SSL_SNI_KEY = record
    IpPort: SOCKADDR_STORAGE;
    Host: PWSTR;
  end;
  HTTP_SERVICE_CONFIG_SSL_SNI_KEY = _HTTP_SERVICE_CONFIG_SSL_SNI_KEY;
  PHTTP_SERVICE_CONFIG_SSL_SNI_KEY = ^_HTTP_SERVICE_CONFIG_SSL_SNI_KEY;

type
  _HTTP_SERVICE_CONFIG_SSL_CCS_KEY = record
    LocalAddress: SOCKADDR_STORAGE;
  end;
  HTTP_SERVICE_CONFIG_SSL_CCS_KEY = _HTTP_SERVICE_CONFIG_SSL_CCS_KEY;
  PHTTP_SERVICE_CONFIG_SSL_CCS_KEY = ^_HTTP_SERVICE_CONFIG_SSL_CCS_KEY;

//
// Define various certificate check mode flags used by DefaultCertCheckMode.
//

const HTTP_CERT_CHECK_MODE_NO_REVOCATION = $00001;
const HTTP_CERT_CHECK_MODE_CACHED_REVOCATION = $00002;
const HTTP_CERT_CHECK_MODE_USE_REVOCATION_FRESHNESS = $00004;
const HTTP_CERT_CHECK_MODE_CACHED_URLS = $00008;
const HTTP_CERT_CHECK_MODE_NO_AIA = $00010;
const HTTP_CERT_CHECK_MODE_NO_USAGE_CHECK = $10000;

//
// This defines a record for the SSL config store.
//

type
  _HTTP_SERVICE_CONFIG_SSL_PARAM = record
    SslHashLength: ULONG; // Length of the SSL hash (in bytes)
    pSslHash: PVOID; // Pointer to the SSL hash
    AppId: GUID; // A unique identifier that can be used to
    // identify the app that has set this parameter
    pSslCertStoreName: PWSTR; // Store name to read the server certificate
    // from; defaults to "MY". Certificate must be
    // stored in the LOCAL_MACHINE context.
    // The following settings are used only for client certificates
    // DefaultCertCheckMode is a bit flag with the following semantics
    // 0x1 - Client certificate will not be verified for revocation
    // 0x2 - Only cached certificate revocation will be used.
    // 0x4 - Enable use of the DefaultRevocationFreshnessTime setting
    // 0x8 - Disable network URL retrieval.
    // 0x10 - Disable AIA checks.
    // 0x10000 - No usage check.
    DefaultCertCheckMode: DWORD;
    // DefaultRevocationFreshnessTime (seconds) - How often to check for
    // an updated Certificate revocation list (CRL). If this value is 0
    // then the new CRL is updated only if the previous one expires
    DefaultRevocationFreshnessTime: DWORD;
    // DefaultRevocationUrlRetrievalTimeout (milliseconds) - Timeout on
    // attempt to retrieve certificate revocation list from the remote URL.
    DefaultRevocationUrlRetrievalTimeout: DWORD;
    // pDefaultSslCtlIdentifier - Restrict the certificate issuers that you
    // want to trust. Can be a subset of the certificate issuers that are
    // trusted by the machine.
    pDefaultSslCtlIdentifier: PWSTR;
    // Store name under LOCAL_MACHINE where Ctl identified by
    // pDefaultSslCtlIdentifier is stored.
    pDefaultSslCtlStoreName: PWSTR;
    // Default Flags - see HTTP_SERVICE_CONFIG_SSL_FLAG * below.
    DefaultFlags: DWORD;
  end;
  HTTP_SERVICE_CONFIG_SSL_PARAM = _HTTP_SERVICE_CONFIG_SSL_PARAM;
  PHTTP_SERVICE_CONFIG_SSL_PARAM = ^_HTTP_SERVICE_CONFIG_SSL_PARAM;

//
// The extended param type for the SSL extended params.
//

type
  _HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE = (
    ExParamTypeHttp2Window,
    ExParamTypeHttp2SettingsLimits,
    ExParamTypeHttpPerformance,
    ExParamTypeTlsRestrictions,
    ExParamTypeErrorHeaders,
    ExParamTypeTlsSessionTicketKeys,
    ExParamTypeCertConfig,
    ExParamTypeMax);
  HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE = _HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE;
  PHTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE = ^_HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE;

type
  _HTTP2_WINDOW_SIZE_PARAM = record
    // The http/2 connection receive window size.
    Http2ReceiveWindowSize: DWORD;
  end;
  HTTP2_WINDOW_SIZE_PARAM = _HTTP2_WINDOW_SIZE_PARAM;
  PHTTP2_WINDOW_SIZE_PARAM = ^_HTTP2_WINDOW_SIZE_PARAM;

type
  _HTTP2_SETTINGS_LIMITS_PARAM = record
    // The maximum allowed settings per SETTINGS frame.
    Http2MaxSettingsPerFrame: DWORD;
    // The maximum settings we will process in a minute.
    Http2MaxSettingsPerMinute: DWORD;
  end;
  HTTP2_SETTINGS_LIMITS_PARAM = _HTTP2_SETTINGS_LIMITS_PARAM;
  PHTTP2_SETTINGS_LIMITS_PARAM = ^_HTTP2_SETTINGS_LIMITS_PARAM;

type
  _HTTP_PERFORMANCE_PARAM_TYPE = (
    PerformanceParamSendBufferingFlags,
    PerformanceParamAggressiveICW,
    PerformanceParamMaxSendBufferSize,
    PerformanceParamMaxConcurrentClientStreams,
    PerformanceParamMaxReceiveBufferSize,
    PerformanceParamDecryptOnSspiThread,
    PerformanceParamMax);
  HTTP_PERFORMANCE_PARAM_TYPE = _HTTP_PERFORMANCE_PARAM_TYPE;
  PHTTP_PERFORMANCE_PARAM_TYPE = ^_HTTP_PERFORMANCE_PARAM_TYPE;

type
  _HTTP_PERFORMANCE_PARAM = record
    &Type: HTTP_PERFORMANCE_PARAM_TYPE;
    BufferSize: ULONG;
    Buffer: PVOID;
  end;
  HTTP_PERFORMANCE_PARAM = _HTTP_PERFORMANCE_PARAM;
  PHTTP_PERFORMANCE_PARAM = ^_HTTP_PERFORMANCE_PARAM;

type
  _HTTP_TLS_RESTRICTIONS_PARAM = record
    RestrictionCount: ULONG;
    TlsRestrictions: PVOID;
  end;
  HTTP_TLS_RESTRICTIONS_PARAM = _HTTP_TLS_RESTRICTIONS_PARAM;
  PHTTP_TLS_RESTRICTIONS_PARAM = ^_HTTP_TLS_RESTRICTIONS_PARAM;

type
  _HTTP_ERROR_HEADERS_PARAM = record
    StatusCode: USHORT;
    HeaderCount: USHORT;
    Headers: PHTTP_UNKNOWN_HEADER;
  end;
  HTTP_ERROR_HEADERS_PARAM = _HTTP_ERROR_HEADERS_PARAM;
  PHTTP_ERROR_HEADERS_PARAM = ^_HTTP_ERROR_HEADERS_PARAM;

type
  _HTTP_TLS_SESSION_TICKET_KEYS_PARAM = record
    SessionTicketKeyCount: ULONG;
    SessionTicketKeys: PVOID;
  end;
  HTTP_TLS_SESSION_TICKET_KEYS_PARAM = _HTTP_TLS_SESSION_TICKET_KEYS_PARAM;
  PHTTP_TLS_SESSION_TICKET_KEYS_PARAM = ^_HTTP_TLS_SESSION_TICKET_KEYS_PARAM;

//
// This should really be defined by one of the security header files.
//

const HTTP_SSL_CERT_SHA_HASH_LENGTH = 20;
const HTTP_SSL_CERT_STORE_NAME_LENGTH = 128;

type
  _HTTP_CERT_CONFIG_ENTRY = record
    CertHash: array[0..HTTP_SSL_CERT_SHA_HASH_LENGTH-1] of BYTE;
    CertStoreName: array[0..HTTP_SSL_CERT_STORE_NAME_LENGTH-1] of WCHAR;
  end;
  HTTP_CERT_CONFIG_ENTRY = _HTTP_CERT_CONFIG_ENTRY;
  PHTTP_CERT_CONFIG_ENTRY = ^_HTTP_CERT_CONFIG_ENTRY;

type
  _HTTP_CERT_CONFIG_PARAM = record
    CertConfigCount: ULONG;
    CertConfigs: PHTTP_CERT_CONFIG_ENTRY;
  end;
  HTTP_CERT_CONFIG_PARAM = _HTTP_CERT_CONFIG_PARAM;
  PHTTP_CERT_CONFIG_PARAM = ^_HTTP_CERT_CONFIG_PARAM;

//
// This defines the extended params for the ssl config record.
//

type
  _HTTP_SERVICE_CONFIG_SSL_PARAM_EX = record
    // The id that decides which param property is passed below.
    ParamType: HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE;
    // Flags for future use, if any.
    Flags: ULONGLONG;
    // The property.
    case Integer of
      0:(Http2WindowSizeParam: HTTP2_WINDOW_SIZE_PARAM);
      1:(Http2SettingsLimitsParam: HTTP2_SETTINGS_LIMITS_PARAM);
      2:(HttpPerformanceParam: HTTP_PERFORMANCE_PARAM);
      3:(HttpTlsRestrictionsParam: HTTP_TLS_RESTRICTIONS_PARAM);
      4:(HttpErrorHeadersParam: HTTP_ERROR_HEADERS_PARAM);
      5:(HttpTlsSessionTicketKeysParam: HTTP_TLS_SESSION_TICKET_KEYS_PARAM);
      6:(HttpCertConfigParam: HTTP_CERT_CONFIG_PARAM);
  end;
  HTTP_SERVICE_CONFIG_SSL_PARAM_EX = _HTTP_SERVICE_CONFIG_SSL_PARAM_EX;
  PHTTP_SERVICE_CONFIG_SSL_PARAM_EX = ^_HTTP_SERVICE_CONFIG_SSL_PARAM_EX;

//
// The SSL config flags.
//

const HTTP_SERVICE_CONFIG_SSL_FLAG_USE_DS_MAPPER = $00000001;
const HTTP_SERVICE_CONFIG_SSL_FLAG_NEGOTIATE_CLIENT_CERT = $00000002;
const HTTP_SERVICE_CONFIG_SSL_FLAG_REJECT = $00000008;

const HTTP_SERVICE_CONFIG_SSL_FLAG_DISABLE_HTTP2 = $00000010;
const HTTP_SERVICE_CONFIG_SSL_FLAG_DISABLE_QUIC = $00000020;
const HTTP_SERVICE_CONFIG_SSL_FLAG_DISABLE_TLS13 = $00000040;

const HTTP_SERVICE_CONFIG_SSL_FLAG_DISABLE_OCSP_STAPLING = $00000080;
const HTTP_SERVICE_CONFIG_SSL_FLAG_ENABLE_TOKEN_BINDING = $00000100;
const HTTP_SERVICE_CONFIG_SSL_FLAG_LOG_EXTENDED_EVENTS = $00000200;
const HTTP_SERVICE_CONFIG_SSL_FLAG_DISABLE_LEGACY_TLS = $00000400;
const HTTP_SERVICE_CONFIG_SSL_FLAG_ENABLE_SESSION_TICKET = $00000800;
const HTTP_SERVICE_CONFIG_SSL_FLAG_DISABLE_TLS12 = $00001000;
const HTTP_SERVICE_CONFIG_SSL_FLAG_ENABLE_CLIENT_CORRELATION = $00002000;
const HTTP_SERVICE_CONFIG_SSL_FLAG_DISABLE_SESSION_ID = $00004000;
const HTTP_SERVICE_CONFIG_SSL_FLAG_ENABLE_CACHE_CLIENT_HELLO = $00008000;

//
// These data structures are used by HttpSetServiceConfiguration() to add a new
// record to the SSL bindings list.
//
// ConfigId | Structure
// --------------------------------+---------------------------------
// HttpServiceConfigSSLCertInfo | HTTP_SERVICE_CONFIG_SSL_SET
// HttpServiceConfigSslSniCertInfo | HTTP_SERVICE_CONFIG_SSL_SNI_SET
// HttpServiceConfigSslCcsCertInfo | HTTP_SERVICE_CONFIG_SSL_CCS_SET
//

type
  _HTTP_SERVICE_CONFIG_SSL_SET = record
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_KEY;
    ParamDesc: HTTP_SERVICE_CONFIG_SSL_PARAM;
  end;
  HTTP_SERVICE_CONFIG_SSL_SET = _HTTP_SERVICE_CONFIG_SSL_SET;
  PHTTP_SERVICE_CONFIG_SSL_SET = ^_HTTP_SERVICE_CONFIG_SSL_SET;

type
  _HTTP_SERVICE_CONFIG_SSL_SNI_SET = record
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_SNI_KEY;
    ParamDesc: HTTP_SERVICE_CONFIG_SSL_PARAM;
  end;
  HTTP_SERVICE_CONFIG_SSL_SNI_SET = _HTTP_SERVICE_CONFIG_SSL_SNI_SET;
  PHTTP_SERVICE_CONFIG_SSL_SNI_SET = ^_HTTP_SERVICE_CONFIG_SSL_SNI_SET;

type
  _HTTP_SERVICE_CONFIG_SSL_CCS_SET = record
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_CCS_KEY;
    ParamDesc: HTTP_SERVICE_CONFIG_SSL_PARAM;
  end;
  HTTP_SERVICE_CONFIG_SSL_CCS_SET = _HTTP_SERVICE_CONFIG_SSL_CCS_SET;
  PHTTP_SERVICE_CONFIG_SSL_CCS_SET = ^_HTTP_SERVICE_CONFIG_SSL_CCS_SET;

type
  _HTTP_SERVICE_CONFIG_SSL_SET_EX = record
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_KEY_EX;
    ParamDesc: HTTP_SERVICE_CONFIG_SSL_PARAM_EX;
  end;
  HTTP_SERVICE_CONFIG_SSL_SET_EX = _HTTP_SERVICE_CONFIG_SSL_SET_EX;
  PHTTP_SERVICE_CONFIG_SSL_SET_EX = ^_HTTP_SERVICE_CONFIG_SSL_SET_EX;

type
  _HTTP_SERVICE_CONFIG_SSL_SNI_SET_EX = record
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_SNI_KEY;
    ParamDesc: HTTP_SERVICE_CONFIG_SSL_PARAM_EX;
  end;
  HTTP_SERVICE_CONFIG_SSL_SNI_SET_EX = _HTTP_SERVICE_CONFIG_SSL_SNI_SET_EX;
  PHTTP_SERVICE_CONFIG_SSL_SNI_SET_EX = ^_HTTP_SERVICE_CONFIG_SSL_SNI_SET_EX;

type
  _HTTP_SERVICE_CONFIG_SSL_CCS_SET_EX = record
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_CCS_KEY;
    ParamDesc: HTTP_SERVICE_CONFIG_SSL_PARAM_EX;
  end;
  HTTP_SERVICE_CONFIG_SSL_CCS_SET_EX = _HTTP_SERVICE_CONFIG_SSL_CCS_SET_EX;
  PHTTP_SERVICE_CONFIG_SSL_CCS_SET_EX = ^_HTTP_SERVICE_CONFIG_SSL_CCS_SET_EX;

//
// These data structures are used by HttpQueryServiceConfiguration() to query a
// particular record from the SSL store.
//
// ConfigId | Structure
// --------------------------------+---------------------------------
// HttpServiceConfigSSLCertInfo | HTTP_SERVICE_CONFIG_SSL_QUERY
// HttpServiceConfigSSLSniCertInfo | HTTP_SERVICE_CONFIG_SSL_SNI_QUERY
// HttpServiceConfigSslCcsCertInfo | HTTP_SERVICE_CONFIG_SSL_CCS_QUERY
//
// If QueryDesc is HttpServiceConfigQueryExact, then the one particular record
// is returned. If the QueryType is HttpServiceConfigQueryNext, then the next
// instance is returned. In such cases, the dwToken field represents the cursor.
// To retrieve the first item, dwToken has to be 0. For retrieving subsequent
// items, dwToken has to be incremented by 1, until ERROR_NO_MORE_ITEMS is
// returned.
//

type
  _HTTP_SERVICE_CONFIG_SSL_QUERY = record
    QueryDesc: HTTP_SERVICE_CONFIG_QUERY_TYPE;
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_KEY;
    dwToken: DWORD;
  end;
  HTTP_SERVICE_CONFIG_SSL_QUERY = _HTTP_SERVICE_CONFIG_SSL_QUERY;
  PHTTP_SERVICE_CONFIG_SSL_QUERY = ^_HTTP_SERVICE_CONFIG_SSL_QUERY;

type
  _HTTP_SERVICE_CONFIG_SSL_SNI_QUERY = record
    QueryDesc: HTTP_SERVICE_CONFIG_QUERY_TYPE;
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_SNI_KEY;
    dwToken: DWORD;
  end;
  HTTP_SERVICE_CONFIG_SSL_SNI_QUERY = _HTTP_SERVICE_CONFIG_SSL_SNI_QUERY;
  PHTTP_SERVICE_CONFIG_SSL_SNI_QUERY = ^_HTTP_SERVICE_CONFIG_SSL_SNI_QUERY;

type
  _HTTP_SERVICE_CONFIG_SSL_CCS_QUERY = record
    QueryDesc: HTTP_SERVICE_CONFIG_QUERY_TYPE;
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_CCS_KEY;
    dwToken: DWORD;
  end;
  HTTP_SERVICE_CONFIG_SSL_CCS_QUERY = _HTTP_SERVICE_CONFIG_SSL_CCS_QUERY;
  PHTTP_SERVICE_CONFIG_SSL_CCS_QUERY = ^_HTTP_SERVICE_CONFIG_SSL_CCS_QUERY;

type
  _HTTP_SERVICE_CONFIG_SSL_QUERY_EX = record
    QueryDesc: HTTP_SERVICE_CONFIG_QUERY_TYPE;
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_KEY_EX;
    dwToken: DWORD;
    ParamType: HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE;
  end;
  HTTP_SERVICE_CONFIG_SSL_QUERY_EX = _HTTP_SERVICE_CONFIG_SSL_QUERY_EX;
  PHTTP_SERVICE_CONFIG_SSL_QUERY_EX = ^_HTTP_SERVICE_CONFIG_SSL_QUERY_EX;

type
  _HTTP_SERVICE_CONFIG_SSL_SNI_QUERY_EX = record
    QueryDesc: HTTP_SERVICE_CONFIG_QUERY_TYPE;
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_SNI_KEY;
    dwToken: DWORD;
    ParamType: HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE;
  end;
  HTTP_SERVICE_CONFIG_SSL_SNI_QUERY_EX = _HTTP_SERVICE_CONFIG_SSL_SNI_QUERY_EX;
  PHTTP_SERVICE_CONFIG_SSL_SNI_QUERY_EX = ^_HTTP_SERVICE_CONFIG_SSL_SNI_QUERY_EX;

type
  _HTTP_SERVICE_CONFIG_SSL_CCS_QUERY_EX = record
    QueryDesc: HTTP_SERVICE_CONFIG_QUERY_TYPE;
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_CCS_KEY;
    dwToken: DWORD;
    ParamType: HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE;
  end;
  HTTP_SERVICE_CONFIG_SSL_CCS_QUERY_EX = _HTTP_SERVICE_CONFIG_SSL_CCS_QUERY_EX;
  PHTTP_SERVICE_CONFIG_SSL_CCS_QUERY_EX = ^_HTTP_SERVICE_CONFIG_SSL_CCS_QUERY_EX;

//
// Set/Delete IP Listen-Only List record
//
// Used as a parameter to both HttpSetServiceConfiguration() and
// HttpDeleteServiceConfiguration() functions.
//

type
  _HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM = record
    AddrLength: USHORT;
    pAddress: PSOCKADDR;
  end;
  HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM = _HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM;
  PHTTP_SERVICE_CONFIG_IP_LISTEN_PARAM = ^_HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM;

//
// Query IP Listen-Only List record.
//
// Parameter to HttpQueryServiceConfiguration() for the config ID
// HttpServiceConfigIPListenList. On successful return, AddrList
// contains an array of AddrCount elements. Caller must provide a
// large enough buffer to hold all elements in one call.
//
// Caller may determine the type of each returned element by examining
// AddrList[i].ss_family. If it's AF_INET, use ((PSOCKADDR_IN) &AddrList[i]);
// otherwise, for AF_INET6, use ((PSOCKADDR_IN6) &AddrList[i])
// to select the appropriate address type.
//

type
  _HTTP_SERVICE_CONFIG_IP_LISTEN_QUERY = record
    AddrCount: ULONG;
    AddrList: array[0..ANYSIZE_ARRAY-1] of SOCKADDR_STORAGE;
  end;
  HTTP_SERVICE_CONFIG_IP_LISTEN_QUERY = _HTTP_SERVICE_CONFIG_IP_LISTEN_QUERY;
  PHTTP_SERVICE_CONFIG_IP_LISTEN_QUERY = ^_HTTP_SERVICE_CONFIG_IP_LISTEN_QUERY;

//
// URL ACL
//
//
type
  _HTTP_SERVICE_CONFIG_URLACL_KEY = record
    pUrlPrefix: PWSTR;
  end;
  HTTP_SERVICE_CONFIG_URLACL_KEY = _HTTP_SERVICE_CONFIG_URLACL_KEY;
  PHTTP_SERVICE_CONFIG_URLACL_KEY = ^_HTTP_SERVICE_CONFIG_URLACL_KEY;

//
// This defines a record for the SSL config store.
//

type
  _HTTP_SERVICE_CONFIG_URLACL_PARAM = record
    pStringSecurityDescriptor: PWSTR;
  end;
  HTTP_SERVICE_CONFIG_URLACL_PARAM = _HTTP_SERVICE_CONFIG_URLACL_PARAM;
  PHTTP_SERVICE_CONFIG_URLACL_PARAM = ^_HTTP_SERVICE_CONFIG_URLACL_PARAM;

//
// This data structure is used by HttpSetServiceConfiguration for the config ID
// HttpServiceConfigUrlAclInfo. It is used to add a new record to the URL ACL
// store.
//

type
  _HTTP_SERVICE_CONFIG_URLACL_SET = record
    KeyDesc: HTTP_SERVICE_CONFIG_URLACL_KEY;
    ParamDesc: HTTP_SERVICE_CONFIG_URLACL_PARAM;
  end;
  HTTP_SERVICE_CONFIG_URLACL_SET = _HTTP_SERVICE_CONFIG_URLACL_SET;
  PHTTP_SERVICE_CONFIG_URLACL_SET = ^_HTTP_SERVICE_CONFIG_URLACL_SET;

//
// This data structure is used by HttpQueryServiceConfiguration() for the
// config ID HttpServiceConfigUrlAclInfo. It's used to query a particular
// record from the URL ACL store.
//
// If QueryType is HttpServiceConfigQueryExact, then one particular record of
// the type HTTP_SERVICE_CONFIG_URLACL_SET is returned. If the QueryType is
// HttpServiceConfigQueryNext, then the next instance of
// HTTP_SERVICE_CONFIG_URLACL_SET is returned. In such cases, the dwToken field
// represents the cursor. For the first item, dwToken has to be 0.
// For subsequent items, dwToken has to be incremented by 1,
// until ERROR_NO_MORE_ITEMS is returned.
//

type
  _HTTP_SERVICE_CONFIG_URLACL_QUERY = record
    QueryDesc: HTTP_SERVICE_CONFIG_QUERY_TYPE;
    KeyDesc: HTTP_SERVICE_CONFIG_URLACL_KEY;
    dwToken: DWORD;
  end;
  HTTP_SERVICE_CONFIG_URLACL_QUERY = _HTTP_SERVICE_CONFIG_URLACL_QUERY;
  PHTTP_SERVICE_CONFIG_URLACL_QUERY = ^_HTTP_SERVICE_CONFIG_URLACL_QUERY;

//
// Cache Paramemers
//

//
// For manipulating global cache parameters.
// The parameters that can be changed or queued are per-uri cache size
// and cached range chunk size.
//

type
  _HTTP_SERVICE_CONFIG_CACHE_KEY = (
    MaxCacheResponseSize = 0,
    CacheRangeChunkSize);
  HTTP_SERVICE_CONFIG_CACHE_KEY = _HTTP_SERVICE_CONFIG_CACHE_KEY;
  PHTTP_SERVICE_CONFIG_CACHE_KEY = ^_HTTP_SERVICE_CONFIG_CACHE_KEY;

type HTTP_SERVICE_CONFIG_CACHE_PARAM = ULONG;
type PHTTP_SERVICE_CONFIG_CACHE_PARAM = ^ULONG;

//
// To set a cache parameter value use the set structure. To query use the key
// directly. When you query a parameter value the output buffer must be exactly
// the sizeof param.
//

type
  HTTP_SERVICE_CONFIG_CACHE_SET = record
    KeyDesc: HTTP_SERVICE_CONFIG_CACHE_KEY;
    ParamDesc: HTTP_SERVICE_CONFIG_CACHE_PARAM;
  end;
  PHTTP_SERVICE_CONFIG_CACHE_SET = ^_ANON_STRUCT_1;

//
// Input types for HttpQueryRequestProperty. Only types are public and not the API
// so that IIS need not have their own types for public usage.
//

type
  _HTTP_REQUEST_PROPERTY = (
    HttpRequestPropertyIsb,
    HttpRequestPropertyTcpInfoV0,
    HttpRequestPropertyQuicStats,
    HttpRequestPropertyTcpInfoV1,
    HttpRequestPropertySni,
    HttpRequestPropertyStreamError,
    HttpRequestPropertyWskApiTimings,
    HttpRequestPropertyQuicApiTimings,
    HttpRequestPropertyQuicStatsV2,
    HttpRequestPropertyQuicStreamStats,
    HttpRequestPropertyTcpInfoV2,
    HttpRequestPropertyTlsClientHello,
    HttpRequestPropertyTransportIdleConnectionTimeout,
    HttpRequestPropertyDscpTag,
    HttpRequestPropertyTlsCipherInfo);
  HTTP_REQUEST_PROPERTY = _HTTP_REQUEST_PROPERTY;
  PHTTP_REQUEST_PROPERTY = ^_HTTP_REQUEST_PROPERTY;

type
  _HTTP_QUERY_REQUEST_QUALIFIER_TCP = record
    Freshness: ULONGLONG;
  end;
  HTTP_QUERY_REQUEST_QUALIFIER_TCP = _HTTP_QUERY_REQUEST_QUALIFIER_TCP;
  PHTTP_QUERY_REQUEST_QUALIFIER_TCP = ^_HTTP_QUERY_REQUEST_QUALIFIER_TCP;

type
  _HTTP_QUERY_REQUEST_QUALIFIER_QUIC = record
    Freshness: ULONGLONG;
  end;
  HTTP_QUERY_REQUEST_QUALIFIER_QUIC = _HTTP_QUERY_REQUEST_QUALIFIER_QUIC;
  PHTTP_QUERY_REQUEST_QUALIFIER_QUIC = ^_HTTP_QUERY_REQUEST_QUALIFIER_QUIC;

const HTTP_REQUEST_PROPERTY_SNI_HOST_MAX_LENGTH = 255;

//
// Flags inside HTTP_REQUEST_PROPERTY_SNI can have following values:
// - HTTP_REQUEST_PROPERTY_SNI_FLAG_SNI_USED: Indicates that SNI was used for succesful
// endpoint lookup during handshake. If client sent the SNI but Http.sys still decided to
// use IP endpoint binding then this flag will not be set.
// - HTTP_REQUEST_PROPERTY_SNI_FLAG_NO_SNI: Indicates that client did not send the SNI.
// If this flag is set, HTTP_REQUEST_PROPERTY_SNI_FLAG_SNI_USED can not be set.
//

const HTTP_REQUEST_PROPERTY_SNI_FLAG_SNI_USED = $00000001;
const HTTP_REQUEST_PROPERTY_SNI_FLAG_NO_SNI = $00000002;

type
  _HTTP_REQUEST_PROPERTY_SNI = record
    Hostname: array[0..HTTP_REQUEST_PROPERTY_SNI_HOST_MAX_LENGTH+1-1] of WCHAR;
    Flags: ULONG;
  end;
  HTTP_REQUEST_PROPERTY_SNI = _HTTP_REQUEST_PROPERTY_SNI;
  PHTTP_REQUEST_PROPERTY_SNI = ^_HTTP_REQUEST_PROPERTY_SNI;

type
  _HTTP_REQUEST_PROPERTY_STREAM_ERROR = record
    ErrorCode: ULONG;
  end;
  HTTP_REQUEST_PROPERTY_STREAM_ERROR = _HTTP_REQUEST_PROPERTY_STREAM_ERROR;
  PHTTP_REQUEST_PROPERTY_STREAM_ERROR = ^_HTTP_REQUEST_PROPERTY_STREAM_ERROR;

type
  _HTTP_WSK_API_TIMINGS = record
    ConnectCount: ULONGLONG;
    ConnectSum: ULONGLONG;
    DisconnectCount: ULONGLONG;
    DisconnectSum: ULONGLONG;
    SendCount: ULONGLONG;
    SendSum: ULONGLONG;
    ReceiveCount: ULONGLONG;
    ReceiveSum: ULONGLONG;
    ReleaseCount: ULONGLONG;
    ReleaseSum: ULONGLONG;
    ControlSocketCount: ULONGLONG;
    ControlSocketSum: ULONGLONG;
  end;
  HTTP_WSK_API_TIMINGS = _HTTP_WSK_API_TIMINGS;
  PHTTP_WSK_API_TIMINGS = ^_HTTP_WSK_API_TIMINGS;

type
  _HTTP_QUIC_STREAM_API_TIMINGS = record
    OpenCount: ULONGLONG;
    OpenSum: ULONGLONG;
    CloseCount: ULONGLONG;
    CloseSum: ULONGLONG;
    StartCount: ULONGLONG;
    StartSum: ULONGLONG;
    ShutdownCount: ULONGLONG;
    ShutdownSum: ULONGLONG;
    SendCount: ULONGLONG;
    SendSum: ULONGLONG;
    ReceiveSetEnabledCount: ULONGLONG;
    ReceiveSetEnabledSum: ULONGLONG;
    GetParamCount: ULONGLONG;
    GetParamSum: ULONGLONG;
    SetParamCount: ULONGLONG;
    SetParamSum: ULONGLONG;
    SetCallbackHandlerCount: ULONGLONG;
    SetCallbackHandlerSum: ULONGLONG;
  end;
  HTTP_QUIC_STREAM_API_TIMINGS = _HTTP_QUIC_STREAM_API_TIMINGS;
  PHTTP_QUIC_STREAM_API_TIMINGS = ^_HTTP_QUIC_STREAM_API_TIMINGS;

type
  _HTTP_QUIC_CONNECTION_API_TIMINGS = record
    OpenTime: ULONGLONG;
    CloseTime: ULONGLONG;
    StartTime: ULONGLONG;
    ShutdownTime: ULONGLONG;
    SecConfigCreateTime: ULONGLONG;
    SecConfigDeleteTime: ULONGLONG;
    GetParamCount: ULONGLONG;
    GetParamSum: ULONGLONG;
    SetParamCount: ULONGLONG;
    SetParamSum: ULONGLONG;
    SetCallbackHandlerCount: ULONGLONG;
    SetCallbackHandlerSum: ULONGLONG;
    ControlStreamTimings: HTTP_QUIC_STREAM_API_TIMINGS;
  end;
  HTTP_QUIC_CONNECTION_API_TIMINGS = _HTTP_QUIC_CONNECTION_API_TIMINGS;
  PHTTP_QUIC_CONNECTION_API_TIMINGS = ^_HTTP_QUIC_CONNECTION_API_TIMINGS;

type
  _HTTP_QUIC_API_TIMINGS = record
    ConnectionTimings: HTTP_QUIC_CONNECTION_API_TIMINGS;
    StreamTimings: HTTP_QUIC_STREAM_API_TIMINGS;
  end;
  HTTP_QUIC_API_TIMINGS = _HTTP_QUIC_API_TIMINGS;
  PHTTP_QUIC_API_TIMINGS = ^_HTTP_QUIC_API_TIMINGS;

type
  _HTTP_QUIC_STREAM_REQUEST_STATS = record
    StreamWaitStart: ULONGLONG;
    StreamWaitEnd: ULONGLONG;
    RequestHeadersCompressionStart: ULONGLONG;
    RequestHeadersCompressionEnd: ULONGLONG;
    ResponseHeadersDecompressionStart: ULONGLONG;
    ResponseHeadersDecompressionEnd: ULONGLONG;
    RequestHeadersCompressedSize: ULONGLONG;
    ResponseHeadersCompressedSize: ULONGLONG;
  end;
  HTTP_QUIC_STREAM_REQUEST_STATS = _HTTP_QUIC_STREAM_REQUEST_STATS;
  PHTTP_QUIC_STREAM_REQUEST_STATS = ^_HTTP_QUIC_STREAM_REQUEST_STATS;

const HTTP_QUIC_KEEPALIVE_TIMEOUT_DISABLED: ULONG = ULONG(-1);

type
  _HTTP_FEATURE_ID = (
    HttpFeatureUnknown = 0,
    HttpFeatureResponseTrailers = 1,
    HttpFeatureApiTimings = 2,
    HttpFeatureDelegateEx = 3,
    HttpFeatureHttp3 = 4,
    HttpFeatureTlsSessionTickets = 5,
    HttpFeatureDisableTlsSessionId = 6,
    HttpFeatureTlsDualCerts = 7,
    HttpFeatureAutomaticChunkedEncoding = 8,
    HttpFeatureDedicatedReqQueueDelegationType = 9,
    HttpFeatureFastForwardResponse = 10,
    HttpFeatureCacheTlsClientHello = 11,
    HttpFeatureIdleConnectionTimeoutRequestProperty = 12,
    HttpFeatureDisableAiaFlag = 13,
    HttpFeatureDscp = 14,
    HttpFeatureQueryCipherInfo = 15,
    HttpFeatureQueryInitialPacketTtl = 16,
    HttpFeatureLast = 17,
    HttpFeaturemax = Integer($FFFFFFFF));
  HTTP_FEATURE_ID = _HTTP_FEATURE_ID;
  PHTTP_FEATURE_ID = ^_HTTP_FEATURE_ID;

//
// Define our API linkage.
//

//
// Initialize/Terminate APIs.
//

// NOTE: MUST be called once before all other APIs

function HttpInitialize(
           Version: HTTPAPI_VERSION;
           Flags: ULONG;
           pReserved: PVOID): ULONG; stdcall; external 'httpapi.dll';

// NOTE: MUST be called after final API call returns.

function HttpTerminate(
           Flags: ULONG;
           pReserved: PVOID): ULONG; stdcall; external 'httpapi.dll';

//
// HTTP Request Queue manipulation APIs.
//
// This API is maintained for backward competibility for the first
// version of the HTTPAPI and should not be used. Instead the new
// HttpCreateRequestQueue() API must be used.
//
// Use CloseHandle() to release the handles returned by
// HttpCreateHttpHandle() API.
//

function HttpCreateHttpHandle(
           RequestQueueHandle: PHANDLE;
           Reserved: ULONG): ULONG; stdcall; external 'httpapi.dll';

//
// Extended Request Queue manipulation APIs.
//
// Use HttpCloseRequestQueue() API to close the handles
// created by the HttpCreateRequestQueue API.
//

function HttpCreateRequestQueue(
           Version: HTTPAPI_VERSION;
           Name: PCWSTR;
           SecurityAttributes: PSECURITY_ATTRIBUTES;
           Flags: ULONG;
           RequestQueueHandle: PHANDLE): ULONG; stdcall; external 'httpapi.dll';

function HttpCloseRequestQueue(
           RequestQueueHandle: HANDLE): ULONG; stdcall; external 'httpapi.dll';

function HttpSetRequestQueueProperty(
           RequestQueueHandle: HANDLE;
           &Property: HTTP_SERVER_PROPERTY;
           PropertyInformation: PVOID;
           PropertyInformationLength: ULONG;
           Reserved1: ULONG;
           Reserved2: PVOID): ULONG; stdcall; external 'httpapi.dll';

function HttpQueryRequestQueueProperty(
           RequestQueueHandle: HANDLE;
           &Property: HTTP_SERVER_PROPERTY;
           PropertyInformation: PVOID;
           PropertyInformationLength: ULONG;
           Reserved1: ULONG;
           ReturnLength: PULONG;
           Reserved2: PVOID): ULONG; stdcall; external 'httpapi.dll';

// __CALLCONV__
// ULONG
// __CALLCONV__
// HttpSetRequestProperty(
// HANDLE RequestQueueHandle,
// HTTP_OPAQUE_ID Id,
// HTTP_REQUEST_PROPERTY PropertyId,
// PVOID Input,
// ULONG InputPropertySize,
// LPOVERLAPPED Overlapped
// );

function HttpQueryRequestProperty(
           RequestQueueHandle: HANDLE;
           Id: HTTP_OPAQUE_ID;
           PropertyId: HTTP_REQUEST_PROPERTY;
           Qualifier: PVOID;
           QualifierSize: ULONG;
           Output: PVOID;
           OutputBufferSize: ULONG;
           BytesReturned: PULONG;
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external 'httpapi.dll';

function HttpShutdownRequestQueue(
           RequestQueueHandle: HANDLE): ULONG; stdcall; external 'httpapi.dll';

//
// SSL APIs.
//

function HttpReceiveClientCertificate(
           RequestQueueHandle: HANDLE;
           ConnectionId: HTTP_CONNECTION_ID;
           Flags: ULONG;
           SslClientCertInfo: PHTTP_SSL_CLIENT_CERT_INFO;
           SslClientCertInfoSize: ULONG;
           BytesReceived: PULONG;
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external 'httpapi.dll';

//
// Server Session APIs.
//

function HttpCreateServerSession(
           Version: HTTPAPI_VERSION;
           ServerSessionId: PHTTP_SERVER_SESSION_ID;
           Reserved: ULONG): ULONG; stdcall; external 'httpapi.dll';

function HttpCloseServerSession(
           ServerSessionId: HTTP_SERVER_SESSION_ID): ULONG; stdcall; external 'httpapi.dll';

function HttpQueryServerSessionProperty(
           ServerSessionId: HTTP_SERVER_SESSION_ID;
           &Property: HTTP_SERVER_PROPERTY;
           PropertyInformation: PVOID;
           PropertyInformationLength: ULONG;
           ReturnLength: PULONG): ULONG; stdcall; external 'httpapi.dll';

function HttpSetServerSessionProperty(
           ServerSessionId: HTTP_SERVER_SESSION_ID;
           &Property: HTTP_SERVER_PROPERTY;
           PropertyInformation: PVOID;
           PropertyInformationLength: ULONG): ULONG; stdcall; external 'httpapi.dll';

//
// Url Configuration APIs. Can only be used for V1 request queues.
//

function HttpAddUrl(
           RequestQueueHandle: HANDLE;
           FullyQualifiedUrl: PCWSTR;
           Reserved: PVOID): ULONG; stdcall; external 'httpapi.dll';

function HttpRemoveUrl(
           RequestQueueHandle: HANDLE;
           FullyQualifiedUrl: PCWSTR): ULONG; stdcall; external 'httpapi.dll';

//
// Url Group APIs.
//

function HttpCreateUrlGroup(
           ServerSessionId: HTTP_SERVER_SESSION_ID;
           pUrlGroupId: PHTTP_URL_GROUP_ID;
           Reserved: ULONG): ULONG; stdcall; external 'httpapi.dll';

function HttpCloseUrlGroup(
           UrlGroupId: HTTP_URL_GROUP_ID): ULONG; stdcall; external 'httpapi.dll';

function HttpAddUrlToUrlGroup(
           UrlGroupId: HTTP_URL_GROUP_ID;
           pFullyQualifiedUrl: PCWSTR;
           UrlContext: HTTP_URL_CONTEXT;
           Reserved: ULONG): ULONG; stdcall; external 'httpapi.dll';

function HttpRemoveUrlFromUrlGroup(
           UrlGroupId: HTTP_URL_GROUP_ID;
           pFullyQualifiedUrl: PCWSTR;
           Flags: ULONG): ULONG; stdcall; external 'httpapi.dll';

function HttpSetUrlGroupProperty(
           UrlGroupId: HTTP_URL_GROUP_ID;
           &Property: HTTP_SERVER_PROPERTY;
           PropertyInformation: PVOID;
           PropertyInformationLength: ULONG): ULONG; stdcall; external 'httpapi.dll';

function HttpQueryUrlGroupProperty(
           UrlGroupId: HTTP_URL_GROUP_ID;
           &Property: HTTP_SERVER_PROPERTY;
           PropertyInformation: PVOID;
           PropertyInformationLength: ULONG;
           ReturnLength: PULONG): ULONG; stdcall; external 'httpapi.dll';

function HttpPrepareUrl(
           Reserved: PVOID;
           Flags: ULONG;
           Url: PCWSTR;
           PreparedUrl: PPWSTR): ULONG; stdcall; external 'httpapi.dll';

//
// HTTP Server I/O APIs.
//

function HttpReceiveHttpRequest(
           RequestQueueHandle: HANDLE;
           RequestId: HTTP_REQUEST_ID;
           Flags: ULONG;
           RequestBuffer: PHTTP_REQUEST;
           RequestBufferLength: ULONG;
           BytesReturned: PULONG;
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external 'httpapi.dll';

function HttpReceiveRequestEntityBody(
           RequestQueueHandle: HANDLE;
           RequestId: HTTP_REQUEST_ID;
           Flags: ULONG;
           EntityBuffer: PVOID;
           EntityBufferLength: ULONG;
           BytesReturned: PULONG;
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external 'httpapi.dll';

function HttpSendHttpResponse(
           RequestQueueHandle: HANDLE;
           RequestId: HTTP_REQUEST_ID;
           Flags: ULONG;
           HttpResponse: PHTTP_RESPONSE;
           CachePolicy: PHTTP_CACHE_POLICY;
           BytesSent: PULONG;
           Reserved1: PVOID;
           Reserved2: ULONG;
           Overlapped: LPOVERLAPPED;
           LogData: PHTTP_LOG_DATA): ULONG; stdcall; external 'httpapi.dll';

function HttpSendResponseEntityBody(
           RequestQueueHandle: HANDLE;
           RequestId: HTTP_REQUEST_ID;
           Flags: ULONG;
           EntityChunkCount: USHORT;
           EntityChunks: PHTTP_DATA_CHUNK;
           BytesSent: PULONG;
           Reserved1: PVOID;
           Reserved2: ULONG;
           Overlapped: LPOVERLAPPED;
           LogData: PHTTP_LOG_DATA): ULONG; stdcall; external 'httpapi.dll';

function HttpDeclarePush(
           RequestQueueHandle: HANDLE;
           RequestId: HTTP_REQUEST_ID;
           Verb: HTTP_VERB;
           Path: PCWSTR;
           Query: PCSTR;
           Headers: PHTTP_REQUEST_HEADERS): ULONG; stdcall; external 'httpapi.dll';

function HttpWaitForDisconnect(
           RequestQueueHandle: HANDLE;
           ConnectionId: HTTP_CONNECTION_ID;
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external 'httpapi.dll';

function HttpWaitForDisconnectEx(
           RequestQueueHandle: HANDLE;
           ConnectionId: HTTP_CONNECTION_ID;
           Reserved: ULONG;
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external 'httpapi.dll';

function HttpCancelHttpRequest(
           RequestQueueHandle: HANDLE;
           RequestId: HTTP_REQUEST_ID;
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external 'httpapi.dll';

function HttpWaitForDemandStart(
           RequestQueueHandle: HANDLE;
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external 'httpapi.dll';

function HttpIsFeatureSupported(
           FeatureId: HTTP_FEATURE_ID): LongBool; stdcall; external 'httpapi.dll';

function HttpDelegateRequestEx(
           RequestQueueHandle: HANDLE;
           DelegateQueueHandle: HANDLE;
           RequestId: HTTP_REQUEST_ID;
           DelegateUrlGroupId: HTTP_URL_GROUP_ID;
           PropertyInfoSetSize: ULONG;
           PropertyInfoSet: PHTTP_DELEGATE_REQUEST_PROPERTY_INFO): ULONG; stdcall; external 'httpapi.dll';

function HttpFindUrlGroupId(
           FullyQualifiedUrl: PCWSTR;
           RequestQueueHandle: HANDLE;
           UrlGroupId: PHTTP_URL_GROUP_ID): ULONG; stdcall; external 'httpapi.dll';

//
// Cache manipulation APIs.
//

function HttpFlushResponseCache(
           RequestQueueHandle: HANDLE;
           UrlPrefix: PCWSTR;
           Flags: ULONG;
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external 'httpapi.dll';

function HttpAddFragmentToCache(
           RequestQueueHandle: HANDLE;
           UrlPrefix: PCWSTR;
           DataChunk: PHTTP_DATA_CHUNK;
           CachePolicy: PHTTP_CACHE_POLICY;
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external 'httpapi.dll';

function HttpReadFragmentFromCache(
           RequestQueueHandle: HANDLE;
           UrlPrefix: PCWSTR;
           ByteRange: PHTTP_BYTE_RANGE;
           Buffer: PVOID;
           BufferLength: ULONG;
           BytesRead: PULONG;
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external 'httpapi.dll';

//
// Server configuration APIs
//

function HttpSetServiceConfiguration(
           ServiceHandle: HANDLE;
           ConfigId: HTTP_SERVICE_CONFIG_ID;
           pConfigInformation: PVOID;
           ConfigInformationLength: ULONG;
           pOverlapped: LPOVERLAPPED): ULONG; stdcall; external 'httpapi.dll';

function HttpUpdateServiceConfiguration(
           Handle: HANDLE;
           ConfigId: HTTP_SERVICE_CONFIG_ID;
           ConfigInfo: PVOID;
           ConfigInfoLength: ULONG;
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external 'httpapi.dll';

function HttpDeleteServiceConfiguration(
           ServiceHandle: HANDLE;
           ConfigId: HTTP_SERVICE_CONFIG_ID;
           pConfigInformation: PVOID;
           ConfigInformationLength: ULONG;
           pOverlapped: LPOVERLAPPED): ULONG; stdcall; external 'httpapi.dll';

function HttpQueryServiceConfiguration(
           ServiceHandle: HANDLE;
           ConfigId: HTTP_SERVICE_CONFIG_ID;
           pInput: PVOID;
           InputLength: ULONG;
           pOutput: PVOID;
           OutputLength: ULONG;
           pReturnLength: PULONG;
           pOverlapped: LPOVERLAPPED): ULONG; stdcall; external 'httpapi.dll';

function HttpGetExtension(
           Version: HTTPAPI_VERSION;
           Extension: ULONG;
           Buffer: PVOID;
           BufferSize: ULONG): ULONG; stdcall; external 'httpapi.dll';

implementation

end.
unit Alcinoe.Winapi.HttpApi;

interface

{$I Alcinoe.inc}

{$MINENUMSIZE 4}
{$A+}

uses
  WinApi.Windows,
  Winapi.Winsock2;

//
// Type aliases
//

type
  PSTR = LPSTR;
  PWSTR = LPWSTR;
  PCSTR = LPCSTR;
  PCWSTR = LPCWSTR;
  HANDLE = THandle;
  GUID = TGUID;
  PSECURITY_ATTRIBUTES = ^SECURITY_ATTRIBUTES;
  LPOVERLAPPED = POVERLAPPED;
  PCHAR = PAnsiChar;
  PWCHAR = PWideChar;

//
// HTTPAPI is available on
//
// a) WinXP SP2 and higher
// b) Windows 2003 and higher
// c) Vista and higher.
//
// Flags for HttpInitialize() and HttpTerminate().
//
//
// HTTP_INITIALIZE_SERVER - Initializes the HTTP API layer and driver for
//                          applications using server APIs.
//
// HTTP_INITIALIZE_CONFIG - Initializes the HTTP API layer and driver for
//                          applications using HTTP configuration APIs.
//
// HTTP_DEMAND_CBT        - Pre-Win7, it checks HTTP API layer and driver for
//                          Extended Protection capabilities.
//                          On Win7 and above, this flag has no use and is
//                          present only for app-compat reasons.
//                          It must be combined with HTTP_INITIALIZE_SERVER.
//
// Notes -
//
// 1. These flags can be used in combination.
//
// 2. HttpTerminate() must be called for each call to HttpInitialize() made
//    with each flag set when invoking HttpInitialize.  For example, one
//    could make two calls to HttpInitialize() setting HTTP_INITIALIZE_SERVER
//    the first time and HTTP_INITIALIZE_CONFIG the second time.  One call
//    to HttpTerminate() with both flags set suffices to clean up both
//    calls to HttpInitialize().
//

const
  HTTP_INITIALIZE_SERVER = $00000001;
  HTTP_INITIALIZE_CONFIG = $00000002;
  HTTP_DEMAND_CBT = $00000004;

//
// Following section defines the properties supported by the
// server side HTTP API.
//

type
  HTTP_SERVER_PROPERTY = (
    // Used for enabling server side authentication.
    HttpServerAuthenticationProperty = 0,
    // Used for enabling logging.
    HttpServerLoggingProperty = 1,
    // Used for setting QoS properties.
    HttpServerQosProperty = 2,
    // Used for configuring timeouts.
    HttpServerTimeoutsProperty = 3,
    // Used for limiting request queue lengths.
    HttpServerQueueLengthProperty = 4,
    // Used for manipulating the state.
    HttpServerStateProperty = 5,
    // Used for modifying the verbosity level of 503 type responses
    // generated by server side API.
    HttpServer503VerbosityProperty = 6,
    // Used for manipulating Url Group to Request Queue association.
    HttpServerBindingProperty = 7,
    // Extended authentication property.
    HttpServerExtendedAuthenticationProperty = 8,
    // Listening endpoint property.
    HttpServerListenEndpointProperty = 9,
    // Authentication channel binding property
    HttpServerChannelBindProperty = 10,
    // IP Protection level policy for a Url Group.
    HttpServerProtectionLevelProperty = 11,
    // Used for manipulating Url Group to Delegate Request Queue association.
    HttpServerDelegationProperty = 16,
    // Used to configure fast forwarding support.
    HttpServerFastForwardingProperty = 18);
  PHTTP_SERVER_PROPERTY = ^HTTP_SERVER_PROPERTY;

const
  HTTP_MAX_SERVER_QUEUE_LENGTH = $7FFFFFFF;
  HTTP_MIN_SERVER_QUEUE_LENGTH = 1;

//
// Generic property flags. Each structure defining a property info typically
// contain an element of this type.
//

type
  HTTP_PROPERTY_FLAGS = record
    Present: ULONG;
  end;
  PHTTP_PROPERTY_FLAGS = ^HTTP_PROPERTY_FLAGS;

//
// Enabled state.
//

type
  HTTP_ENABLED_STATE = (
    HttpEnabledStateActive,
    HttpEnabledStateInactive);
  PHTTP_ENABLED_STATE = ^HTTP_ENABLED_STATE;

  HTTP_STATE_INFO = record
    Flags: HTTP_PROPERTY_FLAGS;
    State: HTTP_ENABLED_STATE;
  end;
  PHTTP_STATE_INFO = ^HTTP_STATE_INFO;

//
// Defines the verbosity level for a request queue which will be used
// when sending "503 - Service Unavailable" type error responses. Note that
// this setting only affects the error responses generated internally
// by HTTPAPI.
//

type
  HTTP_503_RESPONSE_VERBOSITY = (
    // Instead of sending a 503 response, the connection will be reset.
    // This is the default behavior.
    Http503ResponseVerbosityBasic,
    // Will send a 503 w/ a generic reason phrase.
    Http503ResponseVerbosityLimited,
    // Will send a 503 w/ a detailed reason phrase.
    Http503ResponseVerbosityFull);
  PHTTP_503_RESPONSE_VERBOSITY = ^HTTP_503_RESPONSE_VERBOSITY;

//
// Network QoS related.
//

type
  HTTP_QOS_SETTING_TYPE = (
    HttpQosSettingTypeBandwidth,
    HttpQosSettingTypeConnectionLimit,
    HttpQosSettingTypeFlowRate);
  PHTTP_QOS_SETTING_TYPE = ^HTTP_QOS_SETTING_TYPE;

  HTTP_QOS_SETTING_INFO = record
    QosType: HTTP_QOS_SETTING_TYPE;
    QosSetting: PVOID;
  end;
  PHTTP_QOS_SETTING_INFO = ^HTTP_QOS_SETTING_INFO;

  HTTP_CONNECTION_LIMIT_INFO = record
    Flags: HTTP_PROPERTY_FLAGS;
    MaxConnections: ULONG;
  end;
  PHTTP_CONNECTION_LIMIT_INFO = ^HTTP_CONNECTION_LIMIT_INFO;

  HTTP_BANDWIDTH_LIMIT_INFO = record
    Flags: HTTP_PROPERTY_FLAGS;
    MaxBandwidth: ULONG;
  end;
  PHTTP_BANDWIDTH_LIMIT_INFO = ^HTTP_BANDWIDTH_LIMIT_INFO;

  HTTP_FLOWRATE_INFO = record
    Flags: HTTP_PROPERTY_FLAGS;
    MaxBandwidth: ULONG;
    MaxPeakBandwidth: ULONG;
    BurstSize: ULONG;
  end;
  PHTTP_FLOWRATE_INFO = ^HTTP_FLOWRATE_INFO;

//
// Bandwidth throttling limit can not be set lower than the following
// number. The value is in bytes/sec.
//

const
  HTTP_MIN_ALLOWED_BANDWIDTH_THROTTLING_RATE: ULONG = 1024;

//
// Distinguished value for bandwidth, connection limits and logging rollover
// size indicating "no limit".
//

const
  HTTP_LIMIT_INFINITE: ULONG = ULONG(-1);

//
// Timeout information.
//
//
// For manipulating global timeout settings.
// These timers run when connection does not belong to any application.
// Value zero is not allowed for driver wide timeout settings.
//

type
  HTTP_SERVICE_CONFIG_TIMEOUT_KEY = (
    IdleConnectionTimeout = 0,
    HeaderWaitTimeout);
  PHTTP_SERVICE_CONFIG_TIMEOUT_KEY = ^HTTP_SERVICE_CONFIG_TIMEOUT_KEY;

  HTTP_SERVICE_CONFIG_TIMEOUT_PARAM = USHORT;
  PHTTP_SERVICE_CONFIG_TIMEOUT_PARAM = ^HTTP_SERVICE_CONFIG_TIMEOUT_PARAM;

//
// To set a timeout value use the set structure. To query/delete use the key
// directly. When you query a timeout value the output buffer must be exactly
// the sizeof param.
//

type
  HTTP_SERVICE_CONFIG_TIMEOUT_SET = record
    KeyDesc: HTTP_SERVICE_CONFIG_TIMEOUT_KEY;
    ParamDesc: HTTP_SERVICE_CONFIG_TIMEOUT_PARAM;
  end;
  PHTTP_SERVICE_CONFIG_TIMEOUT_SET = ^HTTP_SERVICE_CONFIG_TIMEOUT_SET;

//
// For manipulating application specific timeout settings.
// These timers run when there's a request being processed on a connection
// and HTTPAPI has already associated the request with an application.
// Setting a timeout value to zero will cause HTTPAPI to revert to default.
//

type
  HTTP_TIMEOUT_LIMIT_INFO = record
    Flags: HTTP_PROPERTY_FLAGS;
    // Timeouts configured in seconds.
    EntityBody: USHORT;
    DrainEntityBody: USHORT;
    RequestQueue: USHORT;
    // Following two timeouts are only enforced after first request on
    // connection is routed to the application. These will not manipulate
    // the driver wide timeouts.
    IdleConnection: USHORT;
    HeaderWait: USHORT;
    // Timeouts configured in bytes/second.
    // This timer can be turned off by setting it to MAXULONG.
    MinSendRate: ULONG;
  end;
  PHTTP_TIMEOUT_LIMIT_INFO = ^HTTP_TIMEOUT_LIMIT_INFO;

//
//  Controls config settings
//

type
  HTTP_SERVICE_CONFIG_SETTING_KEY = (
    HttpNone = 0,
    HttpTlsThrottle);
  PHTTP_SERVICE_CONFIG_SETTING_KEY = ^HTTP_SERVICE_CONFIG_SETTING_KEY;

  HTTP_SERVICE_CONFIG_SETTING_PARAM = ULONG;
  PHTTP_SERVICE_CONFIG_SETTING_PARAM = ^HTTP_SERVICE_CONFIG_SETTING_PARAM;

  HTTP_SERVICE_CONFIG_SETTING_SET = record
    KeyDesc: HTTP_SERVICE_CONFIG_SETTING_KEY;
    ParamDesc: HTTP_SERVICE_CONFIG_SETTING_PARAM;
  end;
  PHTTP_SERVICE_CONFIG_SETTING_SET = ^HTTP_SERVICE_CONFIG_SETTING_SET;

//
// Controls whether IP-based URLs should listen on the specific IP or wildcard.
//

type
  HTTP_LISTEN_ENDPOINT_INFO = record
    Flags: HTTP_PROPERTY_FLAGS;
    EnableSharing: BOOLEAN;
  end;
  PHTTP_LISTEN_ENDPOINT_INFO = ^HTTP_LISTEN_ENDPOINT_INFO;

  HTTP_FAST_FORWARD_INFO = record
    Flags: HTTP_PROPERTY_FLAGS;
    EnableFastForwarding: BOOLEAN;
  end;
  PHTTP_FAST_FORWARD_INFO = ^HTTP_FAST_FORWARD_INFO;

  HTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS = record
    DomainNameLength: USHORT;
    DomainName: PWSTR;
    RealmLength: USHORT;
    Realm: PWSTR;
  end;
  PHTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS = ^HTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS;

  HTTP_SERVER_AUTHENTICATION_BASIC_PARAMS = record
    RealmLength: USHORT;
    Realm: PWSTR;
  end;
  PHTTP_SERVER_AUTHENTICATION_BASIC_PARAMS = ^HTTP_SERVER_AUTHENTICATION_BASIC_PARAMS;

//
// Definitions used for setting server side authentication property.
//

const
  HTTP_AUTH_ENABLE_BASIC = ($00000001);
  HTTP_AUTH_ENABLE_DIGEST = ($00000002);
  HTTP_AUTH_ENABLE_NTLM = ($00000004);
  HTTP_AUTH_ENABLE_NEGOTIATE = ($00000008);
  HTTP_AUTH_ENABLE_KERBEROS = ($00000010);
  HTTP_AUTH_ENABLE_ALL = (HTTP_AUTH_ENABLE_BASIC     or
                          HTTP_AUTH_ENABLE_DIGEST    or
                          HTTP_AUTH_ENABLE_NTLM      or
                          HTTP_AUTH_ENABLE_NEGOTIATE or
                          HTTP_AUTH_ENABLE_KERBEROS);

// C_ASSERT(HTTP_AUTH_ENABLE_NEGOTIATE > HTTP_AUTH_ENABLE_NTLM);
// C_ASSERT(HTTP_AUTH_ENABLE_NTLM > HTTP_AUTH_ENABLE_DIGEST);
// C_ASSERT(HTTP_AUTH_ENABLE_DIGEST > HTTP_AUTH_ENABLE_BASIC);

const
  HTTP_AUTH_EX_FLAG_ENABLE_KERBEROS_CREDENTIAL_CACHING = ($01);
  HTTP_AUTH_EX_FLAG_CAPTURE_CREDENTIAL = ($02);

type
  HTTP_SERVER_AUTHENTICATION_INFO = record
    Flags: HTTP_PROPERTY_FLAGS;
    AuthSchemes: ULONG;
    ReceiveMutualAuth: BOOLEAN;
    ReceiveContextHandle: BOOLEAN;
    DisableNTLMCredentialCaching: BOOLEAN;
    ExFlags: UCHAR;
    DigestParams: HTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS;
    BasicParams: HTTP_SERVER_AUTHENTICATION_BASIC_PARAMS;
  end;
  PHTTP_SERVER_AUTHENTICATION_INFO = ^HTTP_SERVER_AUTHENTICATION_INFO;

//
// Definitions for setting authentication channel binding properties
//

type
  HTTP_SERVICE_BINDING_TYPE = (
    HttpServiceBindingTypeNone = 0,
    HttpServiceBindingTypeW,
    HttpServiceBindingTypeA);

  HTTP_SERVICE_BINDING_BASE = record
    &Type: HTTP_SERVICE_BINDING_TYPE;
  end;
  PHTTP_SERVICE_BINDING_BASE = ^HTTP_SERVICE_BINDING_BASE;

  HTTP_SERVICE_BINDING_A = record
    Base: HTTP_SERVICE_BINDING_BASE;
    Buffer: PCHAR;
    BufferSize: ULONG;
  end;
  PHTTP_SERVICE_BINDING_A = ^HTTP_SERVICE_BINDING_A;

  HTTP_SERVICE_BINDING_W = record
    Base: HTTP_SERVICE_BINDING_BASE;
    Buffer: PWCHAR;
    BufferSize: ULONG;
  end;
  PHTTP_SERVICE_BINDING_W = ^HTTP_SERVICE_BINDING_W;

  HTTP_AUTHENTICATION_HARDENING_LEVELS = (
    HttpAuthenticationHardeningLegacy = 0,
    HttpAuthenticationHardeningMedium,
    HttpAuthenticationHardeningStrict);

//
// Channel binding token verification flags.
//

const
  HTTP_CHANNEL_BIND_PROXY = $1;
  HTTP_CHANNEL_BIND_PROXY_COHOSTING = $20;

//
// Service bind verification flags
//

const
  HTTP_CHANNEL_BIND_NO_SERVICE_NAME_CHECK = $2;
  HTTP_CHANNEL_BIND_DOTLESS_SERVICE = $4;

//
// Flags triggering channel bind parameters retrieval
//

const
  HTTP_CHANNEL_BIND_SECURE_CHANNEL_TOKEN = $8;
  HTTP_CHANNEL_BIND_CLIENT_SERVICE = $10;

//
// All valid flags (mask for internal checks)
//

type
  HTTP_CHANNEL_BIND_INFO = record
    Hardening: HTTP_AUTHENTICATION_HARDENING_LEVELS;
    Flags: ULONG;
    ServiceNames: ^PHTTP_SERVICE_BINDING_BASE;
    NumberOfServiceNames: ULONG;
  end;
  PHTTP_CHANNEL_BIND_INFO = ^HTTP_CHANNEL_BIND_INFO;

  HTTP_REQUEST_CHANNEL_BIND_STATUS = record
    ServiceName: PHTTP_SERVICE_BINDING_BASE;
    ChannelToken: PUCHAR;
    ChannelTokenSize: ULONG;
    Flags: ULONG;
  end;
  PHTTP_REQUEST_CHANNEL_BIND_STATUS = ^HTTP_REQUEST_CHANNEL_BIND_STATUS;

  HTTP_REQUEST_TOKEN_BINDING_INFO = record
    TokenBinding: PUCHAR;
    TokenBindingSize: ULONG;
    EKM: PUCHAR;
    EKMSize: ULONG;
    KeyType: UCHAR;
  end;
  PHTTP_REQUEST_TOKEN_BINDING_INFO = ^HTTP_REQUEST_TOKEN_BINDING_INFO;

//
// Definitions used for setting logging property.
//
//
// The known log fields recognized/supported by HTTPAPI. Following fields
// are used for W3C logging. Subset of them are also used for error
// logging.
//

const
  HTTP_LOG_FIELD_DATE = $00000001;
  HTTP_LOG_FIELD_TIME = $00000002;
  HTTP_LOG_FIELD_CLIENT_IP = $00000004;
  HTTP_LOG_FIELD_USER_NAME = $00000008;
  HTTP_LOG_FIELD_SITE_NAME = $00000010;
  HTTP_LOG_FIELD_COMPUTER_NAME = $00000020;
  HTTP_LOG_FIELD_SERVER_IP = $00000040;
  HTTP_LOG_FIELD_METHOD = $00000080;
  HTTP_LOG_FIELD_URI_STEM = $00000100;
  HTTP_LOG_FIELD_URI_QUERY = $00000200;
  HTTP_LOG_FIELD_STATUS = $00000400;
  HTTP_LOG_FIELD_WIN32_STATUS = $00000800;
  HTTP_LOG_FIELD_BYTES_SENT = $00001000;
  HTTP_LOG_FIELD_BYTES_RECV = $00002000;
  HTTP_LOG_FIELD_TIME_TAKEN = $00004000;
  HTTP_LOG_FIELD_SERVER_PORT = $00008000;
  HTTP_LOG_FIELD_USER_AGENT = $00010000;
  HTTP_LOG_FIELD_COOKIE = $00020000;
  HTTP_LOG_FIELD_REFERER = $00040000;
  HTTP_LOG_FIELD_VERSION = $00080000;
  HTTP_LOG_FIELD_HOST = $00100000;
  HTTP_LOG_FIELD_SUB_STATUS = $00200000;
  HTTP_LOG_FIELD_STREAM_ID = $08000000;
  HTTP_LOG_FIELD_STREAM_ID_EX = $10000000;
  HTTP_LOG_FIELD_TRANSPORT_TYPE = $20000000;

//
// Fields that are used only for error logging.
//

const
  HTTP_LOG_FIELD_CLIENT_PORT = $00400000;
  HTTP_LOG_FIELD_URI = $00800000;
  HTTP_LOG_FIELD_SITE_ID = $01000000;
  HTTP_LOG_FIELD_REASON = $02000000;
  HTTP_LOG_FIELD_QUEUE_NAME = $04000000;
  HTTP_LOG_FIELD_CORRELATION_ID = $40000000;
  HTTP_LOG_FIELD_FAULT_CODE = $80000000;
  HTTP_LOG_FIELD_EXT_FAULT_CODE_EXT = $0000000000000001;

//
// Defines the logging type.
//

type
  HTTP_LOGGING_TYPE = (
    HttpLoggingTypeW3C,
    HttpLoggingTypeIIS,
    HttpLoggingTypeNCSA,
    HttpLoggingTypeRaw);
  PHTTP_LOGGING_TYPE = ^HTTP_LOGGING_TYPE;

//
// Defines the rollover type for log files.
//

type
  HTTP_LOGGING_ROLLOVER_TYPE = (
    HttpLoggingRolloverSize,
    HttpLoggingRolloverDaily,
    HttpLoggingRolloverWeekly,
    HttpLoggingRolloverMonthly,
    HttpLoggingRolloverHourly);
  PHTTP_LOGGING_ROLLOVER_TYPE = ^HTTP_LOGGING_ROLLOVER_TYPE;

//
// Log file rollover size can not be set lower than the following
// limit. The value is in bytes.
//

const
  HTTP_MIN_ALLOWED_LOG_FILE_ROLLOVER_SIZE: ULONG = 1 * 1024 * 1024;

//
// Logging option flags. When used in the logging configuration alters
// some default logging behaviour.
//
// HTTP_LOGGING_FLAG_LOCAL_TIME_ROLLOVER - This flag is used to change
//      the log file rollover to happen by local time based. By default
//      log file rollovers happen by GMT time.
//
// HTTP_LOGGING_FLAG_USE_UTF8_CONVERSION - When set the unicode fields
//      will be converted to UTF8 multibytes when writting to the log
//      files. When this flag is not present, the local code page
//      conversion happens.
//
// HTTP_LOGGING_FLAG_LOG_ERRORS_ONLY -
// HTTP_LOGGING_FLAG_LOG_SUCCESS_ONLY - These two flags are used to
//      to do selective logging. If neither of them are present both
//      types of requests will be logged. Only one these flags can be
//      set at a time. They are mutually exclusive.
//

const
  HTTP_LOGGING_FLAG_LOCAL_TIME_ROLLOVER = ($00000001);
  HTTP_LOGGING_FLAG_USE_UTF8_CONVERSION = ($00000002);
  HTTP_LOGGING_FLAG_LOG_ERRORS_ONLY = ($00000004);
  HTTP_LOGGING_FLAG_LOG_SUCCESS_ONLY = ($00000008);

//
// Configuration structure used for setting the logging property.
//

type
  HTTP_LOGGING_INFO = record
    // Specifies whether this property exists or not.
    Flags: HTTP_PROPERTY_FLAGS;
    // Optional logging flags.
    LoggingFlags: ULONG;
    // Optional informatonal software directive string for W3C type logging. Not
    // used for other types of logging. If nothing is provided here HTTPAPI will
    // log a default string. Any arbitrary string could be used here to identify
    // the application. Length cannot be greater than MAX_PATH. Lenght is in
    // bytes.
    SoftwareName: PCWSTR;
    SoftwareNameLength: USHORT;
    // Log file directory must be a fully qualified path.
    // Length must be in number of bytes.
    DirectoryNameLength: USHORT;
    DirectoryName: PCWSTR;
    // Specifies the format for the log files.
    Format: HTTP_LOGGING_TYPE;
    // Bitmask value indicates which fields to be logged
    // if the log format is set to W3C. This must be the 'bitwise or'
    // of the HTTP_LOG_FIELD_... values.
    Fields: ULONG;
    // Following fields are reserved they must be NULL and zero..
    pExtFields: PVOID;
    NumOfExtFields: USHORT;
    // Reserved must be zero.
    MaxRecordSize: USHORT;
    // Defines the rollover type for the log files.
    RolloverType: HTTP_LOGGING_ROLLOVER_TYPE;
    // Indicates the maximum size (in bytes) after which
    // the log files should be rolled over. A value of -1
    // (HTTP_LIMIT_INFINITE) indicates an unlimited size.
    // This value is discarded if rollover type is not set to
    // HttpLoggingRolloverSize.
    RolloverSize: ULONG;
    // Specifies the security descriptor to be applied to
    // the log files and the sub-directories. If null we will
    // inherit the system default. This security descriptor must
    // be self-relative.
    pSecurityDescriptor: PSECURITY_DESCRIPTOR;
  end;
  PHTTP_LOGGING_INFO = ^HTTP_LOGGING_INFO;

//
// Binding information.
//

type
  HTTP_BINDING_INFO = record
    Flags: HTTP_PROPERTY_FLAGS;
    RequestQueueHandle: HANDLE;
  end;
  PHTTP_BINDING_INFO = ^HTTP_BINDING_INFO;

//
// Defines the protection level types for UrlGroups.
//

type
  HTTP_PROTECTION_LEVEL_TYPE = (
    // This option will allow edge (NAT) traversed traffic, i.e. Teredo
    // for the UrlGroup, unless there is an admin rule that overwrites the
    // application's intend.
    HttpProtectionLevelUnrestricted,
    // This setting will ensure that edge (NAT) traversed traffic
    // will not be allowed.
    HttpProtectionLevelEdgeRestricted,
    // Below type is not supported by HTTP API.
    HttpProtectionLevelRestricted);
  PHTTP_PROTECTION_LEVEL_TYPE = ^HTTP_PROTECTION_LEVEL_TYPE;

//
// Controls whether the associated UrlGroup Namespace should receive
// edge traversed traffic. By default this parameter is unspecified.
//

type
  HTTP_PROTECTION_LEVEL_INFO = record
    Flags: HTTP_PROPERTY_FLAGS;
    Level: HTTP_PROTECTION_LEVEL_TYPE;
  end;
  PHTTP_PROTECTION_LEVEL_INFO = ^HTTP_PROTECTION_LEVEL_INFO;

//
// Definitions for request queue manipulation.
//
// These flags are used with HttpCreateRequestQueue() API.
//
// HTTP_CREATE_REQUEST_QUEUE_FLAG_OPEN_EXISTING - To open an existing request
// queue. The request queue name must be supplied.
//
// HTTP_CREATE_REQUEST_QUEUE_FLAG_CONTROLLER - Creates the request queue and
// marks that the caller process is not willing to do send/receive (HTTP I/O)on
// the handle directly.
//

const
  HTTP_CREATE_REQUEST_QUEUE_FLAG_OPEN_EXISTING = ($00000001);
  HTTP_CREATE_REQUEST_QUEUE_FLAG_CONTROLLER = ($00000002);
  HTTP_CREATE_REQUEST_QUEUE_FLAG_DELEGATION = ($00000008);

//
// Flags for HttpReceiveHttpRequest().
//
// HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY - Specifies that the caller would like
// any available entity body to be copied along with the protocol headers.
//
// HTTP_RECEIVE_REQUEST_FLAG_FLUSH_BODY - Specifies that the caller would like
// all of the entity bodies to be copied along with the protocol headers.
//

const
  HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY = $00000001;
  HTTP_RECEIVE_REQUEST_FLAG_FLUSH_BODY = $00000002;

//
// Flags for HttpReceiveRequestEntityBody().
//
// HTTP_RECEIVE_REQUEST_ENTITY_BODY_FLAG_FILL_BUFFER - Specifies that the
// caller would like the buffer to get filled up with entity bodies unless
// there are no more entity bodies to be copied.
//

const
  HTTP_RECEIVE_REQUEST_ENTITY_BODY_FLAG_FILL_BUFFER = $00000001;

//
// Flags for HttpSendHttpResponse() and HttpSendResponseEntityBody().
//
// HTTP_SEND_RESPONSE_FLAG_DISCONNECT - Specifies that the network connection
// should be disconnected immediately after sending the response, overriding
// the HTTP protocol's persistent connection features, such as
// "Connection: keep-alive".
//
// HTTP_SEND_RESPONSE_FLAG_MORE_DATA - Specifies that additional entity body
// data will be sent by the caller.
//
// HTTP_SEND_RESPONSE_FLAG_BUFFER_DATA - Specifies that a caller wants the
// response to complete as soon as possible at the cost of buffering partial
// or the entire response.
//
// HTTP_SEND_RESPONSE_FLAG_ENABLE_NAGLING - Specifies that a caller wants to
// enable the TCP nagling algorithm for this particular send.
//
// HTTP_SEND_RESPONSE_FLAG_PROCESS_RANGES - Specifies that for a range request
// a full response content is passed and a caller wants HTTP API to process
// ranges properly.
//
// HTTP_SEND_RESPONSE_FLAG_OPAQUE - Specifies that the request/response is not
// HTTP compliant and all subsequent bytes should be treated as entity-body.
//
// HTTP_SEND_RESPONSE_FLAG_GOAWAY - A flag that must always be specified with
// HTTP_SEND_RESPONSE_FLAG_DISCONNECT. For pure HTTP/1.x connections, that is
// connections that don't do HTTP/2 and HTTP/3, this behaves the same as
// HTTP_SEND_RESPONSE_FLAG_DISCONNECT. For HTTP/2 and HTTP/3, this results in
// sending a GOAWAY frame and will cause the client to move to a different
// connection.
//
// HTTP_SEND_RESPONSE_FLAG_AUTOMATIC_CHUNKING - This flag instructs the
// http.sys to add chunk encoding automatically.
// HTTP_SEND_RESPONSE_FLAG_MORE_DATA must be specified as well. The caller
// must not add Transfer-Encoding: Chunked header.
//

const
  HTTP_SEND_RESPONSE_FLAG_DISCONNECT = $00000001;
  HTTP_SEND_RESPONSE_FLAG_MORE_DATA = $00000002;
  HTTP_SEND_RESPONSE_FLAG_BUFFER_DATA = $00000004;
  HTTP_SEND_RESPONSE_FLAG_ENABLE_NAGLING = $00000008;
  HTTP_SEND_RESPONSE_FLAG_PROCESS_RANGES = $00000020;
  HTTP_SEND_RESPONSE_FLAG_OPAQUE = $00000040;
  HTTP_SEND_RESPONSE_FLAG_GOAWAY = $00000100;
  HTTP_SEND_RESPONSE_FLAG_AUTOMATIC_CHUNKING = $00000200;

//
// Flags for HttpFlushResponseCache().
//
// HTTP_FLUSH_RESPONSE_FLAG_RECURSIVE - Flushes the specified URL and all
// hierarchally-related sub-URLs from the response or fragment cache.
//

const
  HTTP_FLUSH_RESPONSE_FLAG_RECURSIVE = $00000001;

//
// Opaque identifiers for various HTTPAPI objects.
//

type
  HTTP_OPAQUE_ID = ULONGLONG;
  PHTTP_OPAQUE_ID = ^HTTP_OPAQUE_ID;
  HTTP_REQUEST_ID = HTTP_OPAQUE_ID;
  PHTTP_REQUEST_ID = ^HTTP_REQUEST_ID;
  HTTP_CONNECTION_ID = HTTP_OPAQUE_ID;
  PHTTP_CONNECTION_ID = ^HTTP_CONNECTION_ID;
  HTTP_RAW_CONNECTION_ID = HTTP_OPAQUE_ID;
  PHTTP_RAW_CONNECTION_ID = ^HTTP_RAW_CONNECTION_ID;
  HTTP_URL_GROUP_ID = HTTP_OPAQUE_ID;
  PHTTP_URL_GROUP_ID = ^HTTP_URL_GROUP_ID;
  HTTP_SERVER_SESSION_ID = HTTP_OPAQUE_ID;
  PHTTP_SERVER_SESSION_ID = ^HTTP_SERVER_SESSION_ID;
  HTTP_CLIENT_REQUEST_ID = HTTP_OPAQUE_ID;
  PHTTP_CLIENT_REQUEST_ID = ^HTTP_CLIENT_REQUEST_ID;
  HTTP_CLIENT_CONNECTION_ID = HTTP_OPAQUE_ID;
  PHTTP_CLIENT_CONNECTION_ID = ^HTTP_CLIENT_CONNECTION_ID;
  HTTP_CLIENT_STREAM_ID = HTTP_OPAQUE_ID;
  PHTTP_CLIENT_STREAM_ID = ^HTTP_CLIENT_STREAM_ID;
  HTTP_CLIENT_CREDENTIAL_ID = HTTP_OPAQUE_ID;
  PHTTP_CLIENT_CREDENTIAL_ID = ^HTTP_CLIENT_CREDENTIAL_ID;

//
// Macros for opaque identifier manipulations.
//

const
  HTTP_NULL_ID: UInt64 = 0;
// #define HTTP_IS_NULL_ID(pid)    (HTTP_NULL_ID == *(pid))
// #define HTTP_SET_NULL_ID(pid)   (*(pid) = HTTP_NULL_ID)

//
// This structure defines a file byte range.
//
// If the Length field is HTTP_BYTE_RANGE_TO_EOF then the remainder of the
// file (everything after StartingOffset) is sent.
//

const
  HTTP_BYTE_RANGE_TO_EOF: ULONGLONG = ULONGLONG(-1);

type
  HTTP_BYTE_RANGE = record
    StartingOffset: ULARGE_INTEGER;
    Length: ULARGE_INTEGER;
  end;
  PHTTP_BYTE_RANGE = ^HTTP_BYTE_RANGE;

//
// The type for HTTP protocol version numbers.
//

type
  HTTP_VERSION = record
    MajorVersion: USHORT;
    MinorVersion: USHORT;
  end;
  PHTTP_VERSION = ^HTTP_VERSION;

//
// Some useful macros for HTTP protocol version manipulation.
//

// #define HTTP_VERSION_UNKNOWN    { 0, 0 }
// #define HTTP_VERSION_0_9        { 0, 9 }
// #define HTTP_VERSION_1_0        { 1, 0 }
// #define HTTP_VERSION_1_1        { 1, 1 }
// #define HTTP_VERSION_2_0        { 2, 0 }
// #define HTTP_VERSION_3_0        { 3, 0 }
// #define HTTP_SET_VERSION(version, major, minor)             \
// do {                                                        \
//     (version).MajorVersion = (major);                       \
//     (version).MinorVersion = (minor);                       \
// } while (0)
// #define HTTP_EQUAL_VERSION(version, major, minor)           \
//     ((version).MajorVersion == (major) &&                   \
//      (version).MinorVersion == (minor))
// #define HTTP_GREATER_VERSION(version, major, minor)         \
//     ((version).MajorVersion > (major) ||                    \
//      ((version).MajorVersion == (major) &&                  \
//       (version).MinorVersion > (minor)))
// #define HTTP_LESS_VERSION(version, major, minor)            \
//     ((version).MajorVersion < (major) ||                    \
//      ((version).MajorVersion == (major) &&                  \
//       (version).MinorVersion < (minor)))
// #define HTTP_NOT_EQUAL_VERSION(version, major, minor)       \
//     (!HTTP_EQUAL_VERSION(version, major, minor))
// #define HTTP_GREATER_EQUAL_VERSION(version, major, minor)   \
//     (!HTTP_LESS_VERSION(version, major, minor))
// #define HTTP_LESS_EQUAL_VERSION(version, major, minor)      \
//     (!HTTP_GREATER_VERSION(version, major, minor))

//
// The enum type for HTTP Scheme.
//

type
  HTTP_SCHEME = (
    HttpSchemeHttp,
    HttpSchemeHttps,
    HttpSchemeMaximum);
  PHTTP_URI_SCHEME = ^HTTP_SCHEME;

//
// The enum type for HTTP verbs.
//

type
  HTTP_VERB = (
    HttpVerbUnparsed,
    HttpVerbUnknown,
    HttpVerbInvalid,
    HttpVerbOPTIONS,
    HttpVerbGET,
    HttpVerbHEAD,
    HttpVerbPOST,
    HttpVerbPUT,
    HttpVerbDELETE,
    HttpVerbTRACE,
    HttpVerbCONNECT,
    HttpVerbTRACK,  // used by Microsoft Cluster Server for a non-logged trace
    HttpVerbMOVE,
    HttpVerbCOPY,
    HttpVerbPROPFIND,
    HttpVerbPROPPATCH,
    HttpVerbMKCOL,
    HttpVerbLOCK,
    HttpVerbUNLOCK,
    HttpVerbSEARCH,
    HttpVerbMaximum);
  PHTTP_VERB = ^HTTP_VERB;

//
// Symbols for all HTTP/1.1 headers and other tokens. Notice request +
// response values overlap. Make sure you know which type of header array
// you are indexing.
//
// These values are used as offsets into arrays and as token values in
// HTTP_KNOWN_HEADER arrays in HTTP_REQUEST_HEADERS and HTTP_RESPONSE_HEADERS.
//
// See RFC 2616, HTTP/1.1, for further explanation of most of these headers.
//

type
  HTTP_HEADER_ID = (
    HttpHeaderCacheControl          = 0,    // general-header [section 4.5]
    HttpHeaderConnection            = 1,    // general-header [section 4.5]
    HttpHeaderDate                  = 2,    // general-header [section 4.5]
    HttpHeaderKeepAlive             = 3,    // general-header [not in rfc]
    HttpHeaderPragma                = 4,    // general-header [section 4.5]
    HttpHeaderTrailer               = 5,    // general-header [section 4.5]
    HttpHeaderTransferEncoding      = 6,    // general-header [section 4.5]
    HttpHeaderUpgrade               = 7,    // general-header [section 4.5]
    HttpHeaderVia                   = 8,    // general-header [section 4.5]
    HttpHeaderWarning               = 9,    // general-header [section 4.5]
    HttpHeaderAllow                 = 10,   // entity-header  [section 7.1]
    HttpHeaderContentLength         = 11,   // entity-header  [section 7.1]
    HttpHeaderContentType           = 12,   // entity-header  [section 7.1]
    HttpHeaderContentEncoding       = 13,   // entity-header  [section 7.1]
    HttpHeaderContentLanguage       = 14,   // entity-header  [section 7.1]
    HttpHeaderContentLocation       = 15,   // entity-header  [section 7.1]
    HttpHeaderContentMd5            = 16,   // entity-header  [section 7.1]
    HttpHeaderContentRange          = 17,   // entity-header  [section 7.1]
    HttpHeaderExpires               = 18,   // entity-header  [section 7.1]
    HttpHeaderLastModified          = 19,   // entity-header  [section 7.1]
    // Request Headers
    HttpHeaderAccept                = 20,   // request-header [section 5.3]
    HttpHeaderAcceptCharset         = 21,   // request-header [section 5.3]
    HttpHeaderAcceptEncoding        = 22,   // request-header [section 5.3]
    HttpHeaderAcceptLanguage        = 23,   // request-header [section 5.3]
    HttpHeaderAuthorization         = 24,   // request-header [section 5.3]
    HttpHeaderCookie                = 25,   // request-header [not in rfc]
    HttpHeaderExpect                = 26,   // request-header [section 5.3]
    HttpHeaderFrom                  = 27,   // request-header [section 5.3]
    HttpHeaderHost                  = 28,   // request-header [section 5.3]
    HttpHeaderIfMatch               = 29,   // request-header [section 5.3]
    HttpHeaderIfModifiedSince       = 30,   // request-header [section 5.3]
    HttpHeaderIfNoneMatch           = 31,   // request-header [section 5.3]
    HttpHeaderIfRange               = 32,   // request-header [section 5.3]
    HttpHeaderIfUnmodifiedSince     = 33,   // request-header [section 5.3]
    HttpHeaderMaxForwards           = 34,   // request-header [section 5.3]
    HttpHeaderProxyAuthorization    = 35,   // request-header [section 5.3]
    HttpHeaderReferer               = 36,   // request-header [section 5.3]
    HttpHeaderRange                 = 37,   // request-header [section 5.3]
    HttpHeaderTe                    = 38,   // request-header [section 5.3]
    HttpHeaderTranslate             = 39,   // request-header [webDAV, not in rfc 2518]
    HttpHeaderUserAgent             = 40,   // request-header [section 5.3]
    HttpHeaderRequestMaximum        = 41,
    // Response Headers
    HttpHeaderAcceptRanges          = 20,   // response-header [section 6.2]
    HttpHeaderAge                   = 21,   // response-header [section 6.2]
    HttpHeaderEtag                  = 22,   // response-header [section 6.2]
    HttpHeaderLocation              = 23,   // response-header [section 6.2]
    HttpHeaderProxyAuthenticate     = 24,   // response-header [section 6.2]
    HttpHeaderRetryAfter            = 25,   // response-header [section 6.2]
    HttpHeaderServer                = 26,   // response-header [section 6.2]
    HttpHeaderSetCookie             = 27,   // response-header [not in rfc]
    HttpHeaderVary                  = 28,   // response-header [section 6.2]
    HttpHeaderWwwAuthenticate       = 29,   // response-header [section 6.2]
    HttpHeaderResponseMaximum       = 30,
    HttpHeaderMaximum               = 41);
  PHTTP_HEADER_ID = ^HTTP_HEADER_ID;

//
// Structure defining format of a known HTTP header.
// Name is from HTTP_HEADER_ID.
//

type
  HTTP_KNOWN_HEADER = record
    RawValueLength: USHORT; // in bytes not including the NUL
    pRawValue: PCSTR;
  end;
  PHTTP_KNOWN_HEADER = ^HTTP_KNOWN_HEADER;

//
// Structure defining format of an unknown header.
//

type
  HTTP_UNKNOWN_HEADER = record
    NameLength: USHORT; // in bytes not including the NUL
    RawValueLength: USHORT; // in bytes not including the NUL
    pName: PCSTR; // The header name (minus the ':' character)
    pRawValue: PCSTR; // The header value
  end;
  PHTTP_UNKNOWN_HEADER = ^HTTP_UNKNOWN_HEADER;

//
// Log fields data structure is used for logging a request. This structure must
// be provided along with an HttpSendHttpResponse or HttpSendResponseEntityBody
// call that concludes the send.
//

// Base structure is for future versioning.

type
  HTTP_LOG_DATA_TYPE = (
    HttpLogDataTypeFields = 0);
  PHTTP_LOG_DATA_TYPE = ^HTTP_LOG_DATA_TYPE;

// should we DECLSPEC_ALIGN(4 or 8) == DECLSPEC_POINTERALIGN?

type
  HTTP_LOG_DATA = record
    &Type: HTTP_LOG_DATA_TYPE;
  end;
  PHTTP_LOG_DATA = ^HTTP_LOG_DATA;

// Current log fields data structure for of type HttpLogDataTypeFields.

type
  HTTP_LOG_FIELDS_DATA = record
    Base: HTTP_LOG_DATA;
    UserNameLength: USHORT;
    UriStemLength: USHORT;
    ClientIpLength: USHORT;
    ServerNameLength: USHORT;
    ServiceNameLength: USHORT;
    ServerIpLength: USHORT;
    MethodLength: USHORT;
    UriQueryLength: USHORT;
    HostLength: USHORT;
    UserAgentLength: USHORT;
    CookieLength: USHORT;
    ReferrerLength: USHORT;
    UserName: PWCHAR;
    UriStem: PWCHAR;
    ClientIp: PCHAR;
    ServerName: PCHAR;
    ServiceName: PCHAR;
    ServerIp: PCHAR;
    Method: PCHAR;
    UriQuery: PCHAR;
    Host: PCHAR;
    UserAgent: PCHAR;
    Cookie: PCHAR;
    Referrer: PCHAR;
    ServerPort: USHORT;
    ProtocolStatus: USHORT;
    Win32Status: ULONG;
    MethodNum: HTTP_VERB;
    SubStatus: USHORT;
  end;
  PHTTP_LOG_FIELDS_DATA = ^HTTP_LOG_FIELDS_DATA;

  HTTP_WINHTTP_FAST_FORWARDING_DATA = record
    Reserved: array[0..16-1] of UCHAR;
  end;
  PHTTP_WINHTTP_FAST_FORWARDING_DATA = ^HTTP_WINHTTP_FAST_FORWARDING_DATA;

//
// This enum defines a data source for a particular chunk of data.
//

type
  HTTP_DATA_CHUNK_TYPE = (
    HttpDataChunkFromMemory,
    HttpDataChunkFromFileHandle,
    HttpDataChunkFromFragmentCache,
    HttpDataChunkFromFragmentCacheEx,
    HttpDataChunkTrailers,
    HttpDataChunkFromWinHttpFastForwarding,
    HttpDataChunkMaximum);
  PHTTP_DATA_CHUNK_TYPE = ^HTTP_DATA_CHUNK_TYPE;

//
// This structure describes an individual data chunk.
//

type
  HTTP_DATA_CHUNK = record
    // The type of this data chunk.
    DataChunkType: HTTP_DATA_CHUNK_TYPE;
    // The data chunk structures, one per supported data chunk type.
    case Integer of
      // From-memory data chunk.
      0: (
        FromMemory: record
          pBuffer: PVOID;
          BufferLength: ULONG;
        end;
      );
      // From-file handle data chunk.
      1: (
        FromFileHandle: record
          ByteRange: HTTP_BYTE_RANGE;
          FileHandle: HANDLE;
        end;
      );
      // From-fragment cache data chunk.
      2: (
        FromFragmentCache: record
          FragmentNameLength: USHORT;      // in bytes not including the NUL
          pFragmentName: PCWSTR;
        end;
      );
      // From-fragment cache data chunk that specifies a byte range.
      3: (
        FromFragmentCacheEx: record
          ByteRange: HTTP_BYTE_RANGE;
          pFragmentName: PCWSTR;           // NULL-terminated string
        end;
      );
      // Trailer data chunk that specifies Trailer headers.
      4: (
        Trailers: record
          TrailerCount: USHORT;
          pTrailers: PHTTP_UNKNOWN_HEADER;
        end;
      );
      5: (
        FromWinHttpFastForwarding: record
          WhFastForwardingData: HTTP_WINHTTP_FAST_FORWARDING_DATA;
        end;
      );
  end;
  PHTTP_DATA_CHUNK = ^HTTP_DATA_CHUNK;

//
// HTTP API doesn't support 16 bit applications.
// Neither WIN32 nor _WIN64 was defined.
//

// C_ASSERT(TYPE_ALIGNMENT(HTTP_DATA_CHUNK) == sizeof(ULONGLONG));

//
// Structure defining format of request headers.
//

type
  HTTP_REQUEST_HEADERS = record
    // The array of unknown HTTP headers and the number of
    // entries in the array.
    UnknownHeaderCount: USHORT;
    pUnknownHeaders: PHTTP_UNKNOWN_HEADER;
    // Trailers - we don't use these currently, reserved for a future release
    TrailerCount: USHORT; // Reserved, must be 0
    pTrailers: PHTTP_UNKNOWN_HEADER; // Reserved, must be NULL
    // Known headers.
    KnownHeaders: array[0..Ord(HTTP_HEADER_ID.HttpHeaderRequestMaximum)-1] of HTTP_KNOWN_HEADER;
  end;
  PHTTP_REQUEST_HEADERS = ^HTTP_REQUEST_HEADERS;

//
// Structure defining format of response headers.
//

type
  HTTP_RESPONSE_HEADERS = record
    // The array of unknown HTTP headers and the number of
    // entries in the array.
    UnknownHeaderCount: USHORT;
    pUnknownHeaders: PHTTP_UNKNOWN_HEADER;
    // Trailers - we don't use these currently, reserved for a future release
    TrailerCount: USHORT; // Reserved, must be 0
    pTrailers: PHTTP_UNKNOWN_HEADER; // Reserved, must be NULL
    // Known headers.
    KnownHeaders: array[0..Ord(HTTP_HEADER_ID.HttpHeaderResponseMaximum)-1] of HTTP_KNOWN_HEADER;
  end;
  PHTTP_RESPONSE_HEADERS = ^HTTP_RESPONSE_HEADERS;

//
// Properties that can be passed down with IOCTL_HTTP_DELEGATE_REQUEST_EX
//

type
  HTTP_DELEGATE_REQUEST_PROPERTY_ID = (
    DelegateRequestReservedProperty,
    DelegateRequestDelegateUrlProperty);
  PHTTP_DELEGATE_REQUEST_PROPERTY_ID = ^HTTP_DELEGATE_REQUEST_PROPERTY_ID;

  HTTP_DELEGATE_REQUEST_PROPERTY_INFO = record
    PropertyId: HTTP_DELEGATE_REQUEST_PROPERTY_ID;
    PropertyInfoLength: ULONG;
    PropertyInfo: PVOID;
  end;
  PHTTP_DELEGATE_REQUEST_PROPERTY_INFO = ^HTTP_DELEGATE_REQUEST_PROPERTY_INFO;

//
// Properties that can be passed down with IOCTL_HTTP_CREATE_REQUEST_QUEUE_EX
//

type
  HTTP_CREATE_REQUEST_QUEUE_PROPERTY_ID = (
    CreateRequestQueueExternalIdProperty = 1,
    CreateRequestQueueMax);
  PHTTP_CREATE_REQUEST_QUEUE_PROPERTY_ID = ^HTTP_CREATE_REQUEST_QUEUE_PROPERTY_ID;

  HTTP_CREATE_REQUEST_QUEUE_PROPERTY_INFO = record
    PropertyId: HTTP_CREATE_REQUEST_QUEUE_PROPERTY_ID;
    PropertyInfoLength: ULONG;
    PropertyInfo: PVOID;
  end;
  PHTTP_CREATE_REQUEST_QUEUE_PROPERTY_INFO = ^HTTP_CREATE_REQUEST_QUEUE_PROPERTY_INFO;

//
// Structure defining format of transport address. Use pLocalAddress->sa_family
// to determine whether this is an IPv4 address (AF_INET) or IPv6 (AF_INET6).
//
// pRemoteAddress->sa_family will be the same as pLocalAddress->sa_family.
//
// SOCKADDRs are always in network order, not host order.
//

type
  HTTP_TRANSPORT_ADDRESS = record
    pRemoteAddress: PSOCKADDR;
    pLocalAddress: PSOCKADDR;
  end;
  PHTTP_TRANSPORT_ADDRESS = ^HTTP_TRANSPORT_ADDRESS;

//
// Structure defining format of cooked URL.
//

type
  HTTP_COOKED_URL = record
    // Pointers overlap and point into pFullUrl. NULL if not present.
    FullUrlLength: USHORT; // in bytes not including the NUL
    HostLength: USHORT; // in bytes (no NUL)
    AbsPathLength: USHORT; // in bytes (no NUL)
    QueryStringLength: USHORT; // in bytes (no NUL)
    pFullUrl: PCWSTR; // points to "http://hostname:port/abs/.../path?query"
    pHost: PCWSTR; // points to the first char in the hostname
    pAbsPath: PCWSTR; // Points to the 3rd '/' char
    pQueryString: PCWSTR; // Points to the 1st '?' char or NULL
  end;
  PHTTP_COOKED_URL = ^HTTP_COOKED_URL;

//
// An opaque context for URL manipulation.
//

type
  HTTP_URL_CONTEXT = ULONGLONG;

//
// Optional flags for URL manipulation functions.
//
// HTTP_URL_FLAG_REMOVE_ALL : When this flag is used
// when removing a Url from a url group, regardless of
// the passed URL, all of the Urls from the url group
// will be removed.
//

const
  HTTP_URL_FLAG_REMOVE_ALL = $00000001;

//
// Request Authentication related.
//

type
  HTTP_AUTH_STATUS = (
    HttpAuthStatusSuccess,
    HttpAuthStatusNotAuthenticated,
    HttpAuthStatusFailure);
  PHTTP_AUTH_STATUS = ^HTTP_AUTH_STATUS;

  HTTP_REQUEST_AUTH_TYPE = (
    HttpRequestAuthTypeNone = 0,
    HttpRequestAuthTypeBasic,
    HttpRequestAuthTypeDigest,
    HttpRequestAuthTypeNTLM,
    HttpRequestAuthTypeNegotiate,
    HttpRequestAuthTypeKerberos);
  PHTTP_REQUEST_AUTH_TYPE = ^HTTP_REQUEST_AUTH_TYPE;

//
// SSL Client certificate information.
//

type
  HTTP_SSL_CLIENT_CERT_INFO = record
    CertFlags: ULONG;
    CertEncodedSize: ULONG;
    pCertEncoded: PUCHAR;
    Token: HANDLE;
    CertDeniedByMapper: BOOLEAN;
  end;
  PHTTP_SSL_CLIENT_CERT_INFO = ^HTTP_SSL_CLIENT_CERT_INFO;

//
// Flag to retrieve secure channel binding with HttpReceiveClientCertificate
//

const
  HTTP_RECEIVE_SECURE_CHANNEL_TOKEN = $1;

//
// Flag to retrieve full certificate chain with HttpReceiveClientCertificate
//

const
  HTTP_RECEIVE_FULL_CHAIN = $2;

//
// Data computed during SSL handshake.
//

type
  HTTP_SSL_INFO = record
    ServerCertKeySize: USHORT;
    ConnectionKeySize: USHORT;
    ServerCertIssuerSize: ULONG;
    ServerCertSubjectSize: ULONG;
    pServerCertIssuer: PCSTR;
    pServerCertSubject: PCSTR;
    pClientCertInfo: PHTTP_SSL_CLIENT_CERT_INFO;
    SslClientCertNegotiated: ULONG;
  end;
  PHTTP_SSL_INFO = ^HTTP_SSL_INFO;

//
// HttpRequestInfoTypeSslProtocol payload.  Contains basic information about the
// SSL/TLS protocol and cipher.  See SecPkgContext_ConnectionInfo documentation
// for details.  This information is meant for statistics.  Do not use this for
// security enforcement because by the time you check this the client may
// already have transmitted the information being protected (e.g. HTTP request
// headers).
//

type
  HTTP_SSL_PROTOCOL_INFO = record
    Protocol: ULONG;
    CipherType: ULONG;
    CipherStrength: ULONG;
    HashType: ULONG;
    HashStrength: ULONG;
    KeyExchangeType: ULONG;
    KeyExchangeStrength: ULONG;
  end;
  PHTTP_SSL_PROTOCOL_INFO = ^HTTP_SSL_PROTOCOL_INFO;

//
// List of possible sizes for which information will be retured in HTTP_REQUEST_SIZING_INFO.
//

type
  HTTP_REQUEST_SIZING_TYPE = (
    HttpRequestSizingTypeTlsHandshakeLeg1ClientData, // Inbound/outbound data?
    HttpRequestSizingTypeTlsHandshakeLeg1ServerData,
    HttpRequestSizingTypeTlsHandshakeLeg2ClientData,
    HttpRequestSizingTypeTlsHandshakeLeg2ServerData,
    HttpRequestSizingTypeHeaders,
    HttpRequestSizingTypeMax);
  PHTTP_REQUEST_SIZING_TYPE = ^HTTP_REQUEST_SIZING_TYPE;

//
// Flag values for HTTP_REQUEST_SIZING_INFO
//

const
  HTTP_REQUEST_SIZING_INFO_FLAG_TCP_FAST_OPEN = $00000001;
  HTTP_REQUEST_SIZING_INFO_FLAG_TLS_SESSION_RESUMPTION = $00000002;
  HTTP_REQUEST_SIZING_INFO_FLAG_TLS_FALSE_START = $00000004;
  HTTP_REQUEST_SIZING_INFO_FLAG_FIRST_REQUEST = $00000008;

//
// HttpRequestInfoTypeSizeInfo payload. Contains size information filled by
// each processsing stage.
//

type
  HTTP_REQUEST_SIZING_INFO = record
    Flags: ULONGLONG;
    RequestIndex: ULONG;
    RequestSizingCount: ULONG;
    RequestSizing: array[0..Ord(HTTP_REQUEST_SIZING_TYPE.HttpRequestSizingTypeMax)-1] of ULONGLONG;
  end;
  PHTTP_REQUEST_SIZING_INFO = ^HTTP_REQUEST_SIZING_INFO;

//
// List of possible request timings for which information will be retured in
// HTTP_REQUEST_TIMING_INFO. Not all timings apply for every request.
//

type
  HTTP_REQUEST_TIMING_TYPE = (
    HttpRequestTimingTypeConnectionStart,
    HttpRequestTimingTypeDataStart,
    HttpRequestTimingTypeTlsCertificateLoadStart,
    HttpRequestTimingTypeTlsCertificateLoadEnd,
    HttpRequestTimingTypeTlsHandshakeLeg1Start,
    HttpRequestTimingTypeTlsHandshakeLeg1End,
    HttpRequestTimingTypeTlsHandshakeLeg2Start,
    HttpRequestTimingTypeTlsHandshakeLeg2End,
    HttpRequestTimingTypeTlsAttributesQueryStart,
    HttpRequestTimingTypeTlsAttributesQueryEnd,
    HttpRequestTimingTypeTlsClientCertQueryStart,
    HttpRequestTimingTypeTlsClientCertQueryEnd,
    HttpRequestTimingTypeHttp2StreamStart,
    HttpRequestTimingTypeHttp2HeaderDecodeStart,
    HttpRequestTimingTypeHttp2HeaderDecodeEnd,
    HttpRequestTimingTypeRequestHeaderParseStart,
    HttpRequestTimingTypeRequestHeaderParseEnd,
    HttpRequestTimingTypeRequestRoutingStart,
    HttpRequestTimingTypeRequestRoutingEnd,
    HttpRequestTimingTypeRequestQueuedForInspection,
    HttpRequestTimingTypeRequestDeliveredForInspection,
    HttpRequestTimingTypeRequestReturnedAfterInspection,
    HttpRequestTimingTypeRequestQueuedForDelegation,
    HttpRequestTimingTypeRequestDeliveredForDelegation,
    HttpRequestTimingTypeRequestReturnedAfterDelegation,
    HttpRequestTimingTypeRequestQueuedForIO,
    HttpRequestTimingTypeRequestDeliveredForIO,
    HttpRequestTimingTypeHttp3StreamStart,
    HttpRequestTimingTypeHttp3HeaderDecodeStart,
    HttpRequestTimingTypeHttp3HeaderDecodeEnd,
    HttpRequestTimingTypeMax);
  PHTTP_REQUEST_TIMING_TYPE = ^HTTP_REQUEST_TIMING_TYPE;

//
// HttpRequestInfoTypeTiming payload.  Contains information about how much
// time was spent at each request processing stage.
//

type
  HTTP_REQUEST_TIMING_INFO = record
    RequestTimingCount: ULONG;
    RequestTiming: array[0..Ord(HTTP_REQUEST_TIMING_TYPE.HttpRequestTimingTypeMax)-1] of ULONGLONG;
  end;
  PHTTP_REQUEST_TIMING_INFO = ^HTTP_REQUEST_TIMING_INFO;

  HTTP_REQUEST_TRANSPORT_IDLE_CONNECTION_TIMEOUT_INFO = record
    TransportIdleConnectionTimeout: USHORT;
  end;
  PHTTP_REQUEST_TRANSPORT_IDLE_CONNECTION_TIMEOUT_INFO = ^HTTP_REQUEST_TRANSPORT_IDLE_CONNECTION_TIMEOUT_INFO;

  HTTP_REQUEST_DSCP_INFO = record
    DscpTag: BYTE;
  end;
  PHTTP_REQUEST_DSCP_INFO = ^HTTP_REQUEST_DSCP_INFO;

  HTTP_REQUEST_INITIAL_PACKET_TTL_INFO = record
    InitialPacketTtl: BYTE;
  end;
  PHTTP_REQUEST_INITIAL_PACKET_TTL_INFO = ^HTTP_REQUEST_INITIAL_PACKET_TTL_INFO;

//
// Generic request information type.
//

type
  HTTP_REQUEST_INFO_TYPE = (
    HttpRequestInfoTypeAuth,
    HttpRequestInfoTypeChannelBind,
    HttpRequestInfoTypeSslProtocol,
    HttpRequestInfoTypeSslTokenBindingDraft,
    HttpRequestInfoTypeSslTokenBinding,
    HttpRequestInfoTypeRequestTiming,
    HttpRequestInfoTypeTcpInfoV0,
    HttpRequestInfoTypeRequestSizing,
    HttpRequestInfoTypeQuicStats,
    HttpRequestInfoTypeTcpInfoV1,
    HttpRequestInfoTypeQuicStatsV2,
    HttpRequestInfoTypeTcpInfoV2,
    HttpRequestInfoTypeTransportIdleConnectionTimeout,
    HttpRequestInfoTypeDscpTag,
    HttpRequestInfoTypeInitialPacketTtl);
  PHTTP_REQUEST_INFO_TYPE = ^HTTP_REQUEST_INFO_TYPE;

  HTTP_REQUEST_INFO = record
    InfoType: HTTP_REQUEST_INFO_TYPE;
    InfoLength: ULONG;
    pInfo: PVOID;
  end;
  PHTTP_REQUEST_INFO = ^HTTP_REQUEST_INFO;

  SECURITY_STATUS = LONG;

//
// Authentication request info structure
//

const
  HTTP_REQUEST_AUTH_FLAG_TOKEN_FOR_CACHED_CRED = ($00000001);

type
  HTTP_REQUEST_AUTH_INFO = record
    AuthStatus: HTTP_AUTH_STATUS;
    SecStatus: SECURITY_STATUS;
    Flags: ULONG;
    AuthType: HTTP_REQUEST_AUTH_TYPE;
    AccessToken: HANDLE;
    ContextAttributes: ULONG;
    // Optional serialized context.
    PackedContextLength: ULONG;
    PackedContextType: ULONG;
    PackedContext: PVOID;
    // Optional mutual authentication data and its length in bytes.
    MutualAuthDataLength: ULONG;
    pMutualAuthData: PCHAR;
    // For SSPI based schemes the package name is returned. Length does
    // not include the terminating null and it is in bytes.
    PackageNameLength: USHORT;
    pPackageName: PWSTR;
  end;
  PHTTP_REQUEST_AUTH_INFO = ^HTTP_REQUEST_AUTH_INFO;

//
// The structure of an HTTP request for downlevel OS
//

type
  HTTP_REQUEST_V1 = record
    // Request flags (see HTTP_REQUEST_FLAG_* definitions below).
    Flags: ULONG;
    // An opaque request identifier. These values are used by the driver
    // to correlate outgoing responses with incoming requests.
    ConnectionId: HTTP_CONNECTION_ID;
    RequestId: HTTP_REQUEST_ID;
    // The context associated with the URL prefix.
    UrlContext: HTTP_URL_CONTEXT;
    // The HTTP version number.
    Version: HTTP_VERSION;
    // The request verb.
    Verb: HTTP_VERB;
    // The length of the verb string if the Verb field is HttpVerbUnknown.
    UnknownVerbLength: USHORT; // in bytes not including the NUL
    // The length of the raw (uncooked) URL
    RawUrlLength: USHORT; // in bytes not including the NUL
    // Pointer to the verb string if the Verb field is HttpVerbUnknown.
    pUnknownVerb: PCSTR;
    // Pointer to the raw (uncooked) URL
    pRawUrl: PCSTR;
    // The canonicalized Unicode URL
    CookedUrl: HTTP_COOKED_URL;
    // Local and remote transport addresses for the connection.
    Address: HTTP_TRANSPORT_ADDRESS;
    // The request headers.
    Headers: HTTP_REQUEST_HEADERS;
    // The total number of bytes received from network for this request.
    BytesReceived: ULONGLONG;
    // pEntityChunks is an array of EntityChunkCount HTTP_DATA_CHUNKs. The
    // entity body is copied only if HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY
    // was passed to HttpReceiveHttpRequest().
    EntityChunkCount: USHORT;
    pEntityChunks: PHTTP_DATA_CHUNK;
    // SSL connection information.
    RawConnectionId: HTTP_RAW_CONNECTION_ID;
    pSslInfo: PHTTP_SSL_INFO;
  end;
  PHTTP_REQUEST_V1 = ^HTTP_REQUEST_V1;

  HTTP_REQUEST_V2 = record

    //
    // Version 1.0 members are included explicitly
    //

    // Request flags (see HTTP_REQUEST_FLAG_* definitions below).
    Flags: ULONG;
    // An opaque request identifier. These values are used by the driver
    // to correlate outgoing responses with incoming requests.
    ConnectionId: HTTP_CONNECTION_ID;
    RequestId: HTTP_REQUEST_ID;
    // The context associated with the URL prefix.
    UrlContext: HTTP_URL_CONTEXT;
    // The HTTP version number.
    Version: HTTP_VERSION;
    // The request verb.
    Verb: HTTP_VERB;
    // The length of the verb string if the Verb field is HttpVerbUnknown.
    UnknownVerbLength: USHORT; // in bytes not including the NUL
    // The length of the raw (uncooked) URL
    RawUrlLength: USHORT; // in bytes not including the NUL
    // Pointer to the verb string if the Verb field is HttpVerbUnknown.
    pUnknownVerb: PCSTR;
    // Pointer to the raw (uncooked) URL
    pRawUrl: PCSTR;
    // The canonicalized Unicode URL
    CookedUrl: HTTP_COOKED_URL;
    // Local and remote transport addresses for the connection.
    Address: HTTP_TRANSPORT_ADDRESS;
    // The request headers.
    Headers: HTTP_REQUEST_HEADERS;
    // The total number of bytes received from network for this request.
    BytesReceived: ULONGLONG;
    // pEntityChunks is an array of EntityChunkCount HTTP_DATA_CHUNKs. The
    // entity body is copied only if HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY
    // was passed to HttpReceiveHttpRequest().
    EntityChunkCount: USHORT;
    pEntityChunks: PHTTP_DATA_CHUNK;
    // SSL connection information.
    RawConnectionId: HTTP_RAW_CONNECTION_ID;
    pSslInfo: PHTTP_SSL_INFO;

    //
    // Version 2.0 members are declared below
    //

    // Additional Request Informations.
    RequestInfoCount: USHORT;
    pRequestInfo: PHTTP_REQUEST_INFO;

  end;
  PHTTP_REQUEST_V2 = ^HTTP_REQUEST_V2;

  HTTP_REQUEST = HTTP_REQUEST_V2;
  PHTTP_REQUEST = ^HTTP_REQUEST;

//
// Values for HTTP_REQUEST::Flags. Zero or more of these may be ORed together.
//
// HTTP_REQUEST_FLAG_MORE_ENTITY_BODY_EXISTS - there is more entity body
// to be read for this request. Otherwise, there is no entity body or
// all of the entity body was copied into pEntityChunks.
// HTTP_REQUEST_FLAG_IP_ROUTED - This flag indicates that the request has been
// routed based on host plus ip or ip binding.This is a hint for the application
// to include the local ip while flushing kernel cache entries build for this
// request if any.
// HTTP_REQUEST_FLAG_HTTP2 - Indicates the request was received over HTTP/2.
// HTTP_REQUEST_FLAG_HTTP3 - Indicates the request was received over HTTP/3.
// HTTP_REQUEST_FLAG_FAST_FORWARDING_RESPONSE_ALLOWED - Indicates the response
//                                                      is eligible for
//                                                      fast-forwarding.
// HTTP_REQUEST_FLAG_FAST_FORWARDING_ALLOWED - This should not be used, it is
//                                             the old flag.
//                                             It has been used first, but the flag
//                                             was split into request and response
//                                             side. This old flag has the same
//                                             value as the response-side flag.
//

const
  HTTP_REQUEST_FLAG_MORE_ENTITY_BODY_EXISTS = $00000001;
  HTTP_REQUEST_FLAG_IP_ROUTED = $00000002;
  HTTP_REQUEST_FLAG_HTTP2 = $00000004;
  HTTP_REQUEST_FLAG_HTTP3 = $00000008;
  HTTP_REQUEST_FLAG_FAST_FORWARDING_ALLOWED = $00000010;
  HTTP_REQUEST_FLAG_FAST_FORWARDING_RESPONSE_ALLOWED = HTTP_REQUEST_FLAG_FAST_FORWARDING_ALLOWED;

//
// This structure describes an HTTP response.
//

type
  HTTP_RESPONSE_V1 = record
    // Response flags (see HTTP_RESPONSE_FLAG_* definitions below).
    Flags: ULONG;
    // The raw HTTP protocol version number.
    Version: HTTP_VERSION;
    // The HTTP status code (e.g., 200).
    StatusCode: USHORT;
    // The HTTP reason (e.g., "OK"). This MUST not contain
    // non-ASCII characters (i.e., all chars must be in range $20-$7E).
    ReasonLength: USHORT; // in bytes not including the '\0'
    pReason: PCSTR;
    // The response headers.
    Headers: HTTP_RESPONSE_HEADERS;
    // pEntityChunks points to an array of EntityChunkCount HTTP_DATA_CHUNKs.
    EntityChunkCount: USHORT;
    pEntityChunks: PHTTP_DATA_CHUNK;
  end;
  PHTTP_RESPONSE_V1 = ^HTTP_RESPONSE_V1;

//
// Values for HTTP_RESPONSE::Flags.
//

// HTTP_RESPONSE_FLAG_MULTIPLE_ENCODINGS_AVAILABLE - Set this flag if encodings
// other than identity form are available for this resource.This flag is ignored
// if application has not asked for response to be cached. It's used as a hint
// to the Http Server API for content negotiation  used when serving from the
// the kernel response cache.
//
// HTTP_RESPONSE_FLAG_MORE_ENTITY_BODY_EXISTS - there is more entity body
// to be read for this response.  Otherwise, there is no entity body or
// all of the entity body was copied into pEntityChunks.

const
  HTTP_RESPONSE_FLAG_MULTIPLE_ENCODINGS_AVAILABLE = $00000001;
  HTTP_RESPONSE_FLAG_MORE_ENTITY_BODY_EXISTS = $00000002;

type
  HTTP_RESPONSE_INFO_TYPE = (
    HttpResponseInfoTypeMultipleKnownHeaders,
    HttpResponseInfoTypeAuthenticationProperty,
    HttpResponseInfoTypeQoSProperty,
    HttpResponseInfoTypeChannelBind);
  PHTTP_RESPONSE_INFO_TYPE = ^HTTP_RESPONSE_INFO_TYPE;

  HTTP_RESPONSE_INFO = record
    &Type: HTTP_RESPONSE_INFO_TYPE;
    Length: ULONG;
    pInfo: PVOID;
  end;
  PHTTP_RESPONSE_INFO = ^HTTP_RESPONSE_INFO;

const
  HTTP_RESPONSE_INFO_FLAGS_PRESERVE_ORDER = $00000001;

//
// This structure allows the provision of providing multiple known headers.
//

type
  HTTP_MULTIPLE_KNOWN_HEADERS = record
    // Known header id.
    HeaderId: HTTP_HEADER_ID;
    Flags: ULONG;
    // Number of headers of the same category.
    KnownHeaderCount: USHORT;
    // Array of known header structures.
    KnownHeaders: PHTTP_KNOWN_HEADER;
  end;
  PHTTP_MULTIPLE_KNOWN_HEADERS = ^HTTP_MULTIPLE_KNOWN_HEADERS;

  HTTP_RESPONSE_V2 = record

    //
    // Version 1.0 members are included explicitly
    //

    // Response flags (see HTTP_RESPONSE_FLAG_* definitions below).
    Flags: ULONG;
    // The raw HTTP protocol version number.
    Version: HTTP_VERSION;
    // The HTTP status code (e.g., 200).
    StatusCode: USHORT;
    // The HTTP reason (e.g., "OK"). This MUST not contain
    // non-ASCII characters (i.e., all chars must be in range $20-$7E).
    ReasonLength: USHORT; // in bytes not including the '\0'
    pReason: PCSTR;
    // The response headers.
    Headers: HTTP_RESPONSE_HEADERS;
    // pEntityChunks points to an array of EntityChunkCount HTTP_DATA_CHUNKs.
    EntityChunkCount: USHORT;
    pEntityChunks: PHTTP_DATA_CHUNK;

    //
    // Version 2.0 members are declared below
    //

    ResponseInfoCount: USHORT;
    pResponseInfo: PHTTP_RESPONSE_INFO;

  end;
  PHTTP_RESPONSE_V2 = ^HTTP_RESPONSE_V2;

  HTTP_RESPONSE = HTTP_RESPONSE_V2;
  PHTTP_RESPONSE = ^HTTP_RESPONSE;

//
// Api Version. This is used to ensure compatibility between applications and
// httpapi.dll and http.sys.
//
// This must not be confused with the HTTP Protocol version.
//

type
  HTTPAPI_VERSION = record
    HttpApiMajorVersion: USHORT;
    HttpApiMinorVersion: USHORT;
  end;
  PHTTPAPI_VERSION = ^HTTPAPI_VERSION;

const
  HTTPAPI_VERSION_2: HTTPAPI_VERSION = (HttpApiMajorVersion:2; HttpApiMinorVersion:0);
  HTTPAPI_VERSION_1: HTTPAPI_VERSION = (HttpApiMajorVersion:1; HttpApiMinorVersion:0);

// #define HTTPAPI_EQUAL_VERSION(version, major, minor)                \
//     ((version).HttpApiMajorVersion == (major) &&                    \
//      (version).HttpApiMinorVersion == (minor))
// #define HTTPAPI_GREATER_VERSION(version, major, minor)              \
//     ((version).HttpApiMajorVersion > (major) ||                     \
//      ((version).HttpApiMajorVersion == (major) &&                   \
//       (version).HttpApiMinorVersion > (minor)))
// #define HTTPAPI_LESS_VERSION(version, major, minor)                 \
//     ((version).HttpApiMajorVersion < (major) ||                     \
//      ((version).HttpApiMajorVersion == (major) &&                   \
//       (version).HttpApiMinorVersion < (minor)))
// #define HTTPAPI_VERSION_GREATER_OR_EQUAL( version, major, minor)    \
//     (!HTTPAPI_LESS_VERSION(version, major, minor))

//
// Cache control.
//

//
// This enum defines the available cache policies.
//

type
  HTTP_CACHE_POLICY_TYPE = (
    HttpCachePolicyNocache,
    HttpCachePolicyUserInvalidates,
    HttpCachePolicyTimeToLive,
    HttpCachePolicyMaximum);
  PHTTP_CACHE_POLICY_TYPE = ^HTTP_CACHE_POLICY_TYPE;

//
//  Only cache unauthorized GETs + HEADs.
//

type
  HTTP_CACHE_POLICY = record
    Policy: HTTP_CACHE_POLICY_TYPE;
    SecondsToLive: ULONG;
  end;
  PHTTP_CACHE_POLICY = ^HTTP_CACHE_POLICY;

//
// Enum that is used with HttpSetServiceConfiguration(),
// HttpQueryServiceConfiguration(), and HttpDeleteServiceConfiguration() APIs.
//

type
  HTTP_SERVICE_CONFIG_ID = (
    HttpServiceConfigIPListenList,    // Set, Query & Delete.
    HttpServiceConfigSSLCertInfo,     // Set, Update, Query & Delete.
    HttpServiceConfigUrlAclInfo,      // Set, Query & Delete.
    HttpServiceConfigTimeout,         // Set, Query & Delete.
    HttpServiceConfigCache,           // Set, Query & Delete.
    HttpServiceConfigSslSniCertInfo,  // Set, Update, Query & Delete.
    HttpServiceConfigSslCcsCertInfo,  // Set, Update, Query & Delete.
    HttpServiceConfigSetting,        // Set, Query & Delete.
    HttpServiceConfigSslCertInfoEx,
    HttpServiceConfigSslSniCertInfoEx,
    HttpServiceConfigSslCcsCertInfoEx,
    HttpServiceConfigSslScopedCcsCertInfo,
    HttpServiceConfigSslScopedCcsCertInfoEx,
    HttpServiceConfigMax);
  PHTTP_SERVICE_CONFIG_ID = ^HTTP_SERVICE_CONFIG_ID;

//
// Generic Query enum that can be used with HttpQueryServiceConfiguration()
//

type
  HTTP_SERVICE_CONFIG_QUERY_TYPE = (
    HttpServiceConfigQueryExact,
    HttpServiceConfigQueryNext,
    HttpServiceConfigQueryMax);
  PHTTP_SERVICE_CONFIG_QUERY_TYPE = ^HTTP_SERVICE_CONFIG_QUERY_TYPE;

//
// These data structures are used to define the key types of the various SSL
// bindings.
//

type
  HTTP_SERVICE_CONFIG_SSL_KEY = record
    pIpPort: PSOCKADDR;
  end;
  PHTTP_SERVICE_CONFIG_SSL_KEY = ^HTTP_SERVICE_CONFIG_SSL_KEY;

  HTTP_SERVICE_CONFIG_SSL_KEY_EX = record
    IpPort: SOCKADDR_STORAGE;
  end;
  PHTTP_SERVICE_CONFIG_SSL_KEY_EX = ^HTTP_SERVICE_CONFIG_SSL_KEY_EX;

  HTTP_SERVICE_CONFIG_SSL_SNI_KEY = record
    IpPort: SOCKADDR_STORAGE;
    Host: PWSTR;
  end;
  PHTTP_SERVICE_CONFIG_SSL_SNI_KEY = ^HTTP_SERVICE_CONFIG_SSL_SNI_KEY;

  HTTP_SERVICE_CONFIG_SSL_CCS_KEY = record
    LocalAddress: SOCKADDR_STORAGE;
  end;
  PHTTP_SERVICE_CONFIG_SSL_CCS_KEY = ^HTTP_SERVICE_CONFIG_SSL_CCS_KEY;

//
// Define various certificate check mode flags used by DefaultCertCheckMode.
//

const
  HTTP_CERT_CHECK_MODE_NO_REVOCATION = $00001;
  HTTP_CERT_CHECK_MODE_CACHED_REVOCATION = $00002;
  HTTP_CERT_CHECK_MODE_USE_REVOCATION_FRESHNESS = $00004;
  HTTP_CERT_CHECK_MODE_CACHED_URLS = $00008;
  HTTP_CERT_CHECK_MODE_NO_AIA = $00010;
  HTTP_CERT_CHECK_MODE_NO_USAGE_CHECK = $10000;

//
// This defines a record for the SSL config store.
//

type
  HTTP_SERVICE_CONFIG_SSL_PARAM = record
    SslHashLength: ULONG; // Length of the SSL hash (in bytes)
    pSslHash: PVOID; // Pointer to the SSL hash
    AppId: GUID; // A unique identifier that can be used to
    // identify the app that has set this parameter
    pSslCertStoreName: PWSTR; // Store name to read the server certificate
    // from; defaults to "MY". Certificate must be
    // stored in the LOCAL_MACHINE context.
    // The following settings are used only for client certificates
    // DefaultCertCheckMode is a bit flag with the following semantics
    //  $1     - Client certificate will not be verified for revocation
    //  $2     - Only cached certificate revocation will be used.
    //  $4     - Enable use of the DefaultRevocationFreshnessTime setting
    //  $8     - Disable network URL retrieval.
    //  $10    - Disable AIA checks.
    //  $10000 - No usage check.
    DefaultCertCheckMode: DWORD;
    // DefaultRevocationFreshnessTime (seconds) - How often to check for
    // an updated Certificate revocation list (CRL). If this value is 0
    // then the new CRL is updated only if the previous one expires
    DefaultRevocationFreshnessTime: DWORD;
    // DefaultRevocationUrlRetrievalTimeout (milliseconds) - Timeout on
    // attempt to retrieve certificate revocation list from the remote URL.
    DefaultRevocationUrlRetrievalTimeout: DWORD;
    // pDefaultSslCtlIdentifier - Restrict the certificate issuers that you
    // want to trust. Can be a subset of the certificate issuers that are
    // trusted by the machine.
    pDefaultSslCtlIdentifier: PWSTR;
    // Store name under LOCAL_MACHINE where Ctl identified by
    // pDefaultSslCtlIdentifier is stored.
    pDefaultSslCtlStoreName: PWSTR;
    // Default Flags - see HTTP_SERVICE_CONFIG_SSL_FLAG* below.
    DefaultFlags: DWORD;
  end;
  PHTTP_SERVICE_CONFIG_SSL_PARAM = ^HTTP_SERVICE_CONFIG_SSL_PARAM;

//
// The extended param type for the SSL extended params.
//

type
  HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE = (
    ExParamTypeHttp2Window,
    ExParamTypeHttp2SettingsLimits,
    ExParamTypeHttpPerformance,
    ExParamTypeTlsRestrictions,
    ExParamTypeErrorHeaders,
    ExParamTypeTlsSessionTicketKeys,
    ExParamTypeCertConfig,
    ExParamTypeMax);
  PHTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE = ^HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE;

  HTTP2_WINDOW_SIZE_PARAM = record
    // The http/2 connection receive window size.
    Http2ReceiveWindowSize: DWORD;
  end;
  PHTTP2_WINDOW_SIZE_PARAM = ^HTTP2_WINDOW_SIZE_PARAM;

  HTTP2_SETTINGS_LIMITS_PARAM = record
    // The maximum allowed settings per SETTINGS frame.
    Http2MaxSettingsPerFrame: DWORD;
    // The maximum settings we will process in a minute.
    Http2MaxSettingsPerMinute: DWORD;
  end;
  PHTTP2_SETTINGS_LIMITS_PARAM = ^HTTP2_SETTINGS_LIMITS_PARAM;

  HTTP_PERFORMANCE_PARAM_TYPE = (
    PerformanceParamSendBufferingFlags,
    PerformanceParamAggressiveICW,
    PerformanceParamMaxSendBufferSize,
    PerformanceParamMaxConcurrentClientStreams,
    PerformanceParamMaxReceiveBufferSize,
    PerformanceParamDecryptOnSspiThread,
    PerformanceParamMax);
  PHTTP_PERFORMANCE_PARAM_TYPE = ^HTTP_PERFORMANCE_PARAM_TYPE;

  HTTP_PERFORMANCE_PARAM = record
    &Type: HTTP_PERFORMANCE_PARAM_TYPE;
    BufferSize: ULONG;
    Buffer: PVOID;
  end;
  PHTTP_PERFORMANCE_PARAM = ^HTTP_PERFORMANCE_PARAM;

  HTTP_TLS_RESTRICTIONS_PARAM = record
    RestrictionCount: ULONG;
    TlsRestrictions: PVOID;
  end;
  PHTTP_TLS_RESTRICTIONS_PARAM = ^HTTP_TLS_RESTRICTIONS_PARAM;

  HTTP_ERROR_HEADERS_PARAM = record
    StatusCode: USHORT;
    HeaderCount: USHORT;
    Headers: PHTTP_UNKNOWN_HEADER;
  end;
  PHTTP_ERROR_HEADERS_PARAM = ^HTTP_ERROR_HEADERS_PARAM;

  HTTP_TLS_SESSION_TICKET_KEYS_PARAM = record
    SessionTicketKeyCount: ULONG;
    SessionTicketKeys: PVOID;
  end;
  PHTTP_TLS_SESSION_TICKET_KEYS_PARAM = ^HTTP_TLS_SESSION_TICKET_KEYS_PARAM;

//
// This should really be defined by one of the security header files.
//

const
  HTTP_SSL_CERT_SHA_HASH_LENGTH = 20;
  HTTP_SSL_CERT_STORE_NAME_LENGTH = 128;

type
  HTTP_CERT_CONFIG_ENTRY = record
    CertHash: array[0..HTTP_SSL_CERT_SHA_HASH_LENGTH-1] of BYTE;
    CertStoreName: array[0..HTTP_SSL_CERT_STORE_NAME_LENGTH-1] of WCHAR;
  end;
  PHTTP_CERT_CONFIG_ENTRY = ^HTTP_CERT_CONFIG_ENTRY;

  HTTP_CERT_CONFIG_PARAM = record
    CertConfigCount: ULONG;
    CertConfigs: PHTTP_CERT_CONFIG_ENTRY;
  end;
  PHTTP_CERT_CONFIG_PARAM = ^HTTP_CERT_CONFIG_PARAM;

//
// This defines the extended params for the ssl config record.
//

type
  HTTP_SERVICE_CONFIG_SSL_PARAM_EX = record
     // The id that decides which param property is passed below.
     ParamType: HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE;
     // Flags for future use, if any.
     Flags: ULONGLONG;
     // The property.
     case Integer of
       0:(Http2WindowSizeParam: HTTP2_WINDOW_SIZE_PARAM);
       1:(Http2SettingsLimitsParam: HTTP2_SETTINGS_LIMITS_PARAM);
       2:(HttpPerformanceParam: HTTP_PERFORMANCE_PARAM);
       3:(HttpTlsRestrictionsParam: HTTP_TLS_RESTRICTIONS_PARAM);
       4:(HttpErrorHeadersParam: HTTP_ERROR_HEADERS_PARAM);
       5:(HttpTlsSessionTicketKeysParam: HTTP_TLS_SESSION_TICKET_KEYS_PARAM);
       6:(HttpCertConfigParam: HTTP_CERT_CONFIG_PARAM);
  end;
  PHTTP_SERVICE_CONFIG_SSL_PARAM_EX = ^HTTP_SERVICE_CONFIG_SSL_PARAM_EX;

//
// The SSL config flags.
//

const
  HTTP_SERVICE_CONFIG_SSL_FLAG_USE_DS_MAPPER = $00000001;
  HTTP_SERVICE_CONFIG_SSL_FLAG_NEGOTIATE_CLIENT_CERT = $00000002;
  HTTP_SERVICE_CONFIG_SSL_FLAG_NO_RAW_FILTER = $00000004;
  HTTP_SERVICE_CONFIG_SSL_FLAG_REJECT = $00000008;
  HTTP_SERVICE_CONFIG_SSL_FLAG_DISABLE_HTTP2 = $00000010;
  HTTP_SERVICE_CONFIG_SSL_FLAG_DISABLE_QUIC = $00000020;
  HTTP_SERVICE_CONFIG_SSL_FLAG_DISABLE_TLS13 = $00000040;
  HTTP_SERVICE_CONFIG_SSL_FLAG_DISABLE_OCSP_STAPLING = $00000080;
  HTTP_SERVICE_CONFIG_SSL_FLAG_ENABLE_TOKEN_BINDING = $00000100;
  HTTP_SERVICE_CONFIG_SSL_FLAG_LOG_EXTENDED_EVENTS = $00000200;
  HTTP_SERVICE_CONFIG_SSL_FLAG_DISABLE_LEGACY_TLS = $00000400;
  HTTP_SERVICE_CONFIG_SSL_FLAG_ENABLE_SESSION_TICKET = $00000800;
  HTTP_SERVICE_CONFIG_SSL_FLAG_DISABLE_TLS12 = $00001000;
  HTTP_SERVICE_CONFIG_SSL_FLAG_ENABLE_CLIENT_CORRELATION = $00002000;
  HTTP_SERVICE_CONFIG_SSL_FLAG_DISABLE_SESSION_ID = $00004000;
  HTTP_SERVICE_CONFIG_SSL_FLAG_ENABLE_CACHE_CLIENT_HELLO = $00008000;

//
// These data structures are used by HttpSetServiceConfiguration() to add a new
// record to the SSL bindings list.
//
// ConfigId                        | Structure
// --------------------------------+---------------------------------
// HttpServiceConfigSSLCertInfo    | HTTP_SERVICE_CONFIG_SSL_SET
// HttpServiceConfigSslSniCertInfo | HTTP_SERVICE_CONFIG_SSL_SNI_SET
// HttpServiceConfigSslCcsCertInfo | HTTP_SERVICE_CONFIG_SSL_CCS_SET
//

type
  HTTP_SERVICE_CONFIG_SSL_SET = record
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_KEY;
    ParamDesc: HTTP_SERVICE_CONFIG_SSL_PARAM;
  end;
  PHTTP_SERVICE_CONFIG_SSL_SET = ^HTTP_SERVICE_CONFIG_SSL_SET;

  HTTP_SERVICE_CONFIG_SSL_SNI_SET = record
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_SNI_KEY;
    ParamDesc: HTTP_SERVICE_CONFIG_SSL_PARAM;
  end;
  PHTTP_SERVICE_CONFIG_SSL_SNI_SET = ^HTTP_SERVICE_CONFIG_SSL_SNI_SET;

  HTTP_SERVICE_CONFIG_SSL_CCS_SET = record
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_CCS_KEY;
    ParamDesc: HTTP_SERVICE_CONFIG_SSL_PARAM;
  end;
  PHTTP_SERVICE_CONFIG_SSL_CCS_SET = ^HTTP_SERVICE_CONFIG_SSL_CCS_SET;

  HTTP_SERVICE_CONFIG_SSL_SET_EX = record
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_KEY_EX;
    ParamDesc: HTTP_SERVICE_CONFIG_SSL_PARAM_EX;
  end;
  PHTTP_SERVICE_CONFIG_SSL_SET_EX = ^HTTP_SERVICE_CONFIG_SSL_SET_EX;

  HTTP_SERVICE_CONFIG_SSL_SNI_SET_EX = record
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_SNI_KEY;
    ParamDesc: HTTP_SERVICE_CONFIG_SSL_PARAM_EX;
  end;
  PHTTP_SERVICE_CONFIG_SSL_SNI_SET_EX = ^HTTP_SERVICE_CONFIG_SSL_SNI_SET_EX;

  HTTP_SERVICE_CONFIG_SSL_CCS_SET_EX = record
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_CCS_KEY;
    ParamDesc: HTTP_SERVICE_CONFIG_SSL_PARAM_EX;
  end;
  PHTTP_SERVICE_CONFIG_SSL_CCS_SET_EX = ^HTTP_SERVICE_CONFIG_SSL_CCS_SET_EX;

//
// These data structures are used by HttpQueryServiceConfiguration() to query a
// particular record from the SSL store.
//
// ConfigId                        | Structure
// --------------------------------+---------------------------------
// HttpServiceConfigSSLCertInfo    | HTTP_SERVICE_CONFIG_SSL_QUERY
// HttpServiceConfigSSLSniCertInfo | HTTP_SERVICE_CONFIG_SSL_SNI_QUERY
// HttpServiceConfigSslCcsCertInfo | HTTP_SERVICE_CONFIG_SSL_CCS_QUERY
//
// If QueryDesc is HttpServiceConfigQueryExact, then the one particular record
// is returned. If the QueryType is HttpServiceConfigQueryNext, then the next
// instance is returned. In such cases, the dwToken field represents the cursor.
// To retrieve the first item, dwToken has to be 0. For retrieving subsequent
// items, dwToken has to be incremented by 1, until ERROR_NO_MORE_ITEMS is
// returned.
//

type
  HTTP_SERVICE_CONFIG_SSL_QUERY = record
    QueryDesc: HTTP_SERVICE_CONFIG_QUERY_TYPE;
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_KEY;
    dwToken: DWORD;
  end;
  PHTTP_SERVICE_CONFIG_SSL_QUERY = ^HTTP_SERVICE_CONFIG_SSL_QUERY;

  HTTP_SERVICE_CONFIG_SSL_SNI_QUERY = record
    QueryDesc: HTTP_SERVICE_CONFIG_QUERY_TYPE;
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_SNI_KEY;
    dwToken: DWORD;
  end;
  PHTTP_SERVICE_CONFIG_SSL_SNI_QUERY = ^HTTP_SERVICE_CONFIG_SSL_SNI_QUERY;

  HTTP_SERVICE_CONFIG_SSL_CCS_QUERY = record
    QueryDesc: HTTP_SERVICE_CONFIG_QUERY_TYPE;
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_CCS_KEY;
    dwToken: DWORD;
  end;
  PHTTP_SERVICE_CONFIG_SSL_CCS_QUERY = ^HTTP_SERVICE_CONFIG_SSL_CCS_QUERY;

  HTTP_SERVICE_CONFIG_SSL_QUERY_EX = record
    QueryDesc: HTTP_SERVICE_CONFIG_QUERY_TYPE;
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_KEY_EX;
    dwToken: DWORD;
    ParamType: HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE;
  end;
  PHTTP_SERVICE_CONFIG_SSL_QUERY_EX = ^HTTP_SERVICE_CONFIG_SSL_QUERY_EX;

  HTTP_SERVICE_CONFIG_SSL_SNI_QUERY_EX = record
    QueryDesc: HTTP_SERVICE_CONFIG_QUERY_TYPE;
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_SNI_KEY;
    dwToken: DWORD;
    ParamType: HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE;
  end;
  PHTTP_SERVICE_CONFIG_SSL_SNI_QUERY_EX = ^HTTP_SERVICE_CONFIG_SSL_SNI_QUERY_EX;

  HTTP_SERVICE_CONFIG_SSL_CCS_QUERY_EX = record
    QueryDesc: HTTP_SERVICE_CONFIG_QUERY_TYPE;
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_CCS_KEY;
    dwToken: DWORD;
    ParamType: HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE;
  end;
  PHTTP_SERVICE_CONFIG_SSL_CCS_QUERY_EX = ^HTTP_SERVICE_CONFIG_SSL_CCS_QUERY_EX;

//
// Set/Delete IP Listen-Only List record
//
// Used as a parameter to both HttpSetServiceConfiguration() and
// HttpDeleteServiceConfiguration() functions.
//

type
  HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM = record
    AddrLength: USHORT;
    pAddress: PSOCKADDR;
  end;
  PHTTP_SERVICE_CONFIG_IP_LISTEN_PARAM = ^HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM;

//
// Query IP Listen-Only List record.
//
// Parameter to HttpQueryServiceConfiguration() for the config ID
// HttpServiceConfigIPListenList.  On successful return, AddrList
// contains an array of AddrCount elements.  Caller must provide a
// large enough buffer to hold all elements in one call.
//
// Caller may determine the type of each returned element by examining
// AddrList[i].ss_family. If it's AF_INET, use ((PSOCKADDR_IN) &AddrList[i]);
// otherwise, for AF_INET6, use ((PSOCKADDR_IN6) &AddrList[i])
// to select the appropriate address type.
//

type
  HTTP_SERVICE_CONFIG_IP_LISTEN_QUERY = record
    AddrCount: ULONG;
    AddrList: array[0..ANYSIZE_ARRAY-1] of SOCKADDR_STORAGE;
  end;
  PHTTP_SERVICE_CONFIG_IP_LISTEN_QUERY = ^HTTP_SERVICE_CONFIG_IP_LISTEN_QUERY;

//
// URL ACL
//

type
  HTTP_SERVICE_CONFIG_URLACL_KEY = record
    pUrlPrefix: PWSTR;
  end;
  PHTTP_SERVICE_CONFIG_URLACL_KEY = ^HTTP_SERVICE_CONFIG_URLACL_KEY;

//
// This defines a record for the SSL config store.
//

type
  HTTP_SERVICE_CONFIG_URLACL_PARAM = record
    pStringSecurityDescriptor: PWSTR;
  end;
  PHTTP_SERVICE_CONFIG_URLACL_PARAM = ^HTTP_SERVICE_CONFIG_URLACL_PARAM;

//
// This data structure is used by HttpSetServiceConfiguration for the config ID
// HttpServiceConfigUrlAclInfo. It is used to add a new record to the URL ACL
// store.
//

type
  HTTP_SERVICE_CONFIG_URLACL_SET = record
    KeyDesc: HTTP_SERVICE_CONFIG_URLACL_KEY;
    ParamDesc: HTTP_SERVICE_CONFIG_URLACL_PARAM;
  end;
  PHTTP_SERVICE_CONFIG_URLACL_SET = ^HTTP_SERVICE_CONFIG_URLACL_SET;

//
// This data structure is used by HttpQueryServiceConfiguration() for the
// config ID HttpServiceConfigUrlAclInfo. It's used to query a particular
// record from the URL ACL store.
//
// If QueryType is HttpServiceConfigQueryExact, then one particular record of
// the type HTTP_SERVICE_CONFIG_URLACL_SET is returned. If the QueryType is
// HttpServiceConfigQueryNext, then the next instance of
// HTTP_SERVICE_CONFIG_URLACL_SET is returned. In such cases, the dwToken field
// represents the cursor. For the first item,  dwToken has to be 0.
// For subsequent items, dwToken has to be incremented by 1,
// until ERROR_NO_MORE_ITEMS is returned.
//

type
  HTTP_SERVICE_CONFIG_URLACL_QUERY = record
    QueryDesc: HTTP_SERVICE_CONFIG_QUERY_TYPE;
    KeyDesc: HTTP_SERVICE_CONFIG_URLACL_KEY;
    dwToken: DWORD;
  end;
  PHTTP_SERVICE_CONFIG_URLACL_QUERY = ^HTTP_SERVICE_CONFIG_URLACL_QUERY;

//
// Cache Paramemers
//

//
// For manipulating global cache parameters.
// The parameters that can be changed or queued are per-uri cache size
// and cached range chunk size.
//

type
  HTTP_SERVICE_CONFIG_CACHE_KEY = (
    MaxCacheResponseSize = 0,
    CacheRangeChunkSize);
  PHTTP_SERVICE_CONFIG_CACHE_KEY = ^HTTP_SERVICE_CONFIG_CACHE_KEY;

  HTTP_SERVICE_CONFIG_CACHE_PARAM = ULONG;
  PHTTP_SERVICE_CONFIG_CACHE_PARAM = ^HTTP_SERVICE_CONFIG_CACHE_PARAM;

//
// To set a cache parameter value use the set structure. To query use the key
// directly. When you query a parameter value the output buffer must be exactly
// the sizeof param.
//

type
  HTTP_SERVICE_CONFIG_CACHE_SET = record
    KeyDesc: HTTP_SERVICE_CONFIG_CACHE_KEY;
    ParamDesc: HTTP_SERVICE_CONFIG_CACHE_PARAM;
  end;
  PHTTP_SERVICE_CONFIG_CACHE_SET = ^HTTP_SERVICE_CONFIG_CACHE_SET;

//
// Input types for HttpQueryRequestProperty. Only types are public and not the API
// so that IIS need not have their own types for public usage.
//

type
  HTTP_REQUEST_PROPERTY = (
    HttpRequestPropertyIsb,
    HttpRequestPropertyTcpInfoV0,
    HttpRequestPropertyQuicStats,
    HttpRequestPropertyTcpInfoV1,
    HttpRequestPropertySni,
    HttpRequestPropertyStreamError,
    HttpRequestPropertyWskApiTimings,
    HttpRequestPropertyQuicApiTimings,
    HttpRequestPropertyQuicStatsV2,
    HttpRequestPropertyQuicStreamStats,
    HttpRequestPropertyTcpInfoV2,
    HttpRequestPropertyTlsClientHello,
    HttpRequestPropertyTransportIdleConnectionTimeout,
    HttpRequestPropertyDscpTag,
    HttpRequestPropertyTlsCipherInfo);
  PHTTP_REQUEST_PROPERTY = ^HTTP_REQUEST_PROPERTY;

  HTTP_QUERY_REQUEST_QUALIFIER_TCP = record
    Freshness: ULONGLONG;
  end;
  PHTTP_QUERY_REQUEST_QUALIFIER_TCP = ^HTTP_QUERY_REQUEST_QUALIFIER_TCP;

  HTTP_QUERY_REQUEST_QUALIFIER_QUIC = record
    Freshness: ULONGLONG;
  end;
  PHTTP_QUERY_REQUEST_QUALIFIER_QUIC = ^HTTP_QUERY_REQUEST_QUALIFIER_QUIC;

const
  HTTP_REQUEST_PROPERTY_SNI_HOST_MAX_LENGTH = 255;

//
// Flags inside HTTP_REQUEST_PROPERTY_SNI can have following values:
// - HTTP_REQUEST_PROPERTY_SNI_FLAG_SNI_USED: Indicates that SNI was used for succesful
//   endpoint lookup during handshake. If client sent the SNI but Http.sys still decided to
//   use IP endpoint binding then this flag will not be set.
// - HTTP_REQUEST_PROPERTY_SNI_FLAG_NO_SNI: Indicates that client did not send the SNI.
//   If this flag is set, HTTP_REQUEST_PROPERTY_SNI_FLAG_SNI_USED can not be set.
//

const
  HTTP_REQUEST_PROPERTY_SNI_FLAG_SNI_USED = $00000001;
  HTTP_REQUEST_PROPERTY_SNI_FLAG_NO_SNI = $00000002;

type
  HTTP_REQUEST_PROPERTY_SNI = record
    Hostname: array[0..HTTP_REQUEST_PROPERTY_SNI_HOST_MAX_LENGTH+1-1] of WCHAR;
    Flags: ULONG;
  end;
  PHTTP_REQUEST_PROPERTY_SNI = ^HTTP_REQUEST_PROPERTY_SNI;

  HTTP_REQUEST_PROPERTY_STREAM_ERROR = record
    ErrorCode: ULONG;
  end;
  PHTTP_REQUEST_PROPERTY_STREAM_ERROR = ^HTTP_REQUEST_PROPERTY_STREAM_ERROR;

  HTTP_WSK_API_TIMINGS = record
    ConnectCount: ULONGLONG;
    ConnectSum: ULONGLONG;
    DisconnectCount: ULONGLONG;
    DisconnectSum: ULONGLONG;
    SendCount: ULONGLONG;
    SendSum: ULONGLONG;
    ReceiveCount: ULONGLONG;
    ReceiveSum: ULONGLONG;
    ReleaseCount: ULONGLONG;
    ReleaseSum: ULONGLONG;
    ControlSocketCount: ULONGLONG;
    ControlSocketSum: ULONGLONG;
  end;
  PHTTP_WSK_API_TIMINGS = ^HTTP_WSK_API_TIMINGS;

  HTTP_QUIC_STREAM_API_TIMINGS = record
    OpenCount: ULONGLONG;
    OpenSum: ULONGLONG;
    CloseCount: ULONGLONG;
    CloseSum: ULONGLONG;
    StartCount: ULONGLONG;
    StartSum: ULONGLONG;
    ShutdownCount: ULONGLONG;
    ShutdownSum: ULONGLONG;
    SendCount: ULONGLONG;
    SendSum: ULONGLONG;
    ReceiveSetEnabledCount: ULONGLONG;
    ReceiveSetEnabledSum: ULONGLONG;
    GetParamCount: ULONGLONG;
    GetParamSum: ULONGLONG;
    SetParamCount: ULONGLONG;
    SetParamSum: ULONGLONG;
    SetCallbackHandlerCount: ULONGLONG;
    SetCallbackHandlerSum: ULONGLONG;
  end;
  PHTTP_QUIC_STREAM_API_TIMINGS = ^HTTP_QUIC_STREAM_API_TIMINGS;

  HTTP_QUIC_CONNECTION_API_TIMINGS = record
    OpenTime: ULONGLONG;
    CloseTime: ULONGLONG;
    StartTime: ULONGLONG;
    ShutdownTime: ULONGLONG;
    SecConfigCreateTime: ULONGLONG;
    SecConfigDeleteTime: ULONGLONG;
    GetParamCount: ULONGLONG;
    GetParamSum: ULONGLONG;
    SetParamCount: ULONGLONG;
    SetParamSum: ULONGLONG;
    SetCallbackHandlerCount: ULONGLONG;
    SetCallbackHandlerSum: ULONGLONG;
    ControlStreamTimings: HTTP_QUIC_STREAM_API_TIMINGS;
  end;
  PHTTP_QUIC_CONNECTION_API_TIMINGS = ^HTTP_QUIC_CONNECTION_API_TIMINGS;

  HTTP_QUIC_API_TIMINGS = record
    ConnectionTimings: HTTP_QUIC_CONNECTION_API_TIMINGS;
    StreamTimings: HTTP_QUIC_STREAM_API_TIMINGS;
  end;
  PHTTP_QUIC_API_TIMINGS = ^HTTP_QUIC_API_TIMINGS;

  HTTP_QUIC_STREAM_REQUEST_STATS = record
    StreamWaitStart: ULONGLONG;
    StreamWaitEnd: ULONGLONG;
    RequestHeadersCompressionStart: ULONGLONG;
    RequestHeadersCompressionEnd: ULONGLONG;
    ResponseHeadersDecompressionStart: ULONGLONG;
    ResponseHeadersDecompressionEnd: ULONGLONG;
    RequestHeadersCompressedSize: ULONGLONG;
    ResponseHeadersCompressedSize: ULONGLONG;
  end;
  PHTTP_QUIC_STREAM_REQUEST_STATS = ^HTTP_QUIC_STREAM_REQUEST_STATS;

const
  HTTP_QUIC_KEEPALIVE_TIMEOUT_DISABLED: ULONG = ULONG(-1);

type
  HTTP_FEATURE_ID = (
    HttpFeatureUnknown                              = 0,
    HttpFeatureResponseTrailers                     = 1,
    HttpFeatureApiTimings                           = 2,
    HttpFeatureDelegateEx                           = 3,
    HttpFeatureHttp3                                = 4,
    HttpFeatureTlsSessionTickets                    = 5,
    HttpFeatureDisableTlsSessionId                  = 6,
    HttpFeatureTlsDualCerts                         = 7,
    HttpFeatureAutomaticChunkedEncoding             = 8,
    HttpFeatureDedicatedReqQueueDelegationType      = 9,
    HttpFeatureFastForwardResponse                  = 10,
    HttpFeatureCacheTlsClientHello                  = 11,
    HttpFeatureIdleConnectionTimeoutRequestProperty = 12,
    HttpFeatureDisableAiaFlag                       = 13,
    HttpFeatureDscp                                 = 14,
    HttpFeatureQueryCipherInfo                      = 15,
    HttpFeatureQueryInitialPacketTtl                = 16,
    HttpFeatureLast                                 = 17,
    // Sentinel value (UINT32_MAX). Declared as -1 to fit Delphis signed enum.
    // When passing/comparing, cast to unsigned, e.g.:
    // Cardinal(Ord(HTTP_FEATURE_ID.HttpFeaturemax))
    HttpFeaturemax              = -1{ $FFFFFFFF });
  PHTTP_FEATURE_ID = ^HTTP_FEATURE_ID;

//
// Initialize/Terminate APIs.
//

const
  HTTPAPI_DLL = 'httpapi.dll';

// NOTE: MUST be called once before all other APIs

function HttpInitialize(
           Version: HTTPAPI_VERSION;
           Flags: ULONG;
           pReserved: PVOID): ULONG; stdcall; external HTTPAPI_DLL; // Reserved

// NOTE: MUST be called after final API call returns.

function HttpTerminate(
           Flags: ULONG;
           pReserved: PVOID): ULONG; stdcall; external HTTPAPI_DLL; // Reserved

//
// HTTP Request Queue manipulation APIs.
//
// This API is maintained for backward competibility for the first
// version of the HTTPAPI and should not be used. Instead the new
// HttpCreateRequestQueue() API must be used.
//
// Use CloseHandle() to release the handles returned by
// HttpCreateHttpHandle() API.
//

function HttpCreateHttpHandle(
           RequestQueueHandle: PHANDLE;
           Reserved: ULONG): ULONG; stdcall; external HTTPAPI_DLL; // Reserved

//
// Extended Request Queue manipulation APIs.
//
// Use HttpCloseRequestQueue() API to close the handles
// created by the HttpCreateRequestQueue API.
//

function HttpCreateRequestQueue(
           Version: HTTPAPI_VERSION;
           Name: PCWSTR; // OPTIONAL
           SecurityAttributes: PSECURITY_ATTRIBUTES; // OPTIONAL
           Flags: ULONG; // OPTIONAL
           RequestQueueHandle: PHANDLE): ULONG; stdcall; external HTTPAPI_DLL;

function HttpCloseRequestQueue(
           RequestQueueHandle: HANDLE): ULONG; stdcall; external HTTPAPI_DLL;

function HttpSetRequestQueueProperty(
           RequestQueueHandle: HANDLE;
           &Property: HTTP_SERVER_PROPERTY;
           PropertyInformation: PVOID;
           PropertyInformationLength: ULONG;
           Reserved1: ULONG; // Reserved
           Reserved2: PVOID): ULONG; stdcall; external HTTPAPI_DLL; // Reserved

function HttpQueryRequestQueueProperty(
           RequestQueueHandle: HANDLE;
           &Property: HTTP_SERVER_PROPERTY;
           PropertyInformation: PVOID; // OPTIONAL
           PropertyInformationLength: ULONG;
           Reserved1: ULONG; // Reserved
           ReturnLength: PULONG; // OPTIONAL
           Reserved2: PVOID): ULONG; stdcall; external HTTPAPI_DLL; // Reserved

function HttpSetRequestProperty(
           RequestQueueHandle: HANDLE;
           Id: HTTP_OPAQUE_ID;
           PropertyId: HTTP_REQUEST_PROPERTY;
           Input: PVOID; // OPTIONAL
           InputPropertySize: ULONG;
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external HTTPAPI_DLL;

function HttpQueryRequestProperty(
           RequestQueueHandle: HANDLE;
           Id: HTTP_OPAQUE_ID;
           PropertyId: HTTP_REQUEST_PROPERTY;
           Qualifier: PVOID; // OPTIONAL
           QualifierSize: ULONG;
           Output: PVOID; // OPTIONAL
           OutputBufferSize: ULONG;
           BytesReturned: PULONG; // OPTIONAL
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external HTTPAPI_DLL; // OPTIONAL

function HttpShutdownRequestQueue(
           RequestQueueHandle: HANDLE): ULONG; stdcall; external HTTPAPI_DLL;

//
// SSL APIs.
//

function HttpReceiveClientCertificate(
           RequestQueueHandle: HANDLE;
           ConnectionId: HTTP_CONNECTION_ID;
           Flags: ULONG;
           SslClientCertInfo: PHTTP_SSL_CLIENT_CERT_INFO;
           SslClientCertInfoSize: ULONG;
           BytesReceived: PULONG; // OPTIONAL
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external HTTPAPI_DLL; // OPTIONAL

//
// Server Session APIs.
//

function HttpCreateServerSession(
           Version: HTTPAPI_VERSION;
           ServerSessionId: PHTTP_SERVER_SESSION_ID;
           Reserved: ULONG): ULONG; stdcall; external HTTPAPI_DLL; // Reserved

function HttpCloseServerSession(
           ServerSessionId: HTTP_SERVER_SESSION_ID): ULONG; stdcall; external HTTPAPI_DLL;

// _Success_(return == NO_ERROR)
function HttpQueryServerSessionProperty(
           ServerSessionId: HTTP_SERVER_SESSION_ID;
           &Property: HTTP_SERVER_PROPERTY;
           PropertyInformation: PVOID; // OPTIONAL
           PropertyInformationLength: ULONG;
           ReturnLength: PULONG): ULONG; stdcall; external HTTPAPI_DLL; // OPTIONAL

function HttpSetServerSessionProperty(
           ServerSessionId: HTTP_SERVER_SESSION_ID;
           &Property: HTTP_SERVER_PROPERTY;
           PropertyInformation: PVOID;
           PropertyInformationLength: ULONG): ULONG; stdcall; external HTTPAPI_DLL;

//
// Url Configuration APIs. Can only be used for V1 request queues.
//

function HttpAddUrl(
           RequestQueueHandle: HANDLE;
           FullyQualifiedUrl: PCWSTR;
           Reserved: PVOID): ULONG; stdcall; external HTTPAPI_DLL; // Reserved

function HttpRemoveUrl(
           RequestQueueHandle: HANDLE;
           FullyQualifiedUrl: PCWSTR): ULONG; stdcall; external HTTPAPI_DLL;

//
// Url Group APIs.
//

function HttpCreateUrlGroup(
           ServerSessionId: HTTP_SERVER_SESSION_ID;
           pUrlGroupId: PHTTP_URL_GROUP_ID;
           Reserved: ULONG): ULONG; stdcall; external HTTPAPI_DLL; // Reserved

function HttpCloseUrlGroup(
           UrlGroupId: HTTP_URL_GROUP_ID): ULONG; stdcall; external HTTPAPI_DLL;

function HttpAddUrlToUrlGroup(
           UrlGroupId: HTTP_URL_GROUP_ID;
           pFullyQualifiedUrl: PCWSTR;
           UrlContext: HTTP_URL_CONTEXT; // OPTIONAL
           Reserved: ULONG): ULONG; stdcall; external HTTPAPI_DLL; // Reserved

function HttpRemoveUrlFromUrlGroup(
           UrlGroupId: HTTP_URL_GROUP_ID;
           pFullyQualifiedUrl: PCWSTR;
           Flags: ULONG): ULONG; stdcall; external HTTPAPI_DLL;

function HttpSetUrlGroupProperty(
           UrlGroupId: HTTP_URL_GROUP_ID;
           &Property: HTTP_SERVER_PROPERTY;
           PropertyInformation: PVOID;
           PropertyInformationLength: ULONG): ULONG; stdcall; external HTTPAPI_DLL;

function HttpQueryUrlGroupProperty(
           UrlGroupId: HTTP_URL_GROUP_ID;
           &Property: HTTP_SERVER_PROPERTY;
           PropertyInformation: PVOID; // OPTIONAL
           PropertyInformationLength: ULONG;
           ReturnLength: PULONG): ULONG; stdcall; external HTTPAPI_DLL; // OPTIONAL

function HttpPrepareUrl(
           Reserved: PVOID; // Reserved
           Flags: ULONG; // Reserved
           Url: PCWSTR;
           out PreparedUrl: PWSTR): ULONG; stdcall; external HTTPAPI_DLL;

//
// HTTP Server I/O APIs.
//

function HttpReceiveHttpRequest(
           RequestQueueHandle: HANDLE;
           RequestId: HTTP_REQUEST_ID;
           Flags: ULONG;
           RequestBuffer: PHTTP_REQUEST;
           RequestBufferLength: ULONG;
           BytesReturned: PULONG; // OPTIONAL
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external HTTPAPI_DLL; // OPTIONAL

function HttpReceiveRequestEntityBody(
           RequestQueueHandle: HANDLE;
           RequestId: HTTP_REQUEST_ID;
           Flags: ULONG;
           EntityBuffer: PVOID;
           EntityBufferLength: ULONG;
           BytesReturned: PULONG; // OPTIONAL
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external HTTPAPI_DLL; // OPTIONAL

function HttpSendHttpResponse(
           RequestQueueHandle: HANDLE;
           RequestId: HTTP_REQUEST_ID;
           Flags: ULONG;
           HttpResponse: PHTTP_RESPONSE;
           CachePolicy: PHTTP_CACHE_POLICY; // OPTIONAL
           BytesSent: PULONG; // OPTIONAL
           Reserved1: PVOID; // Reserved
           Reserved2: ULONG; // Reserved
           Overlapped: LPOVERLAPPED; // OPTIONAL
           LogData: PHTTP_LOG_DATA): ULONG; stdcall; external HTTPAPI_DLL; // OPTIONAL

function HttpSendResponseEntityBody(
           RequestQueueHandle: HANDLE;
           RequestId: HTTP_REQUEST_ID;
           Flags: ULONG;
           EntityChunkCount: USHORT; // OPTIONAL
           EntityChunks: PHTTP_DATA_CHUNK; // OPTIONAL
           BytesSent: PULONG; // OPTIONAL
           Reserved1: PVOID; // OPTIONAL, - Reserved
           Reserved2: ULONG; // OPTIONAL, - Reserved
           Overlapped: LPOVERLAPPED; // OPTIONAL
           LogData: PHTTP_LOG_DATA): ULONG; stdcall; external HTTPAPI_DLL; // OPTIONAL

function HttpDeclarePush(
           RequestQueueHandle: HANDLE;
           RequestId: HTTP_REQUEST_ID;
           Verb: HTTP_VERB;
           Path: PCWSTR;
           Query: PCSTR; // OPTIONAL
           Headers: PHTTP_REQUEST_HEADERS): ULONG; stdcall; external HTTPAPI_DLL; // OPTIONAL

function HttpWaitForDisconnect(
           RequestQueueHandle: HANDLE;
           ConnectionId: HTTP_CONNECTION_ID;
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external HTTPAPI_DLL; // OPTIONAL

function HttpWaitForDisconnectEx(
           RequestQueueHandle: HANDLE;
           ConnectionId: HTTP_CONNECTION_ID;
           Reserved: ULONG; // OPTIONAL, - Reserved
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external HTTPAPI_DLL; // OPTIONAL

function HttpCancelHttpRequest(
           RequestQueueHandle: HANDLE;
           RequestId: HTTP_REQUEST_ID;
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external HTTPAPI_DLL; // OPTIONAL

function HttpWaitForDemandStart(
           RequestQueueHandle: HANDLE;
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external HTTPAPI_DLL; // OPTIONAL
function HttpIsFeatureSupported(
           FeatureId: HTTP_FEATURE_ID): BOOL; stdcall; external HTTPAPI_DLL;

function HttpDelegateRequestEx(
           RequestQueueHandle: HANDLE;
           DelegateQueueHandle: HANDLE;
           RequestId: HTTP_REQUEST_ID;
           DelegateUrlGroupId: HTTP_URL_GROUP_ID;
           PropertyInfoSetSize: ULONG;
           PropertyInfoSet: PHTTP_DELEGATE_REQUEST_PROPERTY_INFO): ULONG; stdcall; external HTTPAPI_DLL;

function HttpFindUrlGroupId(
           FullyQualifiedUrl: PCWSTR;
           RequestQueueHandle: HANDLE;
           UrlGroupId: PHTTP_URL_GROUP_ID): ULONG; stdcall; external HTTPAPI_DLL;

//
// Cache manipulation APIs.
//

function HttpFlushResponseCache(
           RequestQueueHandle: HANDLE;
           UrlPrefix: PCWSTR;
           Flags: ULONG;
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external HTTPAPI_DLL; // OPTIONAL

function HttpAddFragmentToCache(
           RequestQueueHandle: HANDLE;
           UrlPrefix: PCWSTR;
           DataChunk: PHTTP_DATA_CHUNK;
           CachePolicy: PHTTP_CACHE_POLICY;
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external HTTPAPI_DLL; // OPTIONAL

function HttpReadFragmentFromCache(
           RequestQueueHandle: HANDLE;
           UrlPrefix: PCWSTR;
           ByteRange: PHTTP_BYTE_RANGE; // OPTIONAL
           Buffer: PVOID;
           BufferLength: ULONG;
           BytesRead: PULONG; // OPTIONAL
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external HTTPAPI_DLL; // OPTIONAL

//
// Server configuration APIs
//

function HttpSetServiceConfiguration(
           ServiceHandle: HANDLE; // Reserved
           ConfigId: HTTP_SERVICE_CONFIG_ID;
           pConfigInformation: PVOID;
           ConfigInformationLength: ULONG;
           pOverlapped: LPOVERLAPPED): ULONG; stdcall; external HTTPAPI_DLL; // Reserved

function HttpUpdateServiceConfiguration(
           Handle: HANDLE; // Reserved
           ConfigId: HTTP_SERVICE_CONFIG_ID;
           ConfigInfo: PVOID;
           ConfigInfoLength: ULONG;
           Overlapped: LPOVERLAPPED): ULONG; stdcall; external HTTPAPI_DLL; // Reserved

function HttpDeleteServiceConfiguration(
           ServiceHandle: HANDLE; // Reserved
           ConfigId: HTTP_SERVICE_CONFIG_ID;
           pConfigInformation: PVOID;
           ConfigInformationLength: ULONG;
           pOverlapped: LPOVERLAPPED): ULONG; stdcall; external HTTPAPI_DLL; // Reserved

function HttpQueryServiceConfiguration(
           ServiceHandle: HANDLE; // Reserved
           ConfigId: HTTP_SERVICE_CONFIG_ID;
           pInput: PVOID; // OPTIONAL
           InputLength: ULONG;
           pOutput: PVOID; // OPTIONAL
           OutputLength: ULONG;
           pReturnLength: PULONG; // OPTIONAL
           pOverlapped: LPOVERLAPPED): ULONG; stdcall; external HTTPAPI_DLL; // Reserved

function HttpGetExtension(
           Version: HTTPAPI_VERSION;
           Extension: ULONG;
           Buffer: PVOID;
           BufferSize: ULONG): ULONG; stdcall; external HTTPAPI_DLL;

implementation

end.
unit Alcinoe.WinApi.SChannel;

//*******************************************************************//
// This unit was automatically generated by CHeaderWrapperGenerator. //
// Do not edit manually.                                             //
//*******************************************************************//

interface

{$I Alcinoe.inc}

{$SCOPEDENUMS OFF}
{$MINENUMSIZE 4}
{$A+}

uses
  WinApi.Windows,
  Alcinoe.WinApi.SSPI,
  Alcinoe.WinApi.Windows;

type
  ALG_ID = UINT;
  PALG_ID = ^ALG_ID;
  PPCCERT_CONTEXT = ^PCCERT_CONTEXT;
  HCRYPTPROV = ULONG_PTR;

// #define __SCHANNEL_H__

//
// Security package names.
//

const UNISP_NAME_A = 'Microsoft Unified Security Protocol Provider';
const UNISP_NAME_W = 'Microsoft Unified Security Protocol Provider';

const SSL2SP_NAME_A = 'Microsoft SSL 2.0';
const SSL2SP_NAME_W = 'Microsoft SSL 2.0';

const SSL3SP_NAME_A = 'Microsoft SSL 3.0';
const SSL3SP_NAME_W = 'Microsoft SSL 3.0';

const TLS1SP_NAME_A = 'Microsoft TLS 1.0';
const TLS1SP_NAME_W = 'Microsoft TLS 1.0';

const PCT1SP_NAME_A = 'Microsoft PCT 1.0';
const PCT1SP_NAME_W = 'Microsoft PCT 1.0';

const SCHANNEL_NAME_A = 'Schannel';
const SCHANNEL_NAME_W = 'Schannel';

const DEFAULT_TLS_SSP_NAME_A = 'Default TLS SSP';
const DEFAULT_TLS_SSP_NAME_W = 'Default TLS SSP';

const UNISP_NAME = UNISP_NAME_W;
const PCT1SP_NAME = PCT1SP_NAME_W;
const SSL2SP_NAME = SSL2SP_NAME_W;
const SSL3SP_NAME = SSL3SP_NAME_W;
const TLS1SP_NAME = TLS1SP_NAME_W;
const SCHANNEL_NAME = SCHANNEL_NAME_W;
const DEFAULT_TLS_SSP_NAME = DEFAULT_TLS_SSP_NAME_W;

type
  _eTlsSignatureAlgorithm = (
    TlsSignatureAlgorithm_Anonymous = 0,
    TlsSignatureAlgorithm_Rsa = 1,
    TlsSignatureAlgorithm_Dsa = 2,
    TlsSignatureAlgorithm_Ecdsa = 3);
  eTlsSignatureAlgorithm = _eTlsSignatureAlgorithm;

type
  _eTlsHashAlgorithm = (
    TlsHashAlgorithm_None = 0,
    TlsHashAlgorithm_Md5 = 1,
    TlsHashAlgorithm_Sha1 = 2,
    TlsHashAlgorithm_Sha224 = 3,
    TlsHashAlgorithm_Sha256 = 4,
    TlsHashAlgorithm_Sha384 = 5,
    TlsHashAlgorithm_Sha512 = 6);
  eTlsHashAlgorithm = _eTlsHashAlgorithm;

//
// RPC constants.
//

const UNISP_RPC_ID = 14;

// OBSOLETE - included here for backward compatibility only
type
  _SecPkgContext_RemoteCredentialInfo = record
    cbCertificateChain: DWORD;
    pbCertificateChain: PBYTE;
    cCertificates: DWORD;
    fFlags: DWORD;
    dwBits: DWORD;
  end;
  SecPkgContext_RemoteCredentialInfo = _SecPkgContext_RemoteCredentialInfo;
  PSecPkgContext_RemoteCredentialInfo = ^_SecPkgContext_RemoteCredentialInfo;

type SecPkgContext_RemoteCredenitalInfo = SecPkgContext_RemoteCredentialInfo;
type PSecPkgContext_RemoteCredenitalInfo = ^SecPkgContext_RemoteCredentialInfo;

const RCRED_STATUS_NOCRED = $00000000;
const RCRED_CRED_EXISTS = $00000001;
const RCRED_STATUS_UNKNOWN_ISSUER = $00000002;

// OBSOLETE - included here for backward compatibility only
type
  _SecPkgContext_LocalCredentialInfo = record
    cbCertificateChain: DWORD;
    pbCertificateChain: PBYTE;
    cCertificates: DWORD;
    fFlags: DWORD;
    dwBits: DWORD;
  end;
  SecPkgContext_LocalCredentialInfo = _SecPkgContext_LocalCredentialInfo;
  PSecPkgContext_LocalCredentialInfo = ^_SecPkgContext_LocalCredentialInfo;

type SecPkgContext_LocalCredenitalInfo = SecPkgContext_LocalCredentialInfo;
type PSecPkgContext_LocalCredenitalInfo = ^SecPkgContext_LocalCredentialInfo;

const LCRED_STATUS_NOCRED = $00000000;
const LCRED_CRED_EXISTS = $00000001;
const LCRED_STATUS_UNKNOWN_ISSUER = $00000002;

type
  _SecPkgContext_ClientCertPolicyResult = record
    dwPolicyResult: HRESULT;
    guidPolicyId: GUID;
  end;
  SecPkgContext_ClientCertPolicyResult = _SecPkgContext_ClientCertPolicyResult;
  PSecPkgContext_ClientCertPolicyResult = ^_SecPkgContext_ClientCertPolicyResult;

type
  _SecPkgContext_IssuerListInfoEx = record
    aIssuers: PCERT_NAME_BLOB;
    cIssuers: DWORD;
  end;
  SecPkgContext_IssuerListInfoEx = _SecPkgContext_IssuerListInfoEx;
  PSecPkgContext_IssuerListInfoEx = ^_SecPkgContext_IssuerListInfoEx;

type
  _SecPkgContext_ConnectionInfo = record
    dwProtocol: DWORD;
    aiCipher: ALG_ID;
    dwCipherStrength: DWORD;
    aiHash: ALG_ID;
    dwHashStrength: DWORD;
    aiExch: ALG_ID;
    dwExchStrength: DWORD;
  end;
  SecPkgContext_ConnectionInfo = _SecPkgContext_ConnectionInfo;
  PSecPkgContext_ConnectionInfo = ^_SecPkgContext_ConnectionInfo;

const SZ_ALG_MAX_SIZE = 64;

const SECPKGCONTEXT_CONNECTION_INFO_EX_V1 = 1;

type
  _SecPkgContext_ConnectionInfoEx = record
    dwVersion: DWORD;
    dwProtocol: DWORD;
    szCipher: array[0..SZ_ALG_MAX_SIZE-1] of WCHAR;
    dwCipherStrength: DWORD;
    szHash: array[0..SZ_ALG_MAX_SIZE-1] of WCHAR;
    dwHashStrength: DWORD;
    szExchange: array[0..SZ_ALG_MAX_SIZE-1] of WCHAR;
    dwExchStrength: DWORD;
  end;
  SecPkgContext_ConnectionInfoEx = _SecPkgContext_ConnectionInfoEx;
  PSecPkgContext_ConnectionInfoEx = ^_SecPkgContext_ConnectionInfoEx;

const SECPKGCONTEXT_CIPHERINFO_V1 = 1;

type
  _SecPkgContext_CipherInfo = record
    dwVersion: DWORD;
    dwProtocol: DWORD;
    dwCipherSuite: DWORD;
    dwBaseCipherSuite: DWORD;
    szCipherSuite: array[0..SZ_ALG_MAX_SIZE-1] of WCHAR;
    szCipher: array[0..SZ_ALG_MAX_SIZE-1] of WCHAR;
    dwCipherLen: DWORD;
    dwCipherBlockLen: DWORD; // in bytes
    szHash: array[0..SZ_ALG_MAX_SIZE-1] of WCHAR;
    dwHashLen: DWORD;
    szExchange: array[0..SZ_ALG_MAX_SIZE-1] of WCHAR;
    dwMinExchangeLen: DWORD;
    dwMaxExchangeLen: DWORD;
    szCertificate: array[0..SZ_ALG_MAX_SIZE-1] of WCHAR;
    dwKeyType: DWORD;
  end;
  SecPkgContext_CipherInfo = _SecPkgContext_CipherInfo;
  PSecPkgContext_CipherInfo = ^_SecPkgContext_CipherInfo;

type
  _SecPkgContext_EapKeyBlock = record
    rgbKeys: array[0..128-1] of BYTE;
    rgbIVs: array[0..64-1] of BYTE;
  end;
  SecPkgContext_EapKeyBlock = _SecPkgContext_EapKeyBlock;
  PSecPkgContext_EapKeyBlock = ^_SecPkgContext_EapKeyBlock;

type
  _SecPkgContext_MappedCredAttr = record
    dwAttribute: DWORD;
    pvBuffer: PVOID;
  end;
  SecPkgContext_MappedCredAttr = _SecPkgContext_MappedCredAttr;
  PSecPkgContext_MappedCredAttr = ^_SecPkgContext_MappedCredAttr;

// Flag values for SecPkgContext_SessionInfo
const SSL_SESSION_RECONNECT = 1;

type
  _SecPkgContext_SessionInfo = record
    dwFlags: DWORD;
    cbSessionId: DWORD;
    rgbSessionId: array[0..32-1] of BYTE;
  end;
  SecPkgContext_SessionInfo = _SecPkgContext_SessionInfo;
  PSecPkgContext_SessionInfo = ^_SecPkgContext_SessionInfo;

type
  _SecPkgContext_SessionAppData = record
    dwFlags: DWORD;
    cbAppData: DWORD;
    pbAppData: PBYTE;
  end;
  SecPkgContext_SessionAppData = _SecPkgContext_SessionAppData;
  PSecPkgContext_SessionAppData = ^_SecPkgContext_SessionAppData;

type
  _SecPkgContext_EapPrfInfo = record
    dwVersion: DWORD;
    cbPrfData: DWORD;
    pbPrfData: PBYTE;
  end;
  SecPkgContext_EapPrfInfo = _SecPkgContext_EapPrfInfo;
  PSecPkgContext_EapPrfInfo = ^_SecPkgContext_EapPrfInfo;

type
  _SecPkgContext_SupportedSignatures = record
    cSignatureAndHashAlgorithms: WORD;
    // Upper byte (from TLS 1.2, RFC 4346):
    // enum {
    // anonymous(0), rsa(1), dsa(2), ecdsa(3), (255)
    // } SignatureAlgorithm;
    // enum eTlsSignatureAlgorithm
    // Lower byte (from TLS 1.2, RFC 4346):
    // enum {
    // none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),
    // sha512(6), (255)
    // } HashAlgorithm;
    // enum eTlsHashAlgorithm
    pSignatureAndHashAlgorithms: PWORD;
  end;
  SecPkgContext_SupportedSignatures = _SecPkgContext_SupportedSignatures;
  PSecPkgContext_SupportedSignatures = ^_SecPkgContext_SupportedSignatures;

//
// This property returns the raw binary certificates that were received
// from the remote party. The format of the buffer that's returned is as
// follows.
//
// <4 bytes> length of certificate #1
// <n bytes> certificate #1
// <4 bytes> length of certificate #2
// <n bytes> certificate #2
// ...
//
// After this data is processed, the caller of QueryContextAttributes
// must free the pbCertificateChain buffer using FreeContextBuffer.
//
type
  _SecPkgContext_Certificates = record
    cCertificates: DWORD;
    cbCertificateChain: DWORD;
    pbCertificateChain: PBYTE;
  end;
  SecPkgContext_Certificates = _SecPkgContext_Certificates;
  PSecPkgContext_Certificates = ^_SecPkgContext_Certificates;

//
// This property returns information about a certificate. In particular
// it is useful (and only available) in the kernel where CAPI2 is not
// available.
//
type
  _SecPkgContext_CertInfo = record
    dwVersion: DWORD;
    cbSubjectName: DWORD;
    pwszSubjectName: LPWSTR;
    cbIssuerName: DWORD;
    pwszIssuerName: LPWSTR;
    dwKeySize: DWORD;
  end;
  SecPkgContext_CertInfo = _SecPkgContext_CertInfo;
  PSecPkgContext_CertInfo = ^_SecPkgContext_CertInfo;

const KERN_CONTEXT_CERT_INFO_V1 = $00000000;

type
  _SecPkgContext_UiInfo = record
    hParentWindow: HWND;
  end;
  SecPkgContext_UiInfo = _SecPkgContext_UiInfo;
  PSecPkgContext_UiInfo = ^_SecPkgContext_UiInfo;

type
  _SecPkgContext_EarlyStart = record
    dwEarlyStartFlags: DWORD;
  end;
  SecPkgContext_EarlyStart = _SecPkgContext_EarlyStart;
  PSecPkgContext_EarlyStart = ^_SecPkgContext_EarlyStart;

// Flag values for SecPkgContext_EarlyStart
const ENABLE_TLS_CLIENT_EARLY_START = $00000001;

type
  _SecPkgContext_KeyingMaterialInfo = record
    cbLabel: WORD; // Disambiguating ASCII label length, in bytes, greater than 0.
    pszLabel: LPSTR; // Disambiguating ASCII label, NUL terminator will be removed by schannel.
    cbContextValue: WORD; // Application context value length, in bytes, can be 0.
    pbContextValue: PBYTE; // Application context value, NULL if cbContextValue == 0.
    cbKeyingMaterial: DWORD; // Requested keying material length, in bytes, greater than 0.
  end;
  SecPkgContext_KeyingMaterialInfo = _SecPkgContext_KeyingMaterialInfo;
  PSecPkgContext_KeyingMaterialInfo = ^_SecPkgContext_KeyingMaterialInfo;

type
  _SecPkgContext_KeyingMaterial = record
    cbKeyingMaterial: DWORD; // Exported keying material length, in bytes.
    pbKeyingMaterial: PBYTE; // Exported keying material.
  end;
  SecPkgContext_KeyingMaterial = _SecPkgContext_KeyingMaterial;
  PSecPkgContext_KeyingMaterial = ^_SecPkgContext_KeyingMaterial;

type
  _SecPkgContext_KeyingMaterial_Inproc = record
    cbLabel: WORD; // Disambiguating ASCII label length, in bytes, greater than 0.
    pszLabel: LPSTR; // Disambiguating ASCII label, NUL terminator will be removed by schannel.
    cbContextValue: WORD; // Application context value length, in bytes, can be 0.
    pbContextValue: PBYTE; // Application context value, NULL if cbContextValue == 0.
    cbKeyingMaterial: DWORD; // Requested keying material length, in bytes, greater than 0.
    pbKeyingMaterial: PBYTE; // Exported keying material.
  end;
  SecPkgContext_KeyingMaterial_Inproc = _SecPkgContext_KeyingMaterial_Inproc;
  PSecPkgContext_KeyingMaterial_Inproc = ^_SecPkgContext_KeyingMaterial_Inproc;

type
  _SecPkgContext_SrtpParameters = record
    ProtectionProfile: WORD; // Negotiated SRTP protection profile (0x0000 means no profile negotiated).
    MasterKeyIdentifierSize: BYTE; // Size in bytes of the SRTP master key identifier.
    MasterKeyIdentifier: PBYTE; // Negotiated SRTP master key identifier.
  end;
  SecPkgContext_SrtpParameters = _SecPkgContext_SrtpParameters;
  PSecPkgContext_SrtpParameters = ^_SecPkgContext_SrtpParameters;

type
  _SecPkgContext_TokenBinding = record
    MajorVersion: BYTE; // Negotiated major version of the Token Binding protocol.
    MinorVersion: BYTE; // Negotiated minor version of the Token Binding protocol.
    KeyParametersSize: WORD; // Size in bytes of the KeyParameters array.
    KeyParameters: PBYTE; // IDs of the negotiated Token Binding key parameters.
  end;
  SecPkgContext_TokenBinding = _SecPkgContext_TokenBinding;
  PSecPkgContext_TokenBinding = ^_SecPkgContext_TokenBinding;

type
  _SecPkgContext_CertificateValidationResult = record
    dwChainErrorStatus: DWORD; // Contains chain build error flags set by CertGetCertificateChain.
    hrVerifyChainStatus: HRESULT; // Certificate validation policy error returned by CertVerifyCertificateChainPolicy.
  end;
  SecPkgContext_CertificateValidationResult = _SecPkgContext_CertificateValidationResult;
  PSecPkgContext_CertificateValidationResult = ^_SecPkgContext_CertificateValidationResult;

//
// Schannel credentials data structure.
//

const SCH_CRED_V1 = $00000001;
const SCH_CRED_V2 = $00000002; // for legacy code
const SCH_CRED_VERSION = $00000002; // for legacy code
const SCH_CRED_V3 = $00000003; // for legacy code
const SCHANNEL_CRED_VERSION = $00000004; // for legacy code
const SCH_CREDENTIALS_VERSION = $00000005;

type
  _HMAPPER = record
  end;
  P_HMAPPER = ^_HMAPPER;
  PP_HMAPPER = ^P_HMAPPER;

type
  _SCHANNEL_CRED = record
    dwVersion: DWORD; // always SCHANNEL_CRED_VERSION
    cCreds: DWORD;
    paCred: PPCCERT_CONTEXT;
    hRootStore: HCERTSTORE;
    cMappers: DWORD;
    aphMappers: PP_HMAPPER;
    cSupportedAlgs: DWORD;
    palgSupportedAlgs: PALG_ID;
    grbitEnabledProtocols: DWORD;
    dwMinimumCipherStrength: DWORD;
    dwMaximumCipherStrength: DWORD;
    dwSessionLifespan: DWORD;
    dwFlags: DWORD;
    dwCredFormat: DWORD;
  end;
  SCHANNEL_CRED = _SCHANNEL_CRED;
  PSCHANNEL_CRED = ^_SCHANNEL_CRED;

// Note, if you #define SCHANNEL_USE_BLACKLISTS
// then you must define UNICODE_STRING and PUNICODE_STRING
// or include Ntdef.h, SubAuth.h or Winternl.h.

// These values distinguish between the different RSA padding modes and can
// be specified in the CRYPTO_SETTINGS strCngAlgId field, in addition to the
// CNG algorithm identifiers.
const SCHANNEL_RSA_PSS_PADDING_ALGORITHM = 'SCH_RSA_PSS_PAD';
const SCHANNEL_RSA_PKCS_PADDING_ALGORITHM = 'SCH_RSA_PKCS_PAD';

type
  _eTlsAlgorithmUsage = (
    TlsParametersCngAlgUsageKeyExchange, // Key exchange algorithm. RSA, ECHDE, DHE, etc.
    TlsParametersCngAlgUsageSignature, // Signature algorithm. RSA, DSA, ECDSA, etc.
    TlsParametersCngAlgUsageCipher, // Encryption algorithm. AES, DES, RC4, etc.
    TlsParametersCngAlgUsageDigest, // Digest of cipher suite. SHA1, SHA256, SHA384, etc.
    TlsParametersCngAlgUsageCertSig); // Signature, hash and/or padding mode components of a TLS signature suite. RSA, DSA, ECDSA, SHA1, SHA256, PSS, etc.
  eTlsAlgorithmUsage = _eTlsAlgorithmUsage;

//
// SCH_CREDENTIALS structures
//
type
  _CRYPTO_SETTINGS = record
    eAlgorithmUsage: eTlsAlgorithmUsage; // How this algorithm is being used.
    strCngAlgId: UNICODE_STRING; // CNG algorithm identifier.
    cChainingModes: DWORD; // Set to 0 if CNG algorithm does not have a chaining mode.
    rgstrChainingModes: PUNICODE_STRING; // Set to NULL if CNG algorithm does not have a chaining mode.
    dwMinBitLength: DWORD; // Blacklist key sizes less than this. Set to 0 if not defined or CNG algorithm implies bit length.
    dwMaxBitLength: DWORD; // Blacklist key sizes greater than this. Set to 0 if not defined or CNG algorithm implies bit length.
  end;
  CRYPTO_SETTINGS = _CRYPTO_SETTINGS;
  PCRYPTO_SETTINGS = ^_CRYPTO_SETTINGS;

type
  _TLS_PARAMETERS = record
    cAlpnIds: DWORD; // Valid for server applications only. Must be zero otherwise. Number of ALPN IDs in rgstrAlpnIds; set to 0 if applies to all.
    rgstrAlpnIds: PUNICODE_STRING; // Valid for server applications only. Must be NULL otherwise. Array of ALPN IDs that the following settings apply to; set to NULL if applies to all.
    grbitDisabledProtocols: DWORD; // List protocols you DO NOT want negotiated.
    cDisabledCrypto: DWORD; // Number of CRYPTO_SETTINGS structures; set to 0 if there are none.
    pDisabledCrypto: PCRYPTO_SETTINGS; // Array of CRYPTO_SETTINGS structures; set to NULL if there are none;
    dwFlags: DWORD; // Optional flags to pass; set to 0 if there are none.
  end;
  TLS_PARAMETERS = _TLS_PARAMETERS;
  PTLS_PARAMETERS = ^_TLS_PARAMETERS;

const TLS_PARAMS_OPTIONAL = $00000001; // Valid for server applications only. Must be zero otherwise.
// TLS_PARAMETERS that will only be honored if they do not cause this server to terminate the handshake.

type
  _SCH_CREDENTIALS = record
    dwVersion: DWORD; // Always SCH_CREDENTIALS_VERSION.
    dwCredFormat: DWORD;
    cCreds: DWORD;
    paCred: PPCCERT_CONTEXT;
    hRootStore: HCERTSTORE;
    cMappers: DWORD;
    aphMappers: PP_HMAPPER;
    dwSessionLifespan: DWORD;
    dwFlags: DWORD;
    cTlsParameters: DWORD;
    pTlsParameters: PTLS_PARAMETERS;
  end;
  SCH_CREDENTIALS = _SCH_CREDENTIALS;
  PSCH_CREDENTIALS = ^_SCH_CREDENTIALS;

const SCH_CRED_MAX_SUPPORTED_PARAMETERS = 16;
const SCH_CRED_MAX_SUPPORTED_ALPN_IDS = 16;
const SCH_CRED_MAX_SUPPORTED_CRYPTO_SETTINGS = 16;
const SCH_CRED_MAX_SUPPORTED_CHAINING_MODES = 16;

type
  _SEND_GENERIC_TLS_EXTENSION = record
    ExtensionType: WORD; // Code point of extension.
    HandshakeType: WORD; // Message type used to transport extension.
    Flags: DWORD; // Flags used to modify behavior. Must be zero.
    BufferSize: WORD; // Size in bytes of the extension data.
    Buffer: array[0..ANYSIZE_ARRAY-1] of UCHAR; // Extension data.
  end;
  SEND_GENERIC_TLS_EXTENSION = _SEND_GENERIC_TLS_EXTENSION;
  PSEND_GENERIC_TLS_EXTENSION = ^_SEND_GENERIC_TLS_EXTENSION;

type
  _TLS_EXTENSION_SUBSCRIPTION = record
    ExtensionType: WORD; // Code point of extension.
    HandshakeType: WORD; // Message type used to transport extension.
  end;
  TLS_EXTENSION_SUBSCRIPTION = _TLS_EXTENSION_SUBSCRIPTION;
  PTLS_EXTENSION_SUBSCRIPTION = ^_TLS_EXTENSION_SUBSCRIPTION;

type
  _SUBSCRIBE_GENERIC_TLS_EXTENSION = record
    Flags: DWORD; // Flags used to modify behavior. Must be zero.
    SubscriptionsCount: DWORD; // Number of elements in the Subscriptions array.
    Subscriptions: array[0..ANYSIZE_ARRAY-1] of TLS_EXTENSION_SUBSCRIPTION; // Array of TLS_EXTENSION_SUBSCRIPTION structures.
  end;
  SUBSCRIBE_GENERIC_TLS_EXTENSION = _SUBSCRIBE_GENERIC_TLS_EXTENSION;
  PSUBSCRIBE_GENERIC_TLS_EXTENSION = ^_SUBSCRIBE_GENERIC_TLS_EXTENSION;

// Maximum number of TLS_EXTENSION_SUBSCRIPTION structures allowed.
const SCH_MAX_EXT_SUBSCRIPTIONS = 2;

// Values for SCHANNEL_CRED dwCredFormat field.
const SCH_CRED_FORMAT_CERT_CONTEXT = $00000000;
const SCH_CRED_FORMAT_CERT_HASH = $00000001;
const SCH_CRED_FORMAT_CERT_HASH_STORE = $00000002;

const SCH_CRED_MAX_STORE_NAME_SIZE = 128;
const SCH_CRED_MAX_SUPPORTED_ALGS = 256;
const SCH_CRED_MAX_SUPPORTED_CERTS = 100;

type
  _SCHANNEL_CERT_HASH = record
    dwLength: DWORD;
    dwFlags: DWORD;
    hProv: HCRYPTPROV;
    ShaHash: array[0..20-1] of BYTE;
  end;
  SCHANNEL_CERT_HASH = _SCHANNEL_CERT_HASH;
  PSCHANNEL_CERT_HASH = ^_SCHANNEL_CERT_HASH;

type
  _SCHANNEL_CERT_HASH_STORE = record
    dwLength: DWORD;
    dwFlags: DWORD;
    hProv: HCRYPTPROV;
    ShaHash: array[0..20-1] of BYTE;
    pwszStoreName: array[0..SCH_CRED_MAX_STORE_NAME_SIZE-1] of WCHAR;
  end;
  SCHANNEL_CERT_HASH_STORE = _SCHANNEL_CERT_HASH_STORE;
  PSCHANNEL_CERT_HASH_STORE = ^_SCHANNEL_CERT_HASH_STORE;

// Values for SCHANNEL_CERT_HASH dwFlags field.
const SCH_MACHINE_CERT_HASH = $00000001;

// +-------------------------------------------------------------------------
// Flags for use with SCHANNEL_CRED
//
// SCH_CRED_NO_SYSTEM_MAPPER
// This flag is intended for use by server applications only. If this
// flag is set, then schannel does * not * attempt to map received client
// certificate chains to an NT user account using the built-in system
// certificate mapper.This flag is ignored by non-NT5 versions of
// schannel.
//
// SCH_CRED_NO_SERVERNAME_CHECK
// This flag is intended for use by client applications only. If this
// flag is set, then when schannel validates the received server
// certificate chain, is does * not * compare the passed in target name
// with the subject name embedded in the certificate. This flag is
// ignored by non-NT5 versions of schannel. This flag is also ignored
// if the SCH_CRED_MANUAL_CRED_VALIDATION flag is set.
//
// SCH_CRED_MANUAL_CRED_VALIDATION
// This flag is intended for use by client applications only. If this
// flag is set, then schannel will * not * automatically attempt to
// validate the received server certificate chain. This flag is
// ignored by non-NT5 versions of schannel, but all client applications
// that wish to validate the certificate chain themselves should
// specify this flag, so that there's at least a chance they'll run
// correctly on NT5.
//
// SCH_CRED_DEFERRED_CRED_VALIDATION
// This flag is intended for use by client applications only. If this
// flag is set, then schannel will attempt to validate the received
// server certificate chain, however, schannel will not terminate the
// handshake with an error if the chain has any issues. Rather, the
// client is expected to retrieve the the result of the chain build
// using SECPKG_ATTR_CERT_CHECK_RESULT at any point after
// receiving the server certificate or by using
// SECPKG_ATTR_CERT_CHECK_RESULT_INPROC after the handshake
// has concluded.
//
// SCH_CRED_NO_DEFAULT_CREDS
// This flag is intended for use by client applications only. If this
// flag is set, and the server requests client authentication, then
// schannel will * not * attempt to automatically acquire a suitable
// default client certificate chain. This flag is ignored by non-NT5
// versions of schannel, but all client applications that wish to
// manually specify their certicate chains should specify this flag,
// so that there's at least a chance they'll run correctly on NT5.
//
// SCH_CRED_AUTO_CRED_VALIDATION
// This flag is the opposite of SCH_CRED_MANUAL_CRED_VALIDATION.
// Conservatively written client applications will always specify one
// flag or the other.
//
// SCH_CRED_USE_DEFAULT_CREDS
// This flag is the opposite of SCH_CRED_NO_DEFAULT_CREDS.
// Conservatively written client applications will always specify one
// flag or the other.
//
// SCH_CRED_DISABLE_RECONNECTS
// This flag is intended for use by server applications only. If this
// flag is set, then full handshakes performed with this credential
// will not be marked suitable for reconnects. A cache entry will still
// be created, however, so the session can be made resumable later
// via a call to ApplyControlToken.
//
//
// SCH_CRED_REVOCATION_CHECK_END_CERT
// SCH_CRED_REVOCATION_CHECK_CHAIN
// SCH_CRED_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT
// These flags specify that when schannel automatically validates a
// received certificate chain, some or all of the certificates are to
// be checked for revocation. Only one of these flags may be specified.
// See the CertGetCertificateChain function. These flags are ignored by
// non-NT5 versions of schannel.
//
// SCH_CRED_IGNORE_NO_REVOCATION_CHECK
// SCH_CRED_IGNORE_REVOCATION_OFFLINE
// These flags instruct schannel to ignore the
// CRYPT_E_NO_REVOCATION_CHECK and CRYPT_E_REVOCATION_OFFLINE errors
// respectively if they are encountered when attempting to check the
// revocation status of a received certificate chain. These flags are
// ignored if none of the above flags are set.
//
// SCH_CRED_CACHE_ONLY_URL_RETRIEVAL_ON_CREATE
// This flag instructs schannel to pass CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL
// flags to CertGetCertificateChain when validating the specified
// credentials during a call to AcquireCredentialsHandle. The default for
// vista is to not specify CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL. Use
// SCH_CRED_CACHE_ONLY_URL_RETRIEVAL_ON_CREATE to override this behavior.
// NOTE: Prior to Vista, this flag(CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL) was
// specified by default.
//
// SCH_SEND_ROOT_CERT
// This flag instructs schannel to send the root cert as part of the
// certificate message.
//
// SCH_SEND_AUX_RECORD
// This flag instructs schannel to split application records.
//
// SCH_USE_STRONG_CRYPTO
// This flag instructs schannel to disable known weak cryptographic
// algorithms, cipher suites and SSL/TLS protocol versions that may be
// otherwise enabled for better interoperability.
//
// SCH_USE_PRESHAREDKEY_ONLY
// This flag instructs schannel to select only PSK cipher suites and
// disable all other cipher suites.
//
// SCH_USE_DTLS_ONLY
// This flag instructs schannel to select only DTLS protocols.
//
// SCH_ALLOW_NULL_ENCRYPTION
// This flag instructs schannel to allow NULL encryption cipher suites.
// For example: TLS_RSA_WITH_NULL_SHA256.
// +-------------------------------------------------------------------------
const SCH_CRED_NO_SYSTEM_MAPPER = $00000002;
const SCH_CRED_NO_SERVERNAME_CHECK = $00000004;
const SCH_CRED_MANUAL_CRED_VALIDATION = $00000008;
const SCH_CRED_NO_DEFAULT_CREDS = $00000010;
const SCH_CRED_AUTO_CRED_VALIDATION = $00000020;
const SCH_CRED_USE_DEFAULT_CREDS = $00000040;
const SCH_CRED_DISABLE_RECONNECTS = $00000080;

const SCH_CRED_REVOCATION_CHECK_END_CERT = $00000100;
const SCH_CRED_REVOCATION_CHECK_CHAIN = $00000200;
const SCH_CRED_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT = $00000400;
const SCH_CRED_IGNORE_NO_REVOCATION_CHECK = $00000800;
const SCH_CRED_IGNORE_REVOCATION_OFFLINE = $00001000;

const SCH_CRED_RESTRICTED_ROOTS = $00002000;
const SCH_CRED_REVOCATION_CHECK_CACHE_ONLY = $00004000;
const SCH_CRED_CACHE_ONLY_URL_RETRIEVAL = $00008000;

const SCH_CRED_MEMORY_STORE_CERT = $00010000;

const SCH_CRED_CACHE_ONLY_URL_RETRIEVAL_ON_CREATE = $00020000;

const SCH_SEND_ROOT_CERT = $00040000;
const SCH_CRED_SNI_CREDENTIAL = $00080000;
const SCH_CRED_SNI_ENABLE_OCSP = $00100000;
const SCH_SEND_AUX_RECORD = $00200000;
const SCH_USE_STRONG_CRYPTO = $00400000;
const SCH_USE_PRESHAREDKEY_ONLY = $00800000;
const SCH_USE_DTLS_ONLY = $01000000;
const SCH_ALLOW_NULL_ENCRYPTION = $02000000;
const SCH_CRED_DEFERRED_CRED_VALIDATION = $04000000;

//
//
// ApplyControlToken PkgParams types
//
// These identifiers are the DWORD types
// to be passed into ApplyControlToken
// through a PkgParams buffer.

const SCHANNEL_RENEGOTIATE = 0; // renegotiate a connection
const SCHANNEL_SHUTDOWN = 1; // gracefully close down a connection
const SCHANNEL_ALERT = 2; // build an error message
const SCHANNEL_SESSION = 3; // session control

// Alert token structure.
type
  _SCHANNEL_ALERT_TOKEN = record
    dwTokenType: DWORD; // SCHANNEL_ALERT
    dwAlertType: DWORD;
    dwAlertNumber: DWORD;
  end;
  SCHANNEL_ALERT_TOKEN = _SCHANNEL_ALERT_TOKEN;

// Alert types.
const TLS1_ALERT_WARNING = 1;
const TLS1_ALERT_FATAL = 2;

// Alert messages.
const TLS1_ALERT_CLOSE_NOTIFY = 0; // warning
const TLS1_ALERT_UNEXPECTED_MESSAGE = 10; // error
const TLS1_ALERT_BAD_RECORD_MAC = 20; // error
const TLS1_ALERT_DECRYPTION_FAILED = 21; // reserved
const TLS1_ALERT_RECORD_OVERFLOW = 22; // error
const TLS1_ALERT_DECOMPRESSION_FAIL = 30; // error
const TLS1_ALERT_HANDSHAKE_FAILURE = 40; // error
const TLS1_ALERT_BAD_CERTIFICATE = 42; // warning or error
const TLS1_ALERT_UNSUPPORTED_CERT = 43; // warning or error
const TLS1_ALERT_CERTIFICATE_REVOKED = 44; // warning or error
const TLS1_ALERT_CERTIFICATE_EXPIRED = 45; // warning or error
const TLS1_ALERT_CERTIFICATE_UNKNOWN = 46; // warning or error
const TLS1_ALERT_ILLEGAL_PARAMETER = 47; // error
const TLS1_ALERT_UNKNOWN_CA = 48; // error
const TLS1_ALERT_ACCESS_DENIED = 49; // error
const TLS1_ALERT_DECODE_ERROR = 50; // error
const TLS1_ALERT_DECRYPT_ERROR = 51; // error
const TLS1_ALERT_EXPORT_RESTRICTION = 60; // reserved
const TLS1_ALERT_PROTOCOL_VERSION = 70; // error
const TLS1_ALERT_INSUFFIENT_SECURITY = 71; // error
const TLS1_ALERT_INTERNAL_ERROR = 80; // error
const TLS1_ALERT_USER_CANCELED = 90; // warning or error
const TLS1_ALERT_NO_RENEGOTIATION = 100; // warning
const TLS1_ALERT_UNSUPPORTED_EXT = 110; // error
const TLS1_ALERT_UNKNOWN_PSK_IDENTITY = 115; // error
const TLS1_ALERT_NO_APP_PROTOCOL = 120; // error

// Session control flags
const SSL_SESSION_ENABLE_RECONNECTS = 1;
const SSL_SESSION_DISABLE_RECONNECTS = 2;

// Session control token structure.
type
  _SCHANNEL_SESSION_TOKEN = record
    dwTokenType: DWORD; // SCHANNEL_SESSION
    dwFlags: DWORD;
  end;
  SCHANNEL_SESSION_TOKEN = _SCHANNEL_SESSION_TOKEN;

type
  _SCHANNEL_CLIENT_SIGNATURE = record
    cbLength: DWORD;
    aiHash: ALG_ID;
    cbHash: DWORD;
    HashValue: array[0..36-1] of BYTE;
    CertThumbprint: array[0..20-1] of BYTE;
  end;
  SCHANNEL_CLIENT_SIGNATURE = _SCHANNEL_CLIENT_SIGNATURE;
  PSCHANNEL_CLIENT_SIGNATURE = ^_SCHANNEL_CLIENT_SIGNATURE;

//
// Flags for identifying the various different protocols.
//

// * flag/identifiers for protocols we support
const SP_PROT_PCT1_SERVER = $00000001;
const SP_PROT_PCT1_CLIENT = $00000002;
const SP_PROT_PCT1 = (SP_PROT_PCT1_SERVER or SP_PROT_PCT1_CLIENT);

const SP_PROT_SSL2_SERVER = $00000004;
const SP_PROT_SSL2_CLIENT = $00000008;
const SP_PROT_SSL2 = (SP_PROT_SSL2_SERVER or SP_PROT_SSL2_CLIENT);

const SP_PROT_SSL3_SERVER = $00000010;
const SP_PROT_SSL3_CLIENT = $00000020;
const SP_PROT_SSL3 = (SP_PROT_SSL3_SERVER or SP_PROT_SSL3_CLIENT);

const SP_PROT_TLS1_SERVER = $00000040;
const SP_PROT_TLS1_CLIENT = $00000080;
const SP_PROT_TLS1 = (SP_PROT_TLS1_SERVER or SP_PROT_TLS1_CLIENT);

const SP_PROT_SSL3TLS1_CLIENTS = (SP_PROT_TLS1_CLIENT or SP_PROT_SSL3_CLIENT);
const SP_PROT_SSL3TLS1_SERVERS = (SP_PROT_TLS1_SERVER or SP_PROT_SSL3_SERVER);
const SP_PROT_SSL3TLS1 = (SP_PROT_SSL3 or SP_PROT_TLS1);

const SP_PROT_UNI_SERVER = $40000000;
const SP_PROT_UNI_CLIENT = $80000000;
const SP_PROT_UNI = (SP_PROT_UNI_SERVER or SP_PROT_UNI_CLIENT);

const SP_PROT_ALL = $ffffffff;
const SP_PROT_NONE = 0;
const SP_PROT_CLIENTS = (SP_PROT_PCT1_CLIENT or SP_PROT_SSL2_CLIENT or SP_PROT_SSL3_CLIENT or SP_PROT_UNI_CLIENT or SP_PROT_TLS1_CLIENT);
const SP_PROT_SERVERS = (SP_PROT_PCT1_SERVER or SP_PROT_SSL2_SERVER or SP_PROT_SSL3_SERVER or SP_PROT_UNI_SERVER or SP_PROT_TLS1_SERVER);

const SP_PROT_TLS1_0_SERVER = SP_PROT_TLS1_SERVER;
const SP_PROT_TLS1_0_CLIENT = SP_PROT_TLS1_CLIENT;
const SP_PROT_TLS1_0 = (SP_PROT_TLS1_0_SERVER or SP_PROT_TLS1_0_CLIENT);

const SP_PROT_TLS1_1_SERVER = $00000100;
const SP_PROT_TLS1_1_CLIENT = $00000200;
const SP_PROT_TLS1_1 = (SP_PROT_TLS1_1_SERVER or SP_PROT_TLS1_1_CLIENT);

const SP_PROT_TLS1_2_SERVER = $00000400;
const SP_PROT_TLS1_2_CLIENT = $00000800;
const SP_PROT_TLS1_2 = (SP_PROT_TLS1_2_SERVER or SP_PROT_TLS1_2_CLIENT);

const SP_PROT_TLS1_3_SERVER = $00001000;
const SP_PROT_TLS1_3_CLIENT = $00002000;
const SP_PROT_TLS1_3 = (SP_PROT_TLS1_3_SERVER or SP_PROT_TLS1_3_CLIENT);

const SP_PROT_DTLS_SERVER = $00010000;
const SP_PROT_DTLS_CLIENT = $00020000;
const SP_PROT_DTLS = (SP_PROT_DTLS_SERVER or SP_PROT_DTLS_CLIENT );

const SP_PROT_DTLS1_0_SERVER = SP_PROT_DTLS_SERVER;
const SP_PROT_DTLS1_0_CLIENT = SP_PROT_DTLS_CLIENT;
const SP_PROT_DTLS1_0 = (SP_PROT_DTLS1_0_SERVER or SP_PROT_DTLS1_0_CLIENT);

const SP_PROT_DTLS1_2_SERVER = $00040000;
const SP_PROT_DTLS1_2_CLIENT = $00080000;
const SP_PROT_DTLS1_2 = (SP_PROT_DTLS1_2_SERVER or SP_PROT_DTLS1_2_CLIENT);

const SP_PROT_DTLS1_X_SERVER = (SP_PROT_DTLS1_0_SERVER or SP_PROT_DTLS1_2_SERVER);

const SP_PROT_DTLS1_X_CLIENT = (SP_PROT_DTLS1_0_CLIENT or SP_PROT_DTLS1_2_CLIENT);

const SP_PROT_DTLS1_X = (SP_PROT_DTLS1_X_SERVER or SP_PROT_DTLS1_X_CLIENT);

const SP_PROT_TLS1_1PLUS_SERVER = (SP_PROT_TLS1_1_SERVER or SP_PROT_TLS1_2_SERVER or SP_PROT_TLS1_3_SERVER);
const SP_PROT_TLS1_1PLUS_CLIENT = (SP_PROT_TLS1_1_CLIENT or SP_PROT_TLS1_2_CLIENT or SP_PROT_TLS1_3_CLIENT);

const SP_PROT_TLS1_1PLUS = (SP_PROT_TLS1_1PLUS_SERVER or SP_PROT_TLS1_1PLUS_CLIENT);

const SP_PROT_TLS1_3PLUS_SERVER = SP_PROT_TLS1_3_SERVER;
const SP_PROT_TLS1_3PLUS_CLIENT = SP_PROT_TLS1_3_CLIENT;
const SP_PROT_TLS1_3PLUS = (SP_PROT_TLS1_3PLUS_SERVER or SP_PROT_TLS1_3PLUS_CLIENT);

const SP_PROT_TLS1_X_SERVER = (SP_PROT_TLS1_0_SERVER or SP_PROT_TLS1_1_SERVER or SP_PROT_TLS1_2_SERVER or SP_PROT_TLS1_3_SERVER);
const SP_PROT_TLS1_X_CLIENT = (SP_PROT_TLS1_0_CLIENT or SP_PROT_TLS1_1_CLIENT or SP_PROT_TLS1_2_CLIENT or SP_PROT_TLS1_3_CLIENT);
const SP_PROT_TLS1_X = (SP_PROT_TLS1_X_SERVER or SP_PROT_TLS1_X_CLIENT);

const SP_PROT_SSL3TLS1_X_CLIENTS = (SP_PROT_TLS1_X_CLIENT or SP_PROT_SSL3_CLIENT);
const SP_PROT_SSL3TLS1_X_SERVERS = (SP_PROT_TLS1_X_SERVER or SP_PROT_SSL3_SERVER);
const SP_PROT_SSL3TLS1_X = (SP_PROT_SSL3 or SP_PROT_TLS1_X);

const SP_PROT_X_CLIENTS = (SP_PROT_CLIENTS or SP_PROT_TLS1_X_CLIENT or SP_PROT_DTLS1_X_CLIENT );
const SP_PROT_X_SERVERS = (SP_PROT_SERVERS or SP_PROT_TLS1_X_SERVER or SP_PROT_DTLS1_X_SERVER );

//
// Helper function used to flush the SSL session cache.
//

type
  SSL_EMPTY_CACHE_FN_A = function (
    pszTargetName: LPSTR;
    dwFlags: DWORD): LongBool; stdcall;

function SslEmptyCacheA(
           pszTargetName: LPSTR;
           dwFlags: DWORD): LongBool; stdcall; external 'schannel.dll';

type
  SSL_EMPTY_CACHE_FN_W = function (
    pszTargetName: LPWSTR;
    dwFlags: DWORD): LongBool; stdcall;

function SslEmptyCacheW(
           pszTargetName: LPWSTR;
           dwFlags: DWORD): LongBool; stdcall; external 'schannel.dll';

// #define SSL_EMPTY_CACHE_FN SSL_EMPTY_CACHE_FN_W
// #define SslEmptyCache SslEmptyCacheW

// Structures for compatability with the
// NT 4.0 SP2 / IE 3.0 schannel interface, do
// not use.

type
  _SSL_CREDENTIAL_CERTIFICATE = record
    cbPrivateKey: DWORD;
    pPrivateKey: PBYTE;
    cbCertificate: DWORD;
    pCertificate: PBYTE;
    pszPassword: PSTR;
  end;
  SSL_CREDENTIAL_CERTIFICATE = _SSL_CREDENTIAL_CERTIFICATE;
  PSSL_CREDENTIAL_CERTIFICATE = ^_SSL_CREDENTIAL_CERTIFICATE;

// Structures for use with the
// NT 4.0 SP3 Schannel interface,
// do not use.
const SCHANNEL_SECRET_TYPE_CAPI = $00000001;
const SCHANNEL_SECRET_PRIVKEY = $00000002;
const SCH_CRED_X509_CERTCHAIN = $00000001;
const SCH_CRED_X509_CAPI = $00000002;
const SCH_CRED_CERT_CONTEXT = $00000003;

// struct _HMAPPER;
type
  _SCH_CRED = record
    dwVersion: DWORD; // always SCH_CRED_VERSION.
    cCreds: DWORD; // Number of credentials.
    paSecret: PPVOID; // Array of SCH_CRED_SECRET_ * pointers
    paPublic: PPVOID; // Array of SCH_CRED_PUBLIC_ * pointers
    cMappers: DWORD; // Number of credential mappers.
    aphMappers: PP_HMAPPER; // pointer to an array of pointers to credential mappers
  end;
  SCH_CRED = _SCH_CRED;
  PSCH_CRED = ^_SCH_CRED;

// Structures for use with the
// NT 4.0 SP3 Schannel interface,
// do not use.
type
  _SCH_CRED_SECRET_CAPI = record
    dwType: DWORD; // SCHANNEL_SECRET_TYPE_CAPI
    hProv: HCRYPTPROV; // credential secret information.
  end;
  SCH_CRED_SECRET_CAPI = _SCH_CRED_SECRET_CAPI;
  PSCH_CRED_SECRET_CAPI = ^_SCH_CRED_SECRET_CAPI;

// Structures for use with the
// NT 4.0 SP3 Schannel interface,
// do not use.
type
  _SCH_CRED_SECRET_PRIVKEY = record
    dwType: DWORD; // SCHANNEL_SECRET_PRIVKEY
    pPrivateKey: PBYTE; // Der encoded private key
    cbPrivateKey: DWORD;
    pszPassword: PSTR; // Password to crack the private key.
  end;
  SCH_CRED_SECRET_PRIVKEY = _SCH_CRED_SECRET_PRIVKEY;
  PSCH_CRED_SECRET_PRIVKEY = ^_SCH_CRED_SECRET_PRIVKEY;

// Structures for use with the
// NT 4.0 SP3 Schannel interface,
// do not use.
type
  _SCH_CRED_PUBLIC_CERTCHAIN = record
    dwType: DWORD;
    cbCertChain: DWORD;
    pCertChain: PBYTE;
  end;
  SCH_CRED_PUBLIC_CERTCHAIN = _SCH_CRED_PUBLIC_CERTCHAIN;
  PSCH_CRED_PUBLIC_CERTCHAIN = ^_SCH_CRED_PUBLIC_CERTCHAIN;

// Structures needed for Pre NT4.0 SP2 calls.
type
  _PctPublicKey = record
    &Type: DWORD;
    cbKey: DWORD;
    pKey: array[0..1-1] of UCHAR;
  end;
  PctPublicKey = _PctPublicKey;
  PPctPublicKey = ^PctPublicKey;

type
  _X509Certificate = record
    Version: DWORD;
    SerialNumber: array[0..4-1] of DWORD;
    SignatureAlgorithm: ALG_ID;
    ValidFrom: FILETIME;
    ValidUntil: FILETIME;
    pszIssuer: PSTR;
    pszSubject: PSTR;
    pPublicKey: PPctPublicKey;
  end;
  X509Certificate = _X509Certificate;
  PX509Certificate = ^_X509Certificate;
  PPX509Certificate = ^PX509Certificate;

// Pre NT4.0 SP2 calls. Call CAPI1 or CAPI2
// to get the same functionality instead.
// BOOL
// __CALLCONV__
// SslGenerateKeyPair(
// PSSL_CREDENTIAL_CERTIFICATE pCerts,
// PSTR pszDN,
// PSTR pszPassword,
// DWORD Bits );

// Pre NT4.0 SP2 calls. Call CAPI1 or CAPI2
// to get the same functionality instead.
procedure SslGenerateRandomBits(
            pRandomData: PUCHAR;
            cRandomData: LONG); stdcall; external 'schannel.dll';

// Pre NT4.0 SP2 calls. Call CAPI1 or CAPI2
// to get the same functionality instead.
function SslCrackCertificate(
           pbCertificate: PUCHAR;
           cbCertificate: DWORD;
           dwFlags: DWORD;
           ppCertificate: PPX509Certificate): LongBool; stdcall; external 'schannel.dll';

// Pre NT4.0 SP2 calls. Call CAPI1 or CAPI2
// to get the same functionality instead.
procedure SslFreeCertificate(
            pCertificate: PX509Certificate); stdcall; external 'schannel.dll';

function SslGetMaximumKeySize(
           Reserved: DWORD): DWORD; stdcall; external 'schannel.dll';

// BOOL
// __CALLCONV__
// SslGetDefaultIssuers(
// PBYTE pbIssuers,
// DWORD * pcbIssuers);

const SSL_CRACK_CERTIFICATE_NAME = 'SslCrackCertificate';
const SSL_FREE_CERTIFICATE_NAME = 'SslFreeCertificate';

// Pre NT4.0 SP2 calls. Call CAPI1 or CAPI2
// to get the same functionality instead.
type
  SSL_CRACK_CERTIFICATE_FN = function (
    pbCertificate: PUCHAR;
    cbCertificate: DWORD;
    VerifySignature: LongBool;
    ppCertificate: PPX509Certificate): LongBool; stdcall;

// Pre NT4.0 SP2 calls. Call CAPI1 or CAPI2
// to get the same functionality instead.
type
  SSL_FREE_CERTIFICATE_FN = procedure (
    pCertificate: PX509Certificate); stdcall;

type
  SslGetServerIdentityFn = function (
    ClientHello: PBYTE;
    ClientHelloSize: DWORD;
    ServerIdentity: PPBYTE;
    ServerIdentitySize: PDWORD;
    Flags: DWORD): SECURITY_STATUS; stdcall;

function SslGetServerIdentity(
           ClientHello: PBYTE;
           ClientHelloSize: DWORD;
           ServerIdentity: PPBYTE;
           ServerIdentitySize: PDWORD;
           Flags: DWORD): SECURITY_STATUS; stdcall; external 'schannel.dll';

type
  _SCH_EXTENSION_DATA = record
    ExtensionType: WORD;
    pExtData: PBYTE;
    cbExtData: DWORD;
  end;
  SCH_EXTENSION_DATA = _SCH_EXTENSION_DATA;
  PSCH_EXTENSION_DATA = ^SCH_EXTENSION_DATA;

type
  _SchGetExtensionsOptions = (
    SCH_EXTENSIONS_OPTIONS_NONE = $0,
    SCH_NO_RECORD_HEADER = $1); // Specifies that the ClientHello message does not contain the record header.
  SchGetExtensionsOptions = _SchGetExtensionsOptions;
// DEFINE_ENUM_FLAG_OPERATORS(SchGetExtensionsOptions);

type
  SslGetExtensionsFn = function (
    clientHello: PBYTE;
    clientHelloByteSize: DWORD;
    genericExtensions: PSCH_EXTENSION_DATA;
    genericExtensionsCount: BYTE;
    bytesToRead: PDWORD;
    flags: SchGetExtensionsOptions): SECURITY_STATUS; stdcall;

function SslGetExtensions(
           clientHello: PBYTE;
           clientHelloByteSize: DWORD;
           genericExtensions: PSCH_EXTENSION_DATA;
           genericExtensionsCount: BYTE;
           bytesToRead: PDWORD;
           flags: SchGetExtensionsOptions): SECURITY_STATUS; stdcall; external 'schannel.dll';

type
  SslDeserializeCertificateStoreFn = function (
    SerializedCertificateStore: CERT_BLOB;
    ppCertContext: PPCCERT_CONTEXT): SECURITY_STATUS; stdcall;

// Deserializes the certificate store provided by QueryContextAttributes for
// SECPKG_ATTR_SERIALIZED_REMOTE_CERT_CONTEXT[_INPROC]. The certificate context of the remote peer's
// leaf certificate is returned. The caller must free * ppCertContext when done by calling
// CertFreeCertificateContext.
// SECURITY_STATUS
// __CALLCONV__
// SslDeserializeCertificateStore(
// CERT_BLOB SerializedCertificateStore,
// PCCERT_CONTEXT * ppCertContext
// );

implementation

end.
unit Alcinoe.WinApi.SSPI;

//*******************************************************************//
// This unit was automatically generated by CHeaderWrapperGenerator. //
// Do not edit manually.                                             //
//*******************************************************************//

interface

{$I Alcinoe.inc}

{$WARN SYMBOL_PLATFORM OFF}
{$SCOPEDENUMS OFF}
{$MINENUMSIZE 4}
{$A+}

uses
  WinApi.Windows,
  Winapi.WinCred,
  Alcinoe.WinApi.Windows;

// begin_ntifs
// #define __SSPI_H__
// end_ntifs

//
// Determine environment:
//

const ISSP_LEVEL = 32;
const ISSP_MODE = 1;

//
// Now, define platform specific mappings:
//

// begin_ntifs

type SEC_WCHAR = WCHAR;
type PSEC_WCHAR = ^SEC_WCHAR;
type SEC_CHAR = AnsiChar;
type PSEC_CHAR = ^SEC_CHAR;

type SECURITY_STATUS = LONG;
type PSECURITY_STATUS = ^SECURITY_STATUS;
// #define __SECSTATUS_DEFINED__

// end_ntifs

//
// Decide what a string - 32 bits only since for 16 bits it is clear.
//

type SECURITY_PSTR = ^SEC_WCHAR;
type SECURITY_PCSTR = ^SEC_WCHAR;

//
// Equivalent string for rpcrt:
//

//
// Okay, security specific types:
//

// begin_ntifs

type
  _SecHandle = record
    dwLower: ULONG_PTR;
    dwUpper: ULONG_PTR;
  end;
  SecHandle = _SecHandle;
  PSecHandle = ^_SecHandle;

// #define __SECHANDLE_DEFINED__

// #define SecInvalidateHandle( x ) ((PSecHandle) (x))->dwLower = ((PSecHandle) (x))->dwUpper = ((ULONG_PTR) ((INT_PTR)-1)) ;

// #define SecIsValidHandle( x ) ( ( ((PSecHandle) (x))->dwLower != ((ULONG_PTR) ((INT_PTR) -1 ))) && ( ((PSecHandle) (x))->dwUpper != ((ULONG_PTR) ((INT_PTR) -1 ))) )

//
// pseudo handle value: the handle has already been deleted
//

const SEC_DELETED_HANDLE: ULONG_PTR = ULONG_PTR( (-2));

type CredHandle = SecHandle;
type PCredHandle = PSecHandle;

type CtxtHandle = SecHandle;
type PCtxtHandle = PSecHandle;

// end_ntifs

type _SECURITY_INTEGER = LARGE_INTEGER; // ntifs
type SECURITY_INTEGER = LARGE_INTEGER; // ntifs
type PSECURITY_INTEGER = ^LARGE_INTEGER; // ntifs

type TimeStamp = SECURITY_INTEGER; // ntifs
type PTimeStamp = ^SECURITY_INTEGER; // ntifs

//
// If we are in 32 bit mode, define the SECURITY_STRING structure,
// as a clone of the base UNICODE_STRING structure. This is used
// internally in security components, an as the string interface
// for kernel components (e.g. FSPs)
//

type
  _SECURITY_STRING = record
    Length: USHORT;
    MaximumLength: USHORT;
    Buffer: PUSHORT;
  end;
  SECURITY_STRING = _SECURITY_STRING;
  PSECURITY_STRING = ^_SECURITY_STRING;

// begin_ntifs

//
// SecPkgInfo structure
//
// Provides general information about a security provider
//

type
  _SecPkgInfoW = record
    fCapabilities: ULONG; // Capability bitmask
    wVersion: USHORT; // Version of driver
    wRPCID: USHORT; // ID for RPC Runtime
    cbMaxToken: ULONG; // Size of authentication token (max)
    Name: PSEC_WCHAR; // Text name
    Comment: PSEC_WCHAR; // Comment
  end;
  SecPkgInfoW = _SecPkgInfoW;
  PSecPkgInfoW = ^_SecPkgInfoW;
  PPSecPkgInfoW = ^PSecPkgInfoW;

// end_ntifs

type
  _SecPkgInfoA = record
    fCapabilities: ULONG; // Capability bitmask
    wVersion: USHORT; // Version of driver
    wRPCID: USHORT; // ID for RPC Runtime
    cbMaxToken: ULONG; // Size of authentication token (max)
    Name: PSEC_CHAR; // Text name
    Comment: PSEC_CHAR; // Comment
  end;
  SecPkgInfoA = _SecPkgInfoA;
  PSecPkgInfoA = ^_SecPkgInfoA;
  PPSecPkgInfoA = ^PSecPkgInfoA;

// #define SecPkgInfo SecPkgInfoW // ntifs
// #define PSecPkgInfo PSecPkgInfoW // ntifs

// begin_ntifs

//
// Security Package Capabilities
//
const SECPKG_FLAG_INTEGRITY = $00000001; // Supports integrity on messages
const SECPKG_FLAG_PRIVACY = $00000002; // Supports privacy (confidentiality)
const SECPKG_FLAG_TOKEN_ONLY = $00000004; // Only security token needed
const SECPKG_FLAG_DATAGRAM = $00000008; // Datagram RPC support
const SECPKG_FLAG_CONNECTION = $00000010; // Connection oriented RPC support
const SECPKG_FLAG_MULTI_REQUIRED = $00000020; // Full 3-leg required for re-auth.
const SECPKG_FLAG_CLIENT_ONLY = $00000040; // Server side functionality not available
const SECPKG_FLAG_EXTENDED_ERROR = $00000080; // Supports extended error msgs
const SECPKG_FLAG_IMPERSONATION = $00000100; // Supports impersonation
const SECPKG_FLAG_ACCEPT_WIN32_NAME = $00000200; // Accepts Win32 names
const SECPKG_FLAG_STREAM = $00000400; // Supports stream semantics
const SECPKG_FLAG_NEGOTIABLE = $00000800; // Can be used by the negotiate package
const SECPKG_FLAG_GSS_COMPATIBLE = $00001000; // GSS Compatibility Available
const SECPKG_FLAG_LOGON = $00002000; // Supports common LsaLogonUser
const SECPKG_FLAG_ASCII_BUFFERS = $00004000; // Token Buffers are in ASCII
const SECPKG_FLAG_FRAGMENT = $00008000; // Package can fragment to fit
const SECPKG_FLAG_MUTUAL_AUTH = $00010000; // Package can perform mutual authentication
const SECPKG_FLAG_DELEGATION = $00020000; // Package can delegate
const SECPKG_FLAG_READONLY_WITH_CHECKSUM = $00040000; // Package can delegate
const SECPKG_FLAG_RESTRICTED_TOKENS = $00080000; // Package supports restricted callers
const SECPKG_FLAG_NEGO_EXTENDER = $00100000; // this package extends SPNEGO, there is at most one
const SECPKG_FLAG_NEGOTIABLE2 = $00200000; // this package is negotiated under the NegoExtender
const SECPKG_FLAG_APPCONTAINER_PASSTHROUGH = $00400000; // this package receives all calls from appcontainer apps
const SECPKG_FLAG_APPCONTAINER_CHECKS = $00800000; // this package receives calls from appcontainer apps
// if the following checks succeed
// 1. Caller has domain auth capability or
// 2. Target is a proxy server or
// 3. The caller has supplied creds
const SECPKG_FLAG_CREDENTIAL_ISOLATION_ENABLED = $01000000; // this package is running with Credential Guard enabled
const SECPKG_FLAG_APPLY_LOOPBACK = $02000000; // this package supports reliable detection of loopback
// 1.) The client and server see the same sequence of tokens
// 2.) The server enforces a unique exchange for each
// non-anonymous authentication. (Replay detection)

const SECPKG_ID_NONE = $FFFF;

//
// Extended Call Flags that currently contains
// Appcontainer related information about the caller.
// Packages can query for these
// via an LsaFunction GetExtendedCallFlags
//

const SECPKG_CALLFLAGS_APPCONTAINER = $00000001;
const SECPKG_CALLFLAGS_APPCONTAINER_AUTHCAPABLE = $00000002;
const SECPKG_CALLFLAGS_FORCE_SUPPLIED = $00000004;
const SECPKG_CALLFLAGS_APPCONTAINER_UPNCAPABLE = $00000008;

//
// SecBuffer
//
// Generic memory descriptors for buffers passed in to the security
// API
//

type
  _SecBuffer = record
    cbBuffer: ULONG; // Size of the buffer, in bytes
    BufferType: ULONG; // Type of the buffer (below)
    pvBuffer: Pvoid; // Pointer to the buffer
  end;
  SecBuffer = _SecBuffer;
  PSecBuffer = ^_SecBuffer;

type
  _SecBufferDesc = record
    ulVersion: ULONG; // Version number
    cBuffers: ULONG; // Number of buffers
    pBuffers: PSecBuffer; // Pointer to array of buffers
  end;
  SecBufferDesc = _SecBufferDesc;
  PSecBufferDesc = ^_SecBufferDesc;

const SECBUFFER_VERSION = 0;

const SECBUFFER_EMPTY = 0; // Undefined, replaced by provider
const SECBUFFER_DATA = 1; // Packet data
const SECBUFFER_TOKEN = 2; // Security token
const SECBUFFER_PKG_PARAMS = 3; // Package specific parameters
const SECBUFFER_MISSING = 4; // Missing Data indicator
const SECBUFFER_EXTRA = 5; // Extra data
const SECBUFFER_STREAM_TRAILER = 6; // Security Trailer
const SECBUFFER_STREAM_HEADER = 7; // Security Header
const SECBUFFER_NEGOTIATION_INFO = 8; // Hints from the negotiation pkg
const SECBUFFER_PADDING = 9; // non-data padding
const SECBUFFER_STREAM = 10; // whole encrypted message
const SECBUFFER_MECHLIST = 11;
const SECBUFFER_MECHLIST_SIGNATURE = 12;
const SECBUFFER_TARGET = 13; // obsolete
const SECBUFFER_CHANNEL_BINDINGS = 14;
const SECBUFFER_CHANGE_PASS_RESPONSE = 15;
const SECBUFFER_TARGET_HOST = 16;
const SECBUFFER_ALERT = 17;
const SECBUFFER_APPLICATION_PROTOCOLS = 18; // Lists of application protocol IDs, one per negotiation extension
const SECBUFFER_SRTP_PROTECTION_PROFILES = 19; // List of SRTP protection profiles, in descending order of preference
const SECBUFFER_SRTP_MASTER_KEY_IDENTIFIER = 20; // SRTP master key identifier
const SECBUFFER_TOKEN_BINDING = 21; // Supported Token Binding protocol version and key parameters
const SECBUFFER_PRESHARED_KEY = 22; // Preshared key
const SECBUFFER_PRESHARED_KEY_IDENTITY = 23; // Preshared key identity
const SECBUFFER_DTLS_MTU = 24; // DTLS path MTU setting
const SECBUFFER_SEND_GENERIC_TLS_EXTENSION = 25; // Buffer for sending generic TLS extensions.
const SECBUFFER_SUBSCRIBE_GENERIC_TLS_EXTENSION = 26; // Buffer for subscribing to generic TLS extensions.
const SECBUFFER_FLAGS = 27; // ISC/ASC REQ Flags
const SECBUFFER_TRAFFIC_SECRETS = 28; // Message sequence lengths and corresponding traffic secrets.
const SECBUFFER_CERTIFICATE_REQUEST_CONTEXT = 29; // TLS 1.3 certificate request context.
const SECBUFFER_CHANNEL_BINDINGS_RESULT = 30; // Output buffer for Channel Bindings Audit
const SECBUFFER_APP_SESSION_STATE = 31; // Application state associated with the TLS 1.3+ session ticket. Server only.
const SECBUFFER_SESSION_TICKET = 32; // TLS 1.3+ session ticket. Client only.

const SECBUFFER_ATTRMASK = $F0000000;
const SECBUFFER_READONLY = $80000000; // Buffer is read-only, no checksum
const SECBUFFER_READONLY_WITH_CHECKSUM = $10000000; // Buffer is read-only, and checksummed
const SECBUFFER_RESERVED = $60000000; // Flags reserved to security system

type
  _SEC_NEGOTIATION_INFO = record
    Size: ULONG; // Size of this structure
    NameLength: ULONG; // Length of name hint
    Name: PSEC_WCHAR; // Name hint
    Reserved: Pvoid; // Reserved
  end;
  SEC_NEGOTIATION_INFO = _SEC_NEGOTIATION_INFO;
  PSEC_NEGOTIATION_INFO = ^_SEC_NEGOTIATION_INFO;

type
  _SEC_CHANNEL_BINDINGS = record
    dwInitiatorAddrType: ULONG;
    cbInitiatorLength: ULONG;
    dwInitiatorOffset: ULONG;
    dwAcceptorAddrType: ULONG;
    cbAcceptorLength: ULONG;
    dwAcceptorOffset: ULONG;
    cbApplicationDataLength: ULONG;
    dwApplicationDataOffset: ULONG;
  end;
  SEC_CHANNEL_BINDINGS = _SEC_CHANNEL_BINDINGS;
  PSEC_CHANNEL_BINDINGS = ^_SEC_CHANNEL_BINDINGS;

const SEC_CHANNEL_BINDINGS_EX_MAGIC = 'XEBC';

type
  _SEC_CHANNEL_BINDINGS_EX = record
    magicNumber: ULONG; // contains SEC_CHANNEL_BINDINGS_VERSION_2. distinguish ex buffer from normal channel bindings buffer. Shouldn't collide with any of assigned dwInitiatorAddrType values
    flags: ULONG; // audit flag is set to indicate if audit is needed
    cbHeaderLength: ULONG;
    cbStructureLength: ULONG;
    dwInitiatorAddrType: ULONG;
    cbInitiatorLength: ULONG;
    dwInitiatorOffset: ULONG;
    dwAcceptorAddrType: ULONG;
    cbAcceptorLength: ULONG;
    dwAcceptorOffset: ULONG;
    cbApplicationDataLength: ULONG;
    dwApplicationDataOffset: ULONG;
  end;
  SEC_CHANNEL_BINDINGS_EX = _SEC_CHANNEL_BINDINGS_EX;
  PSEC_CHANNEL_BINDINGS_EX = ^_SEC_CHANNEL_BINDINGS_EX;

const SEC_CHANNEL_BINDINGS_AUDIT_BINDINGS = $1;

const SEC_CHANNEL_BINDINGS_VALID_FLAGS = SEC_CHANNEL_BINDINGS_AUDIT_BINDINGS;

type
  _SEC_CHANNEL_BINDINGS_RESULT = record
    flags: ULONG;
  end;
  SEC_CHANNEL_BINDINGS_RESULT = _SEC_CHANNEL_BINDINGS_RESULT;
  PSEC_CHANNEL_BINDINGS_RESULT = ^_SEC_CHANNEL_BINDINGS_RESULT;

const SEC_CHANNEL_BINDINGS_RESULT_CLIENT_SUPPORT = $1; // Auth package indicates client versions should support bindings
const SEC_CHANNEL_BINDINGS_RESULT_ABSENT = $2; // The bindings are omitted or all zeroes
const SEC_CHANNEL_BINDINGS_RESULT_NOTVALID_MISMATCH = $4; // The channel binding hash was incorrect
const SEC_CHANNEL_BINDINGS_RESULT_NOTVALID_MISSING = $8; // Missing channel bindings are not allowed for this client
const SEC_CHANNEL_BINDINGS_RESULT_VALID_MATCHED = $10; // The client and server bindings match
const SEC_CHANNEL_BINDINGS_RESULT_VALID_PROXY = $20; // ASC_REQ_PROXY_BINDINGS required the client to provide a binding
const SEC_CHANNEL_BINDINGS_RESULT_VALID_MISSING = $40; // Client permitted by ASC_REQ_ALLOW_MISSING_BINDINGS

const SEC_CHANNEL_BINDINGS_RESULT_VALID = (SEC_CHANNEL_BINDINGS_RESULT_VALID_MATCHED or SEC_CHANNEL_BINDINGS_RESULT_VALID_PROXY or SEC_CHANNEL_BINDINGS_RESULT_VALID_MISSING);

const SEC_CHANNEL_BINDINGS_RESULT_NOTVALID = (SEC_CHANNEL_BINDINGS_RESULT_NOTVALID_MISMATCH or SEC_CHANNEL_BINDINGS_RESULT_NOTVALID_MISSING);

type
  _SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT = (
    SecApplicationProtocolNegotiationExt_None,
    SecApplicationProtocolNegotiationExt_NPN,
    SecApplicationProtocolNegotiationExt_ALPN);
  SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT = _SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT;
  PSEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT = ^_SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT;

type
  _SEC_APPLICATION_PROTOCOL_LIST = record
    ProtoNegoExt: SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT; // Protocol negotiation extension type to use with this list of protocols
    ProtocolListSize: USHORT; // Size in bytes of the protocol ID list
    ProtocolList: array[0..ANYSIZE_ARRAY-1] of UCHAR; // 8-bit length-prefixed application protocol IDs, most preferred first
  end;
  SEC_APPLICATION_PROTOCOL_LIST = _SEC_APPLICATION_PROTOCOL_LIST;
  PSEC_APPLICATION_PROTOCOL_LIST = ^_SEC_APPLICATION_PROTOCOL_LIST;

type
  _SEC_APPLICATION_PROTOCOLS = record
    ProtocolListsSize: ULONG; // Size in bytes of the protocol ID lists array
    ProtocolLists: array[0..ANYSIZE_ARRAY-1] of SEC_APPLICATION_PROTOCOL_LIST; // Array of protocol ID lists
  end;
  SEC_APPLICATION_PROTOCOLS = _SEC_APPLICATION_PROTOCOLS;
  PSEC_APPLICATION_PROTOCOLS = ^_SEC_APPLICATION_PROTOCOLS;

type
  _SEC_SRTP_PROTECTION_PROFILES = record
    ProfilesSize: USHORT; // Size in bytes of the SRTP protection profiles array
    ProfilesList: array[0..ANYSIZE_ARRAY-1] of USHORT; // Array of SRTP protection profiles
  end;
  SEC_SRTP_PROTECTION_PROFILES = _SEC_SRTP_PROTECTION_PROFILES;
  PSEC_SRTP_PROTECTION_PROFILES = ^_SEC_SRTP_PROTECTION_PROFILES;

type
  _SEC_SRTP_MASTER_KEY_IDENTIFIER = record
    MasterKeyIdentifierSize: UCHAR; // Size in bytes of the SRTP master key identifier
    MasterKeyIdentifier: array[0..ANYSIZE_ARRAY-1] of UCHAR; // SRTP master key identifier
  end;
  SEC_SRTP_MASTER_KEY_IDENTIFIER = _SEC_SRTP_MASTER_KEY_IDENTIFIER;
  PSEC_SRTP_MASTER_KEY_IDENTIFIER = ^_SEC_SRTP_MASTER_KEY_IDENTIFIER;

type
  _SEC_TOKEN_BINDING = record
    MajorVersion: UCHAR; // Supported major version of the Token Binding protocol
    MinorVersion: UCHAR; // Supported minor version of the Token Binding protocol
    KeyParametersSize: USHORT; // Size in bytes of the Token Binding key parameter IDs array
    KeyParameters: array[0..ANYSIZE_ARRAY-1] of UCHAR; // Token Binding key parameter IDs, most preferred first
  end;
  SEC_TOKEN_BINDING = _SEC_TOKEN_BINDING;
  PSEC_TOKEN_BINDING = ^_SEC_TOKEN_BINDING;

type
  _SEC_PRESHAREDKEY = record
    KeySize: USHORT; // Size in bytes of the PSK
    Key: array[0..ANYSIZE_ARRAY-1] of UCHAR; // PSK
  end;
  SEC_PRESHAREDKEY = _SEC_PRESHAREDKEY;
  PSEC_PRESHAREDKEY = ^_SEC_PRESHAREDKEY;

type
  _SEC_PRESHAREDKEY_IDENTITY = record
    KeyIdentitySize: USHORT; // Size in bytes of the PSK Identity
    KeyIdentity: array[0..ANYSIZE_ARRAY-1] of UCHAR; // PSK Identity
  end;
  SEC_PRESHAREDKEY_IDENTITY = _SEC_PRESHAREDKEY_IDENTITY;
  PSEC_PRESHAREDKEY_IDENTITY = ^_SEC_PRESHAREDKEY_IDENTITY;

type
  _SEC_DTLS_MTU = record
    PathMTU: USHORT; // Path MTU for the connection
  end;
  SEC_DTLS_MTU = _SEC_DTLS_MTU;
  PSEC_DTLS_MTU = ^_SEC_DTLS_MTU;

type
  _SEC_FLAGS = record
    Flags: ULONGLONG; // The caller sets ISC/ASC REQ flags; the lower 32 bits are reserved, must be set to 0.
  end;
  SEC_FLAGS = _SEC_FLAGS;
  PSEC_FLAGS = ^_SEC_FLAGS;

type
  _SEC_CERTIFICATE_REQUEST_CONTEXT = record
    cbCertificateRequestContext: UCHAR; // Size in bytes of the rgCertificateRequestContext array.
    rgCertificateRequestContext: array[0..ANYSIZE_ARRAY-1] of UCHAR; // The TLS 1.3 certificate request context.
  end;
  SEC_CERTIFICATE_REQUEST_CONTEXT = _SEC_CERTIFICATE_REQUEST_CONTEXT;
  PSEC_CERTIFICATE_REQUEST_CONTEXT = ^_SEC_CERTIFICATE_REQUEST_CONTEXT;

type
  _SEC_APP_SESSION_STATE = record
    AppSessionStateSize: USHORT; // Size in bytes of the application state, up to 2048 bytes.
    AppSessionState: array[0..ANYSIZE_ARRAY-1] of UCHAR; // Application state to be associated with the session ticket.
  end;
  SEC_APP_SESSION_STATE = _SEC_APP_SESSION_STATE;
  PSEC_APP_SESSION_STATE = ^_SEC_APP_SESSION_STATE;

type
  _SEC_SESSION_TICKET = record
    SessionTicketSize: USHORT; // Size in bytes of the session ticket.
    SessionTicket: array[0..ANYSIZE_ARRAY-1] of UCHAR; // TLS 1.3+ session ticket.
  end;
  SEC_SESSION_TICKET = _SEC_SESSION_TICKET;
  PSEC_SESSION_TICKET = ^_SEC_SESSION_TICKET;

//
// Traffic secret types:
//
type
  _SEC_TRAFFIC_SECRET_TYPE = (
    SecTrafficSecret_None,
    SecTrafficSecret_Client,
    SecTrafficSecret_Server);
  SEC_TRAFFIC_SECRET_TYPE = _SEC_TRAFFIC_SECRET_TYPE;
  PSEC_TRAFFIC_SECRET_TYPE = ^_SEC_TRAFFIC_SECRET_TYPE;

const SZ_ALG_MAX_SIZE = 64;

type
  _SEC_TRAFFIC_SECRETS = record
    SymmetricAlgId: array[0..SZ_ALG_MAX_SIZE-1] of wchar_t; // Negotiated symmetric key algorithm. e.g. BCRYPT_AES_ALGORITHM.
    ChainingMode: array[0..SZ_ALG_MAX_SIZE-1] of wchar_t; // Negotiated symmetric key algorithm chaining mode. e.g. BCRYPT_CHAIN_MODE_GCM or BCRYPT_CHAIN_MODE_CCM.
    HashAlgId: array[0..SZ_ALG_MAX_SIZE-1] of wchar_t; // Negotiated hash algorithm. e.g. BCRYPT_SHA256_ALGORITHM or BCRYPT_SHA384_ALGORITHM.
    KeySize: USHORT; // Size in bytes of the symmetric key to derive from this traffic secret.
    IvSize: USHORT; // Size in bytes of the IV to derive from this traffic secret.
    MsgSequenceStart: USHORT; // Offset of the first byte of the TLS message sequence to be protected with a key derived from TrafficSecret. Zero to indicate the first byte of the buffer.
    MsgSequenceEnd: USHORT; // Offset of the last byte of the TLS message sequence to be protected with a key derived from TrafficSecret. Zero if the secret is for the encryption of application data or decryption of incoming records.
    TrafficSecretType: SEC_TRAFFIC_SECRET_TYPE; // Type of traffic secret from the TRAFFIC_SECRET_TYPE enumeration.
    TrafficSecretSize: USHORT; // Size in bytes of the traffic secret.
    TrafficSecret: array[0..ANYSIZE_ARRAY-1] of UCHAR; // Traffic secret of type TrafficSecretType, TrafficSecretSize bytes long, used to derive write key and IV for message protection.
  end;
  SEC_TRAFFIC_SECRETS = _SEC_TRAFFIC_SECRETS;
  PSEC_TRAFFIC_SECRETS = ^_SEC_TRAFFIC_SECRETS;

//
// Data Representation Constant:
//
const SECURITY_NATIVE_DREP = $00000010;
const SECURITY_NETWORK_DREP = $00000000;

//
// Credential Use Flags
//
const SECPKG_CRED_INBOUND = $00000001;
const SECPKG_CRED_OUTBOUND = $00000002;
const SECPKG_CRED_BOTH = $00000003;
const SECPKG_CRED_DEFAULT = $00000004;
const SECPKG_CRED_RESERVED = $F0000000;

//
// SSP SHOULD prompt the user for credentials/consent, independent
// of whether credentials to be used are the 'logged on' credentials
// or retrieved from credman.
//
// An SSP may choose not to prompt, however, in circumstances determined
// by the SSP.
//

const SECPKG_CRED_AUTOLOGON_RESTRICTED = $00000010;

//
// auth will always fail, ISC() is called to process policy data only
//

const SECPKG_CRED_PROCESS_POLICY_ONLY = $00000020;

// Enables configuring Kerberos to only request tickets from a specific DC version

const SECPKG_CRED_KERB_ANCHOR_DS_VERSION = $00000040;

//
// InitializeSecurityContext Requirement and return flags:
//

const ISC_REQ_DELEGATE = $00000001;
const ISC_REQ_MUTUAL_AUTH = $00000002;
const ISC_REQ_REPLAY_DETECT = $00000004;
const ISC_REQ_SEQUENCE_DETECT = $00000008;
const ISC_REQ_CONFIDENTIALITY = $00000010;
const ISC_REQ_USE_SESSION_KEY = $00000020;
const ISC_REQ_PROMPT_FOR_CREDS = $00000040;
const ISC_REQ_USE_SUPPLIED_CREDS = $00000080;
const ISC_REQ_ALLOCATE_MEMORY = $00000100;
const ISC_REQ_USE_DCE_STYLE = $00000200;
const ISC_REQ_DATAGRAM = $00000400;
const ISC_REQ_CONNECTION = $00000800;
const ISC_REQ_CALL_LEVEL = $00001000;
const ISC_REQ_FRAGMENT_SUPPLIED = $00002000;
const ISC_REQ_EXTENDED_ERROR = $00004000;
const ISC_REQ_STREAM = $00008000;
const ISC_REQ_INTEGRITY = $00010000;
const ISC_REQ_IDENTIFY = $00020000;
const ISC_REQ_NULL_SESSION = $00040000;
const ISC_REQ_MANUAL_CRED_VALIDATION = $00080000;
const ISC_REQ_RESERVED1 = $00100000;
const ISC_REQ_FRAGMENT_TO_FIT = $00200000;
// This exists only in Windows Vista and greater
const ISC_REQ_FORWARD_CREDENTIALS = $00400000;
const ISC_REQ_NO_INTEGRITY = $00800000; // honored only by SPNEGO
const ISC_REQ_USE_HTTP_STYLE = $01000000;
const ISC_REQ_UNVERIFIED_TARGET_NAME = $20000000;
const ISC_REQ_CONFIDENTIALITY_ONLY = $40000000; // honored by SPNEGO/Kerberos
const ISC_REQ_MESSAGES = $0000000100000000; // Disables the TLS 1.3+ record layer and causes the security context to consume and produce cleartext TLS messages, rather than records.
// Request that schannel perform server cert chain validation without failing the handshake on errors (deferred),
// same as SCH_CRED_DEFERRED_CRED_VALIDATION except applies to context not credential handle.
const ISC_REQ_DEFERRED_CRED_VALIDATION = $0000000200000000;
// Prevents the client sending the post_handshake_auth extension in the TLS 1.3 Client Hello.
const ISC_REQ_NO_POST_HANDSHAKE_AUTH = $0000000400000000;
// Request TLS 1.3+ session ticket reuse. Passive observers may be able to track the TLS client across networks.
const ISC_REQ_REUSE_SESSION_TICKETS = $0000000800000000;
// Request explicit TLS 1.3+ session management. Received TLS 1.3+ session tickets will be returned to the SSPI caller.
// The SSPI caller will specify the session ticket to send in each resumption attempt.
const ISC_REQ_EXPLICIT_SESSION = $0000001000000000;

const ISC_RET_DELEGATE = $00000001;
const ISC_RET_MUTUAL_AUTH = $00000002;
const ISC_RET_REPLAY_DETECT = $00000004;
const ISC_RET_SEQUENCE_DETECT = $00000008;
const ISC_RET_CONFIDENTIALITY = $00000010;
const ISC_RET_USE_SESSION_KEY = $00000020;
const ISC_RET_USED_COLLECTED_CREDS = $00000040;
const ISC_RET_USED_SUPPLIED_CREDS = $00000080;
const ISC_RET_ALLOCATED_MEMORY = $00000100;
const ISC_RET_USED_DCE_STYLE = $00000200;
const ISC_RET_DATAGRAM = $00000400;
const ISC_RET_CONNECTION = $00000800;
const ISC_RET_INTERMEDIATE_RETURN = $00001000;
const ISC_RET_CALL_LEVEL = $00002000;
const ISC_RET_EXTENDED_ERROR = $00004000;
const ISC_RET_STREAM = $00008000;
const ISC_RET_INTEGRITY = $00010000;
const ISC_RET_IDENTIFY = $00020000;
const ISC_RET_NULL_SESSION = $00040000;
const ISC_RET_MANUAL_CRED_VALIDATION = $00080000;
const ISC_RET_RESERVED1 = $00100000;
const ISC_RET_FRAGMENT_ONLY = $00200000;
// This exists only in Windows Vista and greater
const ISC_RET_FORWARD_CREDENTIALS = $00400000;

const ISC_RET_USED_HTTP_STYLE = $01000000;
const ISC_RET_NO_ADDITIONAL_TOKEN = $02000000; // * INTERNAL *
const ISC_RET_REAUTHENTICATION = $08000000; // * INTERNAL *
const ISC_RET_CONFIDENTIALITY_ONLY = $40000000; // honored by SPNEGO/Kerberos
const ISC_RET_MESSAGES = $0000000100000000; // Indicates that the TLS 1.3+ record layer is disabled, and the security context consumes and produces cleartext TLS messages, rather than records.
const ISC_RET_DEFERRED_CRED_VALIDATION = $0000000200000000; // Indicates that SCH_CRED_DEFERRED_CRED_VALIDATION/ISC_REQ_DEFERRED_CRED_VALIDATION request will be honored.
const ISC_RET_NO_POST_HANDSHAKE_AUTH = $0000000400000000; // Indicates that the TLS 1.3 Client Hello will not contain the post_handshake_auth extension.
const ISC_RET_REUSE_SESSION_TICKETS = $0000000800000000; // Indicates that the TLS 1.3+ client may reuse session tickets.
const ISC_RET_EXPLICIT_SESSION = $0000001000000000; // Indicates that explicit TLS 1.3+ session management is enabled.

const ASC_REQ_DELEGATE = $00000001;
const ASC_REQ_MUTUAL_AUTH = $00000002;
const ASC_REQ_REPLAY_DETECT = $00000004;
const ASC_REQ_SEQUENCE_DETECT = $00000008;
const ASC_REQ_CONFIDENTIALITY = $00000010;
const ASC_REQ_USE_SESSION_KEY = $00000020;
const ASC_REQ_SESSION_TICKET = $00000040;
const ASC_REQ_ALLOCATE_MEMORY = $00000100;
const ASC_REQ_USE_DCE_STYLE = $00000200;
const ASC_REQ_DATAGRAM = $00000400;
const ASC_REQ_CONNECTION = $00000800;
const ASC_REQ_CALL_LEVEL = $00001000;
const ASC_REQ_FRAGMENT_SUPPLIED = $00002000;
const ASC_REQ_EXTENDED_ERROR = $00008000;
const ASC_REQ_STREAM = $00010000;
const ASC_REQ_INTEGRITY = $00020000;
const ASC_REQ_LICENSING = $00040000;
const ASC_REQ_IDENTIFY = $00080000;
const ASC_REQ_ALLOW_NULL_SESSION = $00100000;
const ASC_REQ_ALLOW_NON_USER_LOGONS = $00200000;
const ASC_REQ_ALLOW_CONTEXT_REPLAY = $00400000;
const ASC_REQ_FRAGMENT_TO_FIT = $00800000;

const ASC_REQ_NO_TOKEN = $01000000;
const ASC_REQ_PROXY_BINDINGS = $04000000;
// SSP_RET_REAUTHENTICATION 0x08000000 // * INTERNAL *
const ASC_REQ_ALLOW_MISSING_BINDINGS = $10000000;
const ASC_REQ_MESSAGES = $0000000100000000; // Disables the TLS 1.3+ record layer and causes the security context to consume and produce cleartext TLS messages, rather than records.
// Request explicit TLS 1.3+ session management. TLS 1.3+ session ticket will only be generated when requested by the SSPI caller.
const ASC_REQ_EXPLICIT_SESSION = $0000001000000000;

const ASC_RET_DELEGATE = $00000001;
const ASC_RET_MUTUAL_AUTH = $00000002;
const ASC_RET_REPLAY_DETECT = $00000004;
const ASC_RET_SEQUENCE_DETECT = $00000008;
const ASC_RET_CONFIDENTIALITY = $00000010;
const ASC_RET_USE_SESSION_KEY = $00000020;
const ASC_RET_SESSION_TICKET = $00000040;
const ASC_RET_ALLOCATED_MEMORY = $00000100;
const ASC_RET_USED_DCE_STYLE = $00000200;
const ASC_RET_DATAGRAM = $00000400;
const ASC_RET_CONNECTION = $00000800;
const ASC_RET_CALL_LEVEL = $00002000; // skipped 1000 to be like ISC_
const ASC_RET_THIRD_LEG_FAILED = $00004000;
const ASC_RET_EXTENDED_ERROR = $00008000;
const ASC_RET_STREAM = $00010000;
const ASC_RET_INTEGRITY = $00020000;
const ASC_RET_LICENSING = $00040000;
const ASC_RET_IDENTIFY = $00080000;
const ASC_RET_NULL_SESSION = $00100000;
const ASC_RET_ALLOW_NON_USER_LOGONS = $00200000;
const ASC_RET_ALLOW_CONTEXT_REPLAY = $00400000; // deprecated - don't use this flag!!!
const ASC_RET_FRAGMENT_ONLY = $00800000;
const ASC_RET_NO_TOKEN = $01000000;
const ASC_RET_NO_ADDITIONAL_TOKEN = $02000000; // * INTERNAL *
// SSP_RET_REAUTHENTICATION 0x08000000 // * INTERNAL *
const ASC_RET_MESSAGES = $0000000100000000; // Indicates that the TLS 1.3+ record layer is disabled, and the security context consumes and produces cleartext TLS messages, rather than records.
const ASC_RET_REUSE_SESSION_TICKETS = $0000000800000000; // Indicates that the TLS 1.3+ server will allow session ticket reuse.
const ASC_RET_EXPLICIT_SESSION = $0000001000000000; // Indicates that explicit TLS 1.3+ session management is enabled.

//
// Security Credentials Attributes:
//

const SECPKG_CRED_ATTR_NAMES = 1;
const SECPKG_CRED_ATTR_SSI_PROVIDER = 2;
const SECPKG_CRED_ATTR_KDC_PROXY_SETTINGS = 3; // aliases SECPKG_CRED_ATTR_KDC_NETWORK_SETTINGS
const SECPKG_CRED_ATTR_KDC_NETWORK_SETTINGS = 3; // aliases SECPKG_CRED_ATTR_KDC_PROXY_SETTINGS
const SECPKG_CRED_ATTR_CERT = 4;
const SECPKG_CRED_ATTR_PAC_BYPASS = 5;

type
  _SecPkgCredentials_NamesW = record
    sUserName: PSEC_WCHAR;
  end;
  SecPkgCredentials_NamesW = _SecPkgCredentials_NamesW;
  PSecPkgCredentials_NamesW = ^_SecPkgCredentials_NamesW;

// end_ntifs

type
  _SecPkgCredentials_NamesA = record
    sUserName: PSEC_CHAR;
  end;
  SecPkgCredentials_NamesA = _SecPkgCredentials_NamesA;
  PSecPkgCredentials_NamesA = ^_SecPkgCredentials_NamesA;

// #define SecPkgCredentials_Names SecPkgCredentials_NamesW // ntifs
// #define PSecPkgCredentials_Names PSecPkgCredentials_NamesW // ntifs

// begin_ntifs

type
  _SecPkgCredentials_SSIProviderW = record
    sProviderName: PSEC_WCHAR;
    ProviderInfoLength: ULONG;
    ProviderInfo: PAnsiChar;
  end;
  SecPkgCredentials_SSIProviderW = _SecPkgCredentials_SSIProviderW;
  PSecPkgCredentials_SSIProviderW = ^_SecPkgCredentials_SSIProviderW;
// end_ntifs

type
  _SecPkgCredentials_SSIProviderA = record
    sProviderName: PSEC_CHAR;
    ProviderInfoLength: ULONG;
    ProviderInfo: PAnsiChar;
  end;
  SecPkgCredentials_SSIProviderA = _SecPkgCredentials_SSIProviderA;
  PSecPkgCredentials_SSIProviderA = ^_SecPkgCredentials_SSIProviderA;

// #define SecPkgCredentials_SSIProvider SecPkgCredentials_SSIProviderW // ntifs
// #define PSecPkgCredentials_SSIProvider PSecPkgCredentials_SSIProviderW // ntifs

// begin_ntifs

const KDC_PROXY_SETTINGS_V1 = 1;
const KDC_NETWORK_SETTINGS_V2 = 2;

const KDC_PROXY_SETTINGS_FLAGS_FORCEPROXY = $1;

const KDC_NETWORK_SETTINGS_FLAGS_FORCEPROXY = $1;
const KDC_NETWORK_SETTINGS_FLAGS_CONFIGURE_PROXY = $80000000;
const KDC_NETWORK_SETTINGS_FLAGS_CONFIGURE_DISCOVERY = $40000000;

const KDC_NETWORK_DISCOVERY_FLAGS_DS13_REQUIRED = $80000000;

type
  _SecPkgCredentials_KdcProxySettingsW = record
    Version: ULONG; // KDC_PROXY_SETTINGS_V1
    Flags: ULONG; // KDC_PROXY_SETTINGS_FLAGS_ *
    ProxyServerOffset: USHORT; // ProxyServer, optional
    ProxyServerLength: USHORT;
    ClientTlsCredOffset: USHORT; // ClientTlsCred, optional
    ClientTlsCredLength: USHORT;
  end;
  SecPkgCredentials_KdcProxySettingsW = _SecPkgCredentials_KdcProxySettingsW;
  PSecPkgCredentials_KdcProxySettingsW = ^_SecPkgCredentials_KdcProxySettingsW;

type
  _SecPkgCredentials_KdcNetworkSettingsW = record
    Version: ULONG; // KDC_NETWORK_SETTINGS_V2
    Flags: ULONG; // KDC_NETWORK_SETTINGS_FLAGS_ *
    ProxyServerOffset: USHORT; // ProxyServer, optional
    ProxyServerLength: USHORT;
    ClientTlsCredOffset: USHORT; // ClientTlsCred, optional
    ClientTlsCredLength: USHORT;
    DcDiscoveryFlags: ULONG; // KDC_NETWORK_DISCOVERY_ *
  end;
  SecPkgCredentials_KdcNetworkSettingsW = _SecPkgCredentials_KdcNetworkSettingsW;
  PSecPkgCredentials_KdcNetworkSettingsW = ^_SecPkgCredentials_KdcNetworkSettingsW;

// end_ntifs

// begin_ntifs

type
  _SecPkgCredentials_Cert = record
    EncodedCertSize: ULONG;
    EncodedCert: PUCHAR;
  end;
  SecPkgCredentials_Cert = _SecPkgCredentials_Cert;
  PSecPkgCredentials_Cert = ^_SecPkgCredentials_Cert;

// end_ntifs

// begin_ntifs

//
// Security Context Attributes:
//

const SECPKG_ATTR_SIZES = 0;
const SECPKG_ATTR_NAMES = 1;
const SECPKG_ATTR_LIFESPAN = 2;
const SECPKG_ATTR_DCE_INFO = 3;
const SECPKG_ATTR_STREAM_SIZES = 4;
const SECPKG_ATTR_KEY_INFO = 5;
const SECPKG_ATTR_AUTHORITY = 6;
const SECPKG_ATTR_PROTO_INFO = 7;
const SECPKG_ATTR_PASSWORD_EXPIRY = 8;
const SECPKG_ATTR_SESSION_KEY = 9;
const SECPKG_ATTR_PACKAGE_INFO = 10;
const SECPKG_ATTR_USER_FLAGS = 11;
const SECPKG_ATTR_NEGOTIATION_INFO = 12;
const SECPKG_ATTR_NATIVE_NAMES = 13;
const SECPKG_ATTR_FLAGS = 14;
// These attributes exist only in Win XP and greater
const SECPKG_ATTR_USE_VALIDATED = 15;
const SECPKG_ATTR_CREDENTIAL_NAME = 16;
const SECPKG_ATTR_TARGET_INFORMATION = 17;
const SECPKG_ATTR_ACCESS_TOKEN = 18;
// These attributes exist only in Win2K3 and greater
const SECPKG_ATTR_TARGET = 19;
const SECPKG_ATTR_AUTHENTICATION_ID = 20;
// These attributes exist only in Win2K3SP1 and greater
const SECPKG_ATTR_LOGOFF_TIME = 21;
//
// win7 or greater
//
const SECPKG_ATTR_NEGO_KEYS = 22;
const SECPKG_ATTR_PROMPTING_NEEDED = 24;
const SECPKG_ATTR_UNIQUE_BINDINGS = 25;
const SECPKG_ATTR_ENDPOINT_BINDINGS = 26;
const SECPKG_ATTR_CLIENT_SPECIFIED_TARGET = 27;

const SECPKG_ATTR_LAST_CLIENT_TOKEN_STATUS = 30;
const SECPKG_ATTR_NEGO_PKG_INFO = 31; // contains nego info of packages
const SECPKG_ATTR_NEGO_STATUS = 32; // contains the last error
const SECPKG_ATTR_CONTEXT_DELETED = 33; // a context has been deleted

//
// win8 or greater
//
const SECPKG_ATTR_DTLS_MTU = 34;
const SECPKG_ATTR_DATAGRAM_SIZES = SECPKG_ATTR_STREAM_SIZES;

const SECPKG_ATTR_SUBJECT_SECURITY_ATTRIBUTES = 128;

//
// win8.1 or greater
//
const SECPKG_ATTR_APPLICATION_PROTOCOL = 35;

//
// win10 or greater
//
const SECPKG_ATTR_NEGOTIATED_TLS_EXTENSIONS = 36;
const SECPKG_ATTR_IS_LOOPBACK = 37; // indicates authentication to localhost

type
  _SecPkgContext_SubjectAttributes = record
    AttributeInfo: Pvoid; // contains a PAUTHZ_SECURITY_ATTRIBUTES_INFORMATION structure
  end;
  SecPkgContext_SubjectAttributes = _SecPkgContext_SubjectAttributes;
  PSecPkgContext_SubjectAttributes = ^_SecPkgContext_SubjectAttributes;

const SECPKG_ATTR_NEGO_INFO_FLAG_NO_KERBEROS = $1;
const SECPKG_ATTR_NEGO_INFO_FLAG_NO_NTLM = $2;

//
// types of credentials, used by SECPKG_ATTR_PROMPTING_NEEDED
//

type
  _SECPKG_CRED_CLASS = (
    SecPkgCredClass_None = 0, // no creds
    SecPkgCredClass_Ephemeral = 10, // logon creds
    SecPkgCredClass_PersistedGeneric = 20, // saved creds, not target specific
    SecPkgCredClass_PersistedSpecific = 30, // saved creds, target specific
    SecPkgCredClass_Explicit = 40); // explicitly supplied creds
  SECPKG_CRED_CLASS = _SECPKG_CRED_CLASS;
  PSECPKG_CRED_CLASS = ^_SECPKG_CRED_CLASS;

type
  _SecPkgContext_CredInfo = record
    CredClass: SECPKG_CRED_CLASS;
    IsPromptingNeeded: ULONG;
  end;
  SecPkgContext_CredInfo = _SecPkgContext_CredInfo;
  PSecPkgContext_CredInfo = ^_SecPkgContext_CredInfo;

type
  _SecPkgContext_NegoPackageInfo = record
    PackageMask: ULONG;
  end;
  SecPkgContext_NegoPackageInfo = _SecPkgContext_NegoPackageInfo;
  PSecPkgContext_NegoPackageInfo = ^_SecPkgContext_NegoPackageInfo;

type
  _SecPkgContext_NegoStatus = record
    LastStatus: ULONG;
  end;
  SecPkgContext_NegoStatus = _SecPkgContext_NegoStatus;
  PSecPkgContext_NegoStatus = ^_SecPkgContext_NegoStatus;

type
  _SecPkgContext_Sizes = record
    cbMaxToken: ULONG;
    cbMaxSignature: ULONG;
    cbBlockSize: ULONG;
    cbSecurityTrailer: ULONG;
  end;
  SecPkgContext_Sizes = _SecPkgContext_Sizes;
  PSecPkgContext_Sizes = ^_SecPkgContext_Sizes;

type
  _SecPkgContext_StreamSizes = record
    cbHeader: ULONG;
    cbTrailer: ULONG;
    cbMaximumMessage: ULONG;
    cBuffers: ULONG;
    cbBlockSize: ULONG;
  end;
  SecPkgContext_StreamSizes = _SecPkgContext_StreamSizes;
  PSecPkgContext_StreamSizes = ^_SecPkgContext_StreamSizes;

type SecPkgContext_DatagramSizes = SecPkgContext_StreamSizes;
type PSecPkgContext_DatagramSizes = PSecPkgContext_StreamSizes;

type
  _SecPkgContext_NamesW = record
    sUserName: PSEC_WCHAR;
  end;
  SecPkgContext_NamesW = _SecPkgContext_NamesW;
  PSecPkgContext_NamesW = ^_SecPkgContext_NamesW;

// end_ntifs

type
  _SECPKG_ATTR_LCT_STATUS = (
    SecPkgAttrLastClientTokenYes,
    SecPkgAttrLastClientTokenNo,
    SecPkgAttrLastClientTokenMaybe);
  SECPKG_ATTR_LCT_STATUS = _SECPKG_ATTR_LCT_STATUS;
  PSECPKG_ATTR_LCT_STATUS = ^_SECPKG_ATTR_LCT_STATUS;

type
  _SecPkgContext_LastClientTokenStatus = record
    LastClientTokenStatus: SECPKG_ATTR_LCT_STATUS;
  end;
  SecPkgContext_LastClientTokenStatus = _SecPkgContext_LastClientTokenStatus;
  PSecPkgContext_LastClientTokenStatus = ^_SecPkgContext_LastClientTokenStatus;

type
  _SecPkgContext_NamesA = record
    sUserName: PSEC_CHAR;
  end;
  SecPkgContext_NamesA = _SecPkgContext_NamesA;
  PSecPkgContext_NamesA = ^_SecPkgContext_NamesA;

// #define SecPkgContext_Names SecPkgContext_NamesW // ntifs
// #define PSecPkgContext_Names PSecPkgContext_NamesW // ntifs

// begin_ntifs

type
  _SecPkgContext_Lifespan = record
    tsStart: TimeStamp;
    tsExpiry: TimeStamp;
  end;
  SecPkgContext_Lifespan = _SecPkgContext_Lifespan;
  PSecPkgContext_Lifespan = ^_SecPkgContext_Lifespan;

type
  _SecPkgContext_DceInfo = record
    AuthzSvc: ULONG;
    pPac: Pvoid;
  end;
  SecPkgContext_DceInfo = _SecPkgContext_DceInfo;
  PSecPkgContext_DceInfo = ^_SecPkgContext_DceInfo;

// end_ntifs

type
  _SecPkgContext_KeyInfoA = record
    sSignatureAlgorithmName: PSEC_CHAR;
    sEncryptAlgorithmName: PSEC_CHAR;
    KeySize: ULONG;
    SignatureAlgorithm: ULONG;
    EncryptAlgorithm: ULONG;
  end;
  SecPkgContext_KeyInfoA = _SecPkgContext_KeyInfoA;
  PSecPkgContext_KeyInfoA = ^_SecPkgContext_KeyInfoA;

// begin_ntifs

type
  _SecPkgContext_KeyInfoW = record
    sSignatureAlgorithmName: PSEC_WCHAR;
    sEncryptAlgorithmName: PSEC_WCHAR;
    KeySize: ULONG;
    SignatureAlgorithm: ULONG;
    EncryptAlgorithm: ULONG;
  end;
  SecPkgContext_KeyInfoW = _SecPkgContext_KeyInfoW;
  PSecPkgContext_KeyInfoW = ^_SecPkgContext_KeyInfoW;

// end_ntifs

// #define SecPkgContext_KeyInfo SecPkgContext_KeyInfoW // ntifs
// #define PSecPkgContext_KeyInfo PSecPkgContext_KeyInfoW // ntifs

type
  _SecPkgContext_AuthorityA = record
    sAuthorityName: PSEC_CHAR;
  end;
  SecPkgContext_AuthorityA = _SecPkgContext_AuthorityA;
  PSecPkgContext_AuthorityA = ^_SecPkgContext_AuthorityA;

// begin_ntifs

type
  _SecPkgContext_AuthorityW = record
    sAuthorityName: PSEC_WCHAR;
  end;
  SecPkgContext_AuthorityW = _SecPkgContext_AuthorityW;
  PSecPkgContext_AuthorityW = ^_SecPkgContext_AuthorityW;

// end_ntifs

// #define SecPkgContext_Authority SecPkgContext_AuthorityW // ntifs
// #define PSecPkgContext_Authority PSecPkgContext_AuthorityW // ntifs

type
  _SecPkgContext_ProtoInfoA = record
    sProtocolName: PSEC_CHAR;
    majorVersion: ULONG;
    minorVersion: ULONG;
  end;
  SecPkgContext_ProtoInfoA = _SecPkgContext_ProtoInfoA;
  PSecPkgContext_ProtoInfoA = ^_SecPkgContext_ProtoInfoA;

// begin_ntifs

type
  _SecPkgContext_ProtoInfoW = record
    sProtocolName: PSEC_WCHAR;
    majorVersion: ULONG;
    minorVersion: ULONG;
  end;
  SecPkgContext_ProtoInfoW = _SecPkgContext_ProtoInfoW;
  PSecPkgContext_ProtoInfoW = ^_SecPkgContext_ProtoInfoW;

// end_ntifs

// #define SecPkgContext_ProtoInfo SecPkgContext_ProtoInfoW // ntifs
// #define PSecPkgContext_ProtoInfo PSecPkgContext_ProtoInfoW // ntifs

// begin_ntifs

type
  _SecPkgContext_PasswordExpiry = record
    tsPasswordExpires: TimeStamp;
  end;
  SecPkgContext_PasswordExpiry = _SecPkgContext_PasswordExpiry;
  PSecPkgContext_PasswordExpiry = ^_SecPkgContext_PasswordExpiry;

type
  _SecPkgContext_LogoffTime = record
    tsLogoffTime: TimeStamp;
  end;
  SecPkgContext_LogoffTime = _SecPkgContext_LogoffTime;
  PSecPkgContext_LogoffTime = ^_SecPkgContext_LogoffTime;

type
  _SecPkgContext_SessionKey = record
    SessionKeyLength: ULONG;
    SessionKey: PUCHAR;
  end;
  SecPkgContext_SessionKey = _SecPkgContext_SessionKey;
  PSecPkgContext_SessionKey = ^_SecPkgContext_SessionKey;

// used by nego2
type
  _SecPkgContext_NegoKeys = record
    KeyType: ULONG;
    KeyLength: USHORT;
    KeyValue: PUCHAR;
    VerifyKeyType: ULONG;
    VerifyKeyLength: USHORT;
    VerifyKeyValue: PUCHAR;
  end;
  SecPkgContext_NegoKeys = _SecPkgContext_NegoKeys;
  PSecPkgContext_NegoKeys = ^_SecPkgContext_NegoKeys;

type
  _SecPkgContext_PackageInfoW = record
    PackageInfo: PSecPkgInfoW;
  end;
  SecPkgContext_PackageInfoW = _SecPkgContext_PackageInfoW;
  PSecPkgContext_PackageInfoW = ^_SecPkgContext_PackageInfoW;

// end_ntifs

type
  _SecPkgContext_PackageInfoA = record
    PackageInfo: PSecPkgInfoA;
  end;
  SecPkgContext_PackageInfoA = _SecPkgContext_PackageInfoA;
  PSecPkgContext_PackageInfoA = ^_SecPkgContext_PackageInfoA;

// begin_ntifs

type
  _SecPkgContext_UserFlags = record
    UserFlags: ULONG;
  end;
  SecPkgContext_UserFlags = _SecPkgContext_UserFlags;
  PSecPkgContext_UserFlags = ^_SecPkgContext_UserFlags;

type
  _SecPkgContext_Flags = record
    Flags: ULONG;
  end;
  SecPkgContext_Flags = _SecPkgContext_Flags;
  PSecPkgContext_Flags = ^_SecPkgContext_Flags;

// end_ntifs

// #define SecPkgContext_PackageInfo SecPkgContext_PackageInfoW // ntifs
// #define PSecPkgContext_PackageInfo PSecPkgContext_PackageInfoW // ntifs

type
  _SecPkgContext_NegotiationInfoA = record
    PackageInfo: PSecPkgInfoA;
    NegotiationState: ULONG;
  end;
  SecPkgContext_NegotiationInfoA = _SecPkgContext_NegotiationInfoA;
  PSecPkgContext_NegotiationInfoA = ^_SecPkgContext_NegotiationInfoA;

// begin_ntifs
type
  _SecPkgContext_NegotiationInfoW = record
    PackageInfo: PSecPkgInfoW;
    NegotiationState: ULONG;
  end;
  SecPkgContext_NegotiationInfoW = _SecPkgContext_NegotiationInfoW;
  PSecPkgContext_NegotiationInfoW = ^_SecPkgContext_NegotiationInfoW;

// end_ntifs

// #define SecPkgContext_NegotiationInfo SecPkgContext_NegotiationInfoW
// #define PSecPkgContext_NegotiationInfo PSecPkgContext_NegotiationInfoW

const SECPKG_NEGOTIATION_COMPLETE = 0;
const SECPKG_NEGOTIATION_OPTIMISTIC = 1;
const SECPKG_NEGOTIATION_IN_PROGRESS = 2;
const SECPKG_NEGOTIATION_DIRECT = 3;
const SECPKG_NEGOTIATION_TRY_MULTICRED = 4;

type
  _SecPkgContext_NativeNamesW = record
    sClientName: PSEC_WCHAR;
    sServerName: PSEC_WCHAR;
  end;
  SecPkgContext_NativeNamesW = _SecPkgContext_NativeNamesW;
  PSecPkgContext_NativeNamesW = ^_SecPkgContext_NativeNamesW;

type
  _SecPkgContext_NativeNamesA = record
    sClientName: PSEC_CHAR;
    sServerName: PSEC_CHAR;
  end;
  SecPkgContext_NativeNamesA = _SecPkgContext_NativeNamesA;
  PSecPkgContext_NativeNamesA = ^_SecPkgContext_NativeNamesA;

// #define SecPkgContext_NativeNames SecPkgContext_NativeNamesW // ntifs
// #define PSecPkgContext_NativeNames PSecPkgContext_NativeNamesW // ntifs

// begin_ntifs

type
  _SecPkgContext_CredentialNameW = record
    CredentialType: ULONG;
    sCredentialName: PSEC_WCHAR;
  end;
  SecPkgContext_CredentialNameW = _SecPkgContext_CredentialNameW;
  PSecPkgContext_CredentialNameW = ^_SecPkgContext_CredentialNameW;

// end_ntifs

type
  _SecPkgContext_CredentialNameA = record
    CredentialType: ULONG;
    sCredentialName: PSEC_CHAR;
  end;
  SecPkgContext_CredentialNameA = _SecPkgContext_CredentialNameA;
  PSecPkgContext_CredentialNameA = ^_SecPkgContext_CredentialNameA;

// #define SecPkgContext_CredentialName SecPkgContext_CredentialNameW // ntifs
// #define PSecPkgContext_CredentialName PSecPkgContext_CredentialNameW // ntifs

type
  _SecPkgContext_AccessToken = record
    AccessToken: Pvoid;
  end;
  SecPkgContext_AccessToken = _SecPkgContext_AccessToken;
  PSecPkgContext_AccessToken = ^_SecPkgContext_AccessToken;

type
  _SecPkgContext_TargetInformation = record
    MarshalledTargetInfoLength: ULONG;
    MarshalledTargetInfo: PUCHAR;
  end;
  SecPkgContext_TargetInformation = _SecPkgContext_TargetInformation;
  PSecPkgContext_TargetInformation = ^_SecPkgContext_TargetInformation;

type
  _SecPkgContext_AuthzID = record
    AuthzIDLength: ULONG;
    AuthzID: PAnsiChar;
  end;
  SecPkgContext_AuthzID = _SecPkgContext_AuthzID;
  PSecPkgContext_AuthzID = ^_SecPkgContext_AuthzID;

type
  _SecPkgContext_Target = record
    TargetLength: ULONG;
    Target: PAnsiChar;
  end;
  SecPkgContext_Target = _SecPkgContext_Target;
  PSecPkgContext_Target = ^_SecPkgContext_Target;

type
  _SecPkgContext_ClientSpecifiedTarget = record
    sTargetName: PSEC_WCHAR;
  end;
  SecPkgContext_ClientSpecifiedTarget = _SecPkgContext_ClientSpecifiedTarget;
  PSecPkgContext_ClientSpecifiedTarget = ^_SecPkgContext_ClientSpecifiedTarget;

type
  _SecPkgContext_Bindings = record
    BindingsLength: ULONG;
    Bindings: PSEC_CHANNEL_BINDINGS;
  end;
  SecPkgContext_Bindings = _SecPkgContext_Bindings;
  PSecPkgContext_Bindings = ^_SecPkgContext_Bindings;

type
  _SEC_APPLICATION_PROTOCOL_NEGOTIATION_STATUS = (
    SecApplicationProtocolNegotiationStatus_None,
    SecApplicationProtocolNegotiationStatus_Success,
    SecApplicationProtocolNegotiationStatus_SelectedClientOnly);
  SEC_APPLICATION_PROTOCOL_NEGOTIATION_STATUS = _SEC_APPLICATION_PROTOCOL_NEGOTIATION_STATUS;
  PSEC_APPLICATION_PROTOCOL_NEGOTIATION_STATUS = ^_SEC_APPLICATION_PROTOCOL_NEGOTIATION_STATUS;

const MAX_PROTOCOL_ID_SIZE = $ff;

type
  _SecPkgContext_ApplicationProtocol = record
    ProtoNegoStatus: SEC_APPLICATION_PROTOCOL_NEGOTIATION_STATUS; // Application protocol negotiation status
    ProtoNegoExt: SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT; // Protocol negotiation extension type corresponding to this protocol ID
    ProtocolIdSize: UCHAR; // Size in bytes of the application protocol ID
    ProtocolId: array[0..MAX_PROTOCOL_ID_SIZE-1] of UCHAR; // Byte string representing the negotiated application protocol ID
  end;
  SecPkgContext_ApplicationProtocol = _SecPkgContext_ApplicationProtocol;
  PSecPkgContext_ApplicationProtocol = ^_SecPkgContext_ApplicationProtocol;

type
  _SecPkgContext_NegotiatedTlsExtensions = record
    ExtensionsCount: ULONG; // Number of negotiated TLS extensions.
    Extensions: PUSHORT; // Pointer to array of 2-byte TLS extension IDs (allocated by IANA).
  end;
  SecPkgContext_NegotiatedTlsExtensions = _SecPkgContext_NegotiatedTlsExtensions;
  PSecPkgContext_NegotiatedTlsExtensions = ^_SecPkgContext_NegotiatedTlsExtensions;

type
  _SECPKG_APP_MODE_INFO = record
    UserFunction: ULONG;
    Argument1: ULONG_PTR;
    Argument2: ULONG_PTR;
    UserData: SecBuffer;
    ReturnToLsa: ByteBool;
  end;
  SECPKG_APP_MODE_INFO = _SECPKG_APP_MODE_INFO;
  PSECPKG_APP_MODE_INFO = ^_SECPKG_APP_MODE_INFO;

// begin_ntifs

type
  SEC_GET_KEY_FN = procedure (
    Arg: Pvoid; // Argument passed in
    Principal: Pvoid; // Principal ID
    KeyVer: ULONG; // Key Version
    Key: PPvoid; // Returned ptr to key
    Status: PSECURITY_STATUS); stdcall; // returned status

//
// Flags for ExportSecurityContext
//

const SECPKG_CONTEXT_EXPORT_RESET_NEW = $00000001; // New context is reset to initial state
const SECPKG_CONTEXT_EXPORT_DELETE_OLD = $00000002; // Old context is deleted during export
// This is only valid in W2K3SP1 and greater
const SECPKG_CONTEXT_EXPORT_TO_KERNEL = $00000004; // Context is to be transferred to the kernel

function AcquireCredentialsHandleW(
           pszPrincipal: LPWSTR; // Name of principal
           pszPackage: LPWSTR; // Name of package
           fCredentialUse: ULONG; // Flags indicating use
           pvLogonId: Pvoid; // Pointer to logon ID
           pAuthData: Pvoid; // Package specific data
           pGetKeyFn: SEC_GET_KEY_FN; // Pointer to GetKey() func
           pvGetKeyArgument: Pvoid; // Value to pass to GetKey()
           phCredential: PCredHandle; // (out) Cred Handle
           ptsExpiry: PTimeStamp): SECURITY_STATUS; stdcall; external 'secur32.dll'; // (out) Lifetime (optional)

type
  ACQUIRE_CREDENTIALS_HANDLE_FN_W = function (
    param0: PSEC_WCHAR;
    param1: PSEC_WCHAR;
    param2: ULONG;
    param3: Pvoid;
    param4: Pvoid;
    param5: SEC_GET_KEY_FN;
    param6: Pvoid;
    param7: PCredHandle;
    param8: PTimeStamp): SECURITY_STATUS; stdcall;

// end_ntifs

function AcquireCredentialsHandleA(
           pszPrincipal: LPSTR; // Name of principal
           pszPackage: LPSTR; // Name of package
           fCredentialUse: ULONG; // Flags indicating use
           pvLogonId: Pvoid; // Pointer to logon ID
           pAuthData: Pvoid; // Package specific data
           pGetKeyFn: SEC_GET_KEY_FN; // Pointer to GetKey() func
           pvGetKeyArgument: Pvoid; // Value to pass to GetKey()
           phCredential: PCredHandle; // (out) Cred Handle
           ptsExpiry: PTimeStamp): SECURITY_STATUS; stdcall; external 'secur32.dll'; // (out) Lifetime (optional)

type
  ACQUIRE_CREDENTIALS_HANDLE_FN_A = function (
    param0: PSEC_CHAR;
    param1: PSEC_CHAR;
    param2: ULONG;
    param3: Pvoid;
    param4: Pvoid;
    param5: SEC_GET_KEY_FN;
    param6: Pvoid;
    param7: PCredHandle;
    param8: PTimeStamp): SECURITY_STATUS; stdcall;

// #define AcquireCredentialsHandle AcquireCredentialsHandleW // ntifs
// #define ACQUIRE_CREDENTIALS_HANDLE_FN ACQUIRE_CREDENTIALS_HANDLE_FN_W // ntifs

// begin_ntifs

function FreeCredentialsHandle(
           phCredential: PCredHandle): SECURITY_STATUS; stdcall; external 'secur32.dll'; // Handle to free

type
  FREE_CREDENTIALS_HANDLE_FN = function (
    param0: PCredHandle): SECURITY_STATUS; stdcall;

function AddCredentialsW(
           hCredentials: PCredHandle;
           pszPrincipal: LPWSTR; // Name of principal
           pszPackage: LPWSTR; // Name of package
           fCredentialUse: ULONG; // Flags indicating use
           pAuthData: Pvoid; // Package specific data
           pGetKeyFn: SEC_GET_KEY_FN; // Pointer to GetKey() func
           pvGetKeyArgument: Pvoid; // Value to pass to GetKey()
           ptsExpiry: PTimeStamp): SECURITY_STATUS; stdcall; external 'secur32.dll'; // (out) Lifetime (optional)

type
  ADD_CREDENTIALS_FN_W = function (
    param0: PCredHandle;
    param1: PSEC_WCHAR;
    param2: PSEC_WCHAR;
    param3: ULONG;
    param4: Pvoid;
    param5: SEC_GET_KEY_FN;
    param6: Pvoid;
    param7: PTimeStamp): SECURITY_STATUS; stdcall;

function AddCredentialsA(
           hCredentials: PCredHandle;
           pszPrincipal: LPSTR; // Name of principal
           pszPackage: LPSTR; // Name of package
           fCredentialUse: ULONG; // Flags indicating use
           pAuthData: Pvoid; // Package specific data
           pGetKeyFn: SEC_GET_KEY_FN; // Pointer to GetKey() func
           pvGetKeyArgument: Pvoid; // Value to pass to GetKey()
           ptsExpiry: PTimeStamp): SECURITY_STATUS; stdcall; external 'secur32.dll'; // (out) Lifetime (optional)

type
  ADD_CREDENTIALS_FN_A = function (
    param0: PCredHandle;
    param1: PSEC_CHAR;
    param2: PSEC_CHAR;
    param3: ULONG;
    param4: Pvoid;
    param5: SEC_GET_KEY_FN;
    param6: Pvoid;
    param7: PTimeStamp): SECURITY_STATUS; stdcall;

// #define AddCredentials AddCredentialsW
// #define ADD_CREDENTIALS_FN ADD_CREDENTIALS_FN_W

////////////////////////////////////////////////////////////////////////
///
/// Asynchronous interface. Kernel-only (for now).
///
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
///
/// Password Change Functions
///
////////////////////////////////////////////////////////////////////////

function ChangeAccountPasswordW(
           pszPackageName: PSEC_WCHAR;
           pszDomainName: PSEC_WCHAR;
           pszAccountName: PSEC_WCHAR;
           pszOldPassword: PSEC_WCHAR;
           pszNewPassword: PSEC_WCHAR;
           bImpersonating: ByteBool;
           dwReserved: ULONG;
           pOutput: PSecBufferDesc): SECURITY_STATUS; stdcall; external 'secur32.dll';

type
  CHANGE_PASSWORD_FN_W = function (
    param0: PSEC_WCHAR;
    param1: PSEC_WCHAR;
    param2: PSEC_WCHAR;
    param3: PSEC_WCHAR;
    param4: PSEC_WCHAR;
    param5: ByteBool;
    param6: ULONG;
    param7: PSecBufferDesc): SECURITY_STATUS; stdcall;

function ChangeAccountPasswordA(
           pszPackageName: PSEC_CHAR;
           pszDomainName: PSEC_CHAR;
           pszAccountName: PSEC_CHAR;
           pszOldPassword: PSEC_CHAR;
           pszNewPassword: PSEC_CHAR;
           bImpersonating: ByteBool;
           dwReserved: ULONG;
           pOutput: PSecBufferDesc): SECURITY_STATUS; stdcall; external 'secur32.dll';

type
  CHANGE_PASSWORD_FN_A = function (
    param0: PSEC_CHAR;
    param1: PSEC_CHAR;
    param2: PSEC_CHAR;
    param3: PSEC_CHAR;
    param4: PSEC_CHAR;
    param5: ByteBool;
    param6: ULONG;
    param7: PSecBufferDesc): SECURITY_STATUS; stdcall;

// #define ChangeAccountPassword ChangeAccountPasswordW
// #define CHANGE_PASSWORD_FN CHANGE_PASSWORD_FN_W

////////////////////////////////////////////////////////////////////////
///
/// Context Management Functions
///
////////////////////////////////////////////////////////////////////////

function InitializeSecurityContextW(
           phCredential: PCredHandle; // Cred to base context
           phContext: PCtxtHandle; // Existing context (OPT)
           pszTargetName: PSEC_WCHAR; // Name of target
           fContextReq: ULONG; // Context Requirements
           Reserved1: ULONG; // Reserved, MBZ
           TargetDataRep: ULONG; // Data rep of target
           pInput: PSecBufferDesc; // Input Buffers
           Reserved2: ULONG; // Reserved, MBZ
           phNewContext: PCtxtHandle; // (out) New Context handle
           pOutput: PSecBufferDesc; // (inout) Output Buffers
           pfContextAttr: PULONG; // (out) Context attrs
           ptsExpiry: PTimeStamp): SECURITY_STATUS; stdcall; external 'secur32.dll'; // (out) Life span (OPT)

type
  INITIALIZE_SECURITY_CONTEXT_FN_W = function (
    param0: PCredHandle;
    param1: PCtxtHandle;
    param2: PSEC_WCHAR;
    param3: ULONG;
    param4: ULONG;
    param5: ULONG;
    param6: PSecBufferDesc;
    param7: ULONG;
    param8: PCtxtHandle;
    param9: PSecBufferDesc;
    param10: PULONG;
    param11: PTimeStamp): SECURITY_STATUS; stdcall;

// end_ntifs

function InitializeSecurityContextA(
           phCredential: PCredHandle; // Cred to base context
           phContext: PCtxtHandle; // Existing context (OPT)
           pszTargetName: PSEC_CHAR; // Name of target
           fContextReq: ULONG; // Context Requirements
           Reserved1: ULONG; // Reserved, MBZ
           TargetDataRep: ULONG; // Data rep of target
           pInput: PSecBufferDesc; // Input Buffers
           Reserved2: ULONG; // Reserved, MBZ
           phNewContext: PCtxtHandle; // (out) New Context handle
           pOutput: PSecBufferDesc; // (inout) Output Buffers
           pfContextAttr: PULONG; // (out) Context attrs
           ptsExpiry: PTimeStamp): SECURITY_STATUS; stdcall; external 'secur32.dll'; // (out) Life span (OPT)

type
  INITIALIZE_SECURITY_CONTEXT_FN_A = function (
    param0: PCredHandle;
    param1: PCtxtHandle;
    param2: PSEC_CHAR;
    param3: ULONG;
    param4: ULONG;
    param5: ULONG;
    param6: PSecBufferDesc;
    param7: ULONG;
    param8: PCtxtHandle;
    param9: PSecBufferDesc;
    param10: PULONG;
    param11: PTimeStamp): SECURITY_STATUS; stdcall;

// #define InitializeSecurityContext InitializeSecurityContextW // ntifs
// #define INITIALIZE_SECURITY_CONTEXT_FN INITIALIZE_SECURITY_CONTEXT_FN_W // ntifs

// begin_ntifs

function AcceptSecurityContext(
           phCredential: PCredHandle; // Cred to base context
           phContext: PCtxtHandle; // Existing context (OPT)
           pInput: PSecBufferDesc; // Input buffer
           fContextReq: ULONG; // Context Requirements
           TargetDataRep: ULONG; // Target Data Rep
           phNewContext: PCtxtHandle; // (out) New context handle
           pOutput: PSecBufferDesc; // (inout) Output buffers
           pfContextAttr: PULONG; // (out) Context attributes
           ptsExpiry: PTimeStamp): SECURITY_STATUS; stdcall; external 'secur32.dll'; // (out) Life span (OPT)

type
  ACCEPT_SECURITY_CONTEXT_FN = function (
    param0: PCredHandle;
    param1: PCtxtHandle;
    param2: PSecBufferDesc;
    param3: ULONG;
    param4: ULONG;
    param5: PCtxtHandle;
    param6: PSecBufferDesc;
    param7: PULONG;
    param8: PTimeStamp): SECURITY_STATUS; stdcall;

function CompleteAuthToken(
           phContext: PCtxtHandle; // Context to complete
           pToken: PSecBufferDesc): SECURITY_STATUS; stdcall; external 'secur32.dll'; // Token to complete

type
  COMPLETE_AUTH_TOKEN_FN = function (
    param0: PCtxtHandle;
    param1: PSecBufferDesc): SECURITY_STATUS; stdcall;

function ImpersonateSecurityContext(
           phContext: PCtxtHandle): SECURITY_STATUS; stdcall; external 'secur32.dll'; // Context to impersonate

type
  IMPERSONATE_SECURITY_CONTEXT_FN = function (
    param0: PCtxtHandle): SECURITY_STATUS; stdcall;

function RevertSecurityContext(
           phContext: PCtxtHandle): SECURITY_STATUS; stdcall; external 'secur32.dll'; // Context from which to re

type
  REVERT_SECURITY_CONTEXT_FN = function (
    param0: PCtxtHandle): SECURITY_STATUS; stdcall;

function QuerySecurityContextToken(
           phContext: PCtxtHandle;
           Token: PPvoid): SECURITY_STATUS; stdcall; external 'secur32.dll';

type
  QUERY_SECURITY_CONTEXT_TOKEN_FN = function (
    param0: PCtxtHandle;
    param1: PPvoid): SECURITY_STATUS; stdcall;

function DeleteSecurityContext(
           phContext: PCtxtHandle): SECURITY_STATUS; stdcall; external 'secur32.dll'; // Context to delete

type
  DELETE_SECURITY_CONTEXT_FN = function (
    param0: PCtxtHandle): SECURITY_STATUS; stdcall;

function ApplyControlToken(
           phContext: PCtxtHandle; // Context to modify
           pInput: PSecBufferDesc): SECURITY_STATUS; stdcall; external 'secur32.dll'; // Input token to apply

type
  APPLY_CONTROL_TOKEN_FN = function (
    param0: PCtxtHandle;
    param1: PSecBufferDesc): SECURITY_STATUS; stdcall;

function QueryContextAttributesW(
           phContext: PCtxtHandle; // Context to query
           ulAttribute: ULONG; // Attribute to query
           pBuffer: Pvoid): SECURITY_STATUS; stdcall; external 'secur32.dll'; // Buffer for attributes

type
  QUERY_CONTEXT_ATTRIBUTES_FN_W = function (
    param0: PCtxtHandle;
    param1: ULONG;
    param2: Pvoid): SECURITY_STATUS; stdcall;

function QueryContextAttributesExW(
           phContext: PCtxtHandle; // Context to query
           ulAttribute: ULONG; // Attribute to query
           pBuffer: Pvoid; // Buffer for attributes
           cbBuffer: ULONG): SECURITY_STATUS; stdcall; external 'sspicli.dll'; // Length of buffer

type
  QUERY_CONTEXT_ATTRIBUTES_EX_FN_W = function (
    param0: PCtxtHandle;
    param1: ULONG;
    param2: Pvoid;
    param3: ULONG): SECURITY_STATUS; stdcall;

// end_ntifs

function QueryContextAttributesA(
           phContext: PCtxtHandle; // Context to query
           ulAttribute: ULONG; // Attribute to query
           pBuffer: Pvoid): SECURITY_STATUS; stdcall; external 'secur32.dll'; // Buffer for attributes

type
  QUERY_CONTEXT_ATTRIBUTES_FN_A = function (
    param0: PCtxtHandle;
    param1: ULONG;
    param2: Pvoid): SECURITY_STATUS; stdcall;

function QueryContextAttributesExA(
           phContext: PCtxtHandle; // Context to query
           ulAttribute: ULONG; // Attribute to query
           pBuffer: Pvoid; // Buffer for attributes
           cbBuffer: ULONG): SECURITY_STATUS; stdcall; external 'sspicli.dll'; // Length of buffer

type
  QUERY_CONTEXT_ATTRIBUTES_EX_FN_A = function (
    param0: PCtxtHandle;
    param1: ULONG;
    param2: Pvoid;
    param3: ULONG): SECURITY_STATUS; stdcall;

// #define QueryContextAttributes QueryContextAttributesW // ntifs
// #define QUERY_CONTEXT_ATTRIBUTES_FN QUERY_CONTEXT_ATTRIBUTES_FN_W // ntifs
// #define QueryContextAttributesEx QueryContextAttributesExW // ntifs
// #define QUERY_CONTEXT_ATTRIBUTES_EX_FN QUERY_CONTEXT_ATTRIBUTES_EX_FN_W // ntifs

// begin_ntifs

function SetContextAttributesW(
           phContext: PCtxtHandle; // Context to Set
           ulAttribute: ULONG; // Attribute to Set
           pBuffer: Pvoid; // Buffer for attributes
           cbBuffer: ULONG): SECURITY_STATUS; stdcall; external 'secur32.dll'; // Size (in bytes) of Buffer

type
  SET_CONTEXT_ATTRIBUTES_FN_W = function (
    param0: PCtxtHandle;
    param1: ULONG;
    param2: Pvoid;
    param3: ULONG): SECURITY_STATUS; stdcall;

// end_ntifs

function SetContextAttributesA(
           phContext: PCtxtHandle; // Context to Set
           ulAttribute: ULONG; // Attribute to Set
           pBuffer: Pvoid; // Buffer for attributes
           cbBuffer: ULONG): SECURITY_STATUS; stdcall; external 'secur32.dll'; // Size (in bytes) of Buffer

type
  SET_CONTEXT_ATTRIBUTES_FN_A = function (
    param0: PCtxtHandle;
    param1: ULONG;
    param2: Pvoid;
    param3: ULONG): SECURITY_STATUS; stdcall;

// #define SetContextAttributes SetContextAttributesW // ntifs
// #define SET_CONTEXT_ATTRIBUTES_FN SET_CONTEXT_ATTRIBUTES_FN_W // ntifs

// begin_ntifs

function QueryCredentialsAttributesW(
           phCredential: PCredHandle; // Credential to query
           ulAttribute: ULONG; // Attribute to query
           pBuffer: Pvoid): SECURITY_STATUS; stdcall; external 'secur32.dll'; // Buffer for attributes

type
  QUERY_CREDENTIALS_ATTRIBUTES_FN_W = function (
    param0: PCredHandle;
    param1: ULONG;
    param2: Pvoid): SECURITY_STATUS; stdcall;

function QueryCredentialsAttributesExW(
           phCredential: PCredHandle; // Credential to query
           ulAttribute: ULONG; // Attribute to query
           pBuffer: Pvoid; // Buffer for attributes
           cbBuffer: ULONG): SECURITY_STATUS; stdcall; external 'sspicli.dll'; // Length of buffer

type
  QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_W = function (
    param0: PCredHandle;
    param1: ULONG;
    param2: Pvoid;
    param3: ULONG): SECURITY_STATUS; stdcall;

// end_ntifs

function QueryCredentialsAttributesA(
           phCredential: PCredHandle; // Credential to query
           ulAttribute: ULONG; // Attribute to query
           pBuffer: Pvoid): SECURITY_STATUS; stdcall; external 'secur32.dll'; // Buffer for attributes

type
  QUERY_CREDENTIALS_ATTRIBUTES_FN_A = function (
    param0: PCredHandle;
    param1: ULONG;
    param2: Pvoid): SECURITY_STATUS; stdcall;

function QueryCredentialsAttributesExA(
           phCredential: PCredHandle; // Credential to query
           ulAttribute: ULONG; // Attribute to query
           pBuffer: Pvoid; // Buffer for attributes
           cbBuffer: ULONG): SECURITY_STATUS; stdcall; external 'sspicli.dll'; // Length of buffer

type
  QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_A = function (
    param0: PCredHandle;
    param1: ULONG;
    param2: Pvoid;
    param3: ULONG): SECURITY_STATUS; stdcall;

// #define QueryCredentialsAttributes QueryCredentialsAttributesW // ntifs
// #define QUERY_CREDENTIALS_ATTRIBUTES_FN QUERY_CREDENTIALS_ATTRIBUTES_FN_W // ntifs
// #define QueryCredentialsAttributesEx QueryCredentialsAttributesExW // ntifs
// #define QUERY_CREDENTIALS_ATTRIBUTES_EX_FN QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_W // ntifs

// begin_ntifs

function SetCredentialsAttributesW(
           phCredential: PCredHandle; // Credential to Set
           ulAttribute: ULONG; // Attribute to Set
           pBuffer: Pvoid; // Buffer for attributes
           cbBuffer: ULONG): SECURITY_STATUS; stdcall; external 'secur32.dll'; // Size (in bytes) of Buffer

type
  SET_CREDENTIALS_ATTRIBUTES_FN_W = function (
    param0: PCredHandle;
    param1: ULONG;
    param2: Pvoid;
    param3: ULONG): SECURITY_STATUS; stdcall;

// end_ntifs

function SetCredentialsAttributesA(
           phCredential: PCredHandle; // Credential to Set
           ulAttribute: ULONG; // Attribute to Set
           pBuffer: Pvoid; // Buffer for attributes
           cbBuffer: ULONG): SECURITY_STATUS; stdcall; external 'secur32.dll'; // Size (in bytes) of Buffer

type
  SET_CREDENTIALS_ATTRIBUTES_FN_A = function (
    param0: PCredHandle;
    param1: ULONG;
    param2: Pvoid;
    param3: ULONG): SECURITY_STATUS; stdcall;

// #define SetCredentialsAttributes SetCredentialsAttributesW // ntifs
// #define SET_CREDENTIALS_ATTRIBUTES_FN SET_CREDENTIALS_ATTRIBUTES_FN_W // ntifs

// begin_ntifs

function FreeContextBuffer(
           pvContextBuffer: PVOID): SECURITY_STATUS; stdcall; external 'secur32.dll'; // buffer to free

type
  FREE_CONTEXT_BUFFER_FN = function (
    param0: PVOID): SECURITY_STATUS; stdcall;

// SECURITY_STATUS
// __CALLCONV__
// SecAllocateAndSetIPAddress(
// PUCHAR lpIpAddress,
// ULONG cchIpAddress,
// int * FreeCallContext // Avoid creating a dependence on minwindef.h by replacing PBOOL with its definition int *
// );

// SECURITY_STATUS
// __CALLCONV__
// SecAllocateAndSetCallTarget(
// PUCHAR lpIpAddress,
// ULONG cchIpAddress,
// LPWSTR TargetName,
// int * FreeCallContext // Avoid creating a dependence on minwindef.h by replacing PBOOL with its definition int *
// );

// VOID
// __CALLCONV__
// SecFreeCallContext(
// VOID
// );

// end_ntifs

// begin_ntifs
///////////////////////////////////////////////////////////////////
////
//// Message Support API
////
//////////////////////////////////////////////////////////////////

function MakeSignature(
           phContext: PCtxtHandle; // Context to use
           fQOP: ULONG; // Quality of Protection
           pMessage: PSecBufferDesc; // Message to sign
           MessageSeqNo: ULONG): SECURITY_STATUS; stdcall; external 'secur32.dll'; // Message Sequence Num.

type
  MAKE_SIGNATURE_FN = function (
    param0: PCtxtHandle;
    param1: ULONG;
    param2: PSecBufferDesc;
    param3: ULONG): SECURITY_STATUS; stdcall;

function VerifySignature(
           phContext: PCtxtHandle; // Context to use
           pMessage: PSecBufferDesc; // Message to verify
           MessageSeqNo: ULONG; // Sequence Num.
           pfQOP: PULONG): SECURITY_STATUS; stdcall; external 'secur32.dll'; // QOP used

type
  VERIFY_SIGNATURE_FN = function (
    param0: PCtxtHandle;
    param1: PSecBufferDesc;
    param2: ULONG;
    param3: PULONG): SECURITY_STATUS; stdcall;

// This only exists win Win2k3 and Greater
const SECQOP_WRAP_NO_ENCRYPT = $80000001;
const SECQOP_WRAP_OOB_DATA = $40000000;

function EncryptMessage(
           phContext: PCtxtHandle;
           fQOP: ULONG;
           pMessage: PSecBufferDesc;
           MessageSeqNo: ULONG): SECURITY_STATUS; stdcall; external 'secur32.dll';

type
  ENCRYPT_MESSAGE_FN = function (
    param0: PCtxtHandle;
    param1: ULONG;
    param2: PSecBufferDesc;
    param3: ULONG): SECURITY_STATUS; stdcall;

function DecryptMessage(
           phContext: PCtxtHandle;
           pMessage: PSecBufferDesc;
           MessageSeqNo: ULONG;
           pfQOP: PULONG): SECURITY_STATUS; stdcall; external 'secur32.dll';

type
  DECRYPT_MESSAGE_FN = function (
    param0: PCtxtHandle;
    param1: PSecBufferDesc;
    param2: ULONG;
    param3: PULONG): SECURITY_STATUS; stdcall;

// end_ntifs

// begin_ntifs
///////////////////////////////////////////////////////////////////////////
////
//// Misc.
////
///////////////////////////////////////////////////////////////////////////

function EnumerateSecurityPackagesW(
           pcPackages: PULONG; // Receives num. packages
           ppPackageInfo: PPSecPkgInfoW): SECURITY_STATUS; stdcall; external 'secur32.dll'; // Receives array of info

type
  ENUMERATE_SECURITY_PACKAGES_FN_W = function (
    param0: PULONG;
    param1: PPSecPkgInfoW): SECURITY_STATUS; stdcall;

// end_ntifs

function EnumerateSecurityPackagesA(
           pcPackages: PULONG; // Receives num. packages
           ppPackageInfo: PPSecPkgInfoA): SECURITY_STATUS; stdcall; external 'secur32.dll'; // Receives array of info

type
  ENUMERATE_SECURITY_PACKAGES_FN_A = function (
    param0: PULONG;
    param1: PPSecPkgInfoA): SECURITY_STATUS; stdcall;

// #define EnumerateSecurityPackages EnumerateSecurityPackagesW // ntifs
// #define ENUMERATE_SECURITY_PACKAGES_FN ENUMERATE_SECURITY_PACKAGES_FN_W // ntifs

// begin_ntifs

function QuerySecurityPackageInfoW(
           pszPackageName: LPWSTR; // Name of package
           ppPackageInfo: PPSecPkgInfoW): SECURITY_STATUS; stdcall; external 'secur32.dll'; // Receives package info

type
  QUERY_SECURITY_PACKAGE_INFO_FN_W = function (
    param0: PSEC_WCHAR;
    param1: PPSecPkgInfoW): SECURITY_STATUS; stdcall;

// end_ntifs

function QuerySecurityPackageInfoA(
           pszPackageName: LPSTR; // Name of package
           ppPackageInfo: PPSecPkgInfoA): SECURITY_STATUS; stdcall; external 'secur32.dll'; // Receives package info

type
  QUERY_SECURITY_PACKAGE_INFO_FN_A = function (
    param0: PSEC_CHAR;
    param1: PPSecPkgInfoA): SECURITY_STATUS; stdcall;

// #define QuerySecurityPackageInfo QuerySecurityPackageInfoW // ntifs
// #define QUERY_SECURITY_PACKAGE_INFO_FN QUERY_SECURITY_PACKAGE_INFO_FN_W // ntifs

type
  _SecDelegationType = (
    SecFull,
    SecService,
    SecTree,
    SecDirectory,
    SecObject);
  SecDelegationType = _SecDelegationType;
  PSecDelegationType = ^_SecDelegationType;

// SECURITY_STATUS __CALLCONV__
// DelegateSecurityContext(
// PCtxtHandle phContext, // IN Active context to delegate
// LPSTR pszTarget,
// SecDelegationType DelegationType, // IN Type of delegation
// PTimeStamp pExpiry, // IN OPTIONAL time limit
// PSecBuffer pPackageParameters, // IN OPTIONAL package specific
// PSecBufferDesc pOutput); // OUT Token for applycontroltoken.

///////////////////////////////////////////////////////////////////////////
////
//// Proxies
////
///////////////////////////////////////////////////////////////////////////

//
// Proxies are only available on NT platforms
//

// begin_ntifs

///////////////////////////////////////////////////////////////////////////
////
//// Context export/import
////
///////////////////////////////////////////////////////////////////////////

function ExportSecurityContext(
           phContext: PCtxtHandle; // (in) context to export
           fFlags: ULONG; // (in) option flags
           pPackedContext: PSecBuffer; // (out) marshalled context
           pToken: PPvoid): SECURITY_STATUS; stdcall; external 'secur32.dll'; // (out, optional) token handle for impersonation

type
  EXPORT_SECURITY_CONTEXT_FN = function (
    param0: PCtxtHandle;
    param1: ULONG;
    param2: PSecBuffer;
    param3: PPvoid): SECURITY_STATUS; stdcall;

function ImportSecurityContextW(
           pszPackage: LPWSTR;
           pPackedContext: PSecBuffer; // (in) marshalled context
           Token: Pvoid; // (in, optional) handle to token for context
           phContext: PCtxtHandle): SECURITY_STATUS; stdcall; external 'secur32.dll'; // (out) new context handle

type
  IMPORT_SECURITY_CONTEXT_FN_W = function (
    param0: PSEC_WCHAR;
    param1: PSecBuffer;
    param2: PVOID;
    param3: PCtxtHandle): SECURITY_STATUS; stdcall;

function ImportSecurityContextA(
           pszPackage: LPSTR;
           pPackedContext: PSecBuffer; // (in) marshalled context
           Token: PVOID; // (in, optional) handle to token for context
           phContext: PCtxtHandle): SECURITY_STATUS; stdcall; external 'secur32.dll'; // (out) new context handle

type
  IMPORT_SECURITY_CONTEXT_FN_A = function (
    param0: PSEC_CHAR;
    param1: PSecBuffer;
    param2: Pvoid;
    param3: PCtxtHandle): SECURITY_STATUS; stdcall;

// #define ImportSecurityContext ImportSecurityContextW // ntifs
// #define IMPORT_SECURITY_CONTEXT_FN IMPORT_SECURITY_CONTEXT_FN_W // ntifs

// begin_ntifs

// end_ntifs

///////////////////////////////////////////////////////////////////////////////
////
//// Fast access for RPC:
////
///////////////////////////////////////////////////////////////////////////////

const SECURITY_ENTRYPOINT_ANSIW = 'InitSecurityInterfaceW';
const SECURITY_ENTRYPOINT_ANSIA = 'InitSecurityInterfaceA';
const SECURITY_ENTRYPOINTW = 'InitSecurityInterfaceW'; // ntifs
const SECURITY_ENTRYPOINTA = 'InitSecurityInterfaceA';
const SECURITY_ENTRYPOINT16 = 'INITSECURITYINTERFACEA';

const SECURITY_ENTRYPOINT = SECURITY_ENTRYPOINTW; // ntifs
const SECURITY_ENTRYPOINT_ANSI = SECURITY_ENTRYPOINT_ANSIW;

// begin_ntifs

// #define FreeCredentialHandle FreeCredentialsHandle

type
  _SECURITY_FUNCTION_TABLE_W = record
    dwVersion: ULONG;
    EnumerateSecurityPackagesW: ENUMERATE_SECURITY_PACKAGES_FN_W;
    QueryCredentialsAttributesW: QUERY_CREDENTIALS_ATTRIBUTES_FN_W;
    AcquireCredentialsHandleW: ACQUIRE_CREDENTIALS_HANDLE_FN_W;
    FreeCredentialsHandle: FREE_CREDENTIALS_HANDLE_FN;
    Reserved2: Pvoid;
    InitializeSecurityContextW: INITIALIZE_SECURITY_CONTEXT_FN_W;
    AcceptSecurityContext: ACCEPT_SECURITY_CONTEXT_FN;
    CompleteAuthToken: COMPLETE_AUTH_TOKEN_FN;
    DeleteSecurityContext: DELETE_SECURITY_CONTEXT_FN;
    ApplyControlToken: APPLY_CONTROL_TOKEN_FN;
    QueryContextAttributesW: QUERY_CONTEXT_ATTRIBUTES_FN_W;
    ImpersonateSecurityContext: IMPERSONATE_SECURITY_CONTEXT_FN;
    RevertSecurityContext: REVERT_SECURITY_CONTEXT_FN;
    MakeSignature: MAKE_SIGNATURE_FN;
    VerifySignature: VERIFY_SIGNATURE_FN;
    FreeContextBuffer: FREE_CONTEXT_BUFFER_FN;
    QuerySecurityPackageInfoW: QUERY_SECURITY_PACKAGE_INFO_FN_W;
    Reserved3: Pvoid;
    Reserved4: Pvoid;
    ExportSecurityContext: EXPORT_SECURITY_CONTEXT_FN;
    ImportSecurityContextW: IMPORT_SECURITY_CONTEXT_FN_W;
    AddCredentialsW: ADD_CREDENTIALS_FN_W;
    Reserved8: Pvoid;
    QuerySecurityContextToken: QUERY_SECURITY_CONTEXT_TOKEN_FN;
    EncryptMessage: ENCRYPT_MESSAGE_FN;
    DecryptMessage: DECRYPT_MESSAGE_FN;
    // Fields below this are available in OSes after w2k
    SetContextAttributesW: SET_CONTEXT_ATTRIBUTES_FN_W;
    // Fields below this are available in OSes after W2k3SP1
    SetCredentialsAttributesW: SET_CREDENTIALS_ATTRIBUTES_FN_W;
    ChangeAccountPasswordW: CHANGE_PASSWORD_FN_W;
    // Fields below this are available in OSes after Windows 8.1
    QueryContextAttributesExW: QUERY_CONTEXT_ATTRIBUTES_EX_FN_W;
    QueryCredentialsAttributesExW: QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_W;
  end;
  SecurityFunctionTableW = _SECURITY_FUNCTION_TABLE_W;
  PSecurityFunctionTableW = ^_SECURITY_FUNCTION_TABLE_W;

// end_ntifs

type
  _SECURITY_FUNCTION_TABLE_A = record
    dwVersion: ULONG;
    EnumerateSecurityPackagesA: ENUMERATE_SECURITY_PACKAGES_FN_A;
    QueryCredentialsAttributesA: QUERY_CREDENTIALS_ATTRIBUTES_FN_A;
    AcquireCredentialsHandleA: ACQUIRE_CREDENTIALS_HANDLE_FN_A;
    FreeCredentialHandle: FREE_CREDENTIALS_HANDLE_FN;
    Reserved2: Pvoid;
    InitializeSecurityContextA: INITIALIZE_SECURITY_CONTEXT_FN_A;
    AcceptSecurityContext: ACCEPT_SECURITY_CONTEXT_FN;
    CompleteAuthToken: COMPLETE_AUTH_TOKEN_FN;
    DeleteSecurityContext: DELETE_SECURITY_CONTEXT_FN;
    ApplyControlToken: APPLY_CONTROL_TOKEN_FN;
    QueryContextAttributesA: QUERY_CONTEXT_ATTRIBUTES_FN_A;
    ImpersonateSecurityContext: IMPERSONATE_SECURITY_CONTEXT_FN;
    RevertSecurityContext: REVERT_SECURITY_CONTEXT_FN;
    MakeSignature: MAKE_SIGNATURE_FN;
    VerifySignature: VERIFY_SIGNATURE_FN;
    FreeContextBuffer: FREE_CONTEXT_BUFFER_FN;
    QuerySecurityPackageInfoA: QUERY_SECURITY_PACKAGE_INFO_FN_A;
    Reserved3: Pvoid;
    Reserved4: Pvoid;
    ExportSecurityContext: EXPORT_SECURITY_CONTEXT_FN;
    ImportSecurityContextA: IMPORT_SECURITY_CONTEXT_FN_A;
    AddCredentialsA: ADD_CREDENTIALS_FN_A;
    Reserved8: Pvoid;
    QuerySecurityContextToken: QUERY_SECURITY_CONTEXT_TOKEN_FN;
    EncryptMessage: ENCRYPT_MESSAGE_FN;
    DecryptMessage: DECRYPT_MESSAGE_FN;
    SetContextAttributesA: SET_CONTEXT_ATTRIBUTES_FN_A;
    SetCredentialsAttributesA: SET_CREDENTIALS_ATTRIBUTES_FN_A;
    ChangeAccountPasswordA: CHANGE_PASSWORD_FN_A;
    // Fields below this are available in OSes after Windows 8.1
    QueryContextAttributesExA: QUERY_CONTEXT_ATTRIBUTES_EX_FN_A;
    QueryCredentialsAttributesExA: QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_A;
  end;
  SecurityFunctionTableA = _SECURITY_FUNCTION_TABLE_A;
  PSecurityFunctionTableA = ^_SECURITY_FUNCTION_TABLE_A;

// #define SecurityFunctionTable SecurityFunctionTableW // ntifs
// #define PSecurityFunctionTable PSecurityFunctionTableW // ntifs

// #define SECURITY_

// Function table has all routines through DecryptMessage
const SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION = 1; // ntifs

// Function table has all routines through SetContextAttributes
const SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_2 = 2; // ntifs

// Function table has all routines through SetCredentialsAttributes
const SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_3 = 3; // ntifs

// Function table has all routines through ChangeAccountPassword
const SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_4 = 4; // ntifs

// Function table has all routines through QueryCredentialsAttributesEx
const SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_5 = 5; // ntifs

function InitSecurityInterfaceA(): PSecurityFunctionTableA; stdcall; external 'secur32.dll';

type
  INIT_SECURITY_INTERFACE_A = function (): PSecurityFunctionTableA; stdcall;

// begin_ntifs

function InitSecurityInterfaceW(): PSecurityFunctionTableW; stdcall; external 'secur32.dll';

type
  INIT_SECURITY_INTERFACE_W = function (): PSecurityFunctionTableW; stdcall;

// end_ntifs

// #define InitSecurityInterface InitSecurityInterfaceW // ntifs
// #define INIT_SECURITY_INTERFACE INIT_SECURITY_INTERFACE_W // ntifs

//
// SASL Profile Support
//

function SaslEnumerateProfilesA(
           ProfileList: PLPSTR;
           ProfileCount: PULONG): SECURITY_STATUS; stdcall; external 'secur32.dll';

function SaslEnumerateProfilesW(
           ProfileList: PLPWSTR;
           ProfileCount: PULONG): SECURITY_STATUS; stdcall; external 'secur32.dll';

// #define SaslEnumerateProfiles SaslEnumerateProfilesW

function SaslGetProfilePackageA(
           ProfileName: LPSTR;
           PackageInfo: PPSecPkgInfoA): SECURITY_STATUS; stdcall; external 'secur32.dll';

function SaslGetProfilePackageW(
           ProfileName: LPWSTR;
           PackageInfo: PPSecPkgInfoW): SECURITY_STATUS; stdcall; external 'secur32.dll';

// #define SaslGetProfilePackage SaslGetProfilePackageW

function SaslIdentifyPackageA(
           pInput: PSecBufferDesc;
           PackageInfo: PPSecPkgInfoA): SECURITY_STATUS; stdcall; external 'secur32.dll';

function SaslIdentifyPackageW(
           pInput: PSecBufferDesc;
           PackageInfo: PPSecPkgInfoW): SECURITY_STATUS; stdcall; external 'secur32.dll';

// #define SaslIdentifyPackage SaslIdentifyPackageW

function SaslInitializeSecurityContextW(
           phCredential: PCredHandle; // Cred to base context
           phContext: PCtxtHandle; // Existing context (OPT)
           pszTargetName: LPWSTR; // Name of target
           fContextReq: ULONG; // Context Requirements
           Reserved1: ULONG; // Reserved, MBZ
           TargetDataRep: ULONG; // Data rep of target
           pInput: PSecBufferDesc; // Input Buffers
           Reserved2: ULONG; // Reserved, MBZ
           phNewContext: PCtxtHandle; // (out) New Context handle
           pOutput: PSecBufferDesc; // (inout) Output Buffers
           pfContextAttr: PULONG; // (out) Context attrs
           ptsExpiry: PTimeStamp): SECURITY_STATUS; stdcall; external 'secur32.dll'; // (out) Life span (OPT)

function SaslInitializeSecurityContextA(
           phCredential: PCredHandle; // Cred to base context
           phContext: PCtxtHandle; // Existing context (OPT)
           pszTargetName: LPSTR; // Name of target
           fContextReq: ULONG; // Context Requirements
           Reserved1: ULONG; // Reserved, MBZ
           TargetDataRep: ULONG; // Data rep of target
           pInput: PSecBufferDesc; // Input Buffers
           Reserved2: ULONG; // Reserved, MBZ
           phNewContext: PCtxtHandle; // (out) New Context handle
           pOutput: PSecBufferDesc; // (inout) Output Buffers
           pfContextAttr: PULONG; // (out) Context attrs
           ptsExpiry: PTimeStamp): SECURITY_STATUS; stdcall; external 'secur32.dll'; // (out) Life span (OPT)

// #define SaslInitializeSecurityContext SaslInitializeSecurityContextW

function SaslAcceptSecurityContext(
           phCredential: PCredHandle; // Cred to base context
           phContext: PCtxtHandle; // Existing context (OPT)
           pInput: PSecBufferDesc; // Input buffer
           fContextReq: ULONG; // Context Requirements
           TargetDataRep: ULONG; // Target Data Rep
           phNewContext: PCtxtHandle; // (out) New context handle
           pOutput: PSecBufferDesc; // (inout) Output buffers
           pfContextAttr: PULONG; // (out) Context attributes
           ptsExpiry: PTimeStamp): SECURITY_STATUS; stdcall; external 'secur32.dll'; // (out) Life span (OPT)

const SASL_OPTION_SEND_SIZE = 1; // Maximum size to send to peer
const SASL_OPTION_RECV_SIZE = 2; // Maximum size willing to receive
const SASL_OPTION_AUTHZ_STRING = 3; // Authorization string
const SASL_OPTION_AUTHZ_PROCESSING = 4; // Authorization string processing

type
  _SASL_AUTHZID_STATE = (
    Sasl_AuthZIDForbidden, // allow no AuthZID strings to be specified - error out (default)
    Sasl_AuthZIDProcessed); // AuthZID Strings processed by Application or SSP
  SASL_AUTHZID_STATE = _SASL_AUTHZID_STATE;

function SaslSetContextOption(
           ContextHandle: PCtxtHandle;
           Option: ULONG;
           Value: PVOID;
           Size: ULONG): SECURITY_STATUS; stdcall; external 'secur32.dll';

function SaslGetContextOption(
           ContextHandle: PCtxtHandle;
           Option: ULONG;
           Value: PVOID;
           Size: ULONG;
           Needed: PULONG): SECURITY_STATUS; stdcall; external 'secur32.dll';

//
// This is the legacy credentials structure.
// The EX version below is preferred.

// begin_ntifs

// #define _AUTH_IDENTITY_EX2_DEFINED

const SEC_WINNT_AUTH_IDENTITY_VERSION_2 = $201;

type
  _SEC_WINNT_AUTH_IDENTITY_EX2 = record
    Version: ULONG; // contains SEC_WINNT_AUTH_IDENTITY_VERSION_2
    cbHeaderLength: USHORT;
    cbStructureLength: ULONG;
    UserOffset: ULONG; // Non-NULL terminated string, unicode only
    UserLength: USHORT; // #of bytes (NOT WCHARs), not including NULL.
    DomainOffset: ULONG; // Non-NULL terminated string, unicode only
    DomainLength: USHORT; // #of bytes (NOT WCHARs), not including NULL.
    PackedCredentialsOffset: ULONG; // Non-NULL terminated string, unicode only
    PackedCredentialsLength: USHORT; // #of bytes (NOT WCHARs), not including NULL.
    Flags: ULONG;
    PackageListOffset: ULONG; // Non-NULL terminated string, unicode only
    PackageListLength: USHORT;
  end;
  SEC_WINNT_AUTH_IDENTITY_EX2 = _SEC_WINNT_AUTH_IDENTITY_EX2;
  PSEC_WINNT_AUTH_IDENTITY_EX2 = ^_SEC_WINNT_AUTH_IDENTITY_EX2;

// #define _AUTH_IDENTITY_DEFINED

//
// This was not defined in NTIFS.h for windows 2000 however
// this struct has always been there and are safe to use
// in windows 2000 and above.
//

const SEC_WINNT_AUTH_IDENTITY_ANSI = $1;
const SEC_WINNT_AUTH_IDENTITY_UNICODE = $2;

type
  _SEC_WINNT_AUTH_IDENTITY_W = record
    User: PUSHORT; // Non-NULL terminated string.
    UserLength: ULONG; // #of characters (NOT bytes), not including NULL.
    Domain: PUSHORT; // Non-NULL terminated string.
    DomainLength: ULONG; // #of characters (NOT bytes), not including NULL.
    Password: PUSHORT; // Non-NULL terminated string.
    PasswordLength: ULONG; // #of characters (NOT bytes), not including NULL.
    Flags: ULONG;
  end;
  SEC_WINNT_AUTH_IDENTITY_W = _SEC_WINNT_AUTH_IDENTITY_W;
  PSEC_WINNT_AUTH_IDENTITY_W = ^_SEC_WINNT_AUTH_IDENTITY_W;

// end_ntifs

// #define _AUTH_IDENTITY_A_DEFINED

type
  _SEC_WINNT_AUTH_IDENTITY_A = record
    User: PUCHAR; // Non-NULL terminated string.
    UserLength: ULONG; // #of characters (NOT bytes), not including NULL.
    Domain: PUCHAR; // Non-NULL terminated string.
    DomainLength: ULONG; // #of characters (NOT bytes), not including NULL.
    Password: PUCHAR; // Non-NULL terminated string.
    PasswordLength: ULONG; // #of characters (NOT bytes), not including NULL.
    Flags: ULONG;
  end;
  SEC_WINNT_AUTH_IDENTITY_A = _SEC_WINNT_AUTH_IDENTITY_A;
  PSEC_WINNT_AUTH_IDENTITY_A = ^_SEC_WINNT_AUTH_IDENTITY_A;

// #define SEC_WINNT_AUTH_IDENTITY SEC_WINNT_AUTH_IDENTITY_W // ntifs
// #define PSEC_WINNT_AUTH_IDENTITY PSEC_WINNT_AUTH_IDENTITY_W // ntifs
// #define _SEC_WINNT_AUTH_IDENTITY _SEC_WINNT_AUTH_IDENTITY_W // ntifs

// begin_ntifs

//
// This is the combined authentication identity structure that may be
// used with the negotiate package, NTLM, Kerberos, or SCHANNEL
//

const SEC_WINNT_AUTH_IDENTITY_VERSION = $200;

type
  _SEC_WINNT_AUTH_IDENTITY_EXW = record
    Version: ULONG;
    Length: ULONG;
    User: PUSHORT; // Non-NULL terminated string.
    UserLength: ULONG; // #of characters (NOT bytes), not including NULL.
    Domain: PUSHORT; // Non-NULL terminated string.
    DomainLength: ULONG; // #of characters (NOT bytes), not including NULL.
    Password: PUSHORT; // Non-NULL terminated string.
    PasswordLength: ULONG; // #of characters (NOT bytes), not including NULL.
    Flags: ULONG;
    PackageList: PUSHORT;
    PackageListLength: ULONG;
  end;
  SEC_WINNT_AUTH_IDENTITY_EXW = _SEC_WINNT_AUTH_IDENTITY_EXW;
  PSEC_WINNT_AUTH_IDENTITY_EXW = ^_SEC_WINNT_AUTH_IDENTITY_EXW;

// end_ntifs

type
  _SEC_WINNT_AUTH_IDENTITY_EXA = record
    Version: ULONG;
    Length: ULONG;
    User: PUCHAR; // Non-NULL terminated string.
    UserLength: ULONG; // #of characters (NOT bytes), not including NULL.
    Domain: PUCHAR; // Non-NULL terminated string.
    DomainLength: ULONG; // #of characters (NOT bytes), not including NULL.
    Password: PUCHAR; // Non-NULL terminated string.
    PasswordLength: ULONG; // #of characters (NOT bytes), not including NULL.
    Flags: ULONG;
    PackageList: PUCHAR;
    PackageListLength: ULONG;
  end;
  SEC_WINNT_AUTH_IDENTITY_EXA = _SEC_WINNT_AUTH_IDENTITY_EXA;
  PSEC_WINNT_AUTH_IDENTITY_EXA = ^_SEC_WINNT_AUTH_IDENTITY_EXA;

// #define SEC_WINNT_AUTH_IDENTITY_EX SEC_WINNT_AUTH_IDENTITY_EXW // ntifs
// #define PSEC_WINNT_AUTH_IDENTITY_EX PSEC_WINNT_AUTH_IDENTITY_EXW // ntifs

// begin_ntifs

// end_ntifs

// #define _AUTH_IDENTITY_INFO_DEFINED

//
// the procedure for how to parse a SEC_WINNT_AUTH_IDENTITY_INFO structure:
//
// 1) First check the first DWORD of SEC_WINNT_AUTH_IDENTITY_INFO, if the first
// DWORD is 0x200, it is either an AuthIdExw or AuthIdExA, otherwise if the first
// DWORD is 0x201, the structure is an AuthIdEx2 structure. Otherwise the structure
// is either an AuthId_a or an AuthId_w.
//
// 2) Secondly check the flags for SEC_WINNT_AUTH_IDENTITY_ANSI or
// SEC_WINNT_AUTH_IDENTITY_UNICODE, the presence of the former means the structure
// is an ANSI structure. Otherwise, the structure is the wide version. Note that
// AuthIdEx2 does not have an ANSI version so this check does not apply to it.
//

// typedef union _SEC_WINNT_AUTH_IDENTITY_INFO
// {
// SEC_WINNT_AUTH_IDENTITY_EXW AuthIdExw;
// SEC_WINNT_AUTH_IDENTITY_EXA AuthIdExa;
// SEC_WINNT_AUTH_IDENTITY_A AuthId_a;
// SEC_WINNT_AUTH_IDENTITY_W AuthId_w;
// SEC_WINNT_AUTH_IDENTITY_EX2 AuthIdEx2;
// } SEC_WINNT_AUTH_IDENTITY_INFO, * PSEC_WINNT_AUTH_IDENTITY_INFO;

// the credential structure is encrypted via
// RtlEncryptMemory(OptionFlags = 0)
const SEC_WINNT_AUTH_IDENTITY_FLAGS_PROCESS_ENCRYPTED = $10;

// the credential structure is protected by local system via
// RtlEncryptMemory(OptionFlags=RTL_ENCRYPT_OPTION_SAME_LOGON)
const SEC_WINNT_AUTH_IDENTITY_FLAGS_SYSTEM_PROTECTED = $20;

// the credential structure is encrypted by a non-system context
// RtlEncryptMemory(OptionFlags=RTL_ENCRYPT_OPTION_SAME_LOGON)
const SEC_WINNT_AUTH_IDENTITY_FLAGS_USER_PROTECTED = $40;

// the credential structure is encrypted with
// RtlEncryptMemory(OptionFlags=RTL_ENCRYPT_OPTION_FOR_SYSTEM)
const SEC_WINNT_AUTH_IDENTITY_FLAGS_SYSTEM_ENCRYPTED = $80;

const SEC_WINNT_AUTH_IDENTITY_FLAGS_RESERVED = $10000;
const SEC_WINNT_AUTH_IDENTITY_FLAGS_NULL_USER = $20000;
const SEC_WINNT_AUTH_IDENTITY_FLAGS_NULL_DOMAIN = $40000;
const SEC_WINNT_AUTH_IDENTITY_FLAGS_ID_PROVIDER = $80000;

//
// These bits are for communication between SspiPromptForCredentials()
// and the credential providers. Do not use these bits for any other
// purpose.
//

const SEC_WINNT_AUTH_IDENTITY_FLAGS_SSPIPFC_USE_MASK = $FF000000;

//
// Instructs the credential provider to not save credentials itself
// when caller selects the "Remember my credential" checkbox.
//

const SEC_WINNT_AUTH_IDENTITY_FLAGS_SSPIPFC_CREDPROV_DO_NOT_SAVE = $80000000;

//
// Support the old name for this flag for callers that were built for earlier
// versions of the SDK.
//

const SEC_WINNT_AUTH_IDENTITY_FLAGS_SSPIPFC_SAVE_CRED_BY_CALLER = SEC_WINNT_AUTH_IDENTITY_FLAGS_SSPIPFC_CREDPROV_DO_NOT_SAVE;

//
// State of the "Remember my credentials" checkbox.
// When set, indicates checked; when cleared, indicates unchecked.
//

const SEC_WINNT_AUTH_IDENTITY_FLAGS_SSPIPFC_SAVE_CRED_CHECKED = $40000000;

//
// The "Save" checkbox is not displayed on the credential provider tiles
//

const SEC_WINNT_AUTH_IDENTITY_FLAGS_SSPIPFC_NO_CHECKBOX = $20000000;

//
// Credential providers will not attempt to prepopulate the CredUI dialog
// box with credentials retrieved from Cred Man.
//

const SEC_WINNT_AUTH_IDENTITY_FLAGS_SSPIPFC_CREDPROV_DO_NOT_LOAD = $10000000;

const SEC_WINNT_AUTH_IDENTITY_FLAGS_VALID_SSPIPFC_FLAGS = (SEC_WINNT_AUTH_IDENTITY_FLAGS_SSPIPFC_CREDPROV_DO_NOT_SAVE or SEC_WINNT_AUTH_IDENTITY_FLAGS_SSPIPFC_SAVE_CRED_CHECKED or SEC_WINNT_AUTH_IDENTITY_FLAGS_SSPIPFC_NO_CHECKBOX or SEC_WINNT_AUTH_IDENTITY_FLAGS_SSPIPFC_CREDPROV_DO_NOT_LOAD);

// begin_ntifs

type PSEC_WINNT_AUTH_IDENTITY_OPAQUE = PVOID; // the credential structure is opaque
type PPSEC_WINNT_AUTH_IDENTITY_OPAQUE = ^PSEC_WINNT_AUTH_IDENTITY_OPAQUE; // the credential structure is opaque

// end_ntifs

//
// dwFlags parameter of SspiPromptForCredentials():
//

//
// Indicates that the credentials should not be saved if
// the user selects the 'save' (or 'remember my password')
// checkbox in the credential dialog box. The location pointed
// to by the pfSave parameter indicates whether or not the user
// selected the checkbox.
//
// Note that some credential providers won't honour this flag and
// may save the credentials in a persistent manner anyway if the
// user selects the 'save' checbox.
//

const SSPIPFC_CREDPROV_DO_NOT_SAVE = $00000001;

//
// Support the old name for this flag for callers that were built for earlier
// versions of the SDK.
//

const SSPIPFC_SAVE_CRED_BY_CALLER = SSPIPFC_CREDPROV_DO_NOT_SAVE;

//
// The password and smart card credential providers will not display the
// "Remember my credentials" check box in the provider tiles.
//

const SSPIPFC_NO_CHECKBOX = $00000002;

//
// Credential providers will not attempt to prepopulate the CredUI dialog
// box with credentials retrieved from Cred Man.
//

const SSPIPFC_CREDPROV_DO_NOT_LOAD = $00000004;

//
// Credential providers along with UI Dialog will be hosted in a separate
// broker process.
//
const SSPIPFC_USE_CREDUIBROKER = $00000008;

const SSPIPFC_VALID_FLAGS = (SSPIPFC_CREDPROV_DO_NOT_SAVE or SSPIPFC_NO_CHECKBOX or SSPIPFC_CREDPROV_DO_NOT_LOAD or SSPIPFC_USE_CREDUIBROKER);

// Use SspiFreeAuthIdentity() to free the buffer returned
// in ppAuthIdentity.

// unsigned_long
// __CALLCONV__
// SspiPromptForCredentialsW(
// PCWSTR pszTargetName,
// PCREDUI_INFOW pUiInfo,
// unsigned_long dwAuthError,
// PCWSTR pszPackage,
// PSEC_WINNT_AUTH_IDENTITY_OPAQUE pInputAuthIdentity,
// PSEC_WINNT_AUTH_IDENTITY_OPAQUE * ppAuthIdentity,
// int * pfSave,
// unsigned_long dwFlags
// );

// Use SspiFreeAuthIdentity() to free the buffer returned
// in ppAuthIdentity.

// unsigned_long
// __CALLCONV__
// SspiPromptForCredentialsA(
// PCSTR pszTargetName,
// PCREDUI_INFOA pUiInfo,
// unsigned_long dwAuthError,
// PCSTR pszPackage,
// PSEC_WINNT_AUTH_IDENTITY_OPAQUE pInputAuthIdentity,
// PSEC_WINNT_AUTH_IDENTITY_OPAQUE * ppAuthIdentity,
// int * pfSave,
// unsigned_long dwFlags
// );

// #define SspiPromptForCredentials SspiPromptForCredentialsW

type
  _SEC_WINNT_AUTH_BYTE_VECTOR = record
    ByteArrayOffset: ULONG; // each element is a byte
    ByteArrayLength: USHORT; //
  end;
  SEC_WINNT_AUTH_BYTE_VECTOR = _SEC_WINNT_AUTH_BYTE_VECTOR;
  PSEC_WINNT_AUTH_BYTE_VECTOR = ^_SEC_WINNT_AUTH_BYTE_VECTOR;

type
  _SEC_WINNT_AUTH_DATA = record
    CredType: GUID;
    CredData: SEC_WINNT_AUTH_BYTE_VECTOR;
  end;
  SEC_WINNT_AUTH_DATA = _SEC_WINNT_AUTH_DATA;
  PSEC_WINNT_AUTH_DATA = ^_SEC_WINNT_AUTH_DATA;

type
  _SEC_WINNT_AUTH_PACKED_CREDENTIALS = record
    cbHeaderLength: USHORT; // the length of the header
    cbStructureLength: USHORT; // pay load length including the header
    AuthData: SEC_WINNT_AUTH_DATA;
  end;
  SEC_WINNT_AUTH_PACKED_CREDENTIALS = _SEC_WINNT_AUTH_PACKED_CREDENTIALS;
  PSEC_WINNT_AUTH_PACKED_CREDENTIALS = ^_SEC_WINNT_AUTH_PACKED_CREDENTIALS;

// {28BFC32F-10F6-4738-98D1-1AC061DF716A}
// EXTERN_C __declspec(selectany) const GUID SEC_WINNT_AUTH_DATA_TYPE_PASSWORD =
// { 0x28bfc32f, 0x10f6, 0x4738, { 0x98, 0xd1, 0x1a, 0xc0, 0x61, 0xdf, 0x71, 0x6a } };

// {235F69AD-73FB-4dbc-8203-0629E739339B}
// EXTERN_C __declspec(selectany) const GUID SEC_WINNT_AUTH_DATA_TYPE_CERT =
// { 0x235f69ad, 0x73fb, 0x4dbc, { 0x82, 0x3, 0x6, 0x29, 0xe7, 0x39, 0x33, 0x9b } };

// {7CB72412-1016-491A-8C87-4D2AA1B7DD3A}
// EXTERN_C __declspec(selectany) const GUID SEC_WINNT_AUTH_DATA_TYPE_CREDMAN_CERT =
// { 0x7cb72412, 0x1016, 0x491a, { 0x8c, 0x87, 0x4d, 0x2a, 0xa1, 0xb7, 0xdd, 0x3a } };

// {10A47879-5EBF-4B85-BD8D-C21BB4F49C8A}
// EXTERN_C __declspec(selectany) const GUID SEC_WINNT_AUTH_DATA_TYPE_NGC =
// { 0x10a47879, 0x5ebf, 0x4b85, { 0xbd, 0x8d, 0xc2, 0x1b, 0xb4, 0xf4, 0x9c, 0x8a } };

// {32E8F8D7-7871-4BCC-83C5-460F66C6135C}
// EXTERN_C __declspec(selectany) const GUID SEC_WINNT_AUTH_DATA_TYPE_FIDO =
// { 0x32e8f8d7, 0x7871, 0x4bcc, { 0x83, 0xc5, 0x46, 0xf, 0x66, 0xc6, 0x13, 0x5c } };

// {D587AAE8-F78F-4455-A112-C934BEEE7CE1}
// EXTERN_C __declspec(selectany) const GUID SEC_WINNT_AUTH_DATA_TYPE_KEYTAB =
// { 0xd587aae8, 0xf78f, 0x4455, { 0xa1, 0x12, 0xc9, 0x34, 0xbe, 0xee, 0x7c, 0xe1 } };

// {12E52E0F-6F9B-4F83-9020-9DE42B226267}
// EXTERN_C __declspec(selectany) const GUID SEC_WINNT_AUTH_DATA_TYPE_DELEGATION_TOKEN =
// { 0x12e52e0f, 0x6f9b, 0x4f83, { 0x90, 0x20, 0x9d, 0xe4, 0x2b, 0x22, 0x62, 0x67 } };

type
  _SEC_WINNT_AUTH_DATA_PASSWORD = record
    UnicodePassword: SEC_WINNT_AUTH_BYTE_VECTOR;
  end;
  SEC_WINNT_AUTH_DATA_PASSWORD = _SEC_WINNT_AUTH_DATA_PASSWORD;
  PSEC_WINNT_AUTH_DATA_PASSWORD = _SEC_WINNT_AUTH_DATA_PASSWORD;

//
// smartcard cred data
//
// {68FD9879-079C-4dfe-8281-578AADC1C100}

// EXTERN_C __declspec(selectany) const GUID SEC_WINNT_AUTH_DATA_TYPE_CSP_DATA =
// { 0x68fd9879, 0x79c, 0x4dfe, { 0x82, 0x81, 0x57, 0x8a, 0xad, 0xc1, 0xc1, 0x0 } };

// {B86C4FF3-49D7-4DC4-B560-B1163685B236}
// EXTERN_C __declspec(selectany) const GUID SEC_WINNT_AUTH_DATA_TYPE_SMARTCARD_CONTEXTS =
// { 0xb86c4ff3, 0x49d7, 0x4dc4, { 0xb5, 0x60, 0xb1, 0x16, 0x36, 0x85, 0xb2, 0x36 } };

type
  _SEC_WINNT_AUTH_CERTIFICATE_DATA = record
    cbHeaderLength: USHORT;
    cbStructureLength: USHORT;
    Certificate: SEC_WINNT_AUTH_BYTE_VECTOR;
  end;
  SEC_WINNT_AUTH_CERTIFICATE_DATA = _SEC_WINNT_AUTH_CERTIFICATE_DATA;
  PSEC_WINNT_AUTH_CERTIFICATE_DATA = ^_SEC_WINNT_AUTH_CERTIFICATE_DATA;

type
  _SEC_WINNT_AUTH_NGC_DATA = record
    LogonId: LUID;
    Flags: ULONG;
    CspInfo: SEC_WINNT_AUTH_BYTE_VECTOR;
    UserIdKeyAuthTicket: SEC_WINNT_AUTH_BYTE_VECTOR;
    DecryptionKeyName: SEC_WINNT_AUTH_BYTE_VECTOR;
    DecryptionKeyAuthTicket: SEC_WINNT_AUTH_BYTE_VECTOR;
  end;
  SEC_WINNT_AUTH_NGC_DATA = _SEC_WINNT_AUTH_NGC_DATA;
  PSEC_WINNT_AUTH_NGC_DATA = ^_SEC_WINNT_AUTH_NGC_DATA;

const NGC_DATA_FLAG_KERB_CERTIFICATE_LOGON_FLAG_CHECK_DUPLICATES = ($1); // corresponds to KERB_CERTIFICATE_LOGON_FLAG_CHECK_DUPLICATES
const NGC_DATA_FLAG_KERB_CERTIFICATE_LOGON_FLAG_USE_CERTIFICATE_INFO = ($2); // corresponds to KERB_CERTIFICATE_LOGON_FLAG_USE_CERTIFICATE_INFO
const NGC_DATA_FLAG_IS_SMARTCARD_DATA = ($4);
const NGC_DATA_FLAG_IS_CLOUD_TRUST_CRED = ($8); // credential should be treated as "cloud trust" - use Cloud TGTs instead of on-prem PKINIT

type
  _SEC_WINNT_AUTH_DATA_TYPE_SMARTCARD_CONTEXTS_DATA = record
    pcc: PVOID;
    hProv: PVOID;
    pwszECDHKeyName: LPWSTR; // only optionally set for ECDSA smartcards
  end;
  SEC_WINNT_AUTH_DATA_TYPE_SMARTCARD_CONTEXTS_DATA = _SEC_WINNT_AUTH_DATA_TYPE_SMARTCARD_CONTEXTS_DATA;
  PSEC_WINNT_AUTH_DATA_TYPE_SMARTCARD_CONTEXTS_DATA = ^_SEC_WINNT_AUTH_DATA_TYPE_SMARTCARD_CONTEXTS_DATA;

// FIDO cred data
type
  _SEC_WINNT_AUTH_FIDO_DATA = record
    cbHeaderLength: USHORT;
    cbStructureLength: USHORT;
    Secret: SEC_WINNT_AUTH_BYTE_VECTOR; // offsets are from the beginning of this structure
    NewSecret: SEC_WINNT_AUTH_BYTE_VECTOR;
    EncryptedNewSecret: SEC_WINNT_AUTH_BYTE_VECTOR; // For storage by cloud AP
    NetworkLogonBuffer: SEC_WINNT_AUTH_BYTE_VECTOR; // Opaque data, understood by plugin, may contain signed Nonce and other data to perform a network logon
    ulSignatureCount: ULONG64; // signature count to be stored in public cached info, required for CredProv
  end;
  SEC_WINNT_AUTH_FIDO_DATA = _SEC_WINNT_AUTH_FIDO_DATA;
  PSEC_WINNT_AUTH_FIDO_DATA = ^_SEC_WINNT_AUTH_FIDO_DATA;

type
  _SEC_WINNT_CREDUI_CONTEXT_VECTOR = record
    CredUIContextArrayOffset: ULONG; // offset starts at the beginning of
    // this structure, and each element is a SEC_WINNT_AUTH_BYTE_VECTOR that
    // describes the flat CredUI context returned by SpGetCredUIContext()
    CredUIContextCount: USHORT;
  end;
  SEC_WINNT_CREDUI_CONTEXT_VECTOR = _SEC_WINNT_CREDUI_CONTEXT_VECTOR;
  PSEC_WINNT_CREDUI_CONTEXT_VECTOR = ^_SEC_WINNT_CREDUI_CONTEXT_VECTOR;
  PPSEC_WINNT_CREDUI_CONTEXT_VECTOR = ^PSEC_WINNT_CREDUI_CONTEXT_VECTOR;

type
  _SEC_WINNT_AUTH_SHORT_VECTOR = record
    ShortArrayOffset: ULONG; // each element is a short
    ShortArrayCount: USHORT; // number of characters
  end;
  SEC_WINNT_AUTH_SHORT_VECTOR = _SEC_WINNT_AUTH_SHORT_VECTOR;
  PSEC_WINNT_AUTH_SHORT_VECTOR = ^_SEC_WINNT_AUTH_SHORT_VECTOR;

// free the returned memory using SspiLocalFree

// SECURITY_STATUS
// __CALLCONV__
// SspiGetCredUIContext(
// HANDLE ContextHandle,
// GUID * CredType,
// LUID * LogonId, // use this LogonId, the caller must be localsystem to supply a logon id
// PSEC_WINNT_CREDUI_CONTEXT_VECTOR * CredUIContexts,
// HANDLE * TokenHandle
// );

// SECURITY_STATUS
// __CALLCONV__
// SspiUpdateCredentials(
// HANDLE ContextHandle,
// GUID * CredType,
// ULONG FlatCredUIContextLength,
// PUCHAR FlatCredUIContext
// );

type
  _CREDUIWIN_MARSHALED_CONTEXT = record
    StructureType: GUID;
    cbHeaderLength: USHORT;
    LogonId: LUID; // user's logon id
    MarshaledDataType: GUID;
    MarshaledDataOffset: ULONG;
    MarshaledDataLength: USHORT;
  end;
  CREDUIWIN_MARSHALED_CONTEXT = _CREDUIWIN_MARSHALED_CONTEXT;
  PCREDUIWIN_MARSHALED_CONTEXT = ^_CREDUIWIN_MARSHALED_CONTEXT;

type
  _SEC_WINNT_CREDUI_CONTEXT = record
    cbHeaderLength: USHORT;
    CredUIContextHandle: HANDLE; // the handle to call SspiGetCredUIContext()
    UIInfo: PCREDUI_INFOW; // input from SspiPromptForCredentials()
    dwAuthError: ULONG; // the authentication error
    pInputAuthIdentity: PSEC_WINNT_AUTH_IDENTITY_OPAQUE;
    TargetName: PUNICODE_STRING;
  end;
  SEC_WINNT_CREDUI_CONTEXT = _SEC_WINNT_CREDUI_CONTEXT;
  PSEC_WINNT_CREDUI_CONTEXT = ^_SEC_WINNT_CREDUI_CONTEXT;
  PPSEC_WINNT_CREDUI_CONTEXT = ^PSEC_WINNT_CREDUI_CONTEXT;

// {3C3E93D9-D96B-49b5-94A7-458592088337}
// EXTERN_C __declspec(selectany) const GUID CREDUIWIN_STRUCTURE_TYPE_SSPIPFC =
// { 0x3c3e93d9, 0xd96b, 0x49b5, { 0x94, 0xa7, 0x45, 0x85, 0x92, 0x8, 0x83, 0x37 } };

// {C2FFFE6F-503D-4c3d-A95E-BCE821213D44}
// EXTERN_C __declspec(selectany) const GUID SSPIPFC_STRUCTURE_TYPE_CREDUI_CONTEXT =
// { 0xc2fffe6f, 0x503d, 0x4c3d, { 0xa9, 0x5e, 0xbc, 0xe8, 0x21, 0x21, 0x3d, 0x44 } };

type
  _SEC_WINNT_AUTH_PACKED_CREDENTIALS_EX = record
    cbHeaderLength: USHORT;
    Flags: ULONG; // contains the Flags field in
    // SEC_WINNT_AUTH_IDENTITY_EX
    PackedCredentials: SEC_WINNT_AUTH_BYTE_VECTOR;
    PackageList: SEC_WINNT_AUTH_SHORT_VECTOR;
  end;
  SEC_WINNT_AUTH_PACKED_CREDENTIALS_EX = _SEC_WINNT_AUTH_PACKED_CREDENTIALS_EX;
  PSEC_WINNT_AUTH_PACKED_CREDENTIALS_EX = ^_SEC_WINNT_AUTH_PACKED_CREDENTIALS_EX;

//
// free the returned memory using SspiLocalFree
//

// SECURITY_STATUS
// __CALLCONV__
// SspiUnmarshalCredUIContext(
// PUCHAR MarshaledCredUIContext,
// ULONG MarshaledCredUIContextLength,
// PSEC_WINNT_CREDUI_CONTEXT * CredUIContext
// );

function SspiPrepareForCredRead(
           AuthIdentity: PSEC_WINNT_AUTH_IDENTITY_OPAQUE;
           pszTargetName: PCWSTR;
           pCredmanCredentialType: PULONG;
           ppszCredmanTargetName: PPCWSTR): SECURITY_STATUS; stdcall; external 'secur32.dll';

function SspiPrepareForCredWrite(
           AuthIdentity: PSEC_WINNT_AUTH_IDENTITY_OPAQUE;
           pszTargetName: PCWSTR; // supply NULL for username-target credentials
           pCredmanCredentialType: PULONG;
           ppszCredmanTargetName: PPCWSTR;
           ppszCredmanUserName: PPCWSTR;
           ppCredentialBlob: PPUCHAR;
           pCredentialBlobSize: PULONG): SECURITY_STATUS; stdcall; external 'secur32.dll';

//
// Input flags for SspiEncryptAuthIdentityEx and
// SspiDecryptAuthIdentityEx functions
//

const SEC_WINNT_AUTH_IDENTITY_ENCRYPT_SAME_LOGON = $1;
const SEC_WINNT_AUTH_IDENTITY_ENCRYPT_SAME_PROCESS = $2;
const SEC_WINNT_AUTH_IDENTITY_ENCRYPT_FOR_SYSTEM = $4;

function SspiEncryptAuthIdentity(
           AuthData: PSEC_WINNT_AUTH_IDENTITY_OPAQUE): SECURITY_STATUS; stdcall; external 'secur32.dll';

function SspiEncryptAuthIdentityEx(
           Options: ULONG;
           AuthData: PSEC_WINNT_AUTH_IDENTITY_OPAQUE): SECURITY_STATUS; stdcall; external 'sspicli.dll';

function SspiDecryptAuthIdentity(
           EncryptedAuthData: PSEC_WINNT_AUTH_IDENTITY_OPAQUE): SECURITY_STATUS; stdcall; external 'secur32.dll';

function SspiDecryptAuthIdentityEx(
           Options: ULONG;
           EncryptedAuthData: PSEC_WINNT_AUTH_IDENTITY_OPAQUE): SECURITY_STATUS; stdcall; external 'sspicli.dll';

function SspiIsAuthIdentityEncrypted(
           EncryptedAuthData: PSEC_WINNT_AUTH_IDENTITY_OPAQUE): ByteBool; stdcall; external 'secur32.dll';

// begin_ntifs

//
// Convert the _OPAQUE structure passed in to the
// 3 tuple <username, domainname, 'password'>.
//
// Note: The 'strings' returned need not necessarily be
// in user recognisable form. The purpose of this API
// is to 'flatten' the _OPAQUE structure into the 3 tuple.
// User recognisable <username, domainname> can always be
// obtained by passing NULL to the pszPackedCredentialsString
// parameter.
//
// zero out the pszPackedCredentialsString then
// free the returned memory using SspiLocalFree()
//

function SspiEncodeAuthIdentityAsStrings(
           pAuthIdentity: PSEC_WINNT_AUTH_IDENTITY_OPAQUE;
           ppszUserName: PPCWSTR;
           ppszDomainName: PPCWSTR;
           ppszPackedCredentialsString: PPCWSTR): SECURITY_STATUS; stdcall; external 'secur32.dll';

function SspiValidateAuthIdentity(
           AuthData: PSEC_WINNT_AUTH_IDENTITY_OPAQUE): SECURITY_STATUS; stdcall; external 'secur32.dll';

//
// free the returned memory using SspiFreeAuthIdentity()
//

function SspiCopyAuthIdentity(
           AuthData: PSEC_WINNT_AUTH_IDENTITY_OPAQUE;
           AuthDataCopy: PPSEC_WINNT_AUTH_IDENTITY_OPAQUE): SECURITY_STATUS; stdcall; external 'secur32.dll';

//
// use only for the memory returned by SspiCopyAuthIdentity().
// Internally calls SspiZeroAuthIdentity().
//

procedure SspiFreeAuthIdentity(
            AuthData: PSEC_WINNT_AUTH_IDENTITY_OPAQUE); stdcall; external 'secur32.dll';

procedure SspiZeroAuthIdentity(
            AuthData: PSEC_WINNT_AUTH_IDENTITY_OPAQUE); stdcall; external 'secur32.dll';

procedure SspiLocalFree(
            DataBuffer: PVOID); stdcall; external 'secur32.dll';

//
// call SspiFreeAuthIdentity to free the returned AuthIdentity
// which zeroes out the credentials blob before freeing it
//

function SspiEncodeStringsAsAuthIdentity(
           pszUserName: PCWSTR;
           pszDomainName: PCWSTR;
           pszPackedCredentialsString: PCWSTR;
           ppAuthIdentity: PPSEC_WINNT_AUTH_IDENTITY_OPAQUE): SECURITY_STATUS; stdcall; external 'secur32.dll';

function SspiCompareAuthIdentities(
           AuthIdentity1: PSEC_WINNT_AUTH_IDENTITY_OPAQUE;
           AuthIdentity2: PSEC_WINNT_AUTH_IDENTITY_OPAQUE;
           SameSuppliedUser: PBOOLEAN;
           SameSuppliedIdentity: PBOOLEAN): SECURITY_STATUS; stdcall; external 'secur32.dll';

//
// zero out the returned AuthIdentityByteArray then
// free the returned memory using SspiLocalFree()
//

function SspiMarshalAuthIdentity(
           AuthIdentity: PSEC_WINNT_AUTH_IDENTITY_OPAQUE;
           AuthIdentityLength: PULONG;
           AuthIdentityByteArray: PPAnsiChar): SECURITY_STATUS; stdcall; external 'secur32.dll';

//
// free the returned auth identity using SspiFreeAuthIdentity()
//

function SspiUnmarshalAuthIdentity(
           AuthIdentityLength: ULONG;
           AuthIdentityByteArray: PAnsiChar;
           ppAuthIdentity: PPSEC_WINNT_AUTH_IDENTITY_OPAQUE): SECURITY_STATUS; stdcall; external 'secur32.dll';

// BOOLEAN
// __CALLCONV__
// SspiIsPromptingNeeded(
// unsigned_long ErrorOrNtStatus
// );

function SspiGetTargetHostName(
           pszTargetName: PCWSTR;
           pszHostName: PPWSTR): SECURITY_STATUS; stdcall; external 'secur32.dll';

function SspiExcludePackage(
           AuthIdentity: PSEC_WINNT_AUTH_IDENTITY_OPAQUE;
           pszPackageName: PCWSTR;
           ppNewAuthIdentity: PPSEC_WINNT_AUTH_IDENTITY_OPAQUE): SECURITY_STATUS; stdcall; external 'secur32.dll';

//
// Common types used by negotiable security packages
//
// These are defined after W2K
//

const SEC_WINNT_AUTH_IDENTITY_MARSHALLED = $4; // all data is in one buffer
const SEC_WINNT_AUTH_IDENTITY_ONLY = $8; // these credentials are for identity only - no PAC needed

// end_ntifs

// Set the requested flags in the channel bindings. pBindings->Bindings may change if the structure gets
// larger, but the caller's obligation to call FreeContextBuffer is unchanged.
function SspiSetChannelBindingFlags(
           pBindings: PSecPkgContext_Bindings;
           flags: ULONG): SECURITY_STATUS; stdcall; external 'sspicli.dll';

//
// Routines for manipulating packages
//

type
  _SECURITY_PACKAGE_OPTIONS = record
    Size: ULONG;
    &Type: ULONG;
    Flags: ULONG;
    SignatureSize: ULONG;
    Signature: Pvoid;
  end;
  SECURITY_PACKAGE_OPTIONS = _SECURITY_PACKAGE_OPTIONS;
  PSECURITY_PACKAGE_OPTIONS = ^_SECURITY_PACKAGE_OPTIONS;

const SECPKG_OPTIONS_TYPE_UNKNOWN = 0;
const SECPKG_OPTIONS_TYPE_LSA = 1;
const SECPKG_OPTIONS_TYPE_SSPI = 2;

const SECPKG_OPTIONS_PERMANENT = $00000001;

function AddSecurityPackageA(
           pszPackageName: LPSTR;
           pOptions: PSECURITY_PACKAGE_OPTIONS): SECURITY_STATUS; stdcall; external 'secur32.dll';

function AddSecurityPackageW(
           pszPackageName: LPWSTR;
           pOptions: PSECURITY_PACKAGE_OPTIONS): SECURITY_STATUS; stdcall; external 'secur32.dll';

// #define AddSecurityPackage AddSecurityPackageW

function DeleteSecurityPackageA(
           pszPackageName: LPSTR): SECURITY_STATUS; stdcall; external 'secur32.dll';

function DeleteSecurityPackageW(
           pszPackageName: LPWSTR): SECURITY_STATUS; stdcall; external 'secur32.dll';

// #define DeleteSecurityPackage DeleteSecurityPackageW

// begin_ntifs
// end_ntifs

implementation

end.
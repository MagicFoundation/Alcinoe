//
// This program was made originaly by http://grijjy.com/  (XmlMerge - Allen Drennan)
// for this article: https://blog.grijjy.com/2017/01/30/embed-facebook-sdk-for-android-in-your-delphi-mobile-app-part-2/
// Thanks also to Dave Nottage from https://delphiworlds.com/ for his help.
//
// The code below is following the KISS pattern (Keep it simple, stupid)
// If the app encounter something unusual or something we never see or tested then the app will
// crash and the code must be updated
//

program AndroidMerger;

{$APPTYPE CONSOLE}

{$R *.res}

{$I ..\..\..\..\Source\Alcinoe.inc}

uses
  Winapi.Windows,
  system.Generics.Collections,
  System.Classes,
  System.Types,
  System.SysUtils,
  system.Math,
  System.IOUtils,
  System.Zip,
  System.win.Registry,
  system.AnsiStrings,
  system.UITypes,
  System.Hash,
  Alcinoe.JSONDoc,
  Alcinoe.StringUtils,
  Alcinoe.Files,
  Alcinoe.HTTP.Client,
  Alcinoe.HTTP.Client.WinHTTP,
  Alcinoe.Execute,
  Alcinoe.Common,
  Alcinoe.XMLDoc,
  Alcinoe.StringList;

const
  AutoGeneratedSectionBeginSeparator: AnsiString = '============================================';
  AutoGeneratedSectionBeginText: AnsiString = 'AndroidMerger auto-generated section (BEGIN)';
  AutoGeneratedSectionEndSeparator: AnsiString = '==========================================';
  AutoGeneratedSectionEndText: AnsiString = 'AndroidMerger auto-generated section (END)';

var
  WritelnDuplicatesToSkip: TALStringListW;
  JDKDir: String;

{****************************************************************************************************}
Procedure ExpandPOM(const aPomXmlDoc: TalXmlDocument; const ALocalRepositoryBaseDir: String); forward;

{**************************************}
Procedure OverWrite(const AStr: String);
begin
  var LStdOut := GetStdHandle(STD_OUTPUT_HANDLE);
  if LStdOut = INVALID_HANDLE_VALUE then RaiseLastOsError;
  var LInfo : CONSOLE_SCREEN_BUFFER_INFO;
  if not GetConsoleScreenBufferInfo(LStdOut, LInfo) then raiseLastOsError;
  Write(#13);
  if Linfo.dwSize.X - 1 > 0 then Write(StringOfChar(' ', Linfo.dwSize.X - 1));
  Write(#13);
  if length(AStr) > Linfo.dwSize.X - 1 then System.Write(ALCopyStr(AStr, 1, Linfo.dwSize.X - 4) + '...')
  else if length(AStr) > 0 then System.Write(AStr);
end;

{****************}
Procedure WriteLN(
            const AStr: String;
            const AForegroundColor: TALConsoleColor = TALConsoleColor.ccDarkWhite;
            const ASkipDuplicates: Boolean = false); overload;
begin
  if (not ASkipDuplicates) or (WritelnDuplicatesToSkip.IndexOf(AStr) < 0) then begin
    WritelnDuplicatesToSkip.Add(AStr);
    OverWrite('');
    ALWriteln(AStr, AForegroundColor);
  end;
end;

{*************************************************************************}
procedure MakeAndroidManifestReady(Const AAndroidManifestFilename: String);
begin
  if not Tfile.Exists(AAndroidManifestFilename) then exit;
  Var LSrc := ALGetStringFromFile(AAndroidManifestFilename);
  Lsrc := ALStringReplaceA(Lsrc, '${applicationId}', 'com.embarcadero', [rfReplaceAll, RFIgnoreCase]);
  Tfile.Move(AAndroidManifestFilename, AAndroidManifestFilename + '.original');
  ALSaveStringToFile(Lsrc, AAndroidManifestFilename);
end;

{**********************************************************************************************}
procedure MergeResources(const ASrcDir: String; const ADestDir: String; const ASubPath: String);

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  function _IsXmlResourceDoc(const AFileName: String; out AXmlDoc: TALXMLDocument): Boolean;
  begin
    AXmlDoc := TALXmldocument.Create('resources');
    try
      //poPreserveWhiteSpace because some nodes contain text + <node> + text
      //ex: <string name="com_facebook_smart_login_confirmation_continue_as">Continue as <ns1:g id="user name">%1$s</ns1:g></string>
      AXmlDoc.parseOptions := [poIgnoreXMLReferences, poPreserveWhiteSpace];
      AXmlDoc.LoadFromFile(AFileName);
      if AXmlDoc.DocumentElement <> nil then begin
        Result := ALSameTextA(AXmlDoc.DocumentElement.NodeName, 'resources');
        if not result then ALFreeAndNil(AXmlDoc);
      end
      else begin
        ALFreeAndNil(AXmlDoc);
        Result := False;
      end;
    except
      ALFreeAndNil(AXmlDoc);
      Raise;
    end;
  end;

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  function _nodeIsAlreadyPresent(const aNodeToAdd: TALXMLNode; const aDestXmlDoc: TALXMLDocument): boolean;

    {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
    Procedure _removeCommentNode(const aNode: TALXMLNode);
    Begin
      if aNode.NodeType <> ntElement then exit;
      for var I := aNode.ChildNodes.Count - 1 downto 0 do begin
        var LChildNode := aNode.ChildNodes[i];
        if LChildNode.NodeType = ntComment then begin
          aNode.ChildNodes.Delete(i);
          continue;
        end;
        _removeCommentNode(LChildNode);
      end;
    End;

  begin
    if aNodeToAdd.Attributes['name'] = '' then begin
      if ALSameTextA(aNodeToAdd.NodeName, 'eat-comment') then exit(true)
      else raise Exception.Createfmt('Resource entry without name attribute'#13#10'%s',[aNodeToAdd.xml]);
    end;
    //----
    var LFoundNode := ALFindXmlNodeByNameAndAttribute(
                        aDestXmlDoc.DocumentElement, // xmlrec:TalxmlNode;
                        aNodeToAdd.NodeName, // Const NodeName: ansiString;
                        'name', aNodeToAdd.Attributes['name'], //Const AttributeName, AttributeValue: AnsiString;
                        false); // Const Recurse: Boolean = False): TalxmlNode;
    if LFoundNode = nil then exit(False);
    if LFoundNode.XML <> aNodeToAdd.xml then begin
      Var LtmpXmlDoc1 := TalXmlDocument.Create(true);
      Var LtmpXmlDoc2 := TalXmlDocument.Create(true);
      Try
        LtmpXmlDoc1.LoadFromXML(LFoundNode.xml);
        LtmpXmlDoc2.LoadFromXML(aNodeToAdd.xml);
        _removeCommentNode(LtmpXmlDoc1.DocumentElement);
        _removeCommentNode(LtmpXmlDoc2.DocumentElement);
        if LtmpXmlDoc1.DocumentElement.XML <> LtmpXmlDoc2.DocumentElement.xml then begin
          //https://www.ittybittyapps.com/blog/2020-11-06-understanding-resource-conflicts-in-android/
          //If conflicts occur between multiple AAR libraries, then the resource from the library
          //listed first in the dependencies list (toward the top of the dependencies block) is used.
          Writeln('Resource entry duplicated in XML:', TALConsoleColor.ccAqua);
          Writeln(String(LtmpXmlDoc1.DocumentElement.XML), TALConsoleColor.ccAqua);
          Writeln(String(LtmpXmlDoc2.DocumentElement.xml), TALConsoleColor.ccAqua);
        end;
      Finally
        ALFreeAndNil(LtmpXmlDoc1);
        ALFreeAndNil(LtmpXmlDoc2);
      End;
    end;
    //----
    result := true;
  end;

begin
  if not TDirectory.Exists(ASrcDir + ASubPath) then exit;
  Var LSr: TSearchRec;
  if FindFirst(ASrcDir + ASubPath + '*.*', faAnyFile, LSr) = 0 then begin
    try
      repeat

        //if it's a directory
        if (LSr.Attr and faDirectory) > 0 then begin

          //create the same directory in ADestDir
          //and recurse this function in this directory
          if (LSr.Name <> '') and (LSr.Name[low(LSr.Name)] <> '.') then begin
            TDirectory.CreateDirectory(ADestDir + ASubPath + LSr.Name + '\');
            MergeResources(ASrcDir, ADestDir, ASubPath + LSr.Name + '\');
          end;

        end

        //if it's a file
        else begin

          //it's an resource xml file
          var LSrcXmlDoc: TALXmlDocument;
          if (TPath.GetExtension(LSr.Name).ToLower = '.xml') and
             (_IsXmlResourceDoc(ASrcDir + ASubPath + LSr.Name, LSrcXmlDoc)) then begin

            var LDestXmlDoc := TALXmldocument.Create('resources');
            Try

              //-----
              var LDestXmlFileName := ADestDir + ASubPath + LSr.Name;

              //-----
              //Options := [doNodeAutoIndent] then Options := [] to add a #13#10 between the
              //<?xml version="1.0" encoding="UTF-8" standalone="yes"?><resources/>
              //poPreserveWhiteSpace because some nodes contain text + <node> + text
              //ex: <string name="com_facebook_smart_login_confirmation_continue_as">Continue as <ns1:g id="user name">%1$s</ns1:g></string>
              LDestXmlDoc.Options := [doNodeAutoIndent];
              LDestXmlDoc.Options := [];
              LDestXmlDoc.parseOptions := [poPreserveWhiteSpace, poIgnoreXMLReferences];
              if TFile.exists(LDestXmlFileName) then LDestXmlDoc.LoadFromFile(LDestXmlFileName)
              else LDestXmlDoc.DocumentElement.ChildNodes.Add(TALXmlTextNode.Create(#13#10));

              //-----
              for Var I := 0 to LSrcXmlDoc.DocumentElement.AttributeNodes.Count - 1 do begin
                Var LSrcNode := LSrcXmlDoc.DocumentElement.AttributeNodes[i];
                var LDestNode := LDestXmlDoc.DocumentElement.AttributeNodes.FindNode(LSrcNode.NodeName);
                if LDestNode = nil then LDestXmlDoc.DocumentElement.Attributes[LSrcNode.NodeName] := LSrcNode.NodeValue
                else if LSrcNode.NodeValue <> LDestNode.NodeValue then begin
                  if (LSrcNode.NodeName = 'xmlns:ns1') and (LSrcNode.NodeValue='http://schemas.android.com/tools') then continue
                  else if (LSrcNode.NodeName = 'xmlns:ns1') and (LSrcNode.NodeValue='urn:oasis:names:tc:xliff:document:1.2') then LDestXmlDoc.DocumentElement.Attributes[LSrcNode.NodeName] := LSrcNode.NodeValue
                  else raise Exception.Createfmt('Merging of documentElement attributes failed!'#13#10'%s=%s'#13#10'%s=%s', [LSrcNode.NodeName, LSrcNode.NodeValue, LDestNode.NodeName, LDestNode.NodeValue]);
                end;
              end;

              //-----
              Var i := 0;
              while i <= LSrcXmlDoc.DocumentElement.ChildNodes.Count - 1 do begin
                var LSrcNode := LSrcXmlDoc.DocumentElement.ChildNodes[i];
                //https://stackoverflow.com/questions/74385101/values-xml-with-tag-id-name-vs-item-name-type-id
                //https://stackoverflow.com/questions/74381063/found-tag-id-where-item-is-expected-with-aapt
                {$IFNDEF ALCompilerVersionSupported}
                  {$MESSAGE WARN 'Check if Delphi still use aapt (https://quality.embarcadero.com/browse/RSP-27606) and if not remove the code below'}
                {$IFEND}
                if (LSrcNode.NodeType = ntElement) and (LSrcNode.NodeName = 'id') and (LSr.Name='values.xml') then begin
                  LSrcNode.NodeName := 'item';
                  if LSrcNode.Attributes['type'] <> '' then raise Exception.Create('Error 6A259E48-8543-42B4-9DAD-B5614A490959');
                  LSrcNode.Attributes['type'] := 'id';
                end;
                //----
                if (LSrcNode.NodeType = ntElement) and (not _nodeIsAlreadyPresent(LSrcNode, LDestXmlDoc)) then begin
                  LDestXmlDoc.DocumentElement.ChildNodes.Add(TALXmlTextNode.Create('    '));
                  LDestXmlDoc.DocumentElement.ChildNodes.Add(LSrcXmlDoc.DocumentElement.ChildNodes.Extract(i));
                  LDestXmlDoc.DocumentElement.ChildNodes.Add(TALXmlTextNode.Create(#13#10));
                end
                else
                  inc(i);
              end;

              //-----
              LDestXmlDoc.SaveToFile(LDestXmlFileName);

            finally
              ALFreeAndNil(LSrcXmlDoc);
              ALFreeAndNil(LDestXmlDoc);
            End;

          end

          // not xml that we can merge so just copy the file
          else begin
            if TFile.Exists(ADestDir + ASubPath + LSr.Name) then begin
              var lStr1 := ALGetStringFromFile(ASrcDir + ASubPath + LSr.Name);
              var lStr2 := ALGetStringFromFile(ADestDir + ASubPath + LSr.Name);
              if lStr1 <> lStr2 then begin
                  //https://www.ittybittyapps.com/blog/2020-11-06-understanding-resource-conflicts-in-android/
                  //If conflicts occur between multiple AAR libraries, then the resource from the library
                  //listed first in the dependencies list (toward the top of the dependencies block) is used.
                  Writeln('Resource entry duplicated:', TALConsoleColor.ccAqua);
                  Writeln(ASrcDir + ASubPath + LSr.Name, TALConsoleColor.ccAqua);
                  Writeln(ADestDir + ASubPath + LSr.Name, TALConsoleColor.ccAqua);
              end;
            end
            else
              TFile.Copy(
                ASrcDir + ASubPath + LSr.Name,
                ADestDir + ASubPath + LSr.Name); // << Raise an Exception if the file already exist
          end;

        end;

      until FindNext(LSr) <> 0;
    finally
      FindClose(LSr);
    end;
  end;
end;

{******************************************************************}
function IsAutoGeneratedSectionBeginCommentPresentInAndroidManifest(
           const aNode: TalXmlNode;
           const aStopNode: TalXmlNode = nil): boolean;
begin
  Result := False;
  var LAutoGeneratedSectionBeginText := ' '+AutoGeneratedSectionBeginText+' ';
  for var I := 0 to aNode.ChildNodes.Count - 1 do begin
    Var LChildNode := aNode.ChildNodes[i];
    if LChildNode = aStopNode then break;
    if (LChildNode.NodeType = ntComment) and
       (LChildNode.NodeValue = LAutoGeneratedSectionBeginText) then
      exit(true);
  end;
  if aNode.ParentNode <> nil then
    result := IsAutoGeneratedSectionBeginCommentPresentInAndroidManifest(
                aNode.ParentNode,
                aNode);
end;


{*****************************}
procedure MergeAndroidManifest(
            const APackageName: AnsiString;
            const ASrcNode: TalXmlNode;
            const ADestNode: TalXmlNode;
            const ADisabledNode: TalXmlNode;
            var AMaxMinSdkVersion: integer);

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  procedure _AddAutoGeneratedSectionBeginCommentToDest;
  begin
    if not IsAutoGeneratedSectionBeginCommentPresentInAndroidManifest(ADestNode) then begin
      ADestNode.ChildNodes.Add(TALXmlCommentNode.Create(' '+AutoGeneratedSectionBeginSeparator+' '));
      ADestNode.ChildNodes.Add(TALXmlCommentNode.Create(' '+AutoGeneratedSectionBeginText+' '));
      ADestNode.ChildNodes.Add(TALXmlCommentNode.Create(' '+AutoGeneratedSectionBeginSeparator+' '));
      var LBreakLineNode := TALXmlElementNode.Create('br');
      ADestNode.ChildNodes.Add(LBreakLineNode);
      ADestNode.ChildNodes.Remove(LBreakLineNode);
    end;
  end;

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  procedure _AddPackageNameCommentToDest(const AIndex: integer = -1);
  begin
    var LPackageNameComment := ' ===== '+APackageName+' ===== ';
    if AIndex = -1 then begin
      for var I := 0 to ADestNode.ChildNodes.Count - 1 do begin
        Var LDestChildNode := ADestNode.ChildNodes[i];
        if (LDestChildNode.NodeType = ntComment) and
           (LDestChildNode.NodeValue = LPackageNameComment) then
          exit;
      end;
    end;
    ADestNode.ChildNodes.Insert(AIndex, TALXmlCommentNode.Create(LPackageNameComment));
  end;

  {~~~~~~~~~~~~~~~~~~~~~~~~}
  procedure _SwapNodeToDest(
              var ANode: TALXmlNode;
              const aKeyNodeName: AnsiString;
              const aKeyAttributeName: AnsiString;
              const aKeyAttributeValue: AnsiString); overload;
  begin

    //remove tools:targetApi
    //https://developer.android.com/studio/write/tool-attributes#toolstargetapi
    var Lidx := ANode.AttributeNodes.IndexOf('tools:targetApi');
    if Lidx >= 0 then Anode.AttributeNodes.Delete(Lidx);

    //remove tools:node marker
    //https://developer.android.com/studio/build/manage-manifests#merge_rule_markers
    Var LToolsNode := ANode.Attributes['tools:node'];

    //tools:node="merge"
    //Merge all attributes in this tag and all nested elements when there are no conflicts using the
    //merge conflict heuristics. This is the default behavior for elements.
    if LToolsNode='merge' then ANode.AttributeNodes.Delete('tools:node')

    //tools:node="merge-only-attributes"
    //Merge attributes in this tag only; do not merge nested elements.

    //tools:node="remove"
    //Remove this element from the merged manifest. Although it seems like you should instead just delete
    //this element, using this is necessary when you discover an element in your merged manifest that you
    //don't need, and it was provided by a lower-priority manifest file that's out of your control (such
    //as an imported library).

    //tools:node="removeAll"
    //Like tools:node="remove", but it removes all elements matching this element type (within the
    //same parent element).

    //tools:node="replace"
    //Replace the lower-priority element completely. That is, if there is a matching element in the
    //lower-priority manifest, ignore it and use this element exactly as it appears in this manifest.

    //tools:node="strict"
    //Generate a build failure any time this element in the lower-priority manifest does not exactly match it
    //in the higher-priority manifest (unless resolved by other merge rule markers). This overrides the merge
    //conflict heuristics. For example, if the lower-priority manifest simply includes an extra attribute, the
    //build fails (whereas the default behavior adds the extra attribute to the merged manifest).

    //Unhandled error
    else if LToolsNode <> '' then raise exception.Createfmt('Unknown tools:node attribute: %s', [LToolsNode]);

    //init LNodeAlreadyPresent
    var LAlreadyPresentNode: TalXmlNode;
    if (aKeyNodeName <> '') and (aKeyAttributeName <> '')  then
      LAlreadyPresentNode := ADestNode.ChildNodes.FindNode(
                               aKeyNodeName,
                               [aKeyAttributeName+'='+aKeyAttributeValue])
    else if (aKeyNodeName <> '') then
      LAlreadyPresentNode := ADestNode.ChildNodes.FindNode(aKeyNodeName)
    else
      LAlreadyPresentNode := nil;

    //init
    Var LNodeIsDisabled: boolean;
    if (ADisabledNode <> nil) and (aKeyNodeName <> '') and (aKeyAttributeName <> '')  then
      LNodeIsDisabled := ADisabledNode.ChildNodes.FindNode(
                           aKeyNodeName,
                           ['alcinoe:disabled=1',
                            aKeyAttributeName+'='+aKeyAttributeValue]) <> nil
    else if (ADisabledNode <> nil) and (aKeyNodeName <> '') then
      LNodeIsDisabled := ADisabledNode.ChildNodes.FindNode(
                           aKeyNodeName,
                           ['alcinoe:disabled=1']) <> nil
    else
      LNodeIsDisabled := false;

    //recurse if Node Already Present and if Node have childnodes
    if (LAlreadyPresentNode <> nil) then begin
      Var LpackageNameAddedToDest: Boolean := False;
      for var I := 0 to ANode.AttributeNodes.Count - 1 do begin
        if LAlreadyPresentNode.Attributes[ANode.AttributeNodes.Nodes[i].NodeName] <> ANode.AttributeNodes.Nodes[i].NodeValue then begin
          if IsAutoGeneratedSectionBeginCommentPresentInAndroidManifest(ADestNode, LAlreadyPresentNode) then begin
            if LAlreadyPresentNode.Attributes[ANode.AttributeNodes.Nodes[i].NodeName] <> '' then
              raise Exception.Createfmt('Merge conflicts#13#10%s#13#10%s', [LAlreadyPresentNode.XML, ANode.XML]);
            LAlreadyPresentNode.Attributes[ANode.AttributeNodes.Nodes[i].NodeName] := ANode.AttributeNodes.Nodes[i].NodeValue;
            if not LpackageNameAddedToDest then begin
              _AddPackageNameCommentToDest(ADestNode.ChildNodes.IndexOf(LAlreadyPresentNode));
              LpackageNameAddedToDest := True;
            end;
          end
          else begin
            //unfortunatly no way to add comment inside attributes :(
            //so just add the node with attributes as comment and let
            //the user manually update the AndroidManifest
            _AddAutoGeneratedSectionBeginCommentToDest;
            _AddPackageNameCommentToDest;
            ADestNode.ChildNodes.Add(TALXmlCommentNode.Create(' '+ANode.XML+' '));
            break;
          end;
        end;
      end;
      //--
      if (ANode.ChildNodes.Count > 0) then begin
        Var LDisabledNode: TalXmlNode;
        if ADisabledNode <> nil then LDisabledNode := ADisabledNode.ChildNodes.FindNode(ANode.NodeName)
        else LDisabledNode := nil;
        MergeAndroidManifest(
          APackageName, // const APackageName: AnsiString;
          ANode, // const ASrcNode: TalXmlNode;
          LAlreadyPresentNode, // const ADestNode: TalXmlNode;
          LDisabledNode, // const ADisabledNode: TalXmlNode);
          AMaxMinSdkVersion); // var AMaxMinSdkVersion: integer;
      end;
      ALfreeAndNil(ANode);
      exit;
    end;

    _AddAutoGeneratedSectionBeginCommentToDest;
    _AddPackageNameCommentToDest;
    if LNodeIsDisabled then begin
      ADestNode.ChildNodes.Add(TALXmlCommentNode.Create(' !! '+ANode.XML+' !! '));
      ALFreeAndNil(ANode);
    end
    else
      ADestNode.ChildNodes.Add(ANode);

  end;

  {~~~~~~~~~~~~~~~~~~~~~~~~}
  procedure _SwapNodeToDest(
              var ANode: TALXmlNode;
              const aKeyAttributeName: AnsiString;
              const aKeyAttributeValue: AnsiString); overload;
  begin
    _SwapNodeToDest(
      ANode,
      ANode.NodeName,
      aKeyAttributeName,
      aKeyAttributeValue);
  end;

begin

  //-----
  while ASrcNode.ChildNodes.Count > 0 do begin
    var LSrcChildNode := ASrcNode.ChildNodes.Extract(0);
    if (LSrcChildNode.NodeType = ntElement) then begin

      //<uses-sdk ... />
      //https://developer.android.com/guide/topics/manifest/uses-sdk-element
      if ALSameTextA(ASrcNode.NodeName, 'manifest') and
         ALSameTextA(LSrcChildNode.NodeName, 'uses-sdk') then begin
        AMaxMinSdkVersion := Max(
                               AMaxMinSdkVersion,
                               ALStrToIntdef(LSrcChildNode.Attributes['android:minSdkVersion'], 0));
      end

      //<uses-permission android:name="string" ... />
      //https://developer.android.com/guide/topics/manifest/uses-permission-element
      else if ALSameTextA(ASrcNode.NodeName, 'manifest') and
              ALSameTextA(LSrcChildNode.NodeName, 'uses-permission') then begin
        _SwapNodeToDest(
          LSrcChildNode, // const ANode: TALXmlNode;
          'android:name', // const aKeyAttributeName: AnsiString;
          LSrcChildNode.Attributes['android:name']); // const aKeyAttributeValue: AnsiString;
      end

      //<permission android:name="string" ... />
      //https://developer.android.com/guide/topics/manifest/permission-element
      else if ALSameTextA(ASrcNode.NodeName, 'manifest') and
              ALSameTextA(LSrcChildNode.NodeName, 'permission') then begin
        _SwapNodeToDest(
          LSrcChildNode, // const ANode: TALXmlNode;
          'android:name', // const aKeyAttributeName: AnsiString;
          LSrcChildNode.Attributes['android:name']); // const aKeyAttributeValue: AnsiString;
      end

      //<queries ... >
      //https://developer.android.com/guide/topics/manifest/queries-element
      else if ALSameTextA(ASrcNode.NodeName, 'manifest') and
              ALSameTextA(LSrcChildNode.NodeName, 'queries') then begin
        if (LSrcChildNode.ChildNodes.Count = 0) and (LSrcChildNode.AttributeNodes.Count = 0) then continue;
        _SwapNodeToDest(
          LSrcChildNode, // const ANode: TALXmlNode;
          '', // const aKeyAttributeName: AnsiString;
          ''); // const aKeyAttributeValue: AnsiString;
      end

      //<package android:name="string" ... />
      //https://developer.android.com/guide/topics/manifest/queries-element#package
      else if ALSameTextA(ASrcNode.NodeName, 'queries') and
              ALSameTextA(LSrcChildNode.NodeName, 'package') then begin
        _SwapNodeToDest(
          LSrcChildNode, // const ANode: TALXmlNode;
          'android:name', // const aKeyAttributeName: AnsiString;
          LSrcChildNode.Attributes['android:name']); // const aKeyAttributeValue: AnsiString;
      end

      //<intent>
      //https://developer.android.com/guide/topics/manifest/queries-element#intent
      else if ALSameTextA(ASrcNode.NodeName, 'queries') and
              ALSameTextA(LSrcChildNode.NodeName, 'intent') then begin
        //https://developer.android.com/training/package-visibility/declaring#intent-filter-signature
        //i m not sure but it's look like the same as intent-filter. The <intent> element is never
        //matched between manifests. Each is treated as unique  and is added to the common parent
        //element in the merged manifest.
        _SwapNodeToDest(
          LSrcChildNode, // const ANode: TALXmlNode;
          '', // const aKeyNodename: ansiString;
          '', // const aKeyAttributeName: AnsiString;
          ''); // const aKeyAttributeValue: AnsiString;
      end

      //<application ... >
      //https://developer.android.com/guide/topics/manifest/application-element
      else if ALSameTextA(ASrcNode.NodeName, 'manifest') and
              ALSameTextA(LSrcChildNode.NodeName, 'application') then begin
        if (LSrcChildNode.ChildNodes.Count = 0) and (LSrcChildNode.AttributeNodes.Count = 0) then continue;
        _SwapNodeToDest(
          LSrcChildNode, // const ANode: TALXmlNode;
          '', // const aKeyAttributeName: AnsiString;
          ''); // const aKeyAttributeValue: AnsiString;
      end

      //<meta-data android:name="string" ... />
      //https://developer.android.com/guide/topics/manifest/meta-data-element
      else if (ALSameTextA(ASrcNode.NodeName, 'activity') or
               ALSameTextA(ASrcNode.NodeName, 'activity-alias') or
               ALSameTextA(ASrcNode.NodeName, 'application') or
               ALSameTextA(ASrcNode.NodeName, 'provider') or
               ALSameTextA(ASrcNode.NodeName, 'receiver') or
               ALSameTextA(ASrcNode.NodeName, 'service')) and
              ALSameTextA(LSrcChildNode.NodeName, 'meta-data') then begin
        _SwapNodeToDest(
          LSrcChildNode, // const ANode: TALXmlNode;
          'android:name', // const aKeyAttributeName: AnsiString;
          LSrcChildNode.Attributes['android:name']); // const aKeyAttributeValue: AnsiString;
      end

      //<activity android:name="string" ... />
      //https://developer.android.com/guide/topics/manifest/activity-element
      else if ALSameTextA(ASrcNode.NodeName, 'application') and
              ALSameTextA(LSrcChildNode.NodeName, 'activity') then begin
        _SwapNodeToDest(
          LSrcChildNode, // const ANode: TALXmlNode;
          'android:name', // const aKeyAttributeName: AnsiString;
          LSrcChildNode.Attributes['android:name']); // const aKeyAttributeValue: AnsiString;
      end

      //<intent-filter ... />
      //https://developer.android.com/guide/topics/manifest/intent-filter-element
      else if (ALSameTextA(ASrcNode.NodeName, 'activity') or
               ALSameTextA(ASrcNode.NodeName, 'activity-alias') or
               ALSameTextA(ASrcNode.NodeName, 'service') or
               ALSameTextA(ASrcNode.NodeName, 'receiver') or
               ALSameTextA(ASrcNode.NodeName, 'provider')) and
              ALSameTextA(LSrcChildNode.NodeName, 'intent-filter') then begin
        //https://developer.android.com/studio/build/manage-manifests
        //The <intent-filter> element is never matched between manifests. Each is treated as unique
        //and is added to the common parent element in the merged manifest.
        _SwapNodeToDest(
          LSrcChildNode, // const ANode: TALXmlNode;
          '', // const aKeyNodename: ansiString;
          '', // const aKeyAttributeName: AnsiString;
          ''); // const aKeyAttributeValue: AnsiString;
      end

      //<provider android:name="string" ... />
      //https://developer.android.com/guide/topics/manifest/provider-element
      else if ALSameTextA(ASrcNode.NodeName, 'application') and
              ALSameTextA(LSrcChildNode.NodeName, 'provider') then begin
        _SwapNodeToDest(
          LSrcChildNode, // const ANode: TALXmlNode;
          'android:name', // const aKeyAttributeName: AnsiString;
          LSrcChildNode.Attributes['android:name']); // const aKeyAttributeValue: AnsiString;
      end

      //<receiver android:name="string" ... />
      //https://developer.android.com/guide/topics/manifest/receiver-element
      else if ALSameTextA(ASrcNode.NodeName, 'application') and
              ALSameTextA(LSrcChildNode.NodeName, 'receiver') then begin
        _SwapNodeToDest(
          LSrcChildNode, // const ANode: TALXmlNode;
          'android:name', // const aKeyAttributeName: AnsiString;
          LSrcChildNode.Attributes['android:name']); // const aKeyAttributeValue: AnsiString;
      end

      //<service android:name="string" ... />
      //https://developer.android.com/guide/topics/manifest/service-element
      else if ALSameTextA(ASrcNode.NodeName, 'application') and
              ALSameTextA(LSrcChildNode.NodeName, 'service') then begin
        _SwapNodeToDest(
          LSrcChildNode, // const ANode: TALXmlNode;
          'android:name', // const aKeyAttributeName: AnsiString;
          LSrcChildNode.Attributes['android:name']); // const aKeyAttributeValue: AnsiString;
      end

      //<uses-library android:name="string" ... />
      //https://developer.android.com/guide/topics/manifest/uses-library-element
      else if ALSameTextA(ASrcNode.NodeName, 'application') and
              ALSameTextA(LSrcChildNode.NodeName, 'uses-library') then begin
        _SwapNodeToDest(
          LSrcChildNode, // const ANode: TALXmlNode;
          'android:name', // const aKeyAttributeName: AnsiString;
          LSrcChildNode.Attributes['android:name']); // const aKeyAttributeValue: AnsiString;
      end

      //Unknown node
      else begin
        raise Exception.Createfmt('Unknown node. Please update the source code'#13#10'%s'#13#10'%s', [ASrcNode.nodename, LSrcChildNode.XML]);
      end;

    end
    else
      ALFreeAndNil(LSrcChildNode);
  end;

end;

{*******************************************************}
procedure ExtractAutoGeneratedSectionFromAndroidManifest(
            const AAndroidManifestNode: TalXmlNode;
            const ADisabledXmlDoc: TALXmlDocument);
begin
  var LAutoGeneratedSectionBeginSeparatorComment := ' '+AutoGeneratedSectionBeginSeparator+' '; // ' ============================================ '
  var LAutoGeneratedSectionBeginTextComment := ' '+AutoGeneratedSectionBeginText+' '; // ' AndroidMerger auto-generated section (BEGIN) '
  var LAutoGeneratedSectionEndTextComment := ' '+AutoGeneratedSectionEndText+' '; // ' AndroidMerger auto-generated section (END) '
  var LAutoGeneratedSectionEndSeparatorComment := ' '+AutoGeneratedSectionEndSeparator+' '; // ' ========================================== '
  //--
  Var LInAutoGeneratedSection: Boolean := False;
  var LAutoGeneratedSectionStartAt: Integer := -1;
  //--
  for Var I := AAndroidManifestNode.ChildNodes.Count - 1 downto 0 do begin

    //init LChildNode
    Var LChildNode := AAndroidManifestNode.ChildNodes[i];

    //If we are in AutoGeneratedSection
    if (LInAutoGeneratedSection) or
       ((I >= 2) and
        (LChildNode.NodeType = ntComment) and
        (LChildNode.NodeValue = LAutoGeneratedSectionEndSeparatorComment) and
        (AAndroidManifestNode.ChildNodes[i-1].NodeType = nttext) and
        (AAndroidManifestNode.ChildNodes[i-2].NodeType = ntComment) and
        (AAndroidManifestNode.ChildNodes[i-2].NodeValue = LAutoGeneratedSectionEndTextComment)) then begin

      //--
      LInAutoGeneratedSection := True;
      LChildNode := AAndroidManifestNode.ChildNodes.Extract(LChildNode);
      Try

        //security check
        if LChildNode = nil then raise Exception.Create('Error CA370CC3-D668-4540-BA3A-93475112733A');

        //we are at the end (begining in fact) of the AutoGenerated Section
        if LAutoGeneratedSectionStartAt = I then begin
          LInAutoGeneratedSection := false;
          LAutoGeneratedSectionStartAt := -1;
        end

        //we are in the end (begining in fact) header of the AutoGenerated Section
        else if (I >= 2) and
                (LChildNode.NodeType = ntComment) and
                (LChildNode.NodeValue = LAutoGeneratedSectionBeginTextComment) and
                (AAndroidManifestNode.ChildNodes[i-1].NodeType = nttext) and
                (AAndroidManifestNode.ChildNodes[i-2].NodeType = ntComment) and
                (AAndroidManifestNode.ChildNodes[i-2].NodeValue = LAutoGeneratedSectionBeginSeparatorComment) then begin
          LAutoGeneratedSectionStartAt := i-2;
          while (LAutoGeneratedSectionStartAt > 0) and
                (AAndroidManifestNode.ChildNodes[LAutoGeneratedSectionStartAt-1].NodeType = nttext) do
            dec(LAutoGeneratedSectionStartAt);
        end

        //we are in a disabled node
        else if (LChildNode.NodeType = ntComment) and
                (ALPosA('!!',ALtrim(LChildNode.Text)) = 1) then begin

          Var LPath: TArray<AnsiString>;
          Setlength(Lpath, 0);
          var LtmpNode := AAndroidManifestNode;
          Repeat
            if LtmpNode = AAndroidManifestNode.OwnerDocument.DocumentElement then break;
            Setlength(Lpath, length(Lpath) + 1);
            Lpath[high(Lpath)] := LtmpNode.NodeName;
            LtmpNode := LtmpNode.ParentNode;
          Until LtmpNode=nil;
          //--
          var LDisabledNode := ADisabledXmlDoc.DocumentElement;
          for var J := high(Lpath) downto low(Lpath) do begin
            LtmpNode := LDisabledNode.ChildNodes.FindNode(Lpath[j]);
            if LtmpNode = nil then LDisabledNode := LDisabledNode.AddChild(Lpath[j])
            else LDisabledNode := LtmpNode;
          end;
          //--
          var LDisabledXmlSrc := LChildNode.Text;
          LDisabledXmlSrc := ALStringReplaceA(LDisabledXmlSrc,'!!','',[rfReplaceALL]);
          var LtmpXmlDoc := TALxmlDocument.Create('root');
          try
            LtmpXmlDoc.LoadFromXML('<root>' + LDisabledXmlSrc + '</root>');
            if LtmpXmlDoc.DocumentElement.ChildNodes.Count <> 1 then raise Exception.Create('Error 13F3549B-0241-42AD-AD06-89A97A305FE0');
            LtmpNode := LtmpXmlDoc.DocumentElement.ChildNodes.Extract(0);
            LtmpNode.Attributes['alcinoe:disabled'] := '1';
            LDisabledNode.ChildNodes.Add(LtmpNode);
          finally
            ALFreeAndNil(LtmpXmlDoc);
          end;

        end;

      finally
        ALFreeAndNil(LChildNode);
      end;

    end

    //If we are NOT in an AutoGeneratedSection. recurse in all childs
    else if LChildNode.NodeType = ntelement then begin
      ExtractAutoGeneratedSectionFromAndroidManifest(
        LChildNode,
        ADisabledXmlDoc);
    end;

  end;
end;

{*******************************************************************************************}
procedure CloseAutoGeneratedSectionInAndroidManifest(Const AAndroidManifestNode: TalXmlNode);
begin
  var LAutoGeneratedSectionBeginTextComment := ' '+AutoGeneratedSectionBeginText+' '; // ' AndroidMerger auto-generated section (BEGIN) '
  for Var I := 0 to AAndroidManifestNode.ChildNodes.Count - 1 do begin
    Var LChildNode := AAndroidManifestNode.ChildNodes[i];
    if (LChildNode.NodeType = ntComment) and
       (LChildNode.NodeValue = LAutoGeneratedSectionBeginTextComment) then begin
      Var LBreakLineNode1 := TALXmlElementNode.Create('br');
      Var LBreakLineNode2 := TALXmlElementNode.Create('br');
      AAndroidManifestNode.ChildNodes.Add(LBreakLineNode1);
      AAndroidManifestNode.ChildNodes.Add(TALXmlCommentNode.Create(' '+AutoGeneratedSectionEndSeparator+' '));
      AAndroidManifestNode.ChildNodes.Add(TALXmlCommentNode.Create(' '+AutoGeneratedSectionEndText+' '));
      AAndroidManifestNode.ChildNodes.Add(TALXmlCommentNode.Create(' '+AutoGeneratedSectionEndSeparator+' '));
      AAndroidManifestNode.ChildNodes.Add(LBreakLineNode2);
      AAndroidManifestNode.ChildNodes.Remove(LBreakLineNode1);
      AAndroidManifestNode.ChildNodes.Remove(LBreakLineNode2);
      Break;
    end
    else if LChildNode.NodeType = ntelement then begin
      CloseAutoGeneratedSectionInAndroidManifest(LChildNode);
    end;
  end;
end;

{*******************************************************}
Function GetEnvironmentStringWithJavaHomeUpdated: String;
Begin
  Result := AlGetEnvironmentStringW;
  Var LEnvironmentLst := TALStringListW.Create;
  try
    LEnvironmentLst.LineBreak := #0;
    LEnvironmentLst.Text := Result;
    LEnvironmentLst.Values['JAVA_HOME'] := JDKDir;
    LEnvironmentLst.Values['Path'] := JDKDir + 'bin\;' + LEnvironmentLst.Values['Path'];
    Result := LEnvironmentLst.Text;
  finally
  ALFreeAndNil(LEnvironmentLst);
  end;
end;

{***********************************************}
Procedure ExecuteCmdLine(const ACmdLine: String);
begin
  Var LInputStream := TMemorystream.Create;
  Var LOutputStream := TStringStream.Create;
  try
    OverWrite(ACmdLine);
    Var LCmdLineResult := ALWinExecW(
                            ACmdLine, // const aCommandLine: String;
                            '', // const aCurrentDirectory: AnsiString;
                            GetEnvironmentStringWithJavaHomeUpdated, // const aEnvironment: AnsiString;
                            LInputStream, // const aInputStream: Tstream;
                            LOutputStream); //const aOutputStream: TStream;
    if LCmdLineResult <> 0 then
      raise Exception.Createfmt('Failed to execute %s'#13#10'%s', [ACmdLine, LOutputStream.DataString]);
  finally
    ALFreeandNil(LInputStream);
    ALFreeandNil(LOutputStream);
  end;
end;

{*********************}
procedure CreateRFlata(
            const AMergedResDir: String;
            const ARFlataFilename: String;
            const AAaptFilename: String);
begin
  If Tfile.Exists(ARFlataFilename) then TFile.Delete(ARFlataFilename);
  var LCmdLine := '"'+AAaptFilename+'" '+
                  'compile '+ // Compiles resources to be linked into an apk.
                  '--dir  "'+ALExcludeTrailingPathDelimiterW(AMergedResDir)+'" '+ // Directory to scan for resources
                  '-o "'+ARFlataFilename+'"'; // Output path
  ExecuteCmdLine(LCmdLine);
end;

{***********************}
procedure CreateRClasses(
            const ALibDir: String;
            const AMergedResDir: String;
            const ATmpDir: String;
            const ARJavaDir: String;
            const ARClassDir: String;
            const AAaptFilename: String;
            const ASDKApiLevelJarFilename: String;
            const AJavacFilename: String);
begin

  //check params
  if ALibDir = '' then exit;
  var LLibResDir := ALibDir + '\res';
  if not TDirectory.Exists(LLibResDir) then exit;
  var LLibResFiles := TDirectory.GetFiles(
                        LLibResDir, //const Path,
                        '*', // SearchPattern: string;
                        TSearchOption.soAllDirectories); // const SearchOption: TSearchOption)
  if length(LLibResFiles) = 0 then exit;
  if not TFile.exists(ALibDir + '\AndroidManifest.xml') then exit; // AndroidManifest.xml is mandatory
  if Not TDirectory.Exists(ARJavaDir) then raise EALException.CreateFmt('Directory %s does not exist', [ARJavaDir]);
  if not AlEmptyDirectoryW(ARJavaDir, true{SubDirectory}) then raise EALException.CreateFmt('Cannot clear %s', [ARJavaDir]);

  //init LisAapt2
  var LisAapt2 := ALPosIgnoreCaseW('aapt2.exe', AAaptFilename) > 0;

  //init LDebugRtxtDir
  {$IF defined(DEBUG)}
  var LDebugRtxtDir := ATmpDir + 'Debug\TextSymbols\';
  if LisAapt2 then LDebugRtxtDir := LDebugRtxtDir + 'Aapt2\'
  else LDebugRtxtDir := LDebugRtxtDir + 'Aapt\';
  TDirectory.CreateDirectory(LDebugRtxtDir);
  if LisAapt2 then begin
    LDebugRtxtDir := LDebugRtxtDir + ALExtractFileName(ALExcludeTrailingPathDelimiterW(ALibDir)) + '.R.txt';
    if Tfile.Exists(LDebugRtxtDir) then raise Exception.Create('Error EBDF9955-15D3-4B06-AD50-A02805834EE2');
  end
  else begin
    LDebugRtxtDir := LDebugRtxtDir + ALExtractFileName(ALExcludeTrailingPathDelimiterW(ALibDir));
    if TDirectory.Exists(LDebugRtxtDir) then raise Exception.Create('Error A612C4A3-8FC8-4420-A945-95BB2DD565D8');
    TDirectory.CreateDirectory(LDebugRtxtDir);
  end;
  {$ENDIF}

  //init LDebugRJavaFilename
  {$IF defined(DEBUG)}
  var LDebugRJavaFilename := ATmpDir + 'Debug\RJava\';
  if LisAapt2 then LDebugRJavaFilename := LDebugRJavaFilename + 'Aapt2\'
  else LDebugRJavaFilename := LDebugRJavaFilename + 'Aapt\';
  TDirectory.CreateDirectory(LDebugRJavaFilename);
  var LDebugRJavaOriginalFilename := LDebugRJavaFilename + ALExtractFileName(ALExcludeTrailingPathDelimiterW(ALibDir)) + '.R.java';
  if Tfile.Exists(LDebugRJavaOriginalFilename) then raise Exception.Create('Error C0110540-F418-42B3-8230-37314867DDC6');
  //var LDebugRJavaCompressedFilename := LDebugRJavaFilename + ALExtractFileName(ALExcludeTrailingPathDelimiterW(ALibDir)) + '.R.compressed.java';
  {$ENDIF}

  //Create R.java
  var LCmdLine: String;
  if LisAapt2 then begin
    var LOutputPath := ATmpDir + 'linked_res.ap_';
    if Tfile.Exists(LOutputPath) then Tfile.Delete(LOutputPath);
    LCmdLine := '"'+AAaptFilename+'" '+
                'link '+ // Links resources into an apk.
                '--manifest "'+ALibDir+'\AndroidManifest.xml" '+ // Path to the Android manifest to build.
                '-o "'+LOutputPath+'" '+ // Output path.
                '-I "'+ALExcludeTrailingPathDelimiterW(ASDKApiLevelJarFilename)+'" '+ // Adds an Android APK to link against.
                '-R "'+ALExcludeTrailingPathDelimiterW(AMergedResDir)+'" '+ // Compilation unit to link, using `overlay` semantics. The last conflicting resource given takes precedence.
                '--java "'+ALExcludeTrailingPathDelimiterW(ARJavaDir)+'" '+ // Directory in which to generate R.java.
                {$IF defined(DEBUG)}
                '--output-text-symbols "'+ LDebugRtxtDir +'" ' + // Generates a text file containing the resource symbols of the R class in the specified file
                {$ENDIF}
                //Without auto-add-overlay we have error like
                //C:\Dev\MagicFoundation\Alcinoe\Tools\AndroidMerger\tmp\compiled_res.flata@values-da_values.arsc.flat: note: define an <add-resource> tag or use --auto-add-overlay.
                '--auto-add-overlay'; // Allows the addition of new resources in overlays without <add-resource> tags.
  end
  else begin
    LCmdLine := '"'+AAaptFilename+'" '+
                'package '+ // Package the android resources.  It will read assets and resources that are supplied with the -M -A -S or raw-files-dir arguments.  The -J -P -F and -R options control which files are output.
                '-f '+ // force overwrite of existing files
                '-m '+ // make package directories under location specified by -J
                '-M "'+ALibDir+'\AndroidManifest.xml" '+ // specify full path to AndroidManifest.xml to include in zip
                '-I "'+ALExcludeTrailingPathDelimiterW(ASDKApiLevelJarFilename)+'" '+ // add an existing package to base include set
                '-S "'+ALExcludeTrailingPathDelimiterW(AMergedResDir)+'" '+ // directory in which to find resources.  Multiple directories will be scanned and the first match found (left to right) will take precedence.
                '-J "'+ALExcludeTrailingPathDelimiterW(ARJavaDir)+'" '+ // specify where to output R.java resource constant definitions
                {$IF defined(DEBUG)}
                '--output-text-symbols '+ LDebugRtxtDir +' ' + // Generates a text file containing the resource symbols of the R class in the specified file
                {$ENDIF}
                '--auto-add-overlay'; // Automatically add resources that are only in overlays.
  end;
  ExecuteCmdLine(LCmdLine);

  //get all R.java
  var LRJavaFiles := TDirectory.GetFiles(
                       ARJavaDir, //const Path,
                       '*.java', // SearchPattern: string;
                       TSearchOption.soAllDirectories); // const SearchOption: TSearchOption)
  //Their is some libraries that have a res folder with inside just an empty values.xml
  //(like androidx.lifecycle-lifecycle-livedata-core-2.5.1). In that case no java file will be generated
  //their is also some library that generate a Manifest.java along the R.java (androidx.core)
  var LRJavaFile: String := '';
  for var LTmpRJavaFile in LRJavaFiles do begin
    if ALSameTextW(ALExtractFileName(LTmpRJavaFile), 'R.java') then begin
      LRJavaFile := LTmpRJavaFile;
      break;
    end
    else if not ALSameTextW(ALExtractFileName(LTmpRJavaFile), 'Manifest.java') then
      raise Exception.CreateFmt('Error E8DEB280-BDD8-4A3D-BBD9-6FE7C13066DE'#13#10'%s',[LCmdLine]);
  end;
  if LRJavaFile = '' then exit;

  //With the code below I can see a big difference in the size of the generated R.jar
  //but close to no difference with the size of the final APK. So I decide to deactivate it

  //load the r.txt
  //var LRTxt: AnsiString;
  //if TFile.exists(ALibDir + '\R.txt') then LRTxt := ALTrim(ALGetStringFromFile(ALibDir + '\R.txt'))
  //else LRTxt := '';

  //clear the R.java
  Var LRJavaSrc := ALGetStringFromFile(LRJavaFile);
  {$IF defined(DEBUG)}
  ALSaveStringToFile(LRJavaSrc, LDebugRJavaOriginalFilename);
  {$ENDIF}
  //
  //if LRTxt <> '' then begin
  //  Var P1 := ALPosA('/*', LRJavaSrc);
  //  while P1 > 0 do begin
  //    Var P2 := ALPosA('*/', LRJavaSrc);
  //    if P2 <= P1 then raise Exception.Create('Error E0091FB6-E774-4F7A-8EF2-DFC518C8D706');
  //    delete(LRJavaSrc,P1,P2-P1+2);
  //    P1 := ALPosA('/*', LRJavaSrc);
  //  end;
  //  //
  //  Var LLst := TALStringListA.Create;
  //  try
  //    LLst.Text := LRJavaSrc;
  //    var LCurrentClassName: AnsiString := '';
  //    Var I := 0;
  //    while i <= LLst.Count - 1 do begin
  //      Var LLine := ALTrim(LLst[i]);
  //      //--
  //      if LLine = '' then begin
  //        LLst.Delete(i);
  //        Continue;
  //      end;
  //      //--
  //      P1 := ALPosA(' class ', LLine); // public static final class anim {
  //      if P1 > 0 then begin
  //        LCurrentClassName := ALcopyStr(LLine,P1 + length(' class '), MaxInt); // anim {
  //        LCurrentClassName := ALStringReplaceA(LCurrentClassName,'{', '', []);  // anim
  //        LCurrentClassName := ALTrim(LCurrentClassName); // anim
  //        inc(i);
  //        continue;
  //      end;
  //      //--
  //      P1 := ALPosA('=',LLine); // public static final int[] ViewStubCompat = {
  //                              // 0x010100d0, 0x010100f2, 0x010100f3
  //                              // };
  //      if P1 > 0 then begin
  //        Var LcurrentResName := ALtrim(ALcopyStr(LLine,1,P1-1)); // public static final int[] ViewStubCompat
  //        P1 := Length(LcurrentResName);
  //        while (P1 > 0) and (LCurrentResName[P1] <> ' ') do
  //          dec(P1);
  //        if P1 <= 0 then raise Exception.Create('Error B5092859-B647-46EA-98B4-6269C1FFD073');
  //        LcurrentResName := ALTrim(ALcopyStr(LcurrentResName,P1+1,maxint)); // ViewStubCompat
  //        if LCurrentClassName = '' then raise Exception.Create('Error C7A6C3AC-621C-4AB4-AA64-88E3E3A1B9DE');
  //        if ALPosA(' ' + LCurrentClassName + ' ' + LcurrentResName + ' ', LRTxt) <= 0 then begin // int attr actionBarSplitStyle 0x7f040005
  //          while ALPosA(';', LLst[i]) <= 0 do
  //            LLst.Delete(i);
  //          LLst.Delete(i);
  //          Continue;
  //        end;
  //      end;
  //      //--
  //      inc(i);
  //    end;
  //    //
  //    I := 0;
  //    while i <= LLst.Count - 1 do begin
  //      Var LLine := ALTrim(LLst[i]);
  //      P1 := ALPosA(' class ', LLine); // public static final class anim {
  //      if P1 > 0 then begin
  //        if i = LLst.Count - 1 then raise Exception.Create('Error 91042CCE-06C8-4D6A-9F45-EA7B27CFE836');
  //        if ALtrim(LLst[i+1]) = '}' then begin
  //          LLst.Delete(i);
  //          LLst.Delete(i);
  //          continue;
  //        end;
  //      end;
  //      inc(i);
  //    end;
  //    //
  //    LRJavaSrc := ALTrim(LLst.Text);
  //  finally
  //    ALFreeAndNil(LLst);
  //  end;
  //end;
  //
  //ALSaveStringToFile(LRJavaSrc, LRJavaFile);
  //{$IF defined(DEBUG)}
  //ALSaveStringToFile(LRJavaSrc, LDebugRJavaCompressedFilename);
  //{$ENDIF}

  //check if we have the same amout of items in R.java and in R.txt
  //if (LRTxt <> '') and
  //   (length(LRJavaSrc) - length(ALStringReplaceA(LRJavaSrc, ';', '', [RfIgnoreCase])) <> length(LRTxt) - length(ALStringReplaceA(LRTxt, #10, '', [RfIgnoreCase]))) then
  //  raise Exception.Create('Error 649F370C-226C-4D8D-85C9-B1CE17860EA4');

  //Compile R.java into R$ classes
  LCmdLine := '"'+AJavacFilename+'" '+
              '-d "'+ALExcludeTrailingPathDelimiterW(ARClassDir)+'" '+  // Specify where to place generated class files
              '"'+LRJavaFile+'"'; // input source files
  ExecuteCmdLine(LCmdLine);

end;

{*******************}
procedure CreateRJar(
            const aRJarFilename: String;
            const ARClassDir: String;
            const AJarExeFilename: String);
begin
  If Tfile.Exists(aRJarFilename) then raise Exception.Create('Error 78978F68-66EB-4152-BDF9-35EA5C853E02');
  var LCmdLine := '"'+AJarExeFilename+'" '+
                  'cfM '+ // -c  create new archive -f  specify archive file name
                  '"'+aRJarFilename+'" '+
                  '-C "'+ALExcludeTrailingPathDelimiterW(ARClassDir)+'" .';
  ExecuteCmdLine(LCmdLine);
end;

{*****************************************************************************************************************************************}
Function CompareVersion(const AVersionA, AVersionB: AnsiString; out ARelationship: integer; const ACanWriteError: boolean = True): Boolean;
begin
  if AVersionA = AVersionB then begin
    ARelationship := 0;
    Result := True;
    exit;
  end;
  if AVersionA = '0.0.0.0' then begin
    ARelationship := -1;
    result := True;
    exit;
  end;
  if AVersionB = '0.0.0.0' then begin
    ARelationship := 1;
    result := True;
    exit;
  end;
  if AVersionA = ALIntToStrA(ALMaxInt64)+'.'+ALIntToStrA(ALMaxInt64)+'.'+ALIntToStrA(ALMaxInt64)+'.'+ALIntToStrA(ALMaxInt64) then begin
    ARelationship := 1;
    result := True;
    exit;
  end;
  if AVersionB = ALIntToStrA(ALMaxInt64)+'.'+ALIntToStrA(ALMaxInt64)+'.'+ALIntToStrA(ALMaxInt64)+'.'+ALIntToStrA(ALMaxInt64) then begin
    ARelationship := -1;
    result := True;
    exit;
  end;
  //---
  var LVersionA := AVersionA;
  var LVersionB := AVersionB;
  //---
  //https://gist.github.com/caseykulm/8f229ef3d89dec02780ea880129bc75d - Guava ListenableFuture Hell
  //  9999.0-empty-to-avoid-conflict-with-guava => 9999.0.0
  if LVersionA = '9999.0-empty-to-avoid-conflict-with-guava' then LVersionA := '9999.0';
  if LVersionB = '9999.0-empty-to-avoid-conflict-with-guava' then LVersionB := '9999.0';
  //---
  //if flavor is the same then remove it
  //  31.1-jre => 31.1
  //  27.2-jre => 27.2
  var LFlavorA: AnsiString := '';
  var LFlavorB: AnsiString := '';
  Var P := ALPosA('-',LVersionA);
  if P > 0 then LFlavorA := ALCopyStr(LVersionA, P, Maxint); // -jre
  P := ALPosA('-',LVersionB);
  if P > 0 then LFlavorB := ALCopyStr(LVersionB, P, Maxint); // -jre
  if (LFlavorA <> '') and (LFlavorB <> '') and (LFlavorA = LFlavorB) then begin
    LVersionA := ALStringReplaceA(LVersionA, LFlavorA, '', []); //  31.1
    LVersionB := ALStringReplaceA(LVersionB, LFlavorB, '', []); //  27.2
  end;
  //---
  //their is version like
  //  31.1-jre
  //  31.1-android
  //so I take the rule to ignore the comparaison if their is
  //alpha char inside the version number even for version like
  //  1.4.0-alpha02
  //  1.4.0-alpha03
  var LIsWithAlpha: Boolean := False;
  for var Lch in LVersionA do
    if not (Lch in ['0'..'9', '.']) then begin
      LIsWithAlpha := True;
      Break;
    end;
  for var Lch in LVersionB do
    if not (Lch in ['0'..'9', '.']) then begin
      LIsWithAlpha := True;
      Break;
    end;
  if LIsWithAlpha then begin
    if ACanWriteError then
      Writeln(
        ALStringReplaceW(
          'Can not compare version ' + string(AVersionA) + ' vs ' + String(AVersionB),
          ALIntToStrW(ALMaxint64),
          '<maxint>',
          [rfReplaceALL]),
        TALConsoleColor.ccAqua,
        true{ASkipDuplicates});
    ARelationship := 0;
    Result := False;
    exit;
  end;
  //---
  ARelationship := 0;
  Result := True;
  //---
  var LVersionALst := TALStringListA.Create;
  var LVersionBLst := TALStringListA.Create;
  try
    LVersionALst.LineBreak := '.';
    LVersionBLst.LineBreak := '.';
    LVersionALst.Text := LVersionA;
    LVersionBLst.Text := LVersionB;
    //---
    while LVersionALst.count < LVersionBLst.Count do
      LVersionALst.Add('0'); // 1.2.0.0
    while LVersionBLst.count < LVersionALst.Count do
      LVersionBLst.Add('0'); // 1.4.0.0
    //---
    for var I := 0 to LVersionALst.Count - 1 do begin
      var LVersionANumber: int64;
      var LVersionBNumber: int64;
      if not ALTryStrToInt64(LVersionALst[I], LVersionANumber) then raise Exception.Create('Error A5262D46-2E67-4CF1-A28A-924D445E330F');
      if not ALTryStrToInt64(LVersionBLst[I], LVersionBNumber) then raise Exception.Create('Error 99B4CDDE-0B43-41DE-A1AE-FEB4D9BE21A2');
      if LVersionANumber < LVersionBNumber then begin
        ARelationship := -1;
        Result := True;
        exit;
      end
      else if LVersionANumber > LVersionBNumber then begin
        ARelationship := 1;
        Result := True;
        exit;
      end;
    end;
  finally
    ALFreeAndNil(LVersionALst);
    ALFreeAndNil(LVersionBLst);
  end;
end;

{**********************************************************}
function incVersion(const aVersion: ansiString): ansiString;
begin
  // 1.0.0 => 1.0.0.1
  result := aVersion + '.1';
end;

{**********************************************************}
function decVersion(const aVersion: ansiString): ansiString;
begin
  // 1.0.0 => 0.<maxint>.<maxint>
  Var LLst := TALStringListA.Create;
  try
    LLst.LineBreak := '.';
    LLst.Text := aVersion;
    for var I := LLst.Count - 1 downto 0 do begin
      Var LNumber := ALStrToint64(LLst[i]);
      if LNumber = 0 then begin
        LLst[i] := ALIntToStrA(ALMaxint64);
        continue;
      end
      else begin
        LLst[i] := ALIntToStrA(LNumber-1);
        break;
      end;
    end;
    Result := ALExcludeTrailingPathDelimiterA(LLst.Text, '.');
  finally
    ALFreeAndNil(LLst);
  end;
end;

{**************************************************}
function DownloadMetadataFromCentralMavenRepository(
           const ARemoteRepositoryBaseUrl: AnsiString;
           const AGroupID: AnsiString;
           const AArtifactID: AnsiString;
           out AMavenMetadataSrc: AnsiString): Boolean; overload;
begin

  //init result
  result := False;
  AMavenMetadataSrc := '';

  //create LHttpClient
  var LHttpClient := TALWinHttpClient.Create;
  Try

    //try to download from the ARemoteRepositoryBaseUrl
    Var LUrl := ARemoteRepositoryBaseUrl +
                ALStringReplaceA(AGroupID,'.','/',[RfReplaceALL])+'/'+
                AArtifactID+'/'+
                'maven-metadata.xml'; // https://repo1.maven.org/maven2/androidx/camera/camera-core/maven-metadata.xml
    OverWrite(String(LUrl+'.pom'));
    var LResponseContent := TALStringStreamA.Create('');
    var LResponseHeader := TALHTTPResponseHeader.Create;
    try
      Try
        LHttpClient.Get(
          LUrl, // const aUrl:AnsiString;
          LResponseContent, // const aResponseContent: TStream;
          LResponseHeader); // const aResponseHeader: TALHTTPResponseHeader;
      except
        on E: Exception do begin
          if LResponseHeader.StatusCode = '404' then exit
          else raise;
        end;
      End;
      AMavenMetadataSrc := LResponseContent.DataString;
      Result := True;
    finally
      ALFreeAndNil(LResponseContent);
      ALFreeAndNil(LResponseHeader);
    end;
  Finally
    ALFreeAndNil(LHttpClient);
  End;

end;

{**************************************************}
function DownloadMetadataFromCentralMavenRepository(
           const AGroupID: AnsiString;
           const AArtifactID: AnsiString;
           out AMavenMetadataSrc: AnsiString): Boolean; overload;
begin
  result := DownloadMetadataFromCentralMavenRepository(
              'https://dl.google.com/android/maven2/', // const ARemoteRepositoryBaseUrl: AnsiString;
              AGroupID, // const AGroupID: AnsiString;
              AArtifactID, // const AArtifactID: AnsiString;
              AMavenMetadataSrc) or // out AMavenMetadataSrc: AnsiString
            DownloadMetadataFromCentralMavenRepository(
              'https://repo1.maven.org/maven2/', // const ARemoteRepositoryBaseUrl: AnsiString;
              AGroupID, // const AGroupID: AnsiString;
              AArtifactID, // const AArtifactID: AnsiString;
              AMavenMetadataSrc); // out AMavenMetadataSrc: AnsiString
end;

{*************************************************}
function DownloadLibraryFromCentralMavenRepository(
           const ARemoteRepositoryBaseUrl: AnsiString;
           const ALocalRepositoryBaseDir: String;
           const AGroupID: AnsiString;
           const AArtifactID: AnsiString;
           const AVersion: AnsiString;
           out ALocalArchivefilename: String;
           out ALocalpomfilename: String): Boolean; overload;
begin

  //init result
  result := False;
  ALocalArchivefilename := '';
  ALocalpomfilename := '';

  //init LLocalFilenameWithoutExt
  var LLocalFilenameWithoutExt := ALIncludeTrailingPathDelimiterW(ALocalRepositoryBaseDir) +
                                  ALStringReplaceW(string(AGroupId),'.','\',[RfReplaceALL]) + '\' +
                                  String(AArtifactId) + '\' +
                                  string(AVersion) + '\';
  TDirectory.CreateDirectory(LLocalFilenameWithoutExt);
  LLocalFilenameWithoutExt := LLocalFilenameWithoutExt + string(AArtifactId)+'-'+string(AVersion);

  //check that the file is not already in the local repository
  Var LPackaging: AnsiString;
  if Tfile.Exists(LLocalFilenameWithoutExt +'.aar') then LPackaging := 'aar'
  else if Tfile.Exists(LLocalFilenameWithoutExt +'.jar') then LPackaging := 'jar'
  else if Tfile.Exists(LLocalFilenameWithoutExt +'.pom') then LPackaging := 'pom'
  else LPackaging := '';
  if LPackaging <> '' then begin
    if ALSameTextA(LPackaging, 'pom') then ALocalArchivefilename := ''
    else ALocalArchivefilename := LLocalFilenameWithoutExt+'.'+string(LPackaging);
    ALocalpomfilename := LLocalFilenameWithoutExt+'.pom';
    exit(true);
  end;

  //create LHttpClient
  var LHttpClient := TALWinHttpClient.Create;
  Try

    //try to download from the ARemoteRepositoryBaseUrl
    Var LUrl := ARemoteRepositoryBaseUrl +
                ALStringReplaceA(AGroupId,'.','/',[RfReplaceALL])+'/'+
                AArtifactId+'/'+
                AVersion +'/'+
                AArtifactId+'-'+AVersion; // https://dl.google.com/android/maven2/androidx/camera/camera-core/1.1.0/camera-core-1.1.0
    OverWrite(String(LUrl+'.pom'));
    var LPOMSrc: AnsiString;
    var LResponseContent := TALStringStreamA.Create('');
    var LResponseHeader := TALHTTPResponseHeader.Create;
    try
      Try
        LHttpClient.Get(
          LUrl+'.pom', // const aUrl:AnsiString;
          LResponseContent, // const aResponseContent: TStream;
          LResponseHeader); // const aResponseHeader: TALHTTPResponseHeader;
      except
        on E: Exception do begin
          if LResponseHeader.StatusCode = '404' then exit
          else raise;
        end;
      End;
      LPOMSrc := LResponseContent.DataString;
    finally
      ALFreeAndNil(LResponseContent);
      ALFreeAndNil(LResponseHeader);
    end;
    ALSaveStringTofile(LPOMSrc, LLocalFilenameWithoutExt+ '.pom');
    var LPomXmlDoc := TalXmlDocument.Create('root');
    try
      LPomXmlDoc.LoadFromXML(LPOMSrc);
      ExpandPOM(LPomXmlDoc, ALocalRepositoryBaseDir);
      Var LPackagingNode := LPomXmlDoc.DocumentElement.ChildNodes.FindNode('packaging');
      if LPackagingNode = nil then LPackaging := 'jar'
      else LPackaging := LPackagingNode.Text;
      //https://stackoverflow.com/questions/74315779/what-mean-packagingbundle-mean-inside-the-pom
      if ALSameTextA(LPackaging, 'bundle') then LPackaging := 'jar';
      if (LPackaging <> 'jar') and
         (LPackaging <> 'aar') and
         (LPackaging <> 'pom') then raise Exception.CreateFmt('Unknown Packaging "%s"', [LPackaging]);
      if LPackaging = 'pom' then ALocalArchivefilename := ''
      else begin
        OverWrite(String(LUrl+'.'+LPackaging));
        var LArchiveSrc := LHttpClient.Get(LUrl+'.'+LPackaging);
        ALSaveStringTofile(LArchiveSrc, LLocalFilenameWithoutExt+'.'+string(LPackaging));
        ALocalArchivefilename := LLocalFilenameWithoutExt+'.'+string(LPackaging);
      end;
      ALocalpomfilename := LLocalFilenameWithoutExt+'.pom';
      exit(true);
    finally
      ALFreeAndNil(LPomXmlDoc);
    end;
  Finally
    ALFreeAndNil(LHttpClient);
  End;

end;

{*************************************************}
function DownloadLibraryFromCentralMavenRepository(
           const ALocalRepositoryBaseDir: String;
           const AGroupID: AnsiString;
           const AArtifactID: AnsiString;
           const AVersion: AnsiString;
           out ALocalArchivefilename: String;
           out ALocalpomfilename: String): Boolean; overload;
begin
  result := DownloadLibraryFromCentralMavenRepository(
              'https://dl.google.com/android/maven2/', // const ARemoteRepositoryBaseUrl: AnsiString;
              ALocalRepositoryBaseDir, // const ALocalRepositoryBaseDir: String;
              AGroupID, // const AGroupID: AnsiString;
              AArtifactID, // const AArtifactID: AnsiString;
              AVersion, // const AVersion: AnsiString;
              ALocalArchivefilename, // out ALocalArchivefilename: String;
              ALocalpomfilename) or // out ALocalpomfilename: String)
            DownloadLibraryFromCentralMavenRepository(
              'https://repo1.maven.org/maven2/', // const ARemoteRepositoryBaseUrl: AnsiString;
              ALocalRepositoryBaseDir, // const ALocalRepositoryBaseDir: String;
              AGroupID, // const AGroupID: AnsiString;
              AArtifactID, // const AArtifactID: AnsiString;
              AVersion, // const AVersion: AnsiString;
              ALocalArchivefilename, // out ALocalArchivefilename: String;
              ALocalpomfilename); // out ALocalpomfilename: String)
end;

{*******************************************}
function ExpandDependencyVersionRequirements(
           const aDependencyGroupId: AnsiString;
           const aDependencyArtifactId: AnsiString;
           const aDependencyVersionRequirements: AnsiString;
           out APreferredVersion: AnsiString): Tarray<Tpair<AnsiString,AnsiString>>;
begin

  //Version requirements have the following syntax:
  //1.0: Soft requirement for 1.0. Use 1.0 if no other version appears earlier in the dependency tree.
  //[1.0]: Hard requirement for 1.0. Use 1.0 and only 1.0.
  //(,1.0]: Hard requirement for any version <= 1.0.
  //[1.2,1.3]: Hard requirement for any version between 1.2 and 1.3 inclusive.
  //[1.0,2.0): 1.0 <= x < 2.0; Hard requirement for any version between 1.0 inclusive and 2.0 exclusive.
  //[1.5,): Hard requirement for any version greater than or equal to 1.5.
  //(,1.0],[1.2,): Hard requirement for any version less than or equal to 1.0 than or greater than or equal to 1.2, but not 1.1. Multiple requirements are separated by commas.
  //(,1.1),(1.1,): Hard requirement for any version except 1.1; for example because 1.1 has a critical vulnerability.

  //init LWorkDependencyVersionRequirements
  var LWorkDependencyVersionRequirements := aDependencyVersionRequirements;

  //https://github.com/google/guava/wiki/ReleasePolicy#flavors
  if (aDependencyGroupId = 'com.google.guava') and (aDependencyArtifactId = 'guava') then
    LWorkDependencyVersionRequirements := ALStringReplaceA(LWorkDependencyVersionRequirements, '-jre', '-android', []);

  //handle case la 3.+ => [3.0.0,)
  if ALPosA('+', LWorkDependencyVersionRequirements) > 0 then begin
    if (ALPosA('[', LWorkDependencyVersionRequirements) > 0) or
       (ALPosA(']', LWorkDependencyVersionRequirements) > 0) or
       (ALPosA('(', LWorkDependencyVersionRequirements) > 0) or
       (ALPosA(')', LWorkDependencyVersionRequirements) > 0) then raise Exception.Create('Error 90368DB2-6633-46E7-B3C0-115FC3857496');
    var LMavenMetadataSrc: AnsiString;
    if not DownloadMetadataFromCentralMavenRepository(
             aDependencyGroupId, // const AGroupID: AnsiString;
             aDependencyArtifactId, // const AArtifactID: AnsiString;
             LMavenMetadataSrc) then // out AMavenMetadataSrc: AnsiString): Boolean;
      raise Exception.Createfmt('Could not download maven-metadata.xml for %s:%s', [aDependencyGroupId, aDependencyArtifactId]);
    LWorkDependencyVersionRequirements := ALStringReplaceA(LWorkDependencyVersionRequirements, '+', '.0', []); // 3.+ => 3..0
    LWorkDependencyVersionRequirements := ALStringReplaceA(LWorkDependencyVersionRequirements, '..', '.', []); // 3..0 => 3.0
    var LMavenMetadataDoc := TalXmlDocument.Create;
    try
      LMavenMetadataDoc.LoadFromXML(LMavenMetadataSrc);
      Var LversioningNode := LMavenMetadataDoc.DocumentElement.ChildNodes['versioning'];
      Var LversionsNode := LversioningNode.ChildNodes['versions'];
      var LMostAdequateVersion: AnsiString := '';
      for var I := 0 to LversionsNode.ChildNodes.Count - 1 do begin
        var LVersion := LversionsNode.ChildNodes[i].Text;
        Var LIsGoodVersion: Boolean := True;
        for var Lch in LVersion do
          if not (Lch in ['0'..'9','.']) then begin
            LIsGoodVersion := False;
            break;
          end;
        if not LIsGoodVersion then continue;
        var LVersionRelationShip: integer;
        if (CompareVersion(
              LWorkDependencyVersionRequirements,
              LVersion,
              LVersionRelationShip,
              false{ACanWriteError})) and (LVersionRelationShip <= 0) then begin
         if LMostAdequateVersion = '' then LMostAdequateVersion := LVersion
         else if (CompareVersion(
                    LVersion,
                    LMostAdequateVersion,
                    LVersionRelationShip)) and (LVersionRelationShip <= 0) then LMostAdequateVersion := LVersion
        end;
      end;
      if LMostAdequateVersion = '' then raise Exception.Createfmt('Can not Expand %s:%s:%s', [aDependencyGroupId, aDependencyArtifactId, aDependencyVersionRequirements]);
      LWorkDependencyVersionRequirements := '['+LMostAdequateVersion+',)';
    finally
      ALFreeAndNil(LMavenMetadataDoc);
    end;
  end;

  Setlength(Result, 0);
  APreferredVersion := '';
  var LLst := TALStringListA.Create;
  try

    // 1.0 | [1.0] | (,1.0]       | [1.2,1.3] | [1.0,2.0) | [1.5,)        | (,1.0],[1.2,)              | (,1.1),(1.1,)
    LWorkDependencyVersionRequirements := ALStringReplaceA(LWorkDependencyVersionRequirements, ' ', '', [rfReplaceALL]);
    // 1.0 | [1.0] | 0.0.0.0,1.0] | [1.2,1.3] | [1.0,2.0) | [1.5,)        | 0.0.0.0,1.0],[1.2,)        | 0.0.0.0,1.1),(1.1,)
    LWorkDependencyVersionRequirements := ALStringReplaceA(LWorkDependencyVersionRequirements, '(,', '0.0.0.0,', [rfReplaceALL]);
    // 1.0 | [1.0] | 0.0.0.0,1.0] | [1.2,1.3] | [1.0,2.0) | [1.5,<MAXINT> | 0.0.0.0,1.0],[1.2,<MAXINT> | 0.0.0.0,1.1),(1.1,<MAXINT>
    LWorkDependencyVersionRequirements := ALStringReplaceA(LWorkDependencyVersionRequirements, ',)', ',' + ALIntToStrA(ALMaxInt64)+'.'+ALIntToStrA(ALMaxInt64)+'.'+ALIntToStrA(ALMaxInt64)+'.'+ALIntToStrA(ALMaxInt64), [rfReplaceALL]);

    LLst.LineBreak := ',';
    LLst.Text := LWorkDependencyVersionRequirements;
    if LLst.Count = 0 then raise Exception.Create('Error 57608ECA-8EEE-4C63-B797-39E74CBF7B9D');

    // 1.0 | [1.0]
    if LLst.Count = 1 then begin
      Var LStr := LLst[0];
      // [1.0]
      if (ALPosA('[', LStr) = 1) and
         (ALPosA(']', LStr) = length(LStr)) then begin
        delete(LStr,1,1); // 1.0]
        delete(LStr,length(LStr),1); // 1.0
        APreferredVersion := LStr; // 1.0
        Setlength(Result, 1);
        Result[0] := Tpair<AnsiString,AnsiString>.create(LStr, LStr); // 1.0 - 1.0
      end
      // 1.0
      else begin
        APreferredVersion := LStr; // 1.0
        Setlength(Result, 1);
        Result[0] := Tpair<AnsiString,AnsiString>.create('0.0.0.0', ALIntToStrA(ALMaxInt64)+'.'+ALIntToStrA(ALMaxInt64)+'.'+ALIntToStrA(ALMaxInt64)+'.'+ALIntToStrA(ALMaxInt64)); // 0.0.0.0 - maxint.maxint.maxint.maxint
      end;
      if (ALPosA('[', APreferredVersion) > 0) or
         (ALPosA(']', APreferredVersion) > 0) or
         (ALPosA('(', APreferredVersion) > 0) or
         (ALPosA(')', APreferredVersion) > 0) then raise Exception.Create('Error 73BA1C49-4E46-44A8-8A4D-118BC355889C');
    end

    // 0.0.0.0,1.0] | [1.2,1.3] | [1.0,2.0) | [1.5,<MAXINT> | 0.0.0.0,1.0],[1.2,<MAXINT> | 0.0.0.0,1.1),(1.1,<MAXINT>
    else begin
      if LLst.Count mod 2 <> 0 then raise Exception.Create('Error 57608ECA-8EEE-4C63-B797-39E74CBF7B9D');
      for var I := 0 to LLst.Count - 1 do begin
        if I mod 2 <> 0 then continue;
        //----
        var LstrMin := LLst[i];   // 0.0.0.0 | [1.2 | [1.0 | [1.5 | 0.0.0.0 | [1.2 | 0.0.0.0 | (1.1
        var LstrMax := LLst[i+1]; // 1.0] | 1.3] | 2.0) | <MAXINT> | 1.0] | <MAXINT> | 1.1) | <MAXINT>
        //----
        // [1.2 | [1.0 | [1.5 | [1.2
        if (ALPosA('[', LstrMin) = 1) then begin
          // 1.2 | 1.0 | 1.5 | 1.2
          delete(LstrMin,1,1);
          APreferredVersion := LstrMin;
        end
        // (1.1
        else if (ALPosA('(', LstrMin) = 1) then begin
          // 1.1
          delete(LstrMin,1,1);
          // 1.1.1
          LstrMin := incVersion(LstrMin);
        end;
        //----
        // 1.0] | 1.3] | 1.0]
        if (ALPosA(']', LstrMax) = length(LstrMax)) then begin
          // 1.0 | 1.3 | 1.0
          delete(LstrMax,length(LstrMax),1);
          APreferredVersion := LstrMax;
        end
        // 2.0) | 1.1)
        else if (ALPosA(')', LstrMax) = length(LstrMax)) then begin
          // 2.0 | 1.1
          delete(LstrMax,length(LstrMax),1);
          // 1.<MAXINT> | 1.0
          LstrMax := decVersion(LstrMax);
        end;
        //----
        if (ALPosA('[', LstrMin) > 0) or
           (ALPosA(']', LstrMin) > 0) or
           (ALPosA('(', LstrMin) > 0) or
           (ALPosA(')', LstrMin) > 0) then raise Exception.Create('Error A8246244-77B7-4B2D-BDBA-12D9CAB5B4A1');
        //----
        if (ALPosA('[', LstrMax) > 0) or
           (ALPosA(']', LstrMax) > 0) or
           (ALPosA('(', LstrMax) > 0) or
           (ALPosA(')', LstrMax) > 0) then raise Exception.Create('Error 3BAB20BC-2DA5-458B-839A-08395B523FEE');
        //----
        Setlength(Result, length(Result)+1);
        Result[high(Result)] := Tpair<AnsiString,AnsiString>.create(LstrMin, LstrMax);
      end;
      if APreferredVersion = '' then raise Exception.Create('Error 9572ABBD-A0D8-47AD-859C-DD532B6281A3');
    end;
  finally
    ALFreeAndNil(LLst);
  end;

end;

{***********************}
Function FindLibraryNode(
           const ALibraries: TALJSONDocumentA;
           const AGroupID: AnsiString;
           const AArtifactID: AnsiString;
           const AVersion: AnsiString): TALJSONNodeA;
begin
  Result := nil;
  for var I := 0 to ALibraries.ChildNodes.Count - 1 do begin
    var LLibrary := ALibraries.ChildNodes[i];
    if ((AGroupID = '') or (LLibrary.GetChildNodeValueText('groupid', ''{default}) = AGroupID)) and
       ((AArtifactID = '') or (LLibrary.GetChildNodeValueText('artifactid', ''{default}) = AArtifactID)) and
       ((AVersion = '') or (LLibrary.GetChildNodeValueText('version', ''{default}) = AVersion)) then begin
      if result <> nil then raise Exception.Create('Error 1C88C34A-EF22-4CBB-AD85-B1CC130346D8');
      result := LLibrary;
    end;
  end;
end;

{*************************}
Function RemoveLibraryNode(
           const ALibraries: TALJSONDocumentA;
           const AGroupID: AnsiString;
           const AArtifactID: AnsiString;
           const AVersion: AnsiString): TALJSONNodeA;
begin
  Result := nil;
  for var I := ALibraries.ChildNodes.Count - 1 downto 0 do begin
    var LLibrary := ALibraries.ChildNodes[i];
    if ((AGroupID = '') or (LLibrary.GetChildNodeValueText('groupid', ''{default}) = AGroupID)) and
       ((AArtifactID = '') or (LLibrary.GetChildNodeValueText('artifactid', ''{default}) = AArtifactID)) and
       ((AVersion = '') or (LLibrary.GetChildNodeValueText('version', ''{default}) = AVersion)) then
      ALibraries.ChildNodes.Delete(i);
  end;
end;

{*******************************************************************************************}
Procedure ExpandPOM(const aPomXmlDoc: TalXmlDocument; const ALocalRepositoryBaseDir: String);

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  procedure _SwapTextNode(const AFromPomXmlDoc: TalXmlDocument; const aToPomXmlDoc: TalXmlDocument; Const aNodeName: ansiString);
  begin
    if aToPomXmlDoc.DocumentElement.ChildNodes.FindNode(aNodeName) <> nil then exit;
    var LFromNode := AFromPomXmlDoc.DocumentElement.ChildNodes.FindNode(aNodeName);
    if LFromNode = nil then exit;
    aToPomXmlDoc.DocumentElement.ChildNodes.Add(
      AFromPomXmlDoc.DocumentElement.ChildNodes.extract(LFromNode));
  end;

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  procedure _SwapDependenciesNode(const AFromPomXmlDoc: TalXmlDocument; const aToPomXmlDoc: TalXmlDocument; Const aPath: Array of ansiString; const aIndex: integer = -1);
  begin
    var LFromNode := AFromPomXmlDoc.DocumentElement;
    for var I := Low(aPath) to High(aPath) do begin
      LFromNode := LFromNode.ChildNodes.FindNode(aPath[i]);
      if LFromNode = nil then exit;
    end;
    var LtoNode := aToPomXmlDoc.DocumentElement;
    for var I := Low(aPath) to High(aPath) do begin
      var LtmpToNode := LtoNode.ChildNodes.FindNode(aPath[i]);
      if LtmpToNode = nil then LtoNode := LtoNode.AddChild(aPath[i])
      else LtoNode := LtmpToNode;
    end;
    var Lindex := LtoNode.ChildNodes.Count;
    if aIndex >= 0 then Lindex := aIndex;
    for var I := LFromNode.ChildNodes.Count - 1 downto 0 do
      LtoNode.ChildNodes.Insert(Lindex, LFromNode.ChildNodes.Extract(i));
  end;

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  procedure _SwapPropertiesNodes(const AFromPomXmlDoc: TalXmlDocument; const aToPomXmlDoc: TalXmlDocument);
  begin
    var LToPropertiesNode := aToPomXmlDoc.DocumentElement.childnodes.findNode('properties');
    if LToPropertiesNode = nil then LToPropertiesNode := aToPomXmlDoc.DocumentElement.AddChild('properties');
    var LFromPropertiesNode := AFromPomXmlDoc.DocumentElement.childnodes.findNode('properties');
    if LFromPropertiesNode = nil then LFromPropertiesNode := AFromPomXmlDoc.DocumentElement.AddChild('properties');
    for var I := LFromPropertiesNode.ChildNodes.Count - 1 downto 0 do begin
      var LFromPropertyNode := LFromPropertiesNode.ChildNodes[i];
      if LToPropertiesNode.ChildNodes.FindNode(LFromPropertyNode.NodeName) = nil then
        LToPropertiesNode.ChildNodes.Add(
          LFromPropertiesNode.ChildNodes.Extract(LFromPropertyNode));
    end;
  end;

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  procedure _AddProjectVariable(const AFromPomXmlDoc: TalXmlDocument; const aToPomXmlDoc: TalXmlDocument; Const aNodeName: ansiString);
  begin
    //https://maven.apache.org/guides/introduction/introduction-to-the-pom.html#Project_Inheritance
    //Project Interpolation and Variables
    //One factor to note is that these variables are processed after inheritance as outlined above.
    //This means that if a parent project uses a variable, then its definition in the child, not the parent,
    //will be the one eventually used.
    //----
    var LToPropertiesNode := aToPomXmlDoc.DocumentElement.childnodes.findNode('properties');
    if LToPropertiesNode = nil then LToPropertiesNode := aToPomXmlDoc.DocumentElement.AddChild('properties');
    if LToPropertiesNode.ChildNodes.IndexOf('project.'+aNodeName) >= 0 then
      raise Exception.Create('Error 3673061D-6666-4647-8EA3-21B9F71C827E');
    //----
    var LFromPropertiesNode := aFromPomXmlDoc.DocumentElement.childnodes.findNode('properties');
    if LFromPropertiesNode = nil then LFromPropertiesNode := aFromPomXmlDoc.DocumentElement.AddChild('properties');
    //----
    var LFromNode := LFromPropertiesNode.ChildNodes.FindNode('project.'+ aNodeName);
    if LFromNode = nil then begin
      LFromNode := aFromPomXmlDoc.DocumentElement.ChildNodes.FindNode(aNodeName);
      if LFromNode = nil then LFromNode := aToPomXmlDoc.DocumentElement.ChildNodes.FindNode(aNodeName);
    end;
    //----
    if (LFromNode <> nil) then
      LToPropertiesNode.AddChild('project.'+ aNodeName).Text := LFromNode.Text;
  end;

  {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
  procedure _ResolveVariables(const APomXmlDoc: TalXmlDocument);
  begin
    var LPropertiesNode := APomXmlDoc.DocumentElement.childnodes.findNode('properties');
    if LPropertiesNode = nil then exit;
    Var LXml := APomXmlDoc.XML;
    for var I := 0 to LPropertiesNode.ChildNodes.Count - 1 do begin
      var LPropertyNode := LPropertiesNode.ChildNodes[i];
      LXml := ALStringReplaceA(LXml, '${'+LPropertyNode.NodeName+'}', LPropertyNode.Text, [RfReplaceALL]);  // ${project.oauth.version} => 1.30.5
    end;
    APomXmlDoc.LoadFromXML(LXml);
  end;

begin

  //if no parent node then nothing to do
  Var LParentNode := aPomXmlDoc.DocumentElement.ChildNodes.FindNode('parent');
  if LParentNode = nil then exit;

  //init LParentGroupID, LParentArtifactId, LParentVersion
  var LParentGroupID := LParentNode.ChildNodes['groupId'].Text;
  var LParentArtifactId := LParentNode.ChildNodes['artifactId'].Text;
  var LParentVersion := LParentNode.ChildNodes['version'].Text;
  if (LParentGroupID = '') or (LParentArtifactId='') or (LParentVersion='') then
    raise Exception.Create('Error DD67075B-3B93-4FCD-96C8-D55B931565A5');

  //download the parent POM
  var LParentLocalArchivefilename: String;
  var LParentLocalpomfilename: String;
  if not DownloadLibraryFromCentralMavenRepository(
           ALocalRepositoryBaseDir, // const ALocalRepositoryBaseDir: String;
           LParentGroupID, // const AGroupID: AnsiString;
           LParentArtifactID, // const AArtifactID: AnsiString;
           LParentVersion, // const AVersion: AnsiString;
           LParentLocalArchivefilename, // out ALocalArchivefilename: String;
           LParentLocalpomfilename) then
    raise Exception.Createfmt('Can not download %s:%s:%s', [LParentGroupID, LParentArtifactID, LParentVersion]);
  if LParentLocalpomfilename = '' then raise Exception.Create('Error 87865711-207D-48D9-B59F-9B01783359E9');
  var LParentPomXmlDoc := TalXmlDocument.Create;
  try

    //load the LParentLocalpomfilename
    LParentPomXmlDoc.LoadFromFile(LParentLocalpomfilename);
    _AddProjectVariable(APomXmlDoc, LParentPomXmlDoc, 'groupId');
    _AddProjectVariable(APomXmlDoc, LParentPomXmlDoc, 'artifactId');
    _AddProjectVariable(APomXmlDoc, LParentPomXmlDoc, 'version');
    _AddProjectVariable(APomXmlDoc, LParentPomXmlDoc, 'packaging');
    ExpandPOM(LParentPomXmlDoc, ALocalRepositoryBaseDir);

    //swap the node from parent to aPomXmlDoc
    _SwapTextNode(LParentPomXmlDoc, aPomXmlDoc, 'groupId');
    _SwapTextNode(LParentPomXmlDoc, aPomXmlDoc, 'artifactId');
    _SwapTextNode(LParentPomXmlDoc, aPomXmlDoc, 'version');
    _SwapTextNode(LParentPomXmlDoc, aPomXmlDoc, 'packaging');
    _SwapPropertiesNodes(LParentPomXmlDoc, aPomXmlDoc);
    _SwapDependenciesNode(LParentPomXmlDoc, aPomXmlDoc, ['dependencyManagement', 'dependencies']);
    _SwapDependenciesNode(LParentPomXmlDoc, aPomXmlDoc, ['dependencies']);

    //resolve properties
    _ResolveVariables(aPomXmlDoc);

    //handle the dependencyManagement node
    Var LdependencyManagementNode := aPomXmlDoc.DocumentElement.ChildNodes.FindNode('dependencyManagement');
    Var LdependenciesNode := aPomXmlDoc.DocumentElement.ChildNodes.FindNode('dependencies');
    if (LdependencyManagementNode <> nil) and (LdependenciesNode <> nil) then begin
      var LdependencyManagementDependenciesNode := LdependencyManagementNode.ChildNodes.FindNode('dependencies');
      if LdependencyManagementDependenciesNode <> nil then begin

        //resolve all item in dependencyManagement.dependencies with scope=import
        Var LDone: Boolean := False;
        while not LDone do begin
          LDone := True;
          For var I := LdependencyManagementDependenciesNode.ChildNodes.Count - 1 downto 0 do begin
            var LdependencyManagementDependenciesdependencyNode := LdependencyManagementDependenciesNode.ChildNodes[I];
            if LdependencyManagementDependenciesdependencyNode.Nodetype <> ntelement then continue;
            //---
            Var LImportScopeNode := LdependencyManagementDependenciesdependencyNode.ChildNodes.FindNode('scope');
            if LImportScopeNode = nil then continue;
            if ALSameTextA(LImportScopeNode.Text, 'import') then begin
              var LImportGroupId := LdependencyManagementDependenciesdependencyNode.ChildNodes['groupId'].Text;
              var LImportArtifactId := LdependencyManagementDependenciesdependencyNode.ChildNodes['artifactId'].Text;
              var LImportVersion := LdependencyManagementDependenciesdependencyNode.ChildNodes['version'].Text;
              if (LImportGroupId = '') or (LImportArtifactId = '') or (LImportVersion='') then
                raise Exception.Create('Error C08C02D5-1677-4BD1-8FAE-7867C8054ED4');
              var LImportLocalArchivefilename: String;
              var LImportLocalpomfilename: String;
              if not DownloadLibraryFromCentralMavenRepository(
                       ALocalRepositoryBaseDir, // const ALocalRepositoryBaseDir: String;
                       LImportGroupID, // const AGroupID: AnsiString;
                       LImportArtifactID, // const AArtifactID: AnsiString;
                       LImportVersion, // const AVersion: AnsiString;
                       LImportLocalArchivefilename, // out ALocalArchivefilename: String;
                       LImportLocalpomfilename) then
                raise Exception.Createfmt('Can not download %s:%s:%s', [LImportGroupID, LImportArtifactID, LImportVersion]);
              if LImportLocalpomfilename = '' then raise Exception.Create('Error 244740FA-1F74-487C-9231-E4C937D02E8C');
              var LImportPomXmlDoc := TalXmlDocument.Create;
              try
                LImportPomXmlDoc.LoadFromFile(LImportLocalpomfilename);
                _AddProjectVariable(APomXmlDoc, LImportPomXmlDoc, 'groupId');
                _AddProjectVariable(APomXmlDoc, LImportPomXmlDoc, 'artifactId');
                _AddProjectVariable(APomXmlDoc, LImportPomXmlDoc, 'version');
                _AddProjectVariable(APomXmlDoc, LImportPomXmlDoc, 'packaging');
                ExpandPOM(LImportPomXmlDoc, ALocalRepositoryBaseDir);
                LdependencyManagementDependenciesNode.ChildNodes.Delete(i);
                _SwapDependenciesNode(LImportPomXmlDoc, aPomXmlDoc, ['dependencyManagement', 'dependencies'], I);
                LDone := False;
              finally
                ALFreeAndNil(LImportPomXmlDoc);
              end;
            end;
          end;
        end;

        //update all dependencies with information from dependencyManagement.dependencies
        for var I := 0 to LdependencyManagementDependenciesNode.ChildNodes.Count - 1 do begin
          var LdependencyManagementDependenciesdependencyNode := LdependencyManagementDependenciesNode.ChildNodes[I];
          if LdependencyManagementDependenciesdependencyNode.Nodetype <> ntelement then continue;
          //---
          var LgroupId1 := LdependencyManagementDependenciesdependencyNode.ChildNodes['groupId'].Text;
          var LartifactId1 := LdependencyManagementDependenciesdependencyNode.ChildNodes['artifactId'].Text;
          var Lversion1 := LdependencyManagementDependenciesdependencyNode.ChildNodes['version'].Text;
          //---
          Var LscopeNode1 := LdependencyManagementDependenciesdependencyNode.ChildNodes.FindNode('scope');
          var Lscope1: AnsiString;
          if LscopeNode1 = nil then Lscope1 := ''
          else Lscope1 := LscopeNode1.Text;
          //---
          Var LPackagingNode1 := LdependencyManagementDependenciesdependencyNode.ChildNodes.FindNode('packaging');
          var LPackaging1: AnsiString;
          if LPackagingNode1 = nil then LPackaging1 := 'jar'
          else LPackaging1 := LPackagingNode1.Text;
          //---
          Var LclassifierNode1 := LdependencyManagementDependenciesdependencyNode.ChildNodes.FindNode('classifier');
          var Lclassifier1: AnsiString;
          if LclassifierNode1 = nil then Lclassifier1 := ''
          else Lclassifier1 := LclassifierNode1.Text;
          //---
          if (LgroupId1 = '') or (LartifactId1 = '') or (Lversion1='') or (LPackaging1='') then
            raise Exception.Create('Error F46F12C7-276B-442D-B7D7-36AD23514293');
          //The minimal set of information for matching a dependency reference against a dependencyManagement section is
          //actually {groupId, artifactId, type, classifier}. In many cases, these dependencies will refer to jar
          //artifacts with no classifier. This allows us to shorthand the identity set to {groupId, artifactId},
          //since the default for the type field is jar, and the default classifier is null.
          for var J := 0 to LdependenciesNode.ChildNodes.Count - 1 do begin
            var LdependenciesdependencyNode := LdependenciesNode.ChildNodes[j];
            if LdependenciesdependencyNode.Nodetype <> ntelement then continue;
            //---
            var LgroupId2 := LdependenciesdependencyNode.ChildNodes['groupId'].Text;
            var LartifactId2 := LdependenciesdependencyNode.ChildNodes['artifactId'].Text;
            //---
            Var LPackagingNode2 := LdependenciesdependencyNode.ChildNodes.FindNode('packaging');
            var LPackaging2: AnsiString;
            if LPackagingNode2 = nil then LPackaging2 := 'jar'
            else LPackaging2 := LPackagingNode2.Text;
            //---
            Var LclassifierNode2 := LdependenciesdependencyNode.ChildNodes.FindNode('classifier');
            var Lclassifier2: AnsiString;
            if LclassifierNode2 = nil then Lclassifier2 := ''
            else Lclassifier2 := LclassifierNode2.Text;
            //---
            if (LgroupId1 = LgroupId2) and
               (LartifactId1 = LartifactId2) and
               (LPackaging1 = LPackaging2) and
               (Lclassifier1 = Lclassifier2) then begin
              if (Lversion1 <> '') and (LdependenciesdependencyNode.ChildNodes.FindNode('version') = nil) then
                LdependenciesdependencyNode.AddChild('version').Text := Lversion1;
              if (Lscope1 <> '') and (LdependenciesdependencyNode.ChildNodes.FindNode('scope') = nil) then
                LdependenciesdependencyNode.AddChild('scope').Text := Lscope1;
            end;
          end;
        end;

      end;
    end;

  finally
    ALFreeAndNil(LParentPomXmlDoc);
  end;

end;

{*******************************************************************}
//we need this function for debuging because their is a bug in delphi
//that make we can not debug inlined var when they are inside the
//begin ... end of the dpr
procedure Kickoff;
begin
  try

    {$IFDEF DEBUG}
    ReportMemoryleaksOnSHutdown := True;
    {$ENDIF}
    SetMultiByteConversionCodePage(CP_UTF8);

    {$REGION 'Init local vars'}
    var LNoInteraction: boolean := False;
    {$ENDREGION}

    {$REGION 'Retrieve delphi configuration'}
    {$IFNDEF ALCompilerVersionSupported}
      {$MESSAGE WARN 'Check if Delphi still use aapt (https://quality.embarcadero.com/browse/RSP-27606) and if not remove all usage of aapt.exe and use only aapt2.exe'}
    {$IFEND}
    JDKDir := ''; // C:\Program Files\Eclipse Adoptium\jdk-11.0.16.101-hotspot\
    var LDelphiRootDir: String := ''; // C:\Program Files (x86)\Embarcadero\Studio\22.0\
    Var LAaptFilename: String := '';  // C:\SDKs\android\build-tools\32.0.0\aapt.exe
    Var LAapt2Filename: String := ''; // C:\SDKs\android\build-tools\32.0.0\aapt2.exe
    Var LSDKApiLevelDir: String := ''; // C:\SDKs\android\platforms\android-32\
    Var LSDKApiLevelJarFilename: String := ''; // C:\SDKs\android\platforms\android-32\android.jar
    var LJavacFilename: String := ''; // C:\Program Files\Eclipse Adoptium\jdk-11.0.16.101-hotspot\bin\javac.exe
    var LJarExeFilename: String := ''; // C:\Program Files\Eclipse Adoptium\jdk-11.0.16.101-hotspot\bin\jar.exe
    var LRegistry := TRegistry.Create;
    try
      LRegistry.RootKey:=HKEY_CURRENT_USER;
      if not LRegistry.OpenKeyReadOnly('SOFTWARE\Embarcadero\BDS') then
        raise Exception.Create('Could not find Embarcadero Delphi Registry');
      var LSubKeyNames := TStringList.Create;
      Try
        LRegistry.GetKeyNames(LSubKeyNames);
        var LCompilerVersionStr: String := '';
        var LCompilerVersionFloat: Double := 0;
        for var LName in LSubKeyNames do begin
          var LTmpCompilerVersionFloat := ALStrToFloatDef(LName, 0, ALDefaultFormatSettingsW);
          if LTmpCompilerVersionFloat > LCompilerVersionFloat then begin
            LCompilerVersionStr := LName;
            LCompilerVersionFloat := LTmpCompilerVersionFloat;
          end;
        end;
        if LCompilerVersionStr = '' then raise Exception.Create('Incorrect Embarcadero Delphi Registry');
        LRegistry.CloseKey;
        if not LRegistry.OpenKeyReadOnly('SOFTWARE\Embarcadero\BDS\'+LCompilerVersionStr) then
          raise Exception.Create('Incorrect Embarcadero Delphi Registry');
        LDelphiRootDir := LRegistry.ReadString('RootDir');
        if LDelphiRootDir = '' then raise Exception.Create('Their is no RootDir Configured in Embarcadero Delphi Registry');
        if not TDirectory.Exists(LDelphiRootDir) then raise Exception.CreateFmt('Directory %s does not exist', [LDelphiRootDir]);
        LRegistry.CloseKey;
        if not LRegistry.OpenKeyReadOnly('SOFTWARE\Embarcadero\BDS\'+LCompilerVersionStr+'\PlatformSDKs') then
          raise Exception.Create('Their is no platform SDK Configured');
        Var LPlatformSDKName := LRegistry.ReadString('Default_Android64');
        if LPlatformSDKName = '' then LPlatformSDKName := LRegistry.ReadString('Default_Android');
        if LPlatformSDKName = '' then raise Exception.Create('Their is no default Android platform SDK Configured');
        LRegistry.CloseKey;
        if not LRegistry.OpenKeyReadOnly('SOFTWARE\Embarcadero\BDS\'+LCompilerVersionStr+'\PlatformSDKs\'+LPlatformSDKName) then
          raise Exception.Create('Incorrect Embarcadero Delphi Registry');
        LAaptFilename := LRegistry.ReadString('SDKAaptPath');
        if LAaptFilename = '' then raise Exception.Create('SDKAaptPath is not configured');
        if not TFile.exists(LAaptFilename) then raise Exception.CreateFmt('%s does not exist', [LAaptFilename]);
        LAapt2Filename := ALStringReplaceW(LAaptFilename, 'aapt.exe', 'aapt2.exe', [rfIgnoreCase]);
        if not TFile.exists(LAapt2Filename) then raise Exception.CreateFmt('%s does not exist', [LAapt2Filename]);
        LSDKApiLevelDir := LRegistry.ReadString('SDKApiLevelPath');
        if not TDirectory.Exists(LSDKApiLevelDir) then raise Exception.CreateFmt('Directory %s does not exist', [LSDKApiLevelDir]);
        LSDKApiLevelDir := ALIncludeTrailingPathDelimiterW(LSDKApiLevelDir);
        LSDKApiLevelJarFilename := LSDKApiLevelDir + 'android.jar';
        if not TFile.exists(LSDKApiLevelJarFilename) then raise Exception.CreateFmt('%s does not exist', [LSDKApiLevelJarFilename]);
        JDKDir := LRegistry.ReadString('JDKPath');
        if not TDirectory.Exists(JDKDir) then raise Exception.CreateFmt('Directory %s does not exist', [JDKDir]);
        JDKDir := ALIncludeTrailingPathDelimiterW(JDKDir);
        LJavacFilename := JDKDir + 'bin\javac.exe';
        if not TFile.exists(LJavacFilename) then raise Exception.CreateFmt('%s does not exist', [LJavacFilename]);
        LJarExeFilename := JDKDir + 'bin\jar.exe';
        if not TFile.exists(LJarExeFilename) then raise Exception.CreateFmt('%s does not exist', [LJarExeFilename]);
      Finally
        ALFreeAndNil(LSubKeyNames);
      End;
    finally
      ALFreeAndNil(LRegistry);
    end;
    {$ENDREGION}

    {$REGION 'Create the tmp dir'}
    Var LtmpDirectory := ALGetModulePathW + 'tmp\';
    TDirectory.CreateDirectory(LtmpDirectory);
    if not AlEmptyDirectoryW(LtmpDirectory, true{SubDirectory}) then raise EALException.CreateFmt('Cannot clear %s', [LtmpDirectory]);
    {$ENDREGION}

    {$REGION 'create the LtmpDirectoryLibraries'}
    var LtmpDirectoryLibraries := LtmpDirectory + 'Libraries\';
    TDirectory.CreateDirectory(LtmpDirectoryLibraries);
    {$ENDREGION}

    {$REGION 'create the LtmpDirectoryRJava'}
    var LtmpDirectoryRJava := LtmpDirectory + 'RJava\';
    TDirectory.CreateDirectory(LtmpDirectoryRJava);
    {$ENDREGION}

    {$REGION 'create the LtmpDirectoryRClass'}
    var LtmpDirectoryRClass := LtmpDirectory + 'RClass\';
    TDirectory.CreateDirectory(LtmpDirectoryRClass);
    {$ENDREGION}

    {$REGION 'create the LtmpDirectoryMaven'}
    var LtmpDirectoryMaven := LtmpDirectory + 'Maven\';
    TDirectory.CreateDirectory(LtmpDirectoryMaven);
    {$ENDREGION}

    {$REGION 'create the LtmpDirectoryGoogleServices'}
    var LtmpDirectoryGoogleServices := LtmpDirectory + 'GoogleServices\';
    TDirectory.CreateDirectory(LtmpDirectoryGoogleServices);
    {$ENDREGION}

    {$REGION 'create the LRFlataFilename'}
    var LRFlataFilename := LtmpDirectory + 'compiled_res.flata';
    {$ENDREGION}

    {$REGION 'create local objects'}
    var LParamLst := TALStringListW.Create;
    Var LLibraries := TALJSONDocumentA.Create;
    var LConfigs := TALStringListA.Create;
    var LPlatforms := TALStringListA.Create;
    var LSupportLibraryToAndroidx := TALStringListA.Create;
    {$ENDREGION}

    try

      {$REGION 'Init LParamLst'}
      for var I := 1 to ParamCount do
        LParamLst.Add(ParamStr(i));
      {$IF defined(DEBUG)}
      LParamLst.Clear;
      LParamLst.add('-LocalMavenRepositoryDir=..\..\Libraries\jar\');
      LParamLst.add('-Libraries=.\_Build\Sample\SampleApp;com.alcinoe:alcinoe-firebase-messaging:1.0.0');
      LParamLst.add('-OutputDir=.\_Build\Sample\Merged\');
      LParamLst.add('-DProj=_Build\Sample\Sample.dproj');
      LParamLst.add('-AndroidManifest=_Build\Sample\AndroidManifest.template.xml');
      LParamLst.add('-DProjNormalizer=..\DProjNormalizer\DProjNormalizer.exe');
      LParamLst.add('-RJarSwapper=..\RJarSwapper\RJarSwapper.bat');
      LParamLst.add('-UseGradle=true');
      LParamLst.add('-GoogleServicesJson=_Build\Sample\google-services.json');
      {$ENDIF}
      {$ENDREGION}

      {$REGION 'Init LDownloadDependencies'}
      var LtmpParamStr := ALTrim(LParamLst.Values['-DownloadDependencies']);
      var LDownloadDependencies := (LtmpParamStr = '') or (AlStrToBool(LtmpParamStr));
      {$ENDREGION}

      {$REGION 'Init LNoInteraction'}
      LNoInteraction := AlStrToBool(ALTrim(LParamLst.Values['-NoInteraction']));
      {$ENDREGION}

      {$REGION 'Init LGenerateNativeBridgeFile'}
      var LGenerateNativeBridgeFile := AlStrToBool(ALTrim(LParamLst.Values['-GenerateNativeBridgeFile']));
      {$ENDREGION}

      {$REGION 'Init LOutputDir'}
      var LOutputDir := ExpandFileName(ALTrim(LParamLst.Values['-OutputDir']));
      if LOutputDir = '' then raise Exception.Create('OutputDir param is mandatory');
      LOutputDir := ALIncludeTrailingPathDelimiterW(LOutputDir);
      if TDirectory.Exists(LOutputDir) then begin
        if (not LNoInteraction) then begin
          Write('Empty '+ LOutputDir + ' (Y/N)? ');
          Var LAnswer: String;
          ReadLn(LAnswer);
          if not ALSameTextW(LAnswer, 'Y') then begin
            Writeln('');
            Writeln('Press <Enter> key to quit');
            Readln;
            exit;
          end;
        end;
        if not AlEmptyDirectoryW(LOutputDir, true{SubDirectory}) then raise EALException.CreateFmt('Cannot clear %s', [LOutputDir]);
      end;
      TDirectory.CreateDirectory(LOutputDir);
      {$ENDREGION}

      {$REGION 'Init LLocalMavenRepositoryDir'}
      var LLocalMavenRepositoryDir := ExpandFileName(ALTrim(LParamLst.Values['-LocalMavenRepositoryDir']));
      if LLocalMavenRepositoryDir = '' then LLocalMavenRepositoryDir := LtmpDirectoryMaven;
      TDirectory.CreateDirectory(LLocalMavenRepositoryDir);
      {$ENDREGION}

      {$REGION 'Init LLibsOutputDir'}
      var LLibsOutputDir := LOutputDir + 'libs\';
      TDirectory.CreateDirectory(LLibsOutputDir);
      {$ENDREGION}

      {$REGION 'Init LJniOutputDir'}
      var LjniOutputDir := LOutputDir + 'jni\';
      TDirectory.CreateDirectory(LjniOutputDir);
      {$ENDREGION}

      {$REGION 'Init LResOutputDir'}
      var LresOutputDir := LOutputDir + 'res\';
      TDirectory.CreateDirectory(LresOutputDir);
      {$ENDREGION}

      {$REGION 'Init LAndroidManifest'}
      var LAndroidManifest := ExpandFileName(ALTrim(LParamLst.Values['-AndroidManifest']));
      {$ENDREGION}

      {$REGION 'Init LDProjFilename'}
      var LDProjFilename := ExpandFileName(ALTrim(LParamLst.Values['-DProj']));
      {$ENDREGION}

      {$REGION 'Init LConfigs'}
      LConfigs.CaseSensitive := False;
      LConfigs.LineBreak := ';';
      LConfigs.Text := AnsiString(LParamLst.Values['-Configurations']);
      if LConfigs.Count = 0 then begin
        LConfigs.Add('Debug');
        LConfigs.Add('Release');
      end;
      {$ENDREGION}

      {$REGION 'Init LPlatforms'}
      LPlatforms.CaseSensitive := False;
      LPlatforms.LineBreak := ';';
      LPlatforms.Text := AnsiString(LParamLst.Values['-Platforms']);
      if LPlatforms.Count = 0 then begin
        LPlatforms.Add('Android');
        LPlatforms.Add('Android64');
      end;
      for var LPlatform in LPlatforms do begin
        if (LPlatform <> 'Android') and
           (LPlatform <> 'Android64') then raise Exception.Create('Invalid Platforms parameter');
      end;
      {$ENDREGION}

      {$REGION 'Init LDProjNormalizer'}
      var LDProjNormalizer := ExpandFileName(ALTrim(LParamLst.Values['-DProjNormalizer']));
      {$ENDREGION}

      {$REGION 'Init LGoogleServicesJson'}
      var LGoogleServicesJson := ExpandFileName(ALTrim(LParamLst.Values['-GoogleServicesJson']));
      {$ENDREGION}

      {$REGION 'Init LRJarSwapper'}
      var LRJarSwapper := ExpandFileName(ALTrim(LParamLst.Values['-RJarSwapper']));
      {$ENDREGION}

      {$REGION 'Init LUseGradle'}
      var LUseGradle := AlStrToBool(ALTrim(LParamLst.Values['-UseGradle']));
      {$ENDREGION}

      {$REGION 'Init libraries'}
      Writeln('Init libraries');
      var LLibrariesLst := TALStringListW.Create;
      Try
        LLibrariesLst.LineBreak := ';';
        LLibrariesLst.Text := LParamLst.Values['-Libraries'];
        if LLibrariesLst.Count = 0 then raise Exception.Create('Libraries param is mandatory');
        for var I := 0 to LLibrariesLst.Count - 1 do begin

          //handle case like com.facebook.android:facebook-login:15.1.0
          var LLibrary := LLibrariesLst[i]; // com.facebook.android:facebook-login:15.1.0
          if (ALPosW('/',LLibrary) <= 0) and
             (ALPosW('\',LLibrary) <= 0) and
             (LLibrary.CountChar(':') = 2) then begin
            var LTmpLst := TALStringListA.Create;
            try
              LTmpLst.LineBreak := ':';
              LTmpLst.Text := AnsiString(LLibrary);
              if LTmpLst.Count <> 3 then raise Exception.Createfmt('Invalid library name (%s). Must look like <groupId>:<artifactId>:<version>', [LLibrary]);
              var LLocalArchivefilename: String;
              var LLocalpomfilename: String;
              if not DownloadLibraryFromCentralMavenRepository(
                       LLocalMavenRepositoryDir, // const ALocalRepositoryBaseDir: String;
                       LTmpLst[0], // const AGroupID: AnsiString;
                       LTmpLst[1], // const AArtifactID: AnsiString;
                       LTmpLst[2], // const AVersion: AnsiString;
                       LLocalArchivefilename, // out ALocalArchivefilename: String;
                       LLocalpomfilename) then // out ALocalpomfilename: String)
                raise Exception.CreateFmt('Could not find %s in central repository', [LLibrary]);
              if LLocalArchivefilename <>'' then LLibrariesLst[i] := LLocalArchivefilename
              else LLibrariesLst[i] := LLocalpomfilename;
            finally
              ALFreeAndNil(LTmpLst);
            end;
          end;

          //init LArchiveFilename
          var LArchiveFilename := ExpandFileName(LLibrariesLst[i]);
          if LArchiveFilename = '' then continue;

          //get info from the pom
          var LPomFilename := LArchiveFilename; // C:\Libraries\jar\com.google.firebase\firebase-messaging-23.1.0.aar
          LPomFilename := ALIncludeTrailingPathDelimiterW(ALExtractFilePath(ALExcludeTrailingPathDelimiterW(LPomFilename))) +
                          ALExtractFileName(ALExcludeTrailingPathDelimiterW(LPomFilename), True{RemoveFileExt}) +
                          '.pom'; // C:\Libraries\jar\com.google.firebase\firebase-messaging-23.1.0.pom
          var LGroupID: AnsiString := '';
          var LArtifactId: AnsiString := '';
          var LVersion: AnsiString := '';
          if Tfile.Exists(LPomFilename) then begin
            Var LPomXmlDoc := TalXmlDocument.Create('root');
            try
              LPomXmlDoc.LoadFromFile(LPomFilename);
              ExpandPom(LPomXmlDoc, LLocalMavenRepositoryDir);
              LGroupID := LPomXmlDoc.DocumentElement.ChildNodes['groupId'].Text;
              LArtifactId := LPomXmlDoc.DocumentElement.ChildNodes['artifactId'].Text;
              LVersion := LPomXmlDoc.DocumentElement.ChildNodes['version'].Text;
              if (LGroupID = '') or (LArtifactId='') or (LVersion='') then
                raise Exception.Create('Error DD67075B-3B93-4FCD-96C8-D55B931565A5');
            finally
              ALFreeAndNil(LPomXmlDoc);
            end;
          end
          else LPomFilename := '';

          //If it's a pom only dependency
          if ALSameTextW(ALExtractFileExt(LArchiveFilename), '.pom') then begin
            LArchiveFilename := '';
            if LPomFilename = '' then raise Exception.Create('Error 17EA59ED-E5B2-40A0-89AC-6988149B0284');
          end;

          //update the LLibraries
          With LLibraries.AddChild('library', ntObject) do begin
            Addchild('groupid').Text := LGroupID; // com.google.firebase
            Addchild('artifactid').Text := LArtifactId; // firebase-messaging
            Addchild('version').Text := LVersion; // 23.1.0
            Addchild('archivefilename').Text := AnsiString(LArchiveFilename); // C:\Libraries\jar\com.google.firebase\firebase-messaging-23.1.0.aar
            Addchild('pomfilename').Text := AnsiString(LPomFilename); // C:\Libraries\jar\com.google.firebase\firebase-messaging-23.1.0.pom
            With Addchild('dependencyrequirements', ntarray) do begin
              With addchild(ntobject) do begin
                with Addchild('version', ntobject) do begin
                  Addchild('min').text := LVersion;
                  Addchild('max').text := LVersion;
                end;
                with Addchild('by', ntobject) do begin
                  Addchild('groupid').Text := '';
                  Addchild('artifactid').Text := '';
                  Addchild('version').Text := '';
                end;
              end;
            end;
          end;

        end;
      Finally
        ALFreeAndNil(LLibrariesLst);
      End;
      {$ENDREGION}

      {$REGION 'Check all dependancies using Gradle'}
      if LUseGradle then begin
        Writeln('Check all dependancies using gradle');
        var LDependenciesWalkerOriginalDir := ALGetModulePathW + 'DependenciesWalker\';
        if not TDirectory.Exists(LDependenciesWalkerOriginalDir) then raise EALException.CreateFmt('Directory %s does not exist', [LDependenciesWalkerOriginalDir]);
        var LDependenciesWalkerTmpDir := LtmpDirectory + 'DependenciesWalker\';
        TDirectory.CreateDirectory(LDependenciesWalkerTmpDir);
        //---
        //copy the DependenciesWalker content in TMP dir
        if not AlCopyDirectoryW(
                 LDependenciesWalkerOriginalDir, // SrcDirectory,
                 LDependenciesWalkerTmpDir, // DestDirectory: ansiString;
                 true) then // SubDirectory: Boolean;
          raise Exception.Createfmt('Cannot copy %s to %s', [LDependenciesWalkerOriginalDir, LDependenciesWalkerTmpDir]);
        //---
        //Update the build.gradle
        var LBuildGradleFileName := LDependenciesWalkerTmpDir + 'app\build.gradle';
        if not Tfile.Exists(LBuildGradleFileName) then raise Exception.CreateFmt('%s does not exist', [LBuildGradleFileName]);
        Var LBuildGradledependencies: AnsiString := '';
        for var I := 0 to LLibraries.ChildNodes.Count - 1 do begin
          var LLibrary := LLibraries.ChildNodes[i];
          Var LGroupID := LLibrary.GetChildNodeValueText('groupid', ''{default});
          Var Lartifactid := LLibrary.GetChildNodeValueText('artifactid', ''{default});
          Var LVersion := LLibrary.GetChildNodeValueText('version', ''{default});
          var LLibraryArchiveFileName := string(LLibrary.GetChildNodeValueText('archivefilename', ''{default}));
          var LPomFileName := string(LLibrary.GetChildNodeValueText('pomfilename', ''{default}));
          if (LGroupID <> '') and (Lartifactid <> '') and (LVersion <> '') then begin
            LBuildGradledependencies := LBuildGradledependencies + '    implementation "'+LGroupID+':'+Lartifactid+':'+LVersion+'"'#13#10;
            if ((LLibraryArchiveFileName <> '') and
                (ALPosW(LLocalMavenRepositoryDir, LLibraryArchiveFileName) <> 1))  or
               ((LPomFileName <> '') and
                (ALPosW(LLocalMavenRepositoryDir, LPomFileName) <> 1)) then begin
              Var LRepositoryDirectory := LDependenciesWalkerTmpDir +
                                          'localrepository\' +
                                          ALStringReplaceW(string(LGroupId),'.','\',[RfReplaceALL]) + '\' +
                                          String(LArtifactId) + '\' +
                                          string(LVersion) + '\';
              TDirectory.CreateDirectory(LRepositoryDirectory);
              if LLibraryArchiveFileName <> '' then
                Tfile.Copy(LLibraryArchiveFileName, LRepositoryDirectory + string(LArtifactId)+'-'+string(LVersion) + ALExtractFileExt(LLibraryArchiveFileName));
              if LPomFileName <> '' then
                Tfile.Copy(LPomFileName, LRepositoryDirectory + string(LArtifactId)+'-'+string(LVersion) + ALExtractFileExt(LPomFileName));
            end;
          end
          else begin
            if LLibraryArchiveFileName = '' then raise Exception.Create('Error 6AF219E0-8FDC-4C2A-A112-BBFDB91B9580');
            if LPomFileName <> '' then raise Exception.Create('Error 6F7C2A3E-76E2-44A6-A2D5-D0BCA4C2F1EA');
            Writeln('Skip '+string(LLibraryArchiveFileName) + ' (no pom file found)', TALConsoleColor.ccAqua);
            continue;
          end;
        end;
        var LBuildGradleSrc := ALGetStringFromFile(LBuildGradleFileName, TEncoding.UTF8);
        LBuildGradleSrc := ALStringReplaceW(LBuildGradleSrc, '%dependencies%', ALTrimRight(String(LBuildGradledependencies)), [RfIgnoreCase]);
        ALSaveStringtoFile(LBuildGradleSrc, LBuildGradleFileName, Tencoding.UTF8, false{WriteBOM});
        //---
        var LSettingGradleFileName := LDependenciesWalkerTmpDir + 'settings.gradle';
        var LLocalMavenRepositoryStr := '';
        if LLocalMavenRepositoryDir <> '' then begin
          LLocalMavenRepositoryStr := ALStringReplaceW(LLocalMavenRepositoryDir,'\','/',[RfReplaceALL]);
          LLocalMavenRepositoryStr := 'maven {url uri("file://'+LLocalMavenRepositoryStr+'")}';
        end;
        var LSettingGradleSrc := ALGetStringFromFile(LSettingGradleFileName, TEncoding.UTF8);
        LSettingGradleSrc := ALStringReplaceW(LSettingGradleSrc, '%LocalMavenRepository%', LLocalMavenRepositoryStr, [RfIgnoreCase]);
        ALSaveStringtoFile(LSettingGradleSrc, LSettingGradleFileName, Tencoding.UTF8, false{WriteBOM});
        //---
        //run graddle
        Var LGradleResultSrc: AnsiString;
        Var LInputStream := TMemorystream.Create;
        Var LOutputStream := TStringStream.Create;
        try
          var LcmdLine := LDependenciesWalkerTmpDir + 'gradlew.bat app:dependencies --configuration releaseRuntimeClasspath --project-dir '+LDependenciesWalkerTmpDir;
          OverWrite(LcmdLine);
          Var LCmdLineResult := ALWinExecW(
                                  LcmdLine, // const aCommandLine: String;
                                  LDependenciesWalkerTmpDir, // const aCurrentDirectory: AnsiString;
                                  GetEnvironmentStringWithJavaHomeUpdated, // const aEnvironment: AnsiString;
                                  LInputStream, // const aInputStream: Tstream;
                                  LOutputStream); //const aOutputStream: TStream;
          if LCmdLineResult <> 0 then
            raise Exception.Createfmt('Failed to execute %s'#13#10'%s', [LcmdLine, LOutputStream.DataString]);
          LGradleResultSrc := AnsiString(LOutputStream.DataString);
        finally
          ALFreeandNil(LInputStream);
          ALFreeandNil(LOutputStream);
        end;
        //analyze LGradleResultSrc
        var LInDependanciesTree: Boolean := False;
        Var LGradleResultLst := TALStringListA.Create;
        try
          LGradleResultLst.Text := LGradleResultSrc;
          for Var I := 0 to LGradleResultLst.Count - 1 do begin
            Var LLine := ALTrim(LGradleResultLst[i]); // |    |    |    \--- androidx.annotation:annotation:1.1.0 -> 1.3.0
            If ALSameTextA(LLine, 'releaseRuntimeClasspath - Resolved configuration for runtime for variant: release') then begin
              LInDependanciesTree := True;
              Continue;
            end;
            if not LInDependanciesTree then continue;
            if LLine = '' then break;
            if ALSameTextA(LLine, 'No dependencies') then break;
            while (LLine <> '') and (LLine[low(LLine)] in ['+','|','\','-', ' ']) do
              delete(LLine, 1, 1); // androidx.annotation:annotation:1.1.0 -> 1.3.0
            Var LLst := TALStringListA.Create;
            Try
              LLst.LineBreak := ':';
              LLst.Text := LLine;
              if LLst.Count <> 3 then raise Exception.Create('Error 43963A52-56D3-4B57-AA34-816194BCADCE ('+String(LLine)+')');
              var LDependencyGroupID := LLst[0]; // androidx.annotation
              var LDependencyArtifactID := LLst[1]; // annotation
              var LDependencyVersion := LLst[2]; // 1.1.0 -> 1.3.0 (*)
              Var P := ALPosA('->', LDependencyVersion);
              if P > 0 then begin
                delete(LDependencyVersion, 1, P+1); //  1.3.0 (*)
              end;
              //(*) - dependencies omitted (listed previously)
              LDependencyVersion := ALStringReplaceA(LDependencyVersion, '(*)', '', []); //  1.3.0
              //(c) - dependency constraint
              LDependencyVersion := ALStringReplaceA(LDependencyVersion, '(c)', '', []);
              LDependencyVersion := ALTrim(LDependencyVersion); // 1.3.0
              if ALPosIgnoreCaseA('FAILED', LDependencyVersion) > 0 then begin
                LDependencyVersion := ALTrim(ALStringReplaceA(LDependencyVersion, 'FAILED', '', [RfIgnoreCase]));
                Writeln(
                  'Cannot resolve '+string(LDependencyGroupID)+':'+string(LDependencyArtifactID)+':'+string(LDependencyVersion),
                  TALConsoleColor.ccPurple,
                  true{ASkipDuplicates});
              end
              else begin
                if ALPosA(' ', LDependencyVersion) > 0 then raise Exception.Create('Error CD3F7D9C-874C-4089-B674-9CCCE4AFA50E'#13#10+string(LGradleResultSrc));
                if FindLibraryNode(
                     LLibraries, // const ALibraries: TALJSONDocumentA;
                     LDependencyGroupID, // const AGroupID: AnsiString;
                     LDependencyArtifactID, // const AArtifactID: AnsiString;
                     LDependencyVersion) <> nil then continue; // const AVersion: AnsiString): TALJSONNodeA; then
                var LLocalArchivefilename: String;
                var LLocalpomfilename: String;
                if LDownloadDependencies and
                   DownloadLibraryFromCentralMavenRepository(
                     LLocalMavenRepositoryDir, // const ALocalRepositoryBaseDir: String;
                     LDependencyGroupID, // const AGroupID: AnsiString;
                     LDependencyArtifactID, // const AArtifactID: AnsiString;
                     LDependencyVersion, // const AVersion: AnsiString;
                     LLocalArchivefilename, // out ALocalArchivefilename: String;
                     LLocalpomfilename) then begin // out ALocalpomfilename: String): Boolean;
                  With LLibraries.AddChild('library', ntObject) do begin
                    Addchild('groupid').Text := LDependencyGroupID; // com.google.firebase
                    Addchild('artifactid').Text := LDependencyArtifactID; // firebase-messaging
                    Addchild('version').Text := LDependencyVersion; // 23.1.0
                    Addchild('archivefilename').Text := AnsiString(LLocalArchivefilename); // C:\Libraries\jar\com.google.firebase\firebase-messaging-23.1.0.aar
                    Addchild('pomfilename').Text := AnsiString(LLocalpomfilename); // C:\Libraries\jar\com.google.firebase\firebase-messaging-23.1.0.pom
                    Addchild('dependencyrequirements', ntarray);
                  end;
                end
                else begin
                  Writeln(
                    'Missing Dependency '+string(LDependencyGroupID)+':'+string(LDependencyArtifactID)+':'+string(LDependencyVersion),
                    TALConsoleColor.ccPurple,
                    true{ASkipDuplicates});
                end;
              end;
            Finally
              ALFreeAndNil(LLst);
            End;
          end;
        finally
          ALFreeAndNil(LGradleResultLst);
        end;
        if LInDependanciesTree = False then
          raise Exception.Create('Error FD57344C-9716-421F-B210-6E5E7B367418');
      end
      {$ENDREGION}

      {$REGION 'Check all dependancies using internal algorithm'}
      //https://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-project-dependencies.html#pom-relationships-sect-version-ranges
      else begin
        Writeln('Check all dependancies using internal algorithm');
        var LLibrariesIdx: integer := 0;
        while LLibrariesIdx <= LLibraries.ChildNodes.Count - 1 do begin

          {$REGION 'init LLibrary'}
          var LLibrary := LLibraries.ChildNodes[LLibrariesIdx];
          inc(LLibrariesIdx);
          {$ENDREGION}

          {$REGION 'Their is a pom'}
          var LPomFilename := LLibrary.GetChildNodeValueText('pomfilename', '');
          if LPomFilename <> '' then begin
            Try
              Var LPomXmlDoc := TalXmlDocument.Create('root');
              try

                {$REGION 'load the pom'}
                LPomXmlDoc.LoadFromFile(LPomFilename);
                ExpandPom(LPomXmlDoc, LLocalMavenRepositoryDir);
                {$ENDREGION}

                {$REGION 'init LdependenciesNode'}
                Var LdependenciesNode := LPomXmlDoc.DocumentElement.ChildNodes.FindNode('dependencies');
                {$ENDREGION}

                {$REGION 'no dependency in the pom'}
                if (LdependenciesNode = nil) or
                   (LdependenciesNode.ChildNodes.Count = 0) then continue;
                {$ENDREGION}

                {$REGION 'loop on all dependancies in the pom'}
                For var J := 0 to LdependenciesNode.ChildNodes.Count - 1 do begin

                  {$REGION 'get infos from the dependency'}
                  var LdependencyNode := LdependenciesNode.ChildNodes[J];
                  if LdependencyNode.NodeType <> ntElement then continue;
                  if LdependencyNode.NodeName <> 'dependency' then raise Exception.Create('Error 15D1E7CC-A4D2-49B0-8755-4EFC06296AA2');
                  //---
                  //https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html
                  //When optional=true then they are included only if they are a direct dependancy
                  //in our case direct dependancy are only the one we included in the command line (ie -libraries params)
                  //all other are transitive to our project and can be ignored
                  var LdependancyOptionalNode := LdependencyNode.ChildNodes.FindNode('optional');
                  if (LdependancyOptionalNode <> nil) then begin
                    if not ALSameTextA(LdependancyOptionalNode.Text, 'true') then
                      raise Exception.Create('Error 711FF857-5288-4013-9A2C-861D5C16E007');
                    continue;
                  end;
                  //---
                  //scope: This element refers to the classpath of the task at hand (compiling and runtime, testing, etc.) as well as how
                  //to limit the transitivity of a dependency. There are five scopes available:
                  //compile - this is the default scope, used if none is specified. Compile dependencies are available in all classpaths.
                  //          Furthermore, those dependencies are propagated to dependent projects.
                  //provided - this is much like compile, but indicates you expect the JDK or a container to provide it at runtime.
                  //           It is only available on the compilation and test classpath, and is not transitive.
                  //runtime - this scope indicates that the dependency is not required for compilation, but is for execution.
                  //          It is in the runtime and test classpaths, but not the compile classpath.
                  //test - this scope indicates that the dependency is not required for normal use of the application,
                  //       and is only available for the test compilation and execution phases. It is not transitive.
                  //system - this scope is similar to provided except that you have to provide the JAR which contains it
                  //         explicitly. The artifact is always available and is not looked up in a repository.
                  var LDependencyScopeNode := LdependencyNode.ChildNodes.FindNode('scope');
                  var LDependencyScope: AnsiString;
                  if LDependencyScopeNode = nil then LDependencyScope := 'compile'
                  else LDependencyScope := LDependencyScopeNode.Text;
                  if ALSameTextA(LDependencyScope, 'test') then continue
                  else if ALSameTextA(LDependencyScope, 'provided') then continue // I found stuff like com.google.android:android:4.0.0 (in com.squareup.okhttp3:parent:3.12.1 for exemple)
                  else if ALSameTextA(LDependencyScope, 'system') then continue // same as provided, I found also stuff like com.google.android:android:4.0.0 in com.google.zxing:zxing-parent:3.3.3
                  else if (not ALSameTextA(LDependencyScope, 'compile')) and
                          (not ALSameTextA(LDependencyScope, 'runtime')) then raise Exception.Createfmt('Unknown dependency.scope value "%s"', [LDependencyScope]);
                  //---
                  var LDependencyGroupId := LdependencyNode.ChildNodes['groupId'].text;  // com.android.support
                  var LDependencyArtifactId := LdependencyNode.ChildNodes['artifactId'].text; // support-v4
                  var LDependencyPreferredVersion: AnsiString;
                  var LDependencyVersionRequirements := ExpandDependencyVersionRequirements(
                                                          LDependencyGroupId,
                                                          LDependencyArtifactId,
                                                          LdependencyNode.ChildNodes['version'].Text, // [1.0]
                                                          LDependencyPreferredVersion);
                  if (LDependencyGroupId = '') or (LDependencyArtifactId = '') or (LDependencyPreferredVersion = '') then
                    raise Exception.Create('Error E911B0CA-007B-4DAD-A90C-5F7117A8407C');
                  if length(LDependencyVersionRequirements) = 0 then raise Exception.Create('Error 5B1E62D3-527A-4050-BA8D-ADC727E02304');
                  if length(LDependencyVersionRequirements) > 1 then raise Exception.Create('Error A1F6B447-9276-4247-BE0D-D82E54C23DF0');
                  //---
                  //https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html
                  //I do not handle Dependency Exclusions for now
                  var LdependancyExclusionsNode := LdependencyNode.ChildNodes.FindNode('exclusions');
                  if (LdependancyOptionalNode <> nil) and (LdependancyOptionalNode.ChildNodes.Count > 0) then begin
                    Writeln(
                      string(LDependencyGroupID)+':'+string(LDependencyArtifactID)+':'+string(LDependencyPreferredVersion) + ' use dependency exclusions. AndroidMerger do not yet support dependency exclusions',
                      TALConsoleColor.ccaQua,
                      true{ASkipDuplicates});
                  end;
                  {$ENDREGION}

                  {$REGION 'init LAlreadyIncludedDependencyLibrary'}
                  var LAlreadyIncludedDependencyLibrary := FindLibraryNode(
                                                             LLibraries, // const ALibraries: TALJSONDocumentA;
                                                             LDependencyGroupID, // const AGroupID: AnsiString;
                                                             LDependencyArtifactID, // const AArtifactID: AnsiString;
                                                             ''); // const AVersion: AnsiString): TALJSONNodeA;
                  {$ENDREGION}

                  {$REGION 'We do not yet have any version of the dependency already included'}
                  if (LAlreadyIncludedDependencyLibrary = nil) then begin
                    var LLocalArchivefilename: String;
                    var LLocalpomfilename: String;
                    if LDownloadDependencies and
                       DownloadLibraryFromCentralMavenRepository(
                         LLocalMavenRepositoryDir, // const ALocalRepositoryBaseDir: String;
                         LDependencyGroupID, // const AGroupID: AnsiString;
                         LDependencyArtifactID, // const AArtifactID: AnsiString;
                         LDependencyPreferredVersion, // const AVersion: AnsiString;
                         LLocalArchivefilename, // out ALocalArchivefilename: String;
                         LLocalpomfilename) then begin // out ALocalpomfilename: String): Boolean;
                      With LLibraries.AddChild('library', ntObject) do begin
                        Addchild('groupid').Text := LDependencyGroupID; // com.google.firebase
                        Addchild('artifactid').Text := LDependencyArtifactID; // firebase-messaging
                        Addchild('version').Text := LDependencyPreferredVersion; // 23.1.0
                        Addchild('archivefilename').Text := AnsiString(LLocalArchivefilename); // C:\Libraries\jar\com.google.firebase\firebase-messaging-23.1.0.aar
                        Addchild('pomfilename').Text := AnsiString(LLocalpomfilename); // C:\Libraries\jar\com.google.firebase\firebase-messaging-23.1.0.pom
                        With Addchild('dependencyrequirements', ntarray) do begin
                          for var K := Low(LDependencyVersionRequirements) to High(LDependencyVersionRequirements) do begin
                            With addchild(ntobject) do begin
                              with Addchild('version', ntobject) do begin
                                Addchild('min').text := LDependencyVersionRequirements[k].Key;
                                Addchild('max').text := LDependencyVersionRequirements[k].value;
                              end;
                              with Addchild('by', ntobject) do begin
                                Addchild('groupid').Text := LLibrary.GetChildNodeValueText('groupid', ''{default});
                                Addchild('artifactid').Text := LLibrary.GetChildNodeValueText('artifactid', ''{default});
                                Addchild('version').Text := LLibrary.GetChildNodeValueText('version', ''{default});
                              end;
                            end;
                          end;
                        end;
                      end;
                    end
                    else begin
                      Writeln(
                        'Missing Dependency '+string(LDependencyGroupID)+':'+string(LDependencyArtifactID)+':'+string(LDependencyPreferredVersion),
                        TALConsoleColor.ccPurple,
                        true{ASkipDuplicates});
                    end;
                  end
                  {$ENDREGION}

                  {$REGION 'We do have a version of the dependency already included'}
                  else begin

                    {$REGION 'Check that the range of DependencyVersionRequirements cross the range of AlreadyIncludedDependencyRequirements'}
                    //this will not work perfectly with a dependency that have 2 ranges
                    //for exemple the version xx need the dependency Y with a version between 0 .. 1.1 or 1.2 .. maxint
                    //I do not complicate my life for now as I think this will never happen
                    for var K := Low(LDependencyVersionRequirements) to High(LDependencyVersionRequirements) do begin
                      var LDependencyVersionRequirementMin := LDependencyVersionRequirements[k].Key;
                      var LDependencyVersionRequirementMax := LDependencyVersionRequirements[k].value;
                      var LAlreadyIncludedDependencyRequirementsNode := LAlreadyIncludedDependencyLibrary.ChildNodes['dependencyrequirements'];
                      for var L := 0 to LAlreadyIncludedDependencyRequirementsNode.ChildNodes.Count - 1 do begin
                        var LAlreadyIncludedDependencyRequirementNode := LAlreadyIncludedDependencyRequirementsNode.ChildNodes[L];
                        var LVersionRelationShip1: integer;
                        var LVersionRelationShip2: integer;
                        if ((CompareVersion(LDependencyVersionRequirementMax, LAlreadyIncludedDependencyRequirementNode.GetChildNodeValueText(['version', 'min'], ''{default}), LVersionRelationShip1)) and (LVersionRelationShip1 < 0)) or
                           ((CompareVersion(LDependencyVersionRequirementMin, LAlreadyIncludedDependencyRequirementNode.GetChildNodeValueText(['version', 'max'], ''{default}), LVersionRelationShip2)) and (LVersionRelationShip2 > 0)) then begin
                          Var LProjectName := LAlreadyIncludedDependencyRequirementNode.GetChildNodeValueText(['by', 'groupid'], ''{default});
                          if LProjectName <> '' then
                            LProjectName := LProjectName + ':' +
                                            LAlreadyIncludedDependencyRequirementNode.GetChildNodeValueText(['by', 'artifactid'], ''{default}) + ':' +
                                            LAlreadyIncludedDependencyRequirementNode.GetChildNodeValueText(['by', 'version'], ''{default})
                          else
                            LProjectName := 'The project';
                          var LErrorMessage:= 'Dependency version conflicts. ' +
                                              LProjectName + ' ' +
                                              'need a version of '+
                                              LDependencyGroupId + ':' +
                                              LDependencyGroupID + ' ' +
                                              'between ' +
                                              LAlreadyIncludedDependencyRequirementNode.GetChildNodeValueText(['version', 'min'], ''{default}) + '..' +
                                              LAlreadyIncludedDependencyRequirementNode.GetChildNodeValueText(['version', 'max'], ''{default}) + ' ' +
                                              'and ' +
                                              LLibrary.GetChildNodeValueText('groupid', '') +':'+
                                              LLibrary.GetChildNodeValueText('artifactid', '') +':'+
                                              LLibrary.GetChildNodeValueText('version', '') + ' ' +
                                              'need a version between ' +
                                              LDependencyVersionRequirementMin + '..' +
                                              LDependencyVersionRequirementMax;
                          LErrorMessage := ALStringReplaceA(LErrorMessage, ALIntToStrA(ALMaxint64), '<maxint>', [rfReplaceALL]);
                          LPomFilename := '';
                          raise EALException.Create(LErrorMessage);
                        end;
                      end;
                    end;
                    {$ENDREGION}

                    {$REGION 'Update the AlreadyIncludedDependencyRequirements'}
                    With LAlreadyIncludedDependencyLibrary.ChildNodes['dependencyrequirements'] do begin
                      for var K := Low(LDependencyVersionRequirements) to High(LDependencyVersionRequirements) do begin
                        With addchild(ntobject) do begin
                          with Addchild('version', ntobject) do begin
                            Addchild('min').text := LDependencyVersionRequirements[k].Key;
                            Addchild('max').text := LDependencyVersionRequirements[k].value;
                          end;
                          with Addchild('by', ntobject) do begin
                            Addchild('groupid').Text := LLibrary.GetChildNodeValueText('groupid', ''{default});
                            Addchild('artifactid').Text := LLibrary.GetChildNodeValueText('artifactid', ''{default});
                            Addchild('version').Text := LLibrary.GetChildNodeValueText('version', ''{default});
                          end;
                        end;
                      end;
                    end;
                    {$ENDREGION}

                    {$REGION 'check if the current preferred version is the most adequate'}
                    var LVersionRelationShip: integer;
                    if CompareVersion(
                         LDependencyPreferredVersion,
                         LAlreadyIncludedDependencyLibrary.GetChildNodeValueText('version', ''{default}),
                         LVersionRelationShip) and (LVersionRelationShip > 0) then begin

                      //check that LDependencyPreferredVersion fulfill all the requierement
                      var LDependencyPreferredVersionFulFillRequierements: Boolean := True;
                      var LAlreadyIncludedDependencyRequirementsNode := LAlreadyIncludedDependencyLibrary.ChildNodes['dependencyrequirements'];
                      for var K := 0 to LAlreadyIncludedDependencyRequirementsNode.ChildNodes.Count - 1 do begin
                        var LAlreadyIncludedDependencyRequirementNode := LAlreadyIncludedDependencyRequirementsNode.ChildNodes[K];
                        var LVersionRelationShip1: integer;
                        var LVersionRelationShip2: integer;
                        if ((CompareVersion(LDependencyPreferredVersion, LAlreadyIncludedDependencyRequirementNode.GetChildNodeValueText(['version', 'min'], ''{default}), LVersionRelationShip1)) and (LVersionRelationShip1 < 0)) or
                           ((CompareVersion(LDependencyPreferredVersion, LAlreadyIncludedDependencyRequirementNode.GetChildNodeValueText(['version', 'max'], ''{default}), LVersionRelationShip2)) and (LVersionRelationShip2 > 0)) then begin
                          LDependencyPreferredVersionFulFillRequierements := False;
                          break;
                        end;
                      end;

                      //The LDependencyPreferredVersion fulfill all requierements
                      if LDependencyPreferredVersionFulFillRequierements then begin

                        //download the new dependency
                        var LLocalArchivefilename: String;
                        var LLocalpomfilename: String;
                        if LDownloadDependencies and
                           DownloadLibraryFromCentralMavenRepository(
                             LLocalMavenRepositoryDir, // const ALocalRepositoryBaseDir: String;
                             LDependencyGroupID, // const AGroupID: AnsiString;
                             LDependencyArtifactID, // const AArtifactID: AnsiString;
                             LDependencyPreferredVersion, // const AVersion: AnsiString;
                             LLocalArchivefilename, // out ALocalArchivefilename: String;
                             LLocalpomfilename) then begin // out ALocalpomfilename: String): Boolean;

                          //add the new node
                          var LTmpNode := LLibraries.AddChild('library', ntObject);
                          With LTmpNode do begin
                            Addchild('groupid').Text := LDependencyGroupID; // com.google.firebase
                            Addchild('artifactid').Text := LDependencyArtifactID; // firebase-messaging
                            Addchild('version').Text := LDependencyPreferredVersion; // 23.1.0
                            Addchild('archivefilename').Text := AnsiString(LLocalArchivefilename); // C:\Libraries\jar\com.google.firebase\firebase-messaging-23.1.0.aar
                            Addchild('pomfilename').Text := AnsiString(LLocalpomfilename); // C:\Libraries\jar\com.google.firebase\firebase-messaging-23.1.0.pom
                            With Addchild('dependencyrequirements', ntarray) do begin
                              While LAlreadyIncludedDependencyRequirementsNode.ChildNodes.Count > 0 do
                                Childnodes.Add(LAlreadyIncludedDependencyRequirementsNode.ChildNodes.Extract(0));
                            end;
                          end;

                          //delete the old dependency
                          var LTodeleteGroupID := LAlreadyIncludedDependencyLibrary.GetChildNodeValueText('groupid', ''{default});
                          var LTodeleteArtifactid := LAlreadyIncludedDependencyLibrary.GetChildNodeValueText('artifactid', ''{default});
                          var LTodeleteVersion := LAlreadyIncludedDependencyLibrary.GetChildNodeValueText('version', ''{default});
                          if (LTodeleteGroupID = '') or (LTodeleteArtifactid = '') or (LTodeleteVersion = '') then
                            raise Exception.Create('Error 47607420-D49C-4D38-9185-A2B597EF7551');
                          RemoveLibraryNode(
                            LLibraries, // const ALibraries: TALJSONDocumentA;
                            LTodeleteGroupID, // const AGroupID: AnsiString;
                            LTodeleteArtifactid, // const AArtifactID: AnsiString;
                            LTodeleteVersion); // const AVersion: AnsiString): TALJSONNodeA;

                          //update all dependencyrequirements
                          for var K := LLibraries.ChildNodes.Count - 1 downto 0 do begin
                            if LLibraries.ChildNodes[K] = LTmpNode then continue;
                            Var LdependencyrequirementsNode := LLibraries.ChildNodes[K].ChildNodes['dependencyrequirements'];
                            for var L := LdependencyrequirementsNode.ChildNodes.Count - 1 downto 0 do begin
                              var LdependencyrequirementNode := LdependencyrequirementsNode.ChildNodes[L];
                              if (LdependencyrequirementNode.GetChildNodeValueText(['by', 'groupid'], ''{default}) = LTodeleteGroupID) and
                                 (LdependencyrequirementNode.GetChildNodeValueText(['by', 'artifactid'], ''{default}) = LTodeleteArtifactid) and
                                 (LdependencyrequirementNode.GetChildNodeValueText(['by', 'version'], ''{default}) = LTodeleteVersion) then
                                LdependencyrequirementsNode.ChildNodes.Delete(L);
                            end;
                            if LdependencyrequirementsNode.ChildNodes.Count = 0 then
                              LLibraries.ChildNodes.Delete(K);
                          end;

                          //update LAlreadyIncludedDependencyLibrary
                          LAlreadyIncludedDependencyLibrary := LTmpNode;

                          //instruct to restart the main loop from 0 because we don't know
                          //how many libraries we deleted so LLibrariesIdx is not anymore accurate
                          //I m a little lazzy I know
                          LLibrariesIdx := 0;

                        end

                        //could not download the new dependency, just add a warning
                        else begin
                          Writeln(
                            'Dependency out-of-date. '+string(LDependencyGroupID)+':'+string(LDependencyArtifactID)+':'+string(LDependencyPreferredVersion) + ' seam more adequate than the included version ' + string(LAlreadyIncludedDependencyLibrary.GetChildNodeValueText('version', ''{default})),
                            TALConsoleColor.ccPurple,
                            true{ASkipDuplicates});
                        end;

                      end;

                    end;
                    {$ENDREGION}

                    {$REGION 'check if the dependency version is still inside version requierements'}
                    var LAlreadyIncludedDependencyRequirementsNode := LAlreadyIncludedDependencyLibrary.ChildNodes['dependencyrequirements'];
                    var LAlreadyIncludedDependencyVersion := LAlreadyIncludedDependencyLibrary.GetChildNodeValueText('version', ''{default});
                    for var K := 0 to LAlreadyIncludedDependencyRequirementsNode.ChildNodes.Count - 1 do begin
                      var LAlreadyIncludedDependencyRequirementNode := LAlreadyIncludedDependencyRequirementsNode.ChildNodes[K];
                      var LVersionRelationShip1: integer;
                      var LVersionRelationShip2: integer;
                      if ((CompareVersion(LAlreadyIncludedDependencyVersion, LAlreadyIncludedDependencyRequirementNode.GetChildNodeValueText(['version', 'min'], ''{default}), LVersionRelationShip1)) and (LVersionRelationShip1 < 0)) or
                         ((CompareVersion(LAlreadyIncludedDependencyVersion, LAlreadyIncludedDependencyRequirementNode.GetChildNodeValueText(['version', 'max'], ''{default}), LVersionRelationShip2)) and (LVersionRelationShip2 > 0)) then begin
                        raise EALException.Create('Dependency version conflicts.');
                      end;
                    end;
                    {$ENDREGION}

                  end;
                  {$ENDREGION}

                end;
                {$ENDREGION}

              finally
                ALFreeAndNil(LPomXmlDoc);
              end;
            Except
              On E: Exception do begin
                if LPomFilename <> '' then
                  raise Exception.CreateFmt('%s - %s', [E.Message, LPomFilename])
                else
                  raise;
              end;
            End;
          end
          {$ENDREGION}

          {$REGION 'their is no pom'}
          //If it's a directory and not an archive (jar/aar) then do no show any warning
          //because no pom could be associated with a directory
          else begin
            Writeln(
              'Skip ' + String(LLibrary.GetChildNodeValueText('archivefilename', '') + ' (no pom file found)'),
              TALConsoleColor.ccAqua,
              true{ASkipDuplicates});
          end;
          {$ENDREGION}

        end;
      end;
      {$ENDREGION}

      {$REGION 'init LSupportLibraryToAndroidx'}
      //https://developer.android.com/jetpack/androidx/migrate/artifact-mappings
      LSupportLibraryToAndroidx.add('android.arch.core:common=androidx.arch.core:core-common');
      LSupportLibraryToAndroidx.add('android.arch.core:core=androidx.arch.core:core');
      LSupportLibraryToAndroidx.add('android.arch.core:core-testing=androidx.arch.core:core-testing');
      LSupportLibraryToAndroidx.add('android.arch.core:runtime=androidx.arch.core:core-runtime');
      LSupportLibraryToAndroidx.add('android.arch.lifecycle:common=androidx.lifecycle:lifecycle-common');
      LSupportLibraryToAndroidx.add('android.arch.lifecycle:common-java8=androidx.lifecycle:lifecycle-common-java8');
      LSupportLibraryToAndroidx.add('android.arch.lifecycle:compiler=androidx.lifecycle:lifecycle-compiler');
      LSupportLibraryToAndroidx.add('android.arch.lifecycle:extensions=androidx.lifecycle:lifecycle-extensions');
      LSupportLibraryToAndroidx.add('android.arch.lifecycle:livedata=androidx.lifecycle:lifecycle-livedata');
      LSupportLibraryToAndroidx.add('android.arch.lifecycle:livedata-core=androidx.lifecycle:lifecycle-livedata-core');
      LSupportLibraryToAndroidx.add('android.arch.lifecycle:reactivestreams=androidx.lifecycle:lifecycle-reactivestreams');
      LSupportLibraryToAndroidx.add('android.arch.lifecycle:runtime=androidx.lifecycle:lifecycle-runtime');
      LSupportLibraryToAndroidx.add('android.arch.lifecycle:viewmodel=androidx.lifecycle:lifecycle-viewmodel');
      LSupportLibraryToAndroidx.add('android.arch.paging:common=androidx.paging:paging-common');
      LSupportLibraryToAndroidx.add('android.arch.paging:runtime=androidx.paging:paging-runtime');
      LSupportLibraryToAndroidx.add('android.arch.paging:rxjava2=androidx.paging:paging-rxjava2');
      LSupportLibraryToAndroidx.add('android.arch.persistence.room:common=androidx.room:room-common');
      LSupportLibraryToAndroidx.add('android.arch.persistence.room:compiler=androidx.room:room-compiler');
      LSupportLibraryToAndroidx.add('android.arch.persistence.room:guava=androidx.room:room-guava');
      LSupportLibraryToAndroidx.add('android.arch.persistence.room:migration=androidx.room:room-migration');
      LSupportLibraryToAndroidx.add('android.arch.persistence.room:runtime=androidx.room:room-runtime');
      LSupportLibraryToAndroidx.add('android.arch.persistence.room:rxjava2=androidx.room:room-rxjava2');
      LSupportLibraryToAndroidx.add('android.arch.persistence.room:testing=androidx.room:room-testing');
      LSupportLibraryToAndroidx.add('android.arch.persistence:db=androidx.sqlite:sqlite');
      LSupportLibraryToAndroidx.add('android.arch.persistence:db-framework=androidx.sqlite:sqlite-framework');
      LSupportLibraryToAndroidx.add('com.android.support.constraint:constraint-layout=androidx.constraintlayout:constraintlayout');
      LSupportLibraryToAndroidx.add('com.android.support.constraint:constraint-layout-solver=androidx.constraintlayout:constraintlayout-solver');
      LSupportLibraryToAndroidx.add('com.android.support.test.espresso.idling:idling-concurrent=androidx.test.espresso.idling:idling-concurrent');
      LSupportLibraryToAndroidx.add('com.android.support.test.espresso.idling:idling-net=androidx.test.espresso.idling:idling-net');
      LSupportLibraryToAndroidx.add('com.android.support.test.espresso:espresso-accessibility=androidx.test.espresso:espresso-accessibility');
      LSupportLibraryToAndroidx.add('com.android.support.test.espresso:espresso-contrib=androidx.test.espresso:espresso-contrib');
      LSupportLibraryToAndroidx.add('com.android.support.test.espresso:espresso-core=androidx.test.espresso:espresso-core');
      LSupportLibraryToAndroidx.add('com.android.support.test.espresso:espresso-idling-resource=androidx.test.espresso:espresso-idling-resource');
      LSupportLibraryToAndroidx.add('com.android.support.test.espresso:espresso-intents=androidx.test.espresso:espresso-intents');
      LSupportLibraryToAndroidx.add('com.android.support.test.espresso:espresso-remote=androidx.test.espresso:espresso-remote');
      LSupportLibraryToAndroidx.add('com.android.support.test.espresso:espresso-web=androidx.test.espresso:espresso-web');
      LSupportLibraryToAndroidx.add('com.android.support.test.janktesthelper:janktesthelper=androidx.test.jank:janktesthelper');
      LSupportLibraryToAndroidx.add('com.android.support.test.services:test-services=androidx.test:test-services');
      LSupportLibraryToAndroidx.add('com.android.support.test.uiautomator:uiautomator=androidx.test.uiautomator:uiautomator');
      LSupportLibraryToAndroidx.add('com.android.support.test:monitor=androidx.test:monitor');
      LSupportLibraryToAndroidx.add('com.android.support.test:orchestrator=androidx.test:orchestrator');
      LSupportLibraryToAndroidx.add('com.android.support.test:rules=androidx.test:rules');
      LSupportLibraryToAndroidx.add('com.android.support.test:runner=androidx.test:runner');
      LSupportLibraryToAndroidx.add('com.android.support:animated-vector-drawable=androidx.vectordrawable:vectordrawable-animated');
      LSupportLibraryToAndroidx.add('com.android.support:appcompat-v7=androidx.appcompat:appcompat');
      LSupportLibraryToAndroidx.add('com.android.support:asynclayoutinflater=androidx.asynclayoutinflater:asynclayoutinflater');
      LSupportLibraryToAndroidx.add('com.android.support:car=androidx.car:car');
      LSupportLibraryToAndroidx.add('com.android.support:cardview-v7=androidx.cardview:cardview');
      LSupportLibraryToAndroidx.add('com.android.support:collections=androidx.collection:collection');
      LSupportLibraryToAndroidx.add('com.android.support:coordinatorlayout=androidx.coordinatorlayout:coordinatorlayout');
      LSupportLibraryToAndroidx.add('com.android.support:cursoradapter=androidx.cursoradapter:cursoradapter');
      LSupportLibraryToAndroidx.add('com.android.support:customtabs=androidx.browser:browser');
      LSupportLibraryToAndroidx.add('com.android.support:customview=androidx.customview:customview');
      LSupportLibraryToAndroidx.add('com.android.support:design=com.google.android.material:material');
      LSupportLibraryToAndroidx.add('com.android.support:documentfile=androidx.documentfile:documentfile');
      LSupportLibraryToAndroidx.add('com.android.support:drawerlayout=androidx.drawerlayout:drawerlayout');
      LSupportLibraryToAndroidx.add('com.android.support:exifinterface=androidx.exifinterface:exifinterface');
      LSupportLibraryToAndroidx.add('com.android.support:gridlayout-v7=androidx.gridlayout:gridlayout');
      LSupportLibraryToAndroidx.add('com.android.support:heifwriter=androidx.heifwriter:heifwriter');
      LSupportLibraryToAndroidx.add('com.android.support:interpolator=androidx.interpolator:interpolator');
      LSupportLibraryToAndroidx.add('com.android.support:leanback-v17=androidx.leanback:leanback');
      LSupportLibraryToAndroidx.add('com.android.support:loader=androidx.loader:loader');
      LSupportLibraryToAndroidx.add('com.android.support:localbroadcastmanager=androidx.localbroadcastmanager:localbroadcastmanager');
      LSupportLibraryToAndroidx.add('com.android.support:media2=androidx.media2:media2');
      LSupportLibraryToAndroidx.add('com.android.support:media2-exoplayer=androidx.media2:media2-exoplayer');
      LSupportLibraryToAndroidx.add('com.android.support:mediarouter-v7=androidx.mediarouter:mediarouter');
      LSupportLibraryToAndroidx.add('com.android.support:multidex=androidx.multidex:multidex');
      LSupportLibraryToAndroidx.add('com.android.support:multidex-instrumentation=androidx.multidex:multidex-instrumentation');
      LSupportLibraryToAndroidx.add('com.android.support:palette-v7=androidx.palette:palette');
      LSupportLibraryToAndroidx.add('com.android.support:percent=androidx.percentlayout:percentlayout');
      LSupportLibraryToAndroidx.add('com.android.support:preference-leanback-v17=androidx.leanback:leanback-preference');
      LSupportLibraryToAndroidx.add('com.android.support:preference-v14=androidx.legacy:legacy-preference-v14');
      LSupportLibraryToAndroidx.add('com.android.support:preference-v7=androidx.preference:preference');
      LSupportLibraryToAndroidx.add('com.android.support:print=androidx.print:print');
      LSupportLibraryToAndroidx.add('com.android.support:recommendation=androidx.recommendation:recommendation');
      LSupportLibraryToAndroidx.add('com.android.support:recyclerview-selection=androidx.recyclerview:recyclerview-selection');
      LSupportLibraryToAndroidx.add('com.android.support:recyclerview-v7=androidx.recyclerview:recyclerview');
      LSupportLibraryToAndroidx.add('com.android.support:slices-builders=androidx.slice:slice-builders');
      LSupportLibraryToAndroidx.add('com.android.support:slices-core=androidx.slice:slice-core');
      LSupportLibraryToAndroidx.add('com.android.support:slices-view=androidx.slice:slice-view');
      LSupportLibraryToAndroidx.add('com.android.support:slidingpanelayout=androidx.slidingpanelayout:slidingpanelayout');
      LSupportLibraryToAndroidx.add('com.android.support:support-annotations=androidx.annotation:annotation');
      LSupportLibraryToAndroidx.add('com.android.support:support-compat=androidx.core:core');
      LSupportLibraryToAndroidx.add('com.android.support:support-content=androidx.contentpager:contentpager');
      LSupportLibraryToAndroidx.add('com.android.support:support-core-ui=androidx.legacy:legacy-support-core-ui');
      LSupportLibraryToAndroidx.add('com.android.support:support-core-utils=androidx.legacy:legacy-support-core-utils');
      LSupportLibraryToAndroidx.add('com.android.support:support-dynamic-animation=androidx.dynamicanimation:dynamicanimation');
      LSupportLibraryToAndroidx.add('com.android.support:support-emoji=androidx.emoji:emoji');
      LSupportLibraryToAndroidx.add('com.android.support:support-emoji-appcompat=androidx.emoji:emoji-appcompat');
      LSupportLibraryToAndroidx.add('com.android.support:support-emoji-bundled=androidx.emoji:emoji-bundled');
      LSupportLibraryToAndroidx.add('com.android.support:support-fragment=androidx.fragment:fragment');
      LSupportLibraryToAndroidx.add('com.android.support:support-media-compat=androidx.media:media');
      LSupportLibraryToAndroidx.add('com.android.support:support-tv-provider=androidx.tvprovider:tvprovider');
      LSupportLibraryToAndroidx.add('com.android.support:support-v13=androidx.legacy:legacy-support-v13');
      LSupportLibraryToAndroidx.add('com.android.support:support-v4=androidx.legacy:legacy-support-v4');
      LSupportLibraryToAndroidx.add('com.android.support:support-vector-drawable=androidx.vectordrawable:vectordrawable');
      LSupportLibraryToAndroidx.add('com.android.support:swiperefreshlayout=androidx.swiperefreshlayout:swiperefreshlayout');
      LSupportLibraryToAndroidx.add('com.android.support:textclassifier=androidx.textclassifier:textclassifier');
      LSupportLibraryToAndroidx.add('com.android.support:transition=androidx.transition:transition');
      LSupportLibraryToAndroidx.add('com.android.support:versionedparcelable=androidx.versionedparcelable:versionedparcelable');
      LSupportLibraryToAndroidx.add('com.android.support:viewpager=androidx.viewpager:viewpager');
      LSupportLibraryToAndroidx.add('com.android.support:wear=androidx.wear:wear');
      LSupportLibraryToAndroidx.add('com.android.support:webkit=androidx.webkit:webkit');
      {$ENDREGION}

      {$REGION 'Check we use AndroidX instead of old support library'}
      Writeln('Check AndroidX support');
      for Var I := 0 to LLibraries.ChildNodes.Count - 1 do begin
        var LLibraryNode := LLibraries.ChildNodes[i];
        Var LLibraryID := LLibraryNode.GetChildNodeValueText('groupid', ''{default}) + ':' + LLibraryNode.GetChildNodeValueText('artifactid', ''{default});
        var J := LSupportLibraryToAndroidx.IndexOfName(LLibraryID);
        if J >= 0 then
          Writeln(
            String(LLibraryID)+' is a deprecated old support library. Please use instead ' + String(LSupportLibraryToAndroidx.ValueFromIndex[J]),
            TALConsoleColor.ccAqua);
      end;
      {$ENDREGION}

      {$REGION 'Uncompress all AAR libraries'}
      Writeln('Uncompress all AAR libraries');
      for var I := 0 to LLibraries.ChildNodes.Count - 1 do begin
        var LLibrary := LLibraries.ChildNodes[i];
        var LLibraryArchiveFileName := string(LLibrary.GetChildNodeValueText('archivefilename', ''{default}));
        if LLibraryArchiveFileName = '' then continue;
        Var LUncompressDir := LtmpDirectoryLibraries+
                              String(LLibrary.GetChildNodeValueText('groupid', ''{default}))+'-'+
                              String(LLibrary.GetChildNodeValueText('artifactid', ''{default}))+'-'+
                              String(LLibrary.GetChildNodeValueText('version', ''{default}))+'\';
        if LUncompressDir = LtmpDirectoryLibraries + '--\' then
          LUncompressDir := LtmpDirectoryLibraries + ALExtractFileName(ALExcludeTrailingPathDelimiterW(LLibraryArchiveFileName), true{RemoveFileExt})+'\';
        LLibrary.SetChildNodeValueText('uncompressdir', ansiString(LUncompressDir));
        if TDirectory.Exists(LLibraryArchiveFileName) then begin
          if not AlCopyDirectoryW(
                   LLibraryArchiveFileName, // SrcDirectory,
                   LUncompressDir, // DestDirectory: ansiString;
                   true) then // SubDirectory: Boolean;
            raise Exception.Createfmt('Cannot copy %s to %s', [LLibraryArchiveFileName, LUncompressDir]);
        end
        else if ALSameTextW(TPath.GetExtension(LLibraryArchiveFileName), '.jar') then begin
          TDirectory.CreateDirectory(LUncompressDir);
          TFile.Copy(LLibraryArchiveFileName, LUncompressDir + TPath.GetFileName(LLibraryArchiveFileName));
        end
        else if TFile.exists(LLibraryArchiveFileName) then begin
          if TZipFile.IsValid(LLibraryArchiveFileName) then TZipFile.ExtractZipFile(LLibraryArchiveFileName, LUncompressDir, nil)
          else raise Exception.CreateFmt('Invalid aar file: %s', [LLibraryArchiveFileName]);
        end
        else raise Exception.CreateFmt('Unknown library: %s', [LLibraryArchiveFileName]);
      end;
      {$ENDREGION}

      {$REGION 'Copy all jar to <OutputDir>\libs'}
      Writeln('Copy all jar to <OutputDir>\libs');
      for var I := 0 to LLibraries.ChildNodes.Count - 1 do begin
        var LUncompressDir := string(LLibraries.childNodes[I].GetChildNodeValueText('uncompressdir', ''{default}));
        if LUncompressDir = '' then continue;
        //--
        var LJarFiles := TDirectory.GetFiles(LUncompressDir, '*.jar', TSearchOption.soTopDirectoryOnly);
        if length(LJarFiles) = 0 then continue;
        //--
        Var LTmpJarFile: TStringDynArray;
        Setlength(LTmpJarFile, 0);
        for Var J := Low(LJarFiles) to High(LJarFiles) do begin
          if ALSameTextW(ALExtractFileName(LJarFiles[J]), 'lint.jar') or
             ALSameTextW(ALExtractFileName(LJarFiles[J]), 'inspector.jar') then continue;
          Setlength(LTmpJarFile, length(LTmpJarFile) + 1);
          LTmpJarFile[high(LTmpJarFile)] := LJarFiles[J];
        end;
        LJarFiles := LTmpJarFile;
        //--
        if length(LJarFiles) = 0 then raise Exception.CreateFmt('Erreur 7E56249A-8B43-411D-9834-9D6334D7226B. %s', [LUncompressDir]);
        if length(LJarFiles) > 1 then raise Exception.CreateFmt('Their cannot be more than one classes.jar at the root of a library. %s', [LUncompressDir]);
        //--
        var LDestFilename := LLibsOutputDir + ALExtractFileName(ALExcludeTrailingPathDelimiterW(LUncompressDir)) + '.jar';
        Tfile.Copy(LJarFiles[0], LDestFilename);
        if Tdirectory.Exists(LUncompressDir + '\libs') then begin
          var LlibsFiles := TDirectory.GetFiles(LUncompressDir + '\libs', '*', TSearchOption.soAllDirectories);
          for var J := Low(LlibsFiles) to High(LlibsFiles) do begin
            if not ALSameTextW(ALExtractFileExt(LlibsFiles[j]), '.jar') then raise Exception.Create('Error 1BE76D9D-49BC-4CA7-971C-40B81C01B1C9');
            Tfile.Copy(LlibsFiles[j], LLibsOutputDir + ALExtractFileName(ALExcludeTrailingPathDelimiterW(LUncompressDir)) + '-'+ ALExtractFileName(LlibsFiles[j]));
          end;
        end;
      end;
      {$ENDREGION}

      {$REGION 'Copy all jni to <OutputDir>\jni'}
      Writeln('Copy all jni to <OutputDir>\jni');
      for var I := 0 to LLibraries.ChildNodes.Count - 1 do begin
        var LUncompressDir := string(LLibraries.childNodes[I].GetChildNodeValueText('uncompressdir', ''{default}));
        if LUncompressDir = '' then continue;
        if Tdirectory.Exists(LUncompressDir + '\jni\arm64-v8a') then begin
          var LJniFiles := TDirectory.GetFiles(LUncompressDir + '\jni\arm64-v8a', '*', TSearchOption.soAllDirectories);
          for var J := Low(LJniFiles) to High(LJniFiles) do begin
            if not ALSameTextW(ALExtractFileExt(LJniFiles[j]), '.so') then raise Exception.Create('Error 2FCFB6D0-987A-40EC-BBAC-66D5ADC50DC2');
            TDirectory.CreateDirectory(LJniOutputDir + '\arm64-v8a\');
            Tfile.Copy(LJniFiles[j], LJniOutputDir + '\arm64-v8a\' + ALExtractFileName(LJniFiles[j]));
          end;
        end;
        if Tdirectory.Exists(LUncompressDir + '\jni\armeabi-v7a') then begin
          var LJniFiles := TDirectory.GetFiles(LUncompressDir + '\jni\armeabi-v7a', '*', TSearchOption.soAllDirectories);
          for var J := Low(LJniFiles) to High(LJniFiles) do begin
            if not ALSameTextW(ALExtractFileExt(LJniFiles[j]), '.so') then raise Exception.Create('Error F6BF26A7-A378-4A94-A8CB-C861DB38E11E');
            TDirectory.CreateDirectory(LJniOutputDir + '\armeabi-v7a\');
            Tfile.Copy(LJniFiles[j], LJniOutputDir + '\armeabi-v7a\' + ALExtractFileName(LJniFiles[j]));
          end;
        end;
      end;
      {$ENDREGION}

      {$REGION 'make all AndroidManifest ready'}
      for var I := 0 to LLibraries.ChildNodes.Count - 1 do
        MakeAndroidManifestReady(string(LLibraries.childNodes[I].GetChildNodeValueText('uncompressdir', ''{default}))+'\AndroidManifest.xml');
      {$ENDREGION}

      {$REGION 'Merge resources in <OutputDir>\res'}
      Writeln('Merge resources in <OutputDir>\res');
      for var I := 0 to LLibraries.childNodes.Count - 1 do
        MergeResources(
          string(LLibraries.childNodes[I].GetChildNodeValueText('uncompressdir', ''{default}))+'\res\', // const ASrcDir: String;
          LResOutputDir, // const ADestDir: String;
          ''); // const ASubPath: String
      {$ENDREGION}

      {$REGION 'Merge google-services.json in <OutputDir>\res'}
      if LGoogleServicesJson <> '' then begin
        Writeln('Merge google-services.json in <OutputDir>\res');
        var LGoogleServicesjsonDoc := TALJSONDocumentA.Create;
        var LStringsXmlDoc := TalXmlDocument.Create('resources');
        try
          LStringsXmlDoc.Options := [doNodeAutoIndent];
          LGoogleServicesjsonDoc.LoadFromJSONFile(ansistring(LGoogleServicesJson));
          //---
          var LClientNode := LGoogleServicesjsonDoc.ChildNodes.FindNode('client');
          if LClientNode = nil then raise Exception.Create('Could not find client node in google-services.json');
          if LClientNode.ChildNodes.Count <> 1 then raise Exception.Create('client node must have only 1 child in google-services.json');
          LClientNode := LClientNode.ChildNodes[0];
          //---
          var LOauthClientNode := LClientNode.ChildNodes.FindNode('oauth_client');
          if LOauthClientNode = nil then raise Exception.Create('Could not find client.oauth_client node in google-services.json');
          if LOauthClientNode.ChildNodes.Count <> 1 then raise Exception.Create('client.oauth_client node must have only 1 child in google-services.json');
          LOauthClientNode := LOauthClientNode.ChildNodes[0];
          if LOauthClientNode.GetChildNodeValueFloat('client_type',0) <> 3 then raise Exception.Create('client.oauth_client node must have client_type=3 child node in google-services.json');
          //---
          var LApikeyNode := LClientNode.ChildNodes.FindNode('api_key');
          if LApikeyNode = nil then raise Exception.Create('Could not find client.api_key node in google-services.json');
          if LApikeyNode.ChildNodes.Count <> 1 then raise Exception.Create('client.api_key node must have only 1 child in google-services.json');
          LApikeyNode := LApikeyNode.ChildNodes[0];
          //---
          //<?xml version="1.0" encoding="utf-8"?>
          //<resources>
          //  <string name="default_web_client_id" translatable="false">473525438998-cfesrloac4k87aam569gnivgdkfvckqo.apps.googleusercontent.com</string> <!-- client/oauth_client/client_id (client_type == 3) -->
          //  <string name="gcm_defaultSenderId" translatable="false">473525438998</string> <!-- project_info/project_number -->
          //  <string name="google_api_key" translatable="false">AIzaSyD9y8sPkHve0fsgH11UVgBqcRBTRyqrt7E</string> <!-- client/api_key/current_key -->
          //  <string name="google_app_id" translatable="false">1:473525438998:android:4de91fba3dae57c7e50337</string> <!-- client/client_info/mobilesdk_app_id -->
          //  <string name="google_crash_reporting_api_key" translatable="false">AIzaSyD9y8sPkHve0fsgH11UVgBqcRBTRyqrt7E</string> <!-- client/api_key/current_key -->
          //  <string name="google_storage_bucket" translatable="false">alfirebasemessagingapp.appspot.com</string> <!-- project_info/storage_bucket -->
          //  <string name="project_id" translatable="false">alfirebasemessagingapp</string> <!-- project_info/project_id -->
          //</resources>
          //---
          with LStringsXmlDoc.DocumentElement.AddChild('string') do begin
            Attributes['name'] := 'default_web_client_id';
            Attributes['translatable'] := 'false';
            text := LOauthClientNode.GetChildNodeValueText('client_id','');
          end;
          with LStringsXmlDoc.DocumentElement.AddChild('string') do begin
            Attributes['name'] := 'gcm_defaultSenderId';
            Attributes['translatable'] := 'false';
            text := LGoogleServicesjsonDoc.GetChildNodeValueText(['project_info','project_number'],'');
          end;
          with LStringsXmlDoc.DocumentElement.AddChild('string') do begin
            Attributes['name'] := 'google_api_key';
            Attributes['translatable'] := 'false';
            text := LApikeyNode.GetChildNodeValueText('current_key','');
          end;
          with LStringsXmlDoc.DocumentElement.AddChild('string') do begin
            Attributes['name'] := 'google_app_id';
            Attributes['translatable'] := 'false';
            text := LClientNode.GetChildNodeValueText(['client_info','mobilesdk_app_id'],'');
          end;
          with LStringsXmlDoc.DocumentElement.AddChild('string') do begin
            Attributes['name'] := 'google_crash_reporting_api_key';
            Attributes['translatable'] := 'false';
            text := LApikeyNode.GetChildNodeValueText('current_key','');
          end;
          with LStringsXmlDoc.DocumentElement.AddChild('string') do begin
            Attributes['name'] := 'google_storage_bucket';
            Attributes['translatable'] := 'false';
            text := LGoogleServicesjsonDoc.GetChildNodeValueText(['project_info','storage_bucket'],'');
          end;
          with LStringsXmlDoc.DocumentElement.AddChild('string') do begin
            Attributes['name'] := 'project_id';
            Attributes['translatable'] := 'false';
            text := LGoogleServicesjsonDoc.GetChildNodeValueText(['project_info','project_id'],'');
          end;
          //----
          var LDirectory := LtmpDirectoryGoogleServices + '\res\values\';
          TDirectory.CreateDirectory(LDirectory);
          LStringsXmlDoc.SaveToFile(LDirectory + 'values.xml');
        finally
          ALFreeAndNil(LGoogleServicesjsonDoc);
          ALFreeAndNil(LStringsXmlDoc);
        end;
        MergeResources(
          LtmpDirectoryGoogleServices+'\res\', // const ASrcDir: String;
          LResOutputDir, // const ADestDir: String;
          ''); // const ASubPath: String
      end;
      {$ENDREGION}

      {$REGION 'Generate Native Bridge File'}
      if LGenerateNativeBridgeFile then begin
        Writeln('Generate Native Bridge File');
        var LcmdLine := LdelphiRootDir + '\bin\converters\java2op\Java2OP.exe -jar';
        var LJarFiles := TDirectory.GetFiles(LLibsOutputDir, '*.jar', TSearchOption.soTopDirectoryOnly);
        for var LJarFile in LJarFiles do begin
          Var LInputStream := TMemorystream.Create;
          Var LOutputStream := TStringStream.Create;
          try
            var LTmpcmdLine := LdelphiRootDir + '\bin\converters\java2op\Java2OP.exe -jar "'+LJarFile+'" -unit "'+LOutputDir+'\JavaInterfaces_'+ALExtractFileName(LJarFile, true{RemoveFileExt})+'_'+ALIntToStrW(ALDateTimeToUnixMs(Now))+'"';
            OverWrite(LTmpCmdLine);
            Var LTmpCmdLineResult := ALWinExecW(
                                       LTmpcmdLine, // const aCommandLine: String;
                                       LInputStream, // const aInputStream: Tstream;
                                       LOutputStream); //const aOutputStream: TStream;
            if LTmpCmdLineResult <> 0 then
              Writeln('Skip ' + ALExtractFileName(LJarFile) + ' (not compatible with Java2OP)', TALConsoleColor.ccAqua)
            else
              LcmdLine := LcmdLine+' "'+LJarFile+'"';
          finally
            ALFreeandNil(LInputStream);
            ALFreeandNil(LOutputStream);
            if TFile.Exists(ALGetModulePathW + 'jar.log') then Tfile.Delete(ALGetModulePathW + 'jar.log');
          end;
        end;
        //--
        //Var LInputStream := TMemorystream.Create;
        //Var LOutputStream := TStringStream.Create;
        //try
        //  LcmdLine := LcmdLine + ' -unit "'+LOutputDir+'\JavaInterfaces"';
        //  OverWrite(LcmdLine);
        //  Var LCmdLineResult := ALWinExecW(
        //                          LcmdLine, // const aCommandLine: String;
        //                          '', // const aCurrentDirectory: AnsiString;
        //                          GetEnvironmentStringWithJavaHomeUpdated, // const aEnvironment: AnsiString;
        //                          LInputStream, // const aInputStream: Tstream;
        //                          LOutputStream); //const aOutputStream: TStream;
        //  if LCmdLineResult <> 0 then
        //    raise Exception.Createfmt('Failed to execute %s'#13#10'%s', [LcmdLine, LOutputStream.DataString]);
        //finally
        //  ALFreeandNil(LInputStream);
        //  ALFreeandNil(LOutputStream);
        //  if TFile.Exists(ALGetModulePathW + 'jar.log') then Tfile.Delete(ALGetModulePathW + 'jar.log');
        //end;
      end;
      {$ENDREGION}

      {$REGION 'create r-apk.jar and r-aab.jar'}
      for var LApk := False to True do begin
        Writeln('Create r-'+ALIfThenW(LApk, 'apk', 'aab')+'.jar');
        if not LApk then begin
          CreateRFlata(
            LResOutputDir, // const AMergedResPath: String;
            LRFlataFilename, // const ARFlataPath: String;
            LAapt2Filename);// const AAaptPath: String);
        end;
        //--
        if not AlEmptyDirectoryW(LtmpDirectoryRClass, true{SubDirectory}) then raise EALException.CreateFmt('Cannot clear %s', [LtmpDirectoryRClass]);
        for var I := 0 to LLibraries.childnodes.Count - 1 do begin
          CreateRClasses(
            ALIncludeTrailingPathDelimiterW(string(LLibraries.childNodes[I].GetChildNodeValueText('uncompressdir', ''{default}))), // const ALibPath: String;
            ALIfThenW(LApk, LResOutputDir, LRFlataFilename), // const AMergedResPath: String;
            LtmpDirectory, // const ATmpDir: String;
            LtmpDirectoryRJava, // const ARjavaPath: String;
            LtmpDirectoryRClass, // const ARClassPath: String;
            ALIfThenW(LApk, LAaptFilename, LAapt2Filename), // const AAaptPath: String;
            LSDKApiLevelJarFilename, // const ASDKApiLevelJar: String
            LJavacFilename); // const AJavacPath: String
        end;
        //--
        CreateRJar(
          LLibsOutputDir + ALIfThenW(LApk, 'r-apk.jar', 'r-aab.jar'), // const aRJarPath: String;
          LtmpDirectoryRClass, // const ARClassPath: String;
          LJarExeFilename); // const AJarPath: String);
      end;
      {$ENDREGION}

      {$REGION 'create R.Jar'}
      Var LJarFilename := LLibsOutputDir + 'r.jar';
      if TFile.Exists(LJarFilename) then raise Exception.Create('Error 7FD3D8B3-1565-4897-8943-1519C302875A');
      Tfile.Copy(LLibsOutputDir + 'r-apk.jar', LJarFilename);
      {$ENDREGION}

      {$REGION 'Merge AndroidManifest'}
      //https://developer.android.com/studio/build/manage-manifests
      //The problem is that the merging is done one time on the template,
      //and not on the generated AndroidManifest everytime we compile the project.
      //so we must introduce a mechanism to remove previously merged node from
      //the AndroidManifest template. The way I go is to add section identifiers
      //
      //  <!-- ============================================ -->
      //  <!-- AndroidMerger auto-generated section (BEGIN) -->
      //  <!-- ============================================ -->
      //
      //  .............
      //
      //  <!-- ========================================== -->
      //  <!-- AndroidMerger auto-generated section (END) -->
      //  <!-- ========================================== -->
      //
      //So in this way before merging the AndroidManifest I delete thanks to the
      //section identifiers all previously added node. This work well except for
      //attributes.
      if LAndroidManifest <> '' then begin
        Writeln('Merge AndroidManifest');
        var LMaxMinSdkVersion: integer := 0;
        if not Tfile.Exists(LAndroidManifest) then raise Exception.CreateFmt('%s does not exist', [LAndroidManifest]);
        var LAndroidManifestXmlDoc := TalXmlDocument.Create;
        Var LDisabledXmlDoc := TalXmlDocument.Create('manifest');
        try

          var LAndroidManifestSrc := ALGetStringFromFile(LAndroidManifest);
          if ALPosA('%/>', LAndroidManifestSrc) > 0 then raise Exception.Create('Error 7FE78AC6-C0C3-41EC-9E7D-8497FDBE644C');
          LAndroidManifestSrc := ALStringReplaceA(LAndroidManifestSrc, '%>', '%/>', [rfReplaceALL]);
          //--
          LAndroidManifestXmlDoc.Options := [];
          LAndroidManifestXmlDoc.ParseOptions := [poPreserveWhiteSpace];
          LAndroidManifestXmlDoc.LoadFromXML(LAndroidManifestSrc);
          LAndroidManifestXmlDoc.Options := [DoNodeAutoIndent, doAttributeAutoIndent];
          //--
          ExtractAutoGeneratedSectionFromAndroidManifest(
            LAndroidManifestXmlDoc.DocumentElement,
            LDisabledXmlDoc);
          //--
          for var I := 0 to LLibraries.ChildNodes.Count - 1 do begin
            var LSrcFilename := string(LLibraries.childNodes[I].GetChildNodeValueText('uncompressdir', ''{default}))+'\AndroidManifest.xml.original';
            if TFile.Exists(LSrcFilename) then begin
              Var LSrcXmlDoc := TALXmlDocument.Create;
              Try
                LSrcXmlDoc.Options := [doNodeAutoIndent];
                var LSrcContent := ALgetStringFromFile(LSrcFilename);
                LSrcContent := ALStringReplaceA(LSrcContent, '${applicationId}', '%package%', [rfReplaceAll, RfIgnoreCase]);
                LSrcXmlDoc.LoadFromXML(LSrcContent);
                MergeAndroidManifest(
                  LSrcXmlDoc.DocumentElement.Attributes['package'], // const APackageName: AnsiString;
                  LSrcXmlDoc.DocumentElement, // const ASrcFilename: String;
                  LAndroidManifestXmlDoc.DocumentElement, // const ADestXmlDoc: TalXmlDocument;
                  LDisabledXmlDoc.DocumentElement, // const ADisabledNode: TalXmlNode
                  LMaxMinSdkVersion); // var AMaxMinSdkVersion: integer;
              finally
                ALFreeAndNil(LSrcXmlDoc);
              End;
            end;
          end;
          //--
          CloseAutoGeneratedSectionInAndroidManifest(LAndroidManifestXmlDoc.DocumentElement);
          //--
          //https://developer.android.com/guide/topics/manifest/manifest-intro
          //Elements at the same level are generally not ordered. For example, the <activity>, <provider>,
          //and <service> elements can be placed in any order. There are two key exceptions to this rule:
          //  * An <activity-alias> element must follow the <activity> for which it is an alias.
          //  * The <application> element must be the last element inside the <manifest> element.
          if IsAutoGeneratedSectionBeginCommentPresentInAndroidManifest(LAndroidManifestXmlDoc.DocumentElement) then begin
            var LapplicationNodeIdx := LAndroidManifestXmlDoc.DocumentElement.childnodes.indexOf('application');
            while (LapplicationNodeIdx < LAndroidManifestXmlDoc.DocumentElement.childnodes.count - 1) and
                  (LAndroidManifestXmlDoc.DocumentElement.childnodes[LapplicationNodeIdx+1].nodeType = ntText) do
              LAndroidManifestXmlDoc.DocumentElement.childnodes.delete(LapplicationNodeIdx+1);
            Var LApplicationCommentNodeIdx := LapplicationNodeIdx;
            Var LTmpIdx := LApplicationCommentNodeIdx - 1;
            Var LconcatenatedText: String := '';
            while LTmpIdx >= 0 do begin
              case LAndroidManifestXmlDoc.DocumentElement.childnodes[LTmpIdx].nodeType of
                ntText: begin
                  LconcatenatedText := LconcatenatedText + string(LAndroidManifestXmlDoc.DocumentElement.childnodes[LTmpIdx].Text);
                  if LconcatenatedText.CountChar(#10) > 1 then break;
                  dec(LTmpIdx);
                end;
                ntcomment: begin
                  LApplicationCommentNodeIdx := LTmpIdx;
                  dec(LTmpIdx);
                  LconcatenatedText := '';
                end;
                else
                  break;
              end;
            end;
            for var I := LApplicationCommentNodeIdx to LapplicationNodeIdx do begin
              var LtmpNode := LAndroidManifestXmlDoc.DocumentElement.childnodes.Extract(LApplicationCommentNodeIdx);
              if LtmpNode.nodetype = ntText then ALFreeAndNil(LtmpNode)
              else LAndroidManifestXmlDoc.DocumentElement.childnodes.Add(LtmpNode);
            end;
            var LBreakLineNode := TALXmlElementNode.Create('br');
            LAndroidManifestXmlDoc.DocumentElement.ChildNodes.Add(LBreakLineNode);
            LAndroidManifestXmlDoc.DocumentElement.ChildNodes.Remove(LBreakLineNode);
          end;
          //--
          LAndroidManifestXmlDoc.SaveToXML(LAndroidManifestSrc);
          LAndroidManifestSrc := ALStringReplaceA(LAndroidManifestSrc, '%/>', '%>', [rfReplaceALL]);
          Tfile.Delete(LAndroidManifest);
          ALSaveStringToFile(LAndroidManifestSrc, LAndroidManifest);
        finally
          ALFreeAndNil(LAndroidManifestXmlDoc);
          ALFreeAndNil(LDisabledXmlDoc);
        end;
        if LMaxMinSdkVersion > 0 then
          Writeln('Max MinSdkVersion found in libraries: ' + ALIntToStrW(LMaxMinSdkVersion), TALConsoleColor.ccDarkYellow);
      end;
      {$ENDREGION}

      {$REGION 'Update dproj'}
      if LDProjFilename <> '' then begin
        Writeln('Update dproj');
        var LdprojXmlDoc := TalXmlDocument.Create('root');
        var LDeployFilesToDeactivate := TALStringListA.Create;
        try

          //init LDProjDir
          var LDProjDir := ALExtractFilePath(LDProjFilename);

          //init LdprojXmlDoc
          LdprojXmlDoc.LoadFromFile(LDProjFilename);

          //init LProjectExtensionsNode
          var LProjectExtensionsNode := LDProjXmlDoc.DocumentElement.ChildNodes.FindNode('ProjectExtensions');
          if LProjectExtensionsNode = nil then raise Exception.Create('ProjectExtensions node not found!');

          //init LBorlandProjectNode
          var LBorlandProjectNode := LProjectExtensionsNode.ChildNodes.FindNode('BorlandProject');
          if LBorlandProjectNode = nil then raise Exception.Create('ProjectExtensions.BorlandProject node not found!');

          //init LDeploymentNode
          var LDeploymentNode := LBorlandProjectNode.ChildNodes.FindNode('Deployment');
          if LDeploymentNode = nil then raise Exception.Create('ProjectExtensions.BorlandProject.Deployment node not found!');

          //init LDeployFilesToDeactivate
          LDeployFilesToDeactivate.Add('Android_Strings=<PlatForm>\<Config>\strings.xml');
          LDeployFilesToDeactivate.Add('Android_Colors=<PlatForm>\<Config>\colors.xml');
          LDeployFilesToDeactivate.Add('AndroidSplashImageDef=<PlatForm>\<Config>\splash_image_def.xml');
          LDeployFilesToDeactivate.Add('AndroidSplashStylesV21=<PlatForm>\<Config>\styles-v21.xml|styles.xml');
          LDeployFilesToDeactivate.Add('AndroidSplashStyles=<PlatForm>\<Config>\styles.xml');
          LDeployFilesToDeactivate.Add('Android_LauncherIcon36=$(BDS)\bin\Artwork\Android\FM_LauncherIcon_36x36.png|ic_launcher.png');
          LDeployFilesToDeactivate.Add('Android_LauncherIcon48=$(BDS)\bin\Artwork\Android\FM_LauncherIcon_48x48.png|ic_launcher.png');
          LDeployFilesToDeactivate.Add('Android_LauncherIcon72=$(BDS)\bin\Artwork\Android\FM_LauncherIcon_72x72.png|ic_launcher.png');
          LDeployFilesToDeactivate.Add('Android_LauncherIcon96=$(BDS)\bin\Artwork\Android\FM_LauncherIcon_96x96.png|ic_launcher.png');
          LDeployFilesToDeactivate.Add('Android_LauncherIcon144=$(BDS)\bin\Artwork\Android\FM_LauncherIcon_144x144.png|ic_launcher.png');
          LDeployFilesToDeactivate.Add('Android_LauncherIcon192=$(BDS)\bin\Artwork\Android\FM_LauncherIcon_192x192.png|ic_launcher.png');
          LDeployFilesToDeactivate.Add('Android_SplashImage426=$(BDS)\bin\Artwork\Android\FM_SplashImage_426x320.png|splash_image.png');
          LDeployFilesToDeactivate.Add('Android_SplashImage470=$(BDS)\bin\Artwork\Android\FM_SplashImage_470x320.png|splash_image.png');
          LDeployFilesToDeactivate.Add('Android_SplashImage640=$(BDS)\bin\Artwork\Android\FM_SplashImage_640x480.png|splash_image.png');
          LDeployFilesToDeactivate.Add('Android_SplashImage960=$(BDS)\bin\Artwork\Android\FM_SplashImage_960x720.png|splash_image.png');
          LDeployFilesToDeactivate.Add('Android_NotificationIcon24=$(BDS)\bin\Artwork\Android\FM_NotificationIcon_24x24.png|ic_notification.png');
          LDeployFilesToDeactivate.Add('Android_NotificationIcon36=$(BDS)\bin\Artwork\Android\FM_NotificationIcon_36x36.png|ic_notification.png');
          LDeployFilesToDeactivate.Add('Android_NotificationIcon48=$(BDS)\bin\Artwork\Android\FM_NotificationIcon_48x48.png|ic_notification.png');
          LDeployFilesToDeactivate.Add('Android_NotificationIcon72=$(BDS)\bin\Artwork\Android\FM_NotificationIcon_72x72.png|ic_notification.png');
          LDeployFilesToDeactivate.Add('Android_NotificationIcon96=$(BDS)\bin\Artwork\Android\FM_NotificationIcon_96x96.png|ic_notification.png');

          //remove from deployment all items deployed to "res\", "library\lib\arm64-v8a\" and "library\lib\armeabi-v7a\" remote folder
          //<DeployFile LocalName="android\res\drawable\common_google_signin_btn_icon_disabled.xml" Configuration="Release" Class="File">
          //    <Platform Name="Android">
          //        <RemoteDir>res\drawable</RemoteDir>
          //        <RemoteName>common_google_signin_btn_icon_disabled.xml</RemoteName>
          //        <Overwrite>true</Overwrite>
          //    </Platform>
          //    <Platform Name="Android64">
          //        <RemoteDir>res\drawable</RemoteDir>
          //        <RemoteName>common_google_signin_btn_icon_disabled.xml</RemoteName>
          //        <Overwrite>true</Overwrite>
          //    </Platform>
          //</DeployFile>
          //<DeployFile LocalName="..\..\..\..\..\Alcinoe\lib\jar\org.webrtc\jni\arm64-v8a\libjingle_peerconnection_so.so" Configuration="Release" Class="File">
          //    <Platform Name="Android">
          //        <RemoteDir>library\lib\arm64-v8a\</RemoteDir>
          //        <RemoteName>libjingle_peerconnection_so.so</RemoteName>
          //        <Overwrite>true</Overwrite>
          //    </Platform>
          //    <Platform Name="Android64">
          //        <RemoteDir>library\lib\arm64-v8a\</RemoteDir>
          //        <RemoteName>libjingle_peerconnection_so.so</RemoteName>
          //        <Overwrite>true</Overwrite>
          //    </Platform>
          //</DeployFile>
          for var I := LDeploymentNode.ChildNodes.Count - 1 downto 0 do begin
            var LDeployFileNode := LDeploymentNode.ChildNodes[i];
            if ALSameTextA(LDeployFileNode.NodeName, 'DeployFile') then begin
              if ALSameTextA(LDeployFileNode.Attributes['Class'], 'File') then begin
                if LDeployFileNode.ChildNodes.Count = 0 then raise Exception.Create('Error A892E02E-A8BA-4003-AEF1-A81271AD0A9F');
                for Var J := LDeployFileNode.ChildNodes.Count - 1 downto 0 do begin
                  var LPlatformNode := LDeployFileNode.ChildNodes[j];
                  if not ALSameTextA(LPlatformNode.NodeName, 'Platform') then raise Exception.Create('Error 65714071-86F2-4796-82F8-9F01C5C9824B');
                  var LName := LPlatformNode.Attributes['Name'];
                  if LName = '' then raise Exception.Create('Error 42C3C299-BA31-4B17-9EA4-8320E0048848');
                  if (LPlatforms.IndexOf(LName) >= 0) then begin
                    Var LremoteDirNode := LPlatformNode.ChildNodes.FindNode('RemoteDir');
                    if (LremoteDirNode <> nil) and
                       ((ALPosIgnoreCaseA('res\', LremoteDirNode.Text) = 1) or
                        (ALSameTextA('res', LremoteDirNode.Text)) or
                        (ALPosIgnoreCaseA('library\lib\arm64-v8a', LremoteDirNode.Text) = 1) or
                        (ALPosIgnoreCaseA('library\lib\armeabi-v7a', LremoteDirNode.Text) = 1)) then begin
                      LDeployFileNode.ChildNodes.Delete(j);
                      continue;
                    end;
                  end;
                end;
                if LDeployFileNode.ChildNodes.Count = 0 then
                  LDeploymentNode.ChildNodes.Delete(i);
              end
              else if LDeployFilesToDeactivate.IndexOfName(LDeployFileNode.Attributes['Class']) >= 0 then begin
                LDeploymentNode.ChildNodes.Delete(i);
              end;
            end
          end;

          //add to deployment all items from local res\ folder
          var LResFiles := TDirectory.GetFiles(LResOutputDir, '*', TSearchOption.soAllDirectories); // c:\....Android\Merged\res\drawable\common_google_signin_btn_icon_disabled.xml
          var LResRelativePath := ansiString(ExtractRelativePath(LDProjDir, LResOutputDir)); // Android\Merged\res\
          for Var I := Low(LResFiles) to High(LResFiles) do begin
            Var LLocalName := AnsiString(ExtractRelativePath(LDProjDir, LResFiles[i])); // Android\Merged\res\drawable\common_google_signin_btn_icon_disabled.xml
            for var LConfig in LConfigs do begin
              With LDeploymentNode.AddChild('DeployFile') do begin
                Attributes['LocalName'] := LLocalName;
                Attributes['Configuration'] := LConfig;
                Attributes['Class'] := 'File';
                for var LPlatForm in LPlatforms do begin
                  With AddChild('Platform') do begin
                    Attributes['Name'] := LPlatForm;
                    Addchild('RemoteDir').Text := 'res\' + ALStringReplaceA(ALExcludeTrailingPathDelimiterA(ALExtractFilePath(LLocalName)), LResRelativePath, '', [rfIgnoreCase]);
                    Addchild('RemoteName').Text := ALExtractFileName(LLocalName);
                    Addchild('Overwrite').Text := 'true';
                  end;
                end;
              end;
            end;
          end;

          //deactivate all items in LDeployFilesToDeactivate
          for Var I := 0 to LDeployFilesToDeactivate.Count-1 do begin
            for var LConfig in LConfigs do begin
              for var LPlatForm in LPlatforms do begin
                Var LLocalName := LDeployFilesToDeactivate.ValueFromIndex[i]; // <PlatForm>\<Config>\styles-v21.xml|styles.xml
                Var LRemoteName: AnsiString := '';
                var P := ALPosA('|', LLocalName);
                if P > 0 then begin
                  LRemoteName := ALCopyStr(LLocalName, P+1, Maxint); // styles.xml
                  LLocalName :=  ALCopyStr(LLocalName, 1, P-1); // <PlatForm>\<Config>\styles-v21.xml
                end;
                LLocalName := ALStringReplaceA(LLocalName, '<PlatForm>', LPlatForm, [RfIgnoreCase]); // Android64\<Config>\styles-v21.xml
                LLocalName := ALStringReplaceA(LLocalName, '<Config>', LConfig, [RfIgnoreCase]); // // Android64\Release\styles-v21.xml
                With LDeploymentNode.AddChild('DeployFile') do begin
                  Attributes['LocalName'] := LLocalName;
                  Attributes['Configuration'] := LConfig;
                  Attributes['Class'] := LDeployFilesToDeactivate.Names[i];
                  With AddChild('Platform') do begin
                    Attributes['Name'] := LPlatForm;
                    Addchild('Enabled').Text := 'false';
                    Addchild('Overwrite').Text := 'true';
                    if LRemoteName <> '' then Addchild('RemoteName').Text := LRemoteName;
                  end;
                end;
              end;
            end;
          end;

          //add to deployment all items from local jni\ folder
          var LJniFiles := TDirectory.GetFiles(LJniOutputDir, '*', TSearchOption.soAllDirectories); // c:\....Android\Merged\jni\arm64-v8a\libjingle_peerconnection_so.so
          var LJniRelativePath := ansiString(ExtractRelativePath(LDProjDir, LJniOutputDir)); // Android\Merged\jni\
          for Var I := Low(LJniFiles) to High(LJniFiles) do begin
            Var LLocalName := AnsiString(ExtractRelativePath(LDProjDir, LJniFiles[i])); // Android\Merged\jni\arm64-v8a\libjingle_peerconnection_so.so
            for var LConfig in LConfigs do begin
              With LDeploymentNode.AddChild('DeployFile') do begin
                Attributes['LocalName'] := LLocalName;
                Attributes['Configuration'] := LConfig;
                Attributes['Class'] := 'File';
                for var LPlatForm in LPlatforms do begin
                  With AddChild('Platform') do begin
                    Attributes['Name'] := LPlatForm;
                    Addchild('RemoteDir').Text := 'library\lib\' + ALStringReplaceA(ALExcludeTrailingPathDelimiterA(ALExtractFilePath(LLocalName)), LJniRelativePath, '', [rfIgnoreCase]); // library\lib\arm64-v8a\libjingle_peerconnection_so.so
                    Addchild('RemoteName').Text := ALExtractFileName(LLocalName);
                    Addchild('Overwrite').Text := 'true';
                  end;
                end;
              end;
            end;
          end;

          //init LItemGroupNode
          var LItemGroupNode := LDProjXmlDoc.DocumentElement.ChildNodes.FindNode('ItemGroup');
          if LItemGroupNode = nil then raise Exception.Create('ItemGroup node not found!');

          //remove from ItemGroup all JavaReference
          //<JavaReference Include="..\..\..\libraries\jar\android.arch.core\arch-core-common.jar">
          //  <Disabled/>
          //</JavaReference>
          for var I := LItemGroupNode.ChildNodes.Count - 1 downto 0 do begin
            var LJavaReferenceNode := LItemGroupNode.ChildNodes[i];
            if ALSameTextA(LJavaReferenceNode.NodeName, 'JavaReference') then
              LItemGroupNode.ChildNodes.Delete(i);
          end;

          //because of https://quality.embarcadero.com/browse/RSP-40709 we must duplicate all libs
          //in 2 different subdirectories (32bit and 64bit) so that we can add them in Delphi in both
          //android32 libraries and android64 libraries of the project
          {$IFNDEF ALCompilerVersionSupported}
            {$MESSAGE WARN 'Check if https://quality.embarcadero.com/browse/RSP-40709 is corrected and update the code below. !!Update also the tool RJarSwapper.bat!!'}
          {$IFEND}
          var LLibsFiles := TDirectory.GetFiles(LLibsOutputDir, '*', TSearchOption.soAllDirectories); // c:\....android\libs\r.jar
          Var LLibs32BitOutputDir := LLibsOutputDir + '32bit\';
          TDirectory.CreateDirectory(LLibs32BitOutputDir);
          Var LLibs64BitOutputDir := LLibsOutputDir + '64bit\';
          TDirectory.CreateDirectory(LLibs64BitOutputDir);
          for Var I := Low(LLibsFiles) to High(LLibsFiles) do begin
            if ALSameTextW(ALExtractFileName(LLibsFiles[i]), 'r-apk.jar') or
               ALSameTextW(ALExtractFileName(LLibsFiles[i]), 'r-aab.jar') then continue;
            if not ALSameTextW(ALExtractFileExt(LLibsFiles[i]),'.jar') then raise Exception.Create('Error E88BE4F0-B6E5-4EC4-B890-B9B6169FC58B');
            Tfile.Copy(LLibsFiles[i], LLibs32BitOutputDir + ALExtractFileName(LLibsFiles[i]));
            Tfile.Move(LLibsFiles[i], LLibs64BitOutputDir + ALExtractFileName(LLibsFiles[i]));
          end;

          //add to ItemGroup all items from local libs\32bit folder
          var LLibs32bitFiles := TDirectory.GetFiles(LLibs32bitOutputDir, '*', TSearchOption.soAllDirectories); // c:\....android\libs\32bit\r.jar
          var LLibs32bitRelativePath := ansiString(ExtractRelativePath(LDProjDir, LLibs32bitOutputDir)); // android\libs\32bit\
          for Var I := Low(LLibs32bitFiles) to High(LLibs32bitFiles) do begin
            if ALSameTextW(ALExtractFileName(LLibs32bitFiles[i]), 'r-apk.jar') or
               ALSameTextW(ALExtractFileName(LLibs32bitFiles[i]), 'r-aab.jar') then continue;
            if not ALSameTextW(ALExtractFileExt(LLibs32bitFiles[i]),'.jar') then raise Exception.Create('Error F44A9437-4B53-4D12-A434-7FD978B4E6F1');
            Var LLocalName := AnsiString(ExtractRelativePath(LDProjDir, LLibs32bitFiles[i])); // android\libs\32bit\r.jar
            With LItemGroupNode.AddChild('JavaReference') do begin
              Attributes['Include'] := LLocalName;
              AddChild('ContainerId').Text := 'ClassesdexFile';
            end;
          end;

          //add to ItemGroup all items from local libs\64bit folder
          var LLibs64bitFiles := TDirectory.GetFiles(LLibs64bitOutputDir, '*', TSearchOption.soAllDirectories); // c:\....android\libs\64bit\r.jar
          var LLibs64bitRelativePath := ansiString(ExtractRelativePath(LDProjDir, LLibs64bitOutputDir)); // android\libs\64bit\
          for Var I := Low(LLibs64bitFiles) to High(LLibs64bitFiles) do begin
            if ALSameTextW(ALExtractFileName(LLibs64bitFiles[i]), 'r-apk.jar') or
               ALSameTextW(ALExtractFileName(LLibs64bitFiles[i]), 'r-aab.jar') then continue;
            if not ALSameTextW(ALExtractFileExt(LLibs64bitFiles[i]),'.jar') then raise Exception.Create('Error 21B5091B-8149-4817-90E1-52A31C08FA1F');
            Var LLocalName := AnsiString(ExtractRelativePath(LDProjDir, LLibs64bitFiles[i])); // android\libs\64bit\r.jar
            With LItemGroupNode.AddChild('JavaReference') do begin
              Attributes['Include'] := LLocalName;
              AddChild('ContainerId').Text := 'ClassesdexFile64';
            end;
          end;

          //Update EnabledSysJars
          for var I := 0 to LdprojXmlDoc.DocumentElement.ChildNodes.Count - 1 do begin
            var LPropertyGroupNode := LdprojXmlDoc.DocumentElement.ChildNodes[i];
            if LPropertyGroupNode.NodeName = 'PropertyGroup' then begin
              Var LEnabledSysJarsNode := LPropertyGroupNode.ChildNodes.FindNode('EnabledSysJars');
              if (LEnabledSysJarsNode <> nil) and (LEnabledSysJarsNode.Text <> '') then LEnabledSysJarsNode.Text := 'fmx.dex.jar';
            end;
          end;

          //update DisabledSysJars
          for var I := 0 to LdprojXmlDoc.DocumentElement.ChildNodes.Count - 1 do begin
            var LPropertyGroupNode := LdprojXmlDoc.DocumentElement.ChildNodes[i];
            if LPropertyGroupNode.NodeName = 'PropertyGroup' then begin
              Var LDisabledSysJarsNode := LPropertyGroupNode.ChildNodes.FindNode('DisabledSysJars');
              if LDisabledSysJarsNode <> nil then LPropertyGroupNode.ChildNodes.Remove(LDisabledSysJarsNode);
            end;
          end;

          //add the RJarSwapper command line
          if LRJarSwapper <> '' then begin
            var LRJarDir := ExtractRelativePath(ALExtractFilePath(LDProjDir), LLibsOutputDir);
            Var LConditions := TALStringListA.Create;
            try
              if LPlatforms.IndexOf('Android') >= 0 then begin
                if LConfigs.IndexOf('Debug') >= 0 then LConditions.Add('Android=Debug');
                if LConfigs.IndexOf('Release') >= 0 then LConditions.Add('Android=Release');
              end;
              if LPlatforms.IndexOf('Android64') >= 0 then begin
                if LConfigs.IndexOf('Debug') >= 0 then LConditions.Add('Android64=Debug');
                if LConfigs.IndexOf('Release') >= 0 then LConditions.Add('Android64=Release');
              end;
              //----
              for var I := 0 to LdprojXmlDoc.DocumentElement.ChildNodes.Count - 1 do begin
                var LPropertyGroupNode := LdprojXmlDoc.DocumentElement.ChildNodes[i];
                if LPropertyGroupNode.NodeName = 'PropertyGroup' then begin
                  var LCondition := LPropertyGroupNode.Attributes['Condition'];
                  var LPlatform: AnsiString := '';
                  if (ALPosIgnoreCaseA('Android64', LCondition) > 0) then LPlatform := 'Android64'
                  else if (ALPosIgnoreCaseA('Android', LCondition) > 0) then LPlatform := 'Android';
                  if LPlatforms.IndexOf(LPlatform) >= 0 then begin
                    Var LPreBuildEventNode := LPropertyGroupNode.ChildNodes.FindNode('PreBuildEvent');
                    var LPreBuildEventXml: ansiString := '';
                    if (LPreBuildEventNode <> nil) then LPreBuildEventNode.SaveToXML(LPreBuildEventXml, true{SaveOnlyChildNodes});
                    if (LPreBuildEventXml <> '') and
                       (ALPosIgnoreCaseA('RJarSwapper.bat', LPreBuildEventXml) <= 0) then
                      raise Exception.Create('Cannot set RJarSwapper.bat in PreBuildEvent because it''s not empty');
                    if LPreBuildEventNode <> nil then LPropertyGroupNode.ChildNodes.Remove(LPreBuildEventNode);
                    Var LIndex := LPropertyGroupNode.ChildNodes.IndexOf('PreBuildEventCancelOnError');
                    if LIndex >= 0 then LPropertyGroupNode.ChildNodes.Delete(LIndex);
                    LIndex := LPropertyGroupNode.ChildNodes.IndexOf('PreBuildEventIgnoreExitCode');
                    if LIndex >= 0 then LPropertyGroupNode.ChildNodes.Delete(LIndex);
                    LIndex := LPropertyGroupNode.ChildNodes.IndexOf('PreBuildEventExecuteWhen');
                    if LIndex >= 0 then LPropertyGroupNode.ChildNodes.Delete(LIndex);
                    //A little (completely) ugly but i considere that
                    //'$(Cfg_1_Android)'!='' => mean we are in debug
                    //'$(Cfg_2_Android)'!='' => mean we are in release
                    var J := LConditions.IndexOf(LPlatform+'=Debug');
                    if (J >= 0) and
                       (ALSameTextA(LCondition, '''$(Cfg_1_'+LPlatform+')''!=''''')) then begin
                      LPropertyGroupNode.AddChild('PreBuildEvent').Text := '"'+AnsiString(ExtractRelativePath(LDProjDir, LRJarSwapper))+'" -RJarDir="'+ansiString(LRJarDir)+'" -IsAabPackage="false"';
                      LConditions.Delete(J);
                    end
                    else begin
                      J := LConditions.IndexOf(LPlatform+'=Release');
                      if (J >= 0) and
                         (ALSameTextA(LCondition, '''$(Cfg_2_'+LPlatform+')''!=''''')) then begin
                        LPropertyGroupNode.AddChild('PreBuildEvent').Text := '"'+AnsiString(ExtractRelativePath(LDProjDir, LRJarSwapper))+'" -RJarDir="'+ansiString(LRJarDir)+'" -IsAabPackage="true"';
                        LConditions.Delete(J);
                      end;
                    end;
                  end;
                end;
              end;
              //----
              //for var I := 0 to LConditions.Count - 1 do begin
              //  var LPropertyGroupNode := LdprojXmlDoc.DocumentElement.AddChild('PropertyGroup');
              //  LPropertyGroupNode.Attributes['Condition'] := '''$(Config)''=='''+LConditions.ValueFromIndex[i]+''' And ''$(Platform)''=='''+LConditions.Names[i]+'''';
              //  if ALSameTextA(LConditions.ValueFromIndex[i], 'Debug') then
              //    LPropertyGroupNode.AddChild('PreBuildEvent').Text := '"'+AnsiString(ExtractRelativePath(LDProjDir, LRJarSwapper))+'" -RJarDir="'+ansiString(LRJarDir)+'" -IsAabPackage="false"'
              //  else if ALSameTextA(LConditions.ValueFromIndex[i], 'Release') then
              //    LPropertyGroupNode.AddChild('PreBuildEvent').Text := '"'+AnsiString(ExtractRelativePath(LDProjDir, LRJarSwapper))+'" -RJarDir="'+ansiString(LRJarDir)+'" -IsAabPackage="true"';
              //end;
            finally
              ALFreeAndNil(LConditions);
            end;
          end;

          //save LdprojXmlDoc
          var LDprojXmlSrc: AnsiString;
          LdprojXmlDoc.SaveToXML(LDprojXmlSrc);
          LdprojXmlDoc.Options := [doNodeAutoIndent];
          LdprojXmlDoc.LoadFromXML(LDprojXmlSrc);
          LdprojXmlDoc.SaveToFile(LDProjFilename);

          //normalize the LdprojXmlDoc
          if LDProjNormalizer <> '' then
            ExecuteCmdLine('"'+LDProjNormalizer+'" "' +LDProjFilename + '" false');

        finally
          ALFreeAndNil(LdprojXmlDoc);
          ALFreeAndNil(LDeployFilesToDeactivate);
        end;
      end;
      {$ENDREGION}

      {$REGION 'List imported Libraries'}
      Writeln('Imported Libraries:');
      Var LdependenciesLst := TALStringListA.Create;
      Try
        for var I := 0 to LLibraries.ChildNodes.Count - 1 do begin
          var LLibrary := LLibraries.ChildNodes[i];
          var LgroupID := LLibrary.GetChildNodeValueText('groupid', ''{default});
          if LgroupID = '' then begin
            LdependenciesLst.Add(
              LLibrary.GetChildNodeValueText('archivefilename', ''{default}));
          end
          else begin
            LdependenciesLst.Add(
              LLibrary.GetChildNodeValueText('groupid', ''{default}) + ':' +
              LLibrary.GetChildNodeValueText('artifactid', ''{default}) + ':' +
              LLibrary.GetChildNodeValueText('version', ''{default}));
          end;
        end;
        LdependenciesLst.Sorted := True;
        for var I := 0 to LdependenciesLst.Count - 1 do
          Writeln(
            String(LdependenciesLst[i]),
            TALConsoleColor.ccDarkYellow);
      finally
        ALFreeAndNil(LdependenciesLst);
      End;
      {$ENDREGION}

    finally

      {$REGION 'Free local objects'}
      ALFreeAndNil(LParamLst);
      ALFreeAndNil(LLibraries);
      ALFreeAndNil(LConfigs);
      ALFreeAndNil(LPlatforms);
      ALFreeAndNil(LSupportLibraryToAndroidx);
      {$ENDREGION}

    end;

    if not LNoInteraction then begin
      Writeln('');
      Writeln('Merge successful');
      Writeln('Press <Enter> key to quit');
      Readln;
    end;

    {$REGION 'Empty tmp directory'}
    {$IF not defined(DEBUG)}
    AlEmptyDirectoryW(LtmpDirectory, true{SubDirectory});
    Tdirectory.Delete(LtmpDirectory);
    {$ENDIF}
    {$ENDREGION}

  except
    on E: Exception do begin
      Writeln(E.ClassName+': '+E.Message, TALConsoleColor.ccRed);
      Writeln('');
      Writeln('Usage:');
      Writeln('  AndroidMerger.exe');
      Writeln('    -Libraries=Paths to libraries (aar, jar, directory, maven name). Separate paths with '';''.');
      Writeln('    -DownloadDependencies=Download dependencies from local or central maven repository. Default true');
      Writeln('    -LocalMavenRepositoryDir=Directory on the local machine where to stores all artifacts.');
      Writeln('    -OutputDir=Path where all libraries will be merged.');
      Writeln('    -DProj=Path to the project file (*.dproj).');
      Writeln('    -AndroidManifest=Path to the AndroidManifest.template.xml of the project.');
      Writeln('    -Configurations=Default Debug;Release. Separate Configurations with '';''.');
      Writeln('    -Platforms=Default Android;Android64. Separate Platforms with '';''.');
      Writeln('    -GoogleServicesJson=Path to the google-services.json');
      Writeln('    -DProjNormalizer=Path to the Alcinoe DProjNormalizer tool.');
      Writeln('    -RJarSwapper=Path to the Alcinoe RJarSwapper tool.');
      Writeln('    -UseGradle=Use Gradle build tool to retrieve the dependencies. default false');
      Writeln('    -GenerateNativeBridgeFile=Generate in OutputDir the Delphi native bridge file from the Java libraries.');
      Writeln('    -NoInteraction=Non-interactive mode.');
      Writeln('');
      Writeln('Example:');
      Writeln('  AndroidMerger.exe^');
      Writeln('    -Libraries=com.facebook.android:facebook-android-sdk:15.1.0;c:\MyLibs\af-android.aar;c:\MyProject\Android\ToMerge^');
      Writeln('    -LocalMavenRepositoryDir=c:\LocalMavenRepository\^');
      Writeln('    -OutputDir=c:\MyProject\Android\Merged^');
      Writeln('    -DProj=c:\MyProject\MyProject.dproj^');
      Writeln('    -AndroidManifest=c:\MyProject\AndroidManifest.template.xml^');
      Writeln('    -DProjNormalizer=c:\Alcinoe\Tools\DeployProjNormalizer\DeployProjNormalizer.exe^');
      Writeln('    -RJarSwapper=c:\Alcinoe\Tools\RJarSwapper\RJarSwapper.bat');
      Writeln('    -UseGradle=true');
      Writeln('');
      Writeln('');
      Writeln('Merge failed!');
      Writeln('Press <Enter> key to quit');
      Readln;
      halt(1);
    end;
  end;
end;

begin
  WritelnDuplicatesToSkip := TALStringListW.Create;
  try
    kickoff;
  finally
    ALFreeAndNil(WritelnDuplicatesToSkip);
  end;
end.

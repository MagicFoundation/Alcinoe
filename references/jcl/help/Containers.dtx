@@IJclCloneable
<GROUP Containers.Interfaces>
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@IJclCloneable.ObjectClone
Makes a deep copy of the current object.
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@IJclIntfCloneable
<GROUP Containers.Interfaces>
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@IJclIntfCloneable.IntfClone
  Makes a deep copy of the current object.
--------------------------------------------------------------------------------
@@IJclIterator
<GROUP Containers.Interfaces>
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@IJclCollection
<GROUP Containers.Interfaces>
Summary:
  The IJclCollection interface is the root of the collection hierarchy.
Description:
  A IJclCollection represents a group of objects, known as its elements. Some
  IJclCollection implementations allow duplicate elements and others do not. Some
  are ordered and others unordered. The JCL doesn't provide any direct
  implementations of this interface: It provides implementations of more specific
  subinterfaces like Set and List. This interface is the least common denominator
  that all collections implement. IJclCollection is used to pass collections
  around and manipulate them when maximum generality is desired.
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@IJclCollection.Add@TObject
  Add AObject at the end of the collection. Return True if the method succeeds.
--------------------------------------------------------------------------------
@@IJclCollection.AddAll@IJclCollection
Summary:
  Add all objetcs from ACollection at the end of the collection.
Result:
  Return True if the method succeeds.
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@IJclCollection.Clear
  Clear all objects contained in the collection.
--------------------------------------------------------------------------------
@@IJclCollection.Contains@TObject
  Return True if the collection contains AObject.
--------------------------------------------------------------------------------
@@IJclCollection.ContainsAll@IJclCollection
  Return True if the collection contains all objects of ACollection.
--------------------------------------------------------------------------------
@@IJclCollection.CollectionEquals@IJclCollection
  Return True if all objects of the collection are equal to all objects
  of ACollection.
--------------------------------------------------------------------------------
@@IJclCollection.First
  Return a new Iterator from the begin of the collection.
--------------------------------------------------------------------------------
@@IJclCollection.IsEmpty
  Return True if the collection does not contain any objects.
--------------------------------------------------------------------------------
@@IJclCollection.Last
  Return a new Iterator from the end of the collection.
--------------------------------------------------------------------------------
@@IJclCollection.Remove@TObject
  Remove AObject from the collection. Return True if the method succeeds.
--------------------------------------------------------------------------------
@@IJclCollection.RemoveAll@IJclCollection
  Remove all objects from the collection contained in ACollection.
  Return True if the method succeeds.
--------------------------------------------------------------------------------
@@IJclCollection.RetainAll@IJclCollection
  Remove all objects from the collection except all objects
  contained in ACollection. Return True if the method succeeds.
--------------------------------------------------------------------------------
@@IJclCollection.Size
  Return the number of objects contained in the collection.
--------------------------------------------------------------------------------
@@IJclList
<GROUP Containers.Interfaces>
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@IJclArray
<GROUP Containers.Interfaces>
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@IJclSet
<GROUP Containers.Interfaces>
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@IJclTree
<GROUP Containers.Interfaces>
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@IJclMap
<GROUP Containers.Interfaces>
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@IJclQueue
<GROUP Containers.Interfaces>
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@IJclSortedMap
<GROUP Containers.Interfaces>
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@IJclSortedSet
<GROUP Containers.Interfaces>
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@IJclStack
<GROUP Containers.Interfaces>
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@TJclTraverseOrder
<GROUP Containers.Interfaces>
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@TJclVector
<GROUP Containers.Sequence.Vectors>
Summary:
  This class store objects in a dynamic array.
Notes:
  The default capacity is 16 elements. When the limit is
  reached, the capacity grows of 25%.

  When an element is removed or insert, all elements after it
  are shifted.

  The dynamic array is in public for fast access in read. To
  have directly access to the dynamic array, you have to use
  the class and not the interface.

  This container is NOT threadsafe.
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@TJclQueue
<GROUP Containers.Adapters.Queues>
Summary:
  This class store objects in a FIFO dynamic array.
Notes:
  The default capacity is 16 elements. This limit is fixed.

  If the compilation symbol THREADSAFE is defined,
  this container is threadsafe.
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@TJclStack
<GROUP Containers.Adapters.Stacks>
Summary:
  This class store objects in a LIFO dynamic array.
Notes:
  The default capacity is 16 elements. When the limit is
  reached, the capacity grows of 25%.

  If the compilation symbol THREADSAFE is defined,
  this container is threadsafe.
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@TJclAbstractContainer
<GROUP Containers>
Summary:
  If the compilation symbol THREADSAFE is defined,
  this class provides EnterCriticalSection function to protect
  code in a Critical Section. The function retuen an interface
  and when this interface is released (RefCount = 0) the
  critical section is relased too.
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@TJclArrayList
<GROUP Containers.Specialized.Arrays>
Summary:
  This class store objects in a dynamic array.
Notes:
  The default capacity is 16 elements. When the limit is
  reached, the capacity grows of 25%.

  When an element is removed or insert, all elements after it
  are shifted.

  If the compilation symbol THREADSAFE is defined,
  this container is threadsafe.
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@TJclArraySet
Summary:
  This class stores objects only one time in a dynamic array.
Notes:
  The default capacity is 16 elements. When the limit is
  reached, the capacity grows of 25%.

  When an element is removed or inserted, all elements after it
  are shifted.

  If the compilation symbol THREADSAFE is defined, this
  container is threadsafe.
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@TJclBinaryTree
Summary:
  This class store objects in a red-black binary tree.
Notes:
  The binary tree is always balanced with red-black algorithms
  (from CLR) for best performance in search.

  When an element is removed or insert, the tree is modified to
  keep balancing.

  You can traverse the tree with iterators in different order
  (PreOrder, Order and PostOrder). Iterators are
  bidirectionnal.

  If the compilation symbol THREADSAFE is defined,
  this container is threadsafe.
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@TJclHashMap
<GROUP Containers.Associative.Maps>
Summary:
  This class store a map with object as hashed key and object as value.
Notes:
  Hashed value give an index to a dynamic array (Buckets) that
  store another (Entries) in each cells for collisions.
  The default buckets capacity is 16 elements. The buckets
  capacity is fixed. The default entries capcity is 1. When the
  limit is reached, the capacity grows of 25% if \> 64 else it
  is muliply by 4.

  You can change the hash function by the property HashFunction

  If the compilation symbol THREADSAFE is defined,
  this container is threadsafe.
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@TJclHashSet
<GROUP Containers.OrderedSets>
Summary:
  This class store hashed objects only one time in a HashMap.
Notes:
  If the compilation symbol THREADSAFE is defined,
  this container is threadsafe.
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@TJclLinkedList
<GROUP Containers.Sequence.LinkedLists>
Summary:
  This class store objects in a simple linked list.
Notes:
  When an element is insert, a new node is created.

  When an element is removed, the node is destroyed.

  When you access to a element by an index, you go trough all
  intermediate nodes from the head.

  If the compilation symbol THREADSAFE is defined,
  this container is threadsafe.
Donator:
  Jean-Philippe Bempel
--------------------------------------------------------------------------------
@@TJclAnsiStrAbstractCollection
Summary:
  Abstract class; serves as a common ancestor to classes which
  implement the IJclAnsiStrCollection interface.
Donator:
  Daniele Teti
--------------------------------------------------------------------------------
@@JclAbstractContainers.pas
Summary:
  The JclAbstractContainers unit contains ancestor
  classes for all containers.
Notes:
  This unit was part of the DCL (Delphi Container Library)
  merged into the JCL in 2005.
Donator:
  Jean-Philippe Bempel

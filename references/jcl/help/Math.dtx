@@MathRoutines.Conversion
<GROUP MathRoutines>
<TITLE Conversion>
<TOPICORDER 200>
--------------------------------------------------------------------------------
@@MathRoutines.CRC
<TITLE CRC>
<GROUP MathRoutines>
<TOPICORDER 300>
Description:
  The CRC method used here is a quite "native" translation of a
  hardware CRC generator to software. The data array is
  interpreted as a bit stream with Byte 0 Bit 7 sent first.
  Mathematically when calculating an m-Bit CRC on a n Byte
  data-array, this is like calculating the "modulus" of an an
  8*n + m Bit word, Byte 0 bit 7 of the array being the most
  significant Bit, m Zero Bits added to the end of the array. To
  check the CRC the Zero Bits are replaced by the CRC to be
  checked, thus the CRC forming the low order bits of the 8*n +
  m Bit word. If the CRC is correct the result of this
  operation is Zero, otherwise it's the "syndrome" that can be
  used to calculate the order of the false bit to correct it.
  The software comes with the CRC calculating function in two
  kinds. A "basic" one that works bitwise, like a hardware CRC
  generator would do and a fast one that uses a lookup table
  for complete bytes. The bitwise function can be used to
  calculate the table. So this kind of CRC calculating offers
  some specialities:
      *   The table based operation creates the same result as
          the bitwise calculation.
      *   The table is reproduced by calculating the CRC of a
          single byte, using the starting value Zero.
      *   The CRC check immediately creates the syndrome.
  Beware, that the results of different CRC software algorithms
  might be different even if the same Polynomial and starting
  value is used. The algorithm might use another order of bits
  in the byte stream to be checked or another order of bits in
  the calculated CRC-value. Moreover the input and/or output
  bits might be used inverted and as the CRC-result the
  contents of the shift register after 8*n shifts might be used
  instead shifting the m bits out through the generator the
  additional m steps as done here. E.g. as far as I know the
  CRC result used by "ZIP" is our CRC32 result xor $FFFFFFFF.
--------------------------------------------------------------------------------
@@MathRoutines.Exponential
<GROUP MathRoutines>
<TITLE Exponential>
<TOPICORDER 400>
--------------------------------------------------------------------------------
@@MathRoutines.Floatsupport
<GROUP MathRoutines>
<TITLE Float support>
<TOPICORDER 500>
--------------------------------------------------------------------------------
@@MathRoutines.Hyperbolic
<GROUP MathRoutines>
<TITLE Hyperbolic>
<TOPICORDER 700>
--------------------------------------------------------------------------------
@@MathRoutines.Logarithmic
<GROUP MathRoutines>
<TITLE Logarithmic>
<TOPICORDER 800>
--------------------------------------------------------------------------------
@@MathRoutines.Miscellaneous
<GROUP MathRoutines>
<TITLE Miscellaneous>
<TOPICORDER 900>
--------------------------------------------------------------------------------
@@MathRoutines.Statistics
<GROUP MathRoutines>
<TITLE Statistics>
<TOPICORDER 1000>
--------------------------------------------------------------------------------
@@MathRoutines.Transcendental
<GROUP MathRoutines>
<TITLE Transcendental>
<TOPICORDER 1100>
--------------------------------------------------------------------------------
@@ISqrt
<GROUP MathRoutines.Miscellaneous>
Summary:
  Returns the integral part of the square root.
Description:
  ISqrt calculates the integral part of the square root of the argument. That is,
  it returns Int(Sqrt(I)). Valid values for I are 0..32767. The function does not
  check the validity of the argument, i.e. it must be within the aforementioned range.
Parameters:
  I - The value for which to calculate ISqrt(I). Must be greater than or equal to zero.
Result:
  The integral part of the square root of the argument.
Donator:
  ESB Consultancy
--------------------------------------------------------------------------------
@@ModFloat
<GROUP MathRoutines.Floatsupport>
Summary:
  Returns the modulus of two floating point numbers.
Description:
  ModFloat calculates the modulus (remainder) of the two floating point numbers.
  For floating point numbers the modulus is calculated as: X - Floor(X / Y) * Y.
Parameters:
  X - The first float.
  Y - The second float.
Result:
  Modulus of the two floating point numbers.
See also:
  RemainderFloat
Donator:
  ESB Consultancy
--------------------------------------------------------------------------------
@@RemainderFloat
<GROUP MathRoutines.Floatsupport>
Summary:
  Returns the remainder of two floating point numbers.
Description:
  RemainderFloat calculates the remainder of the two floating point numbers. For
  floating point numbers the remainder is calculated as: X - Int(X / Y) * Y
Parameters:
  X - The first float.
  Y - The second float.
Result:
  The remainder of the two floating point numbers.
See also:
  ModFloat
Donator:
  ESB Consultancy
--------------------------------------------------------------------------------
@@DegMinSecToFloat
<GROUP MathRoutines.Conversion>
Summary:
  Converts degrees, minutes, seconds to a float.
Description:
  DegMinSecToFloat converts, or packs, the supplied degrees, minutes and seconds
  to a float.
Parameters:
  Degs - Degrees.
  Min - Minutes.
  Sec - Seconds.
Result:
  Degrees, Minutes and Seconds converted to a float.
Notes:
  This function is obsolete. Use the function DmsToDeg respectively DmsToRad instead.
See also:
  FloatToDegMinSec
  DmsToDeg
  DmsToRad
  DegToDms
  DegToDmsStr
Donator:
  ESB Consultancy
--------------------------------------------------------------------------------
@@FloatToDegMinSec
<GROUP MathRoutines.Conversion>
Summary:
  Converts a float to degrees, minutes and seconds.
Description:
  FloatToDegMinSec converts a float to degrees, minutes and seconds.
Parameters:
  X - The float to convert to degrees, minutes and seconds.
  Deg - Receives the degrees.
  Min - Receives the minutes.
  Sec - Receives the seconds.
Notes:
  This function is obsolete. Use the function DegToDms instead.
See also:
  DegMinSecToFloat
  DmsToDeg
  DmsToRad
  DegToDms
  DegToDmsStr
Donator:
  ESB Consultancy
--------------------------------------------------------------------------------
@@FloatIsZero
<GROUP MathRoutines.Floatsupport>
Summary:
  Tests if a float is zero.
Description:
  FloatIsZero tests whether the supplied floating point value equals zero within
  the precision as specified by the PrecisionTolerance.
  Thus the function returns True if (X &gt; -PT) and (X &lt; +PT).
Parameters:
  X - The floating point value to test.
Result:
  If the supplied floating point value equals zero within the precision as defined
  by the PrecisionTolerance
  global variable, the function returns True, otherwise it returns False.
See also:
  FloatsEqual
Donator:
  ESB Consultancy
--------------------------------------------------------------------------------
@@FloatsEqual
<GROUP MathRoutines.Floatsupport>
Summary:
  Compares two floats for equality.
Description:
  FloatsEqual compares the two supplied floating point values for equality within
  the precision defined by the PrecisionTolerance
  global variable. Thus the two values are considered to be equal if the absolute
  difference between them is smaller than the value defined by PrecisionTolerance.
Parameters:
  X1 - First value to compare.
  X2 - Second value to compare.
Result:
  If the two supplied values are equal within the precision defined by
  the PrecisionTolerance
  global variable, the function returns True, otherwise it returns False.
See also:
  FloatIsZero
Donator:
  ESB Consultancy
--------------------------------------------------------------------------------
@@SwapFloats
<GROUP MathRoutines.Floatsupport>
Summary:
  Swaps two floating point values.
Description:
  SwapFloat swaps the two supplied floating point values. That is, at return from
  this subroutine X contains the value of Y and Y contains the value of X.
Parameters:
  X - First float.
  Y - Second float.
Donator:
  Marcel van Brakel
--------------------------------------------------------------------------------
@@Pythagoras
<GROUP MathRoutines.Miscellaneous>
Summary:
  Computes Sqrt(X^2 + Y^2)
Description:
  Computes Sqrt(X^2 + Y^2) without destructive underflow or overflow.
Parameters:
  X - First float.
  Y - Second float.
Result:
  Sqrt(X^2 + Y^2)
Donator:
  J. Debord
--------------------------------------------------------------------------------
@@NormalizeAngle
<GROUP MathRoutines.Miscellaneous>
Summary:
  Normalizes the given angle
Description:
  NormalizeAngle normalizes the given angle. That is, it makes sure that the angle
  falls in the interval -PI..PI by iteratively adding or subtracting 2*PI.
Parameters:
  Angle - The angle to normalize.
Result:
  The normalized angle.
Donator:
  J. Debord
--------------------------------------------------------------------------------
@@TenToY
<GROUP MathRoutines.Exponential>
Summary:
  Raises 10 to the power Y.
Description:
  TenToY calculates 10 to the power Y.
Parameters:
  Y - The exponent to raise 10 to.
Result:
  10 to the power Y.
See also:
  Power
  PowerInt
  TwoToY
Donator:
  ESB Consultancy
--------------------------------------------------------------------------------
@@TwoToY
<GROUP MathRoutines.Exponential>
Summary:
  Raises 2 to the power Y.
Description:
  TenToY calculates 2 to the power Y.
Parameters:
  Y - The exponent to raise 2 to.
Result:
  2 to the power Y.
See also:
  Power
  PowerInt
  TenToY
Donator:
  ESB Consultancy
--------------------------------------------------------------------------------
@@PowerInt
<GROUP MathRoutines.Exponential>
Summary:
  Returns X to the power N.
Description:
  PowerInt calculates X to the power N where N is an integer. This function uses
  multiplication to raise X to the power N which is faster than using the
  formal formula for Power (which uses Exp and Ln) and therefore you should favor
  this function over Power when the exponent is an integer.
Parameters:
  X - Base value.
  N - Exponent.
Result:
  X to the power N.
See also:
  Power
  TenToY
  TwoToY
Donator:
  J. Debord
--------------------------------------------------------------------------------
@@IsRelativePrime
<GROUP MathRoutines.Miscellaneous>
Summary:
  Tests if two numbers are relatively prime.
Description:
  IsRelativePrime returns whether the two supplied numbers are relatively prime to each
  other. Two numbers are said to be relatively prime if their greatest common divisor
  equals 1. Another term used for relative prime is coprime.
Parameters:
  X - First of the two values.
  Y - Second of the two values.
Result:
  If the two numbers are relatively prime the result is True, otherwise the result is
  False.
See also:
  GCD
  LCM
Donator:
  ESB Consultancy
--------------------------------------------------------------------------------
@@LCM
<GROUP MathRoutines.Miscellaneous>
Summary:
  Returns the Least Common Multiple of two integers.
Description:
  The LCM function returns the Least Common Multiple (LCM) of the two supplied
  integers.
Parameters:
  X - First of the two values.
  Y - Second of the two values.
Result:
  The least common multiple of X and Y.
See also:
  GCD
  IsRelativePrime
Donator:
  ESB Consultancy
--------------------------------------------------------------------------------
@@GCD
<GROUP MathRoutines.Miscellaneous>
Summary:
  Returns the greatest common divisor.
Description:
  The GCD function returns the greatest common divisor (GCD) of the two supplied
  integers. This is also sometimes referred to as the Highest Common Factor (HCF).
  The function is implemented using Euclid's algorithm.
Parameters:
  X - First of the two values.
  Y - Second of the two values.
Result:
  The greatest common divisor of X and Y.
See also:
  LCM
  IsRelativePrime
Donator:
  ESB Consultancy
--------------------------------------------------------------------------------
@@CycleToGrad
<GROUP MathRoutines.Conversion>
Summary:
  Converts cycles to grads.
Description:
  CycleToGrad converts a given angle, in cycles, to the corresponding angle in grads.
Parameters:
  Cycles - The angle, in cycles, to convert.
Result:
  The angle in cycles.
Donator:
  Marcel van Brakel
--------------------------------------------------------------------------------
@@DegToGrad
<GROUP MathRoutines.Conversion>
Summary:
  Converts degrees to grads.
Description:
  DegToGrad converts a given angle, in degrees, to the corresponding angle in grads.
Parameters:
  Degrees - The angle, in degrees, to convert.
Result:
  The angle in grads.
Donator:
  Marcel van Brakel
--------------------------------------------------------------------------------
@@GradToCycle
<GROUP MathRoutines.Conversion>
Summary:
  Converts grads to cycles.
Description:
  GradToCycle converts a given angle, in grads, to the corresponding angle in cycles.
Parameters:
  Grads - The angle, in grads, to convert.
Result:
  The angle in cycles.
Donator:
  Marcel van Brakel
--------------------------------------------------------------------------------
@@GradToDeg
<GROUP MathRoutines.Conversion>
Summary:
  Converts grads to degrees.
Description:
  GradToDeg converts a given angle, in grads, to the corresponding angle in degrees.
Parameters:
  Grads - The angle, in grads, to convert.
Result:
  The angle in degrees.
Donator:
  Marcel van Brakel
--------------------------------------------------------------------------------
@@LogBaseN
<GROUP MathRoutines.Logarithmic>
Summary:
  Returns log base N.
Description:
  LogBaseN returns the log base N of X. This is calculated as LogN(X) := Log.2(X) / Log.2(N)
Parameters:
  Base - Base of log (N). Base must be larger than 0.0 and cannot be 1.0 or an exception is raised.
  X - Value whose log base N to calculate. N must be larger than 0.0.
Result:
  Log base N of X.
See also:
  LogBase2
  LogBase10
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@LogBase2
<GROUP MathRoutines.Logarithmic>
Summary:
  Returns log base 2.
Description:
  LogBase2 returns the log base 2 of X.
Parameters:
  X - Value whose log base 2 to calculate. X must be larger than 0.0.
Result:
  Log base 2 of X.
See also:
  LogBase10
  LogBaseN
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@LogBase10
<GROUP MathRoutines.Logarithmic>
Summary:
  Returns log base 10.
Description:
  LogBase10 returns the log base 10 of X. This is calculated as Log10(X) := Log.2(X) * Log.10(2)
Parameters:
  X - Value whose log base 10 to calculate. X must be larger than 0.0.
Result:
  Log base 10 of X.
See also:
  LogBase2
  LogBaseN
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@ArcCos
<GROUP MathRoutines.Transcendental>
Summary:
  Calculates the inverse cosine of X.
Description:
  ArcCos calculates the inverse cosine of X. Meaning it returns the angle whose
  cosine equals X. ArcCos is defined as ArcTan2(Sqrt(1.0 - X*X), X).
Parameters:
  X - Value for which to calculate the inverse cosine. Absolute value of X must be smaller than 1.0.
Result:
  The inverse cosine of X in radians.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@ArcCosH
<GROUP MathRoutines.Hyperbolic>
Summary:
  Calculates the inverse hyperbolic cosine.
Description:
  ArcCosH calculates the inverse hyperbolic cosine of X. ArcCosH is defined as
  Ln(X + Sqrt(X * X - 1).
Parameters:
  X - Value for which to calculate the inverse hyperbolic cosine. Must be greater than or equal to 1.0.
Result:
  The inverse hyperbolic cosine of X.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@ArcCot
<GROUP MathRoutines.Transcendental>
Summary:
  Calculates the inverse of cotangent.
Description:
  ArcCot calculates the inverse cotangent. Meaning it returns the angle whose
  cotangent equals X. ArcCot is calculated as -Arctan(X) + PI_2.
Parameters:
  X - Value whose ArcCot to calculate
Result:
  The angle whose cotangent equals X in radians.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@ArcCotH
<GROUP MathRoutines.Hyperbolic>
Summary:
  Calculates the inverse hyperbolic cotangent.
Description:
  ArcCotH calculates the inverse hyperbolic CotH. Meaning it returns the value
  whose hyperbolic cotangent equals X. It is defined as Ln((X + 1.0) / (X - 1.0)) / 2.0.
Parameters:
  X - The value whose ArcCotH to calculate. Absolute value of X must be inequal to 1.0.
Result:
  ArcCoth of X.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@ArcCsc
<GROUP MathRoutines.Transcendental>
Summary:
  Calculates the inverse cosecant.
Description:
  ArcCsc calculates the inverse cosecant. Meaning it returns the angle whose cosecant equals X.
  ArcCsc is calculated as ArcTan(1.0 / Sqrt(1.0 - Sqr(X))) + (Sgn(X) - 1.0) * PI_2.
Parameters:
  X - Value whose ArcCsc to calculate. Absolute value of X must be smaller than 1.0.
Result:
  The angle, in radians, whose cosecant equals X.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@ArcCscH
<GROUP MathRoutines.Hyperbolic>
Summary:
  Calculates the inverse hyperbolic cosecant.
Description:
  ArcCscH calculates the inverse hyperbolic cosecant. Meaning, it returns the value
  whose hyperbolic cosecant equals X. ArcCscH is calculates as Ln((Sgn(X) * Sqrt (Sqr(X) + 1.0) + 1.0) / X)
Parameters:
  X - Value whose ArcCscH to calculate, cannot be 0.0.
Result:
  ArcCscH of X.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@ArcSec
<GROUP MathRoutines.Transcendental>
Summary:
  Calculates the inverse Sec.
Description:
  ArcSec calculates the inverse secant of X. Meaning it returns the angle whose
  secant equals X.
Parameters:
  X - Value whose ArcSec to calculate. Absolute value of X must be smaller than 1.0.
Result:
  ArcSec of X in radians.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@ArcSecH
<GROUP MathRoutines.Hyperbolic>
Summary:
  Calculates the inverse hyperbolic secant.
Description:
  Calculates the inverse hyperbolic secant. Meaning it returns the value whose hyperbolic
  secant equals X. ArcSecH is calculated as Ln((Sqrt(1.0 - Sqr(X)) + 1.0) / X).
Parameters:
  X - Value whose ArcSecH to calculate. X must be smaller than or equal to 1.0.
Result:
  Inverse hyperbolic secant of X.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@ArcSin
<GROUP MathRoutines.Transcendental>
Summary:
  Calculates the inverse sine.
Description:
  ArcSin calculates the inverse sine. Meaning it returns the
  angle whose sine equals X.
Parameters:
  X - The value whose inverse sine to calculate. X must be
      smaller than or equal to 1.0.
Result:
  ArcSin of X in radians.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@ArcSinH
<GROUP MathRoutines.Hyperbolic>
Summary:
  Calculates the inverse hyperbolic sine.
Description:
  ArcSinH calculates the inverse hyperbolic sine of X. Meaning it returns the value
  whose hyperbolic sine equals X.
Parameters:
  X - Value whose ArcSinH to calculate.
Result:
  ArcSinH of X.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@ArcTan
<GROUP MathRoutines.Transcendental>
Summary:
  Calculates the inverse tangent.
Description:
  ArcTan calculates the inverse tangent of X. Meaning it returns the angle whose
  tangent equals X.
Parameters:
  X - Value whose inverse tangent to calculate.
Result:
  Inverse tangent of X.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@ArcTan2
<GROUP MathRoutines.Transcendental>
Summary:
  Calculates the inverse tangent of Y / X.
Description:
  ArcTan2 calculates the inverse tangent of Y / X. Meaning it returns the angle
  whose tangent equals Y / X.
Parameters:
  Y - The value of Y in Y / X.
  X - The value of X in Y / X.
Result:
  The inverse tangent of Y / X in radians.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@ArcTanH
<GROUP MathRoutines.Hyperbolic>
Summary:
  Returns the inverse hyperbolic tangent of X.
Description:
  Returns the inverse hyperbolic tangent of X.
Parameters:
  X - Value whose inverse hyperbolic tangent to calculate.
Result:
  Inverse hyperbolic tangent of X.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@Cos
<GROUP MathRoutines.Transcendental>
Summary:
  Calculates the cosine of X.
Description:
  Calculates the cosine of X.
Parameters:
  X - Angle, in radians, whose cosine to calculate.
Result:
  Cosine of X.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@CosH
<GROUP MathRoutines.Hyperbolic>
Summary:
  Returns the hyperbolic cosine of X.
Description:
  Returns the hyperbolic cosine of X. CosH is calculated as [Exp(X) + Exp(-X)] / 2.0.
Parameters:
  X - Value whose CosH to calculate.
Result:
  Hyperbolic cosine of X.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@Cot
<GROUP MathRoutines.Transcendental>
Summary:
  Returns the cotangent of the argument.
Description:
  Cot returns the cotangent of X. Cot(X) is defined as 1.0 / Tan(X).
Parameters:
  X - Angle, in radians, whose cotangent to calculate.
Result:
  Cotangent of X.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@CotH
<GROUP MathRoutines.Hyperbolic>
Summary:
  Returns the hyperbolic cotangent of X.
Description:
  Returns the hyperbolic cotangent of X. CotH(x) equals
  cosh(x) / sinh(x).
Parameters:
  X - Value whose hyperbolic cotangent to calculate.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@Csc
<GROUP MathRoutines.Transcendental>
Summary:
  Returns the reciprocal of the sine of X.
Description:
  Returns the reciprocal of the sine of X (cosecant). Meaning, Csc(X) := 1.0 / Sin(X).
Parameters:
  X - Angle, in radians, whose Csc to calculate.
Result:
  Cosecant of X.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@CscH
<GROUP MathRoutines.Hyperbolic>
Summary:
  Hyperbolic Cosecant (csc).
Description:
  Returns the hyperbolic cosecant of X. This is defined as 2.0 / (Exp(X) - Exp(-X)).
Parameters:
  X - Value whose hyperbolic cosecant to calculate.
Result:
  Hyperbolic cosecant of X.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@Sec
<GROUP MathRoutines.Transcendental>
Summary:
  Returns the reciprocal of the cosine of the argument.
Description:
  Returns the reciprocal of the cosine of X, meaning: Sec(X) = 1.0 / Cos(X).
Parameters:
  X - Angle, in radians, whose Sec to calculate.
Result:
  Secant of X.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@SecH
<GROUP MathRoutines.Hyperbolic>
Summary:
  Returns the hyperbolic secant of the argument.
Description:
  SecH calculates the hyperbolic secant of X, which is defined as 2.0 / (Exp(X) + Exp(-X))
Parameters:
  X - Value whose hyperbolic secant to calculate.
Result:
  Hyperbolic secant of X.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@Haversine
<GROUP MathRoutines.Transcendental>
Summary:
  Returns the haversine of the argument.
Description:
  Haversine calculates the aversine of X.
Parameters:
  X - Angle, in radians, whose haversine to calculate.
Result:
  Haversine of X.
Donator:
  Matthias Thoma
--------------------------------------------------------------------------------
@@Coversine
<GROUP MathRoutines.Transcendental>
Summary:
  Returns the coversine of the argument.
Description:
  Coversine calculates the coversine of X.
Parameters:
  X - Angle, in radians, whose coversine to calculate.
Result:
  Coersine of X.
Donator:
  Matthias Thoma
--------------------------------------------------------------------------------
@@Versine
<GROUP MathRoutines.Transcendental>
Summary:
  Returns the versine of the argument.
Description:
  Versine calculates the versine of X.
Parameters:
  X - Angle, in radians, whose versine to calculate.
Result:
  Versine of X.
Donator:
  Matthias Thoma
--------------------------------------------------------------------------------
@@Sin
<GROUP MathRoutines.Transcendental>
Summary:
  Returns the sine of the argument.
Description:
  Sin calculates the sine of X.
Parameters:
  X - Angle, in radians, whose sine to calculate.
Result:
  Sine of X.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@SinCos
<GROUP MathRoutines.Transcendental>
Summary:
  Calculates the sine and cosine of the argument.
Description:
  SinCos calculates both the sine and cosine of the angle X in one call. This is
  much faster than calling Sin() and Cos() separately.
Parameters:
  X - The angle, in radians, whose sine and cosine to calculate.
  Sin - Sine of X.
  Cos - Cosine of X.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@SinH
<GROUP MathRoutines.Hyperbolic>
Summary:
  Returns the hyperbolic sine of the argument.
Description:
  SinH returns the hyperbolic sine of X. This is defined as [Exp(X) - Exp(-X)] / 2.0.
Parameters:
  X - Value whose hyperbolic sine to calculate.
Result:
  Hyperbolic sine of X.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@Tan
<GROUP MathRoutines.Transcendental>
Summary:
  Returns the tangent of the argument.
Description:
  Tan calculates the tangent of X. The tangent is defines as Sin(X) / Cos(X).
Parameters:
  X - Angle, in radians, whose tangent to calculate.
Result:
  Tangent of X.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@TanH
<GROUP MathRoutines.Hyperbolic>
Summary:
  Returns the hyperbolic tangent of the argument.
Description:
  TanH calculates the hyperbolic tangent of X which is defined
  as [Sqr(Exp(X)) - 1.0] / [Sqr(Exp(X)) + 1.0].
Parameters:
  X - Value whose hyperbolic tangent to calculate.
Result:
  Hyperbolic tangent of X.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@Power
<GROUP MathRoutines.Exponential>
Summary:
  Returns Base to the power Exponent.
Description:
  Power calculates Base to the power Exponent. If Base equals 0 the result is 0,
  if Exponent equals 0 the result is 1. If the exponent is an integer as opposed to
  a floating point value you should use PowerInt instead.
Parameters:
  Base - Base value.
  Exponent - Exponent value.
Result:
  Base to the power Exponent.
See also:
  PowerInt
  TenToY
  TwoToY
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@Ceiling
<GROUP MathRoutines.Miscellaneous>
Summary:
  Return the nearest integer value above X.
Description:
  Return the nearest integer value above X.
Parameters:
  X - The value to return the ceiling of.
Result:
  Nearest integer value above X.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@CommercialRound
<GROUP MathRoutines.Miscellaneous>
Summary:
  Performs symmetic arithmetic rounding.
Description:
  CommercialRound returns the value of X rounded to the nearest whole number.
  If X is exactly halfway between two whole numbers, the result is always the
  larger absolute value. For example, -2.5 is rounded to -3.
Parameters:
  X - The value to round.
Result:
  The rounded value.
Donator:
  Ernesto Benestante
--------------------------------------------------------------------------------
@@Floor
<GROUP MathRoutines.Miscellaneous>
Summary:
  Return the nearest integer value below X.
Description:
  Return the nearest integer value below X.
Parameters:
  X - The value to floor.
Result:
  Nearest integer value below X.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@Factorial
<GROUP MathRoutines.Miscellaneous>
Summary:
  Returns the factorial of the argument.
Description:
  Factorial returns the factorial of N. Factorial is defined as the product of 1..N,
  or 1 * 2 * 3 ... N. This value grows very rapidly; to avoid an
  overflow N must be smaller than 14.
Parameters:
  X - The value whose factorial to calculate. N must be smaller than 14.
Result:
  Factorial of N.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@MinFloat
<GROUP MathRoutines.Floatsupport>
Summary:
  Returns the smaller of the arguments
Description:
  MinFloat returns the smaller value of the two arguments. I.e. if X &lt; Y the result
  is X, otherwise the result is Y.
Parameters:
  X - Value 1.
  Y - Value 2.
Result:
  The smaller of the two arguments.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@MaxFloat
<GROUP MathRoutines.Floatsupport>
Summary:
  Returns the larger of the two arguments.
Description:
  MaxFloat returns the larger value of the two arguments. I.e. if X &gt; Y the result
  is X, otherwise it's Y.
Parameters:
  X - Value 1.
  Y - Value 2.
Result:
  The larger of the two arguments.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@Sgn
<GROUP MathRoutines.Miscellaneous>
Summary:
  Returns the sign of the argument.
Description:
  Sgn returns the sign of X. If X &gt; 0 the result is 1, if X &lt; 0 the result is -1,
  and finally if X = 0 the result is 0.
Parameters:
  X - Value whose sign to determine.
Result:
  Sign of X expressed as -1, 0 or +1.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------
@@Signe
<GROUP MathRoutines.Miscellaneous>
Summary:
  Returns the value of X with the same sign as Y.
Description:
  The result is the value of X with the same sign (positive or negative) as Y. If Y is zero, the result will be -X (the value of X with the sign reversed). If X is zero, the result will always be 0.
Parameters:
  X - The value you wish to assign a sign to.
  Y - The value that has the desired sign to assign to X.
Result:
  The value of X with the sign (positive or negative) of Y.
Donator:
  Clayton Collie
--------------------------------------------------------------------------------

@@CheckCrc32
<GROUP MathRoutines.CRC>
Summary:
  Checks and, if possible, corrects the data protected by a 32 bit CRC.
Description:
  Checks and, if possible, corrects the data protected by the same 32 bit CRC the function Crc32 uses.
  With  a 32 bit CRC a single bit error in 2^31-32 bit (2^28-4 = 268435454 byte) of data can be corrected.
  Beware that when trying to correct an error in a greater array of bytes, you will not get an error indicator but
  an unwanted  bit might be changed. In arrays small enough, multiple bit errors are not corrected, but by
  far most multiple bit errors are detected (see CRC32).
Parameters:
  X - The array which contains the data. With CheckCrc32 and CheckCrc32_A this is an open array parameter, with CheckCrC32_P this is a pointer to the first byte of the array of bytes.
  N - The number of elements in X. CheckCrc32_A uses all bytes in the array X.
  Crc - Transmitted CRC value to check the data against.
Result:
   * 0 No CRC error.
   * 1 Correctable error. If the false bit was in the data, it has been corrected.
   * -1 Uncorrectable error (more than one false bit).
See also:
  Crc32
  InitCrc32
  CheckCrc16
Donator:
  Michael Schnell
@@CheckCrc32_A
<COMBINE CheckCrc32>
@@CheckCrc32_P
<COMBINE CheckCrc32>
--------------------------------------------------------------------------------
@@Crc32
<GROUP MathRoutines.CRC>
Summary:
  Calculates or checks a 32 Bit CRC.
Description:
  32 Bit CRC function. Calculates or checks a CRC. Independently from the size of the data array,
  with a 32 bit CRC any single and double bit error can be detected. By far most multiple bit errors
  are detected, too: E.g. all even (or odd) count of bit errors (depending on the polynomial used) and
  all burst errors with up to 32 bits length (so any sequence of up to 4 incorrect bytes) are detected.
  Burst error with a length of more than 32 are detected with a probability of 99,9999999767 %.
  All this is true only if an appropriate polynomial is used.
  By default the 32 Bit CRC "generator polynomial" suggested by the CCITT is used:
  x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1 ($104C11DB7).
  This polynomial has a "maximum cycle" and is used by Ethernet and Zip, too. The default starting value is
  $FFFFFFFF. By InitCrc32 a different polynomial and starting value can be defined.
Parameters:
  X - The array which contains the data. With Crc32 and Crc32_A this is an open array parameter, with CrC32_P this is a pointer to the first byte of the array of bytes.
  N - The number of elements in X. Crc32_A calculates the checksum of all bytes in the array X.
  Crc - (optional) if not defined or = 0: Crc32 calculates the CRC for the data array transmitted; if CRC is defined: the CRC value is checked against the data and the result is 0 if the CRC was correct.
Result:
   * If on input CRC not defined or = 0: The result is the created CRC.
   * If on input CRC is defined: The result is 0 if the CRC was OK,
  otherwise the function
    returns the residuum for the correction function.
See also:
  CheckCrc32
  InitCrc32
  Crc16
Donator:
  Michael Schnell
@@Crc32_A
<COMBINE Crc32>
@@Crc32_P
<COMBINE Crc32>
--------------------------------------------------------------------------------
@@InitCrc32
<GROUP MathRoutines.CRC>
Summary:
  Defines a new polynomial and starting value for the 32 bit CRC functions.
Description:
  Defines a new "generator polynomial" and starting value for the 32 bit CRC functions. Beware that the check and the correction
  only works if the polynomial is "appropriate". Two of these polynomials are predefined: Crc32PolynomCCITT = $04C11DB7
  represents the polynomial x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1 that is
  suggested by the CCITT and used by Ethernet and ZIP. Crc32PolynomXXXXX = $9DB11213 represents the polynomial
  x^32 + x^31 + x^28 + x^27 + x^26 + x^24 + x^23 + x^21 + x^20 + x^16 + x^12 + x^9 + x^4 + x + 1 which is another
  "appropriate" polynomial (as far as I know). Beware that not appropriate polynomials result in highly undesirable behaviour
  of the CRC.
  The starting value can by anything. $FFFFFFFF and 0 are usual definitions.
Parameters:
  polynomial - Generator polynomial to be used with subsequent calls to 32 bit CRC functions. The polynomial is given without the highest bit (bit x^32)
  Start - 32 bit starting value to be used with subsequent calls to 32 bit CRC functions
Notes:
  As a standard in the JEDI Code Library the compiler option {$J-} is set to prevent modifying typed constants. So the function CRC32Init only exists if JCLMath is recompiled with the compiler environment variable "CRCINIT" defined, which temporarily sets {$J+} for the CRC functions.
See also:
  Crc32
  CheckCrc32
  InitCrc16
Donator:
  Michael Schnell
--------------------------------------------------------------------------------
@@CheckCrc16
<GROUP MathRoutines.CRC>
Summary:
  Checks and, if possible, corrects the data protected by a 16 bit CRC.
Description:
  Checks and, if possible, corrects the data protected by the same 16 bit CRC the function Crc16 uses.
  With  a 16 bit CRC a single bit error in 2^15-16 bit (2^12-2 = 4094 byte) of data can be corrected.
  Beware that when trying to correct an error in a greater array of bytes, you will not get an error indicator but
  an unwanted bit might be changed. In arrays small enough, multiple bit errors are not corrected, but by
  far most multiple bit errors are detected (see CRC16).
Parameters:
  X - The array which contains the data. With CheckCrc16 and CheckCrc16_A this is an open array parameter, with CheckCrC16_P this is a pointer to the first byte of the array of bytes.
  N - The number of elements in X. CheckCrc16_A uses all bytes in the array X.
  Crc - Transmitted CRC value to check the data against.
Result:
   * 0 No CRC error.
   * 1 Correctable error. If the false bit was in the data, it has been corrected.
   * -1 Uncorrectable error (more than one false bit).
See also:
  Crc16
  InitCrc16
  CheckCrc32
Donator:
  Michael Schnell
@@CheckCrc16_A
<COMBINE CheckCrc16>
@@CheckCrc16_P
<COMBINE CheckCrc16>
--------------------------------------------------------------------------------
@@Crc16
<GROUP MathRoutines.CRC>
Summary:
  Calculates or checks a 16 Bit CRC.
Description:
  16 Bit CRC function. Calculates or checks a CRC. Independently from the size of the data array,
  with a 16 bit CRC any single and double bit error can be detected. By far most multiple bit errors
  are detected, too: E.g. all even (or odd) count of bit errors (depending on the polynomial used) and
  all burst errors with up to 16 bits length (so any sequence of up to two incorrect bytes) are detected.
  Burst error with a length of more than 16 are detected with a probability of 99,99998474 %.
  All this is true only if an appropriate polynomial is used.
  By default the 16 Bit CRC "generator polynomial" suggested by the CCITT is used:
  x^16 + x^12 + x^5 + 1 ($11021).
  This polynomial has a "maximum cycle" and is used to protect data on floppy disks, too. The default starting value is
  $FFFF. By InitCrc16 a different polynomial and starting value can be defined.
Parameters:
  X - The array which contains the data. With Crc16 and Crc16_A this is an open array parameter, with CrC16_P this is a pointer to the first byte of the array of bytes.
  N - The number of elements in X. Crc16_A calculates the checksum of all bytes in the array X.
  Crc - (optional) if not defined or = 0: Crc16 calculates the CRC for the data array transmitted; if CRC is defined: the CRC value is checked against the data and the result is 0 if the CRC was correct.
Result:
   * If on input CRC not defined or = 0: The result is the created CRC.
   * If on input CRC is defined: The result is 0 if the CRC was OK,
     otherwise the function returns the residuum for the correction function.
See also:
  CheckCrc16
  InitCrc16
  Crc32
Donator:
  Michael Schnell
@@Crc16_A
<COMBINE Crc16>
@@Crc16_P
<COMBINE Crc16>
--------------------------------------------------------------------------------
@@InitCrc16
<GROUP MathRoutines.CRC>
Summary:
  Defines a new polynomial and starting value for the 16 bit CRC functions.
Description:
  Defines a new "generator polynomial" and starting value for the 16 bit CRC functions. Beware that the check and the correction
  only works if the polynomial is "appropriate". Two of these polynomials are predefined: Crc16PolynomCCITT = $1021
  represents the polynomial x^16 + x^12 + x^5 + 1 that is
  suggested by the CCITT and used to protect floppy disks. Crc16PolynomXXXXX = $8005 represents the polynomial
  x^16 + x^15 + x^2 + 1 which is another "appropriate" polynomial and used to protect magnetic tapes. Beware that not appropriate polynomials result in highly undesirable behaviour
  of the CRC.
  The starting value can by anything. $FFFF and 0 are usual definitions.
Parameters:
  Polynomial - Generator polynomial to be used with subsequent calls to 16 bit CRC functions. The polynomial is given without the highest bit (bit x^16).
  Start - 16 bit starting value to be used with subsequent calls to 16 bit CRC functions.
Notes:
  As a standard in the JEDI Code Library the compiler option {$J-} is set to prevent modifying typed constants. So the function CRC32Init only exists if JCLMath is recompiled with the compiler environment variable "CRCINIT" defined, which temporarily sets {$J+} for the CRC functions.
See also:
  Crc16
  CheckCrc16
  InitCrc32
Donator:
  Michael Schnell
--------------------------------------------------------------------------------
@@TFloatingPointClass
<GROUP MathRoutines.Floatsupport>
Summary:
  Describes the hierarchy of floating point classes.
Description:
  Enumeration which describes the classes into which floating point encodings can
  be divided. Their relations are as follows: A floating point encoding can be
  either supported by the hardware or unsupported (fpInvalid). Supported
  encodings subdivide into numbers and non-numbers, denoted by the term NaN
  (Not a Number, fpNaN).  A number is either
  finite or infinite (fpInfinite).  If finite, it is either denormal
  (fpDenormal) or normal. If normal, it is either non-zero (fpNormal)
  or zero (fpZero).
Notes:
  Only the Extended data type allows for unsupported encodings.
  
  What separates NaNs from numbers is that the former are unordered. That is,
  the result of relational operations (<, <=, =, >=, >) is not defined for NaNs.
  
  Certain classes of floating point values may result from an exception
  condition if the corresponding FPU exception is masked out.
  See table below.
<TABLE>
Exception class  Result on masked exception  Result class
---------------  --------------------------  ------------
EInvalidOp       NaN (real indefinite)       fpNaN
EZeroDivide      Infinity/NegInfinity        fpInfinite
EOverflow        Infinity/NegInfinity        fpInfinite
EUnderflow       Denormal number             fpDenormal
</TABLE>
See also:
  FloatingPointClass
  IsNaN
  IsInfinite
Donator:
  Robert Rossmair
@@TFloatingPointClass.fpZero
  Zero.
@@TFloatingPointClass.fpNormal
  Non-zero normal finite number.
@@TFloatingPointClass.fpDenormal
  Denormalized finite.
@@TFloatingPointClass.fpInfinite
  Infinite.
@@TFloatingPointClass.fpNaN
  Not a number.
@@TFloatingPointClass.fpInvalid
  Unsupported floating point format.
--------------------------------------------------------------------------------
@@FloatingPointClass
<GROUP MathRoutines.Floatsupport>
Summary:
  Classifies the supplied floating point value.
Description:
  Classifies the supplied floating point value.
Parameters:
  Value - The value to classify.
Result:
  The result is the class to which Value belongs.
See also:
  TFloatingPointClass
Donator:
  Robert Rossmair
--------------------------------------------------------------------------------
@@IsInfinite
<GROUP MathRoutines.Floatsupport>
Summary:
  Determines whether Value is infinite.
Description:
  Determines whether Value is infinite.
Parameters:
  Value - The floating point value to examine.
Result:
  The result is True when Value is infinite, False otherwise.
See also:
  TFloatingPointClass
  FloatingPointClass
Donator:
  Robert Rossmair
--------------------------------------------------------------------------------
@@IsNaN
<GROUP MathRoutines.Floatsupport>
Summary:
  Determines whether Value is a NaN.
Description:
  Determines whether Value is a NaN.
Parameters:
  Value - The floating point value to examine.
Result:
  The result is True when Value is a NaN, False otherwise.
See also:
  TFloatingPointClass
  FloatingPointClass
  MakeQuietNaN
  MakeSignalingNaN
  TNaNTag
Donator:
  Robert Rossmair
--------------------------------------------------------------------------------
@@TNaNTag
<GROUP MathRoutines.Floatsupport>
Summary:
  The data type used by JCL routines for tagging numeric information to NaN values.
Description:
  The data type used by JCL routines for tagging numeric information to NaN values.
See also:
  GetNaNTag
  MakeQuietNaN
  MakeSignalingNaN
Donator:
  Robert Rossmair
--------------------------------------------------------------------------------
@@GetNaNTag
<GROUP MathRoutines.Floatsupport>
Summary:
  Retrieves some numeric information tagged to the NaN value.
Description:
  Retrieves some numeric information tagged to the NaN value.
Parameters:
  NaN - The NaN value to evaluate.
Result:
  The value encoded in the NaN.
See also:
  TNaNTag
  MakeQuietNaN
  MakeSignalingNaN
Donator:
  Robert Rossmair
--------------------------------------------------------------------------------
@@MakeQuietNaN
<GROUP MathRoutines.Floatsupport>
Summary:
  Makes X a quiet NaN.
Description:
  Makes a floating point variable X a quiet NaN (QNaN).
  A QNaN is a NaN with the most significant fraction bit set.
  QNaNs, in contrast to signaling NaNs (SNaNs), are allowed to propagate
  through most arithmetic operations without signaling an exception.
Parameters:
  X - The floating point variable to change into a QNaN.
  Tag - An integer value to be encoded in the resulting NaN value. It may be used to propagate some information through a sequence of arithmetic operations.
See also:
  TFloatingPointClass
  TNaNTag
  MakeSignalingNaN
  GetNaNTag
Donator:
  Robert Rossmair
--------------------------------------------------------------------------------
@@MakeSignalingNaN
<GROUP MathRoutines.Floatsupport>
Summary:
  Makes X a signaling NaN.
Description:
  Makes a floating point variable X a signaling NaN (SNaN). An SNaN is a NaN with
  the most significant fraction bit clear.
  SNaNs generally signal an floating-point invalidoperation exception whenever
  they appear as operands in arithmetic operations.
  SNaNs are typically used to trap or invoke an exception handler. They must be
  inserted by software; that is, the processor never generates an SNaN as a result
  of a floating-point operation.
Parameters:
  X - The floating point variable to change into a SNaN.
  Tag - An integer value to be encoded in the resulting NaN value.
See also:
  TFloatingPointClass
  TNaNTag
  MakeQuietNaN
  GetNaNTag
Donator:
  Robert Rossmair
--------------------------------------------------------------------------------
@@MineSingleBuffer
<GROUP MathRoutines.Floatsupport>
Summary:
  MineSingleBuffer fills the buffer with consecutive tagged signaling NaNs.
Description:
  MineSingleBuffer fills the buffer with consecutive tagged signaling NaNs. This
  allows for real number arrays which enforce initialization: any attempt to load
  an uninitialized array element into the FPU will raise an exception either of
  class EJclNaNSignal (Windows NT) or EInvalidOp (else).
  Under Windows NT thus the violating array index can be derived from the
  EJclNaNSignal object's Tag property.
Parameters:
  Buffer - The buffer to initialize with SNaN values.
  Count - The number of array elements.
  StartTag - The integer value assigned to the first array element. The tag is increased with each subsequent array element.
See also:
  TNaNTag
  GetNaNTag
  MineDoubleBuffer
  MakeSignalingNaN
Donator:
  Robert Rossmair
--------------------------------------------------------------------------------
@@MineDoubleBuffer
<GROUP MathRoutines.Floatsupport>
Summary:
  MineDoubleBuffer fills the buffer with consecutive tagged signaling NaNs.
Description:
  MineDoubleBuffer fills the buffer with consecutive tagged signaling NaNs. This
  allows for real number arrays which enforce initialization: any attempt to load
  an uninitialized array element into the FPU will raise an exception either of
  class EJclNaNSignal (Windows NT) or EInvalidOp (else).
  Under Windows NT thus the violating array index can be derived from the
  EJclNaNSignal object's Tag property.
Parameters:
  Buffer - The buffer to initialize with SNaN values.
  Count - The number of array elements.
  StartTag - The integer value assigned to the first array element. The tag is increased with each subsequent array element.
See also:
  TNaNTag
  GetNaNTag
  MineSingleBuffer
  MakeSignalingNaN
Donator:
  Robert Rossmair
--------------------------------------------------------------------------------
@@CalcMachineEps
<GROUP MathRoutines.Floatsupport>
Summary:
  Calculates the Machine Epsilon value for the current precision.
Description:
  This procedure calculates the Machine Epsilon value for the current precision
  and stores it in the variable Epsilon. Nontheless Epsilon is not used
  for any calculations. Per definition, all JCL functions which need a specific epsilon
  use the PrecisionTolerance variable instead. Therefore you need to call either
  SetPrecisionTolerance or SetPrecisionToleranceToEpsilon.
See also:
  CalcMachineEpsSingle
  CalcMachineEpsDouble
  CalcMachineEpsExtended
  SetPrecisionTolerance
  SetPrecisionToleranceToEpsilon
Donator:
  Anonymous
--------------------------------------------------------------------------------
@@CalcMachineEpsSingle
<GROUP MathRoutines.Floatsupport>
Summary:
  Calculates the Machine Epsilon value for single precision.
Description:
  This procedure calculates the Machine Epsilon value for single precision
  and stores it within the variable EpsSingle. Both, the variable Epsilon as well as the variable
  PrecisionTolerance stay untouched.
See also:
  CalcMachineEps
  CalcMachineEpsDouble
  CalcMachineEpsExtended
  SetPrecisionTolerance
  SetPrecisionToleranceToEpsilon
Donator:
  Anonymous
--------------------------------------------------------------------------------
@@CalcMachineEpsDouble
<GROUP MathRoutines.Floatsupport>
Summary:
  Calculates the Machine Epsilon value for double precision.
Description:
  This procedure calculates the Machine Epsilon value for double precision
  and stores it within the variable EpsDouble. Both, the variable Epsilon as well as the variable
  PrecisionTolerance stay untouched.
See also:
  CalcMachineEps
  CalcMachineEpsSingle
  CalcMachineEpsExtended
  SetPrecisionTolerance
  SetPrecisionToleranceToEpsilon
Donator:
  Anonymous
--------------------------------------------------------------------------------
@@CalcMachineEpsExtended
<GROUP MathRoutines.Floatsupport>
Summary:
  Calculates the Machine Epsilon value for extended precision.
Description:
  This procedure calculates the Machine Epsilon value for extended precision
  and stores it within the variable EpsExtended. Both, the variable Epsilon as well as the variable
  PrecisionTolerance stay untouched.
See also:
  CalcMachineEps
  CalcMachineEpsSingle
  CalcMachineEpsDouble
  SetPrecisionTolerance
  SetPrecisionToleranceToEpsilon
Donator:
  Anonymous
--------------------------------------------------------------------------------
@@Exp
<GROUP MathRoutines.Exponential>
Summary:
  Calculates e raised to a power x.
Description:
  Calculates e raised to a power x.
Parameters:
  X - Value for which to calculate the exp.
Donator:
  Anonymous
--------------------------------------------------------------------------------
@@IsFloatZero
<GROUP MathRoutines.Floatsupport>
Summary:
  Determines whether value X is zero.
Description:
  Determines whether value X is zero or near by zero. To determine if a value is
  near by zero the function takes advance of the PrecisionTolerance variable.
Parameters:
  X - Value to test.
See also:
  IsNaN
  IsInfinite
  IsSpecialValue
Donator:
  Anonymous
--------------------------------------------------------------------------------
@@IsPrimeFactor
<GROUP MathRoutines.Miscellaneous>
Summary:
  Determines if a specific value is a prime factor of another value.
Description:
  IsPrimeFactor determines if a specific value F is a prime factor of another value N.
  F is a prime factor if (F mod N) = 0 and, of course, the value F is a prime number. To
  determine if F is a prime number the IsPrime function is used.
Parameters:
  F - The value to test if it is a prime factor.
  N - The value for which to determine if F is a prime factor.
See also:
  IsPrime
  IsPrimeRM
  IsPrimeTD
  IsRelativePrime
Donator:
  Anonymous
--------------------------------------------------------------------------------
@@IsPrimeRM
<GROUP MathRoutines.Miscellaneous>
Summary:
  Determines whether a value is a prime number according the Rabin-Miller Strong
  Primality Test.
Description:
  Determines whether the value N is a prime number according the Rabin-Miller Strong
  Primality Test. Instead of using this function directly you should set the Primality Test
  using the SetPrimalityTest function and use the function IsPrime to check if a value is
  prime.
Parameters:
  N - The value to test.
See also:
  SetPrimalityTest
  IsPrime
Donator:
  Anonymous
--------------------------------------------------------------------------------
@@IsPrimeTD
<GROUP MathRoutines.Miscellaneous>
Summary:
  Determines whether a Value is a prime number according the Trial Division primality test.
Description:
  Determines whether the value N is a prime number according the Trial Division
  Primality Test. Instead of using this function directly you should set the Primality Test
  using the SetPrimalityTest function and use the function IsPrime to check if a value is
  prime.
Parameters:
  N - The value to test.
Donator:
  Anonymous
--------------------------------------------------------------------------------
@@IsSpecialValue
<GROUP MathRoutines.Floatsupport>
Summary:
  Determines of a value is either NaN or infinite.
Description:
  IsSpecialValue returns true if the value is either a NaN, positive Infinite or
  negative Infinite.
Parameters:
  X - The value to test.
See also:
  IsNaN
  IsInfinite
Donator:
  Matthias Thoma
--------------------------------------------------------------------------------
@@PrimeFactors
<GROUP MathRoutines.Miscellaneous>
Summary:
  Determines all prime factors of a value.
Description:
  PrimeFactors determines all prime factors of a given value.
Parameters:
  N - The number for which the prime factors should be determined.
See also:
  TODO
Donator:
  Anonymous
--------------------------------------------------------------------------------
@@SetPrecisionTolerance
<GROUP MathRoutines.Floatsupport>
Summary:
  Set the precision tolerance to a new value.
Description:
  This function sets the PrecisionTolerance variable to
  a new value NewTolerance.
Parameters:
  NewTolerance - The new tolerance to use.
See also:
  SetPrecisionToleranceToEpsilon
Donator:
  Anonymous
--------------------------------------------------------------------------------
@@SetPrecisionToleranceToEpsilon
<GROUP MathRoutines.Floatsupport>
Summary:
  Set the PrecisionTolerance variable to Epsilon.
Description:
  This procedure sets the PrecisionTolerance variable to
  Epsilon. Epsilon is (re-) calaculated using the
  CalcMachineEps function.
Parameters:
  TODO
Donator:
  Anonymous
--------------------------------------------------------------------------------
@@SetPrimalityTest
<GROUP MathRoutines.Miscellaneous>
Summary
  Set the primality test to use within the JCL.
Description
  This procedures sets the primality test to use within the
  JCL. Currently two different algorithms are available:
  Rabin-Miller strong primality test and the more traditional
  and straight forward Trial Division method.

  If you need to implement a new primality test please follow
  these rules:

  First you need to add a function similar to IsPrimeRM. Per
  definition, each new primality test function name starts with
  IsPrime followed by the kind of primality test. A future
  function concerning the Lehmann primality test would be
  called, for example, IsPrimeLehmann.

  <CODE>
  function IsPrimeLehmann(X: Cardinal): Boolean;
  begin
  [...]
  end;
  </CODE>

  The next step is to add your new test to the
  TPrimalityTestMethod set.

  <CODE>
  type
    TPrimalityTestMethod = (ptTrialDivision, ptRabinMiller, ptLehmann);
  </CODE>

  Furthermore you'll need to add a new case to SetPrimality
  test.

  <CODE>
  case Method of
    ptTrialDivision: IsPrime := IsPrimeTD;
    ptRabinMiller: IsPrime := IsPrimeRM;
    ptLehmann: IsPrime := IsPrimeLehmann;
  end;
  </CODE>

  Now you are done. Anyway, please consider to donate your
  function to the main JCL branch.
Donator:
  Matthias Thoma
--------------------------------------------------------------------------------
@@MathConstants
<TITLE Constants used in JclMath>
<GROUP MathRoutines>
Description:
  The JCL provides many mathematical constants. Some to speed
  up a function and some just because they are common within
  math calculations. All these constants are provided with the
  greatest possible precision.

  <TABLE>
  constant name           Description         Value
  ------------------      -----------------   -------------------------------------
  Cbrt2                   CubeRoot (2)         1.2599210498948731647672106072782
  Cbrt3                   CubeRoot (3)         1.4422495703074083823216383107801
  Cbrt10                  CubeRoot (10)        2.1544346900318837217592935665194
  Cbrt100                 CubeRoot (100)       4.6415888336127788924100763509194
  CbrtPi                  CubeRoot (PI)        1.4645918875615232630201425272638
  PiOn2                   PI / 2               1.5707963267948966192313216916398
  PiOn3                   PI / 3               1.0471975511965977461542144610932
  PiOn4                   PI / 4               0.78539816339744830961566084581988
  Sqrt2                   Sqrt (2)             1.4142135623730950488016887242097
  Sqrt3                   Sqrt (3)             1.7320508075688772935274463415059
  Sqrt5                   Sqrt (5)             2.2360679774997896964091736687313
  Sqrt10                  Sqrt (10)            3.1622776601683793319988935444327
  SqrtPi                  Sqrt (PI)            1.7724538509055160272981674833411
  Sqrt2Pi                 Sqrt (2 * PI)        2.506628274631000502415765284811
  TwoPi                   2 * PI               6.283185307179586476925286766559;
  ThreePi                 3 * PI               9.4247779607693797153879301498385
  Ln2                     Ln(2)                0.69314718055994530941723212145818
  Ln10                    Ln(10)               2.3025850929940456840179914546844
  LnPi                    Ln(PI)               1.1447298858494001741434273513531
  Log2                    Log10(2)             0.30102999566398119521373889472449
  Log3                    Log10(3)             0.47712125471966243729502790325512
  LogPi                   Log10(PI)            0.4971498726941338543512682882909
  LogE                    Log10(E)             0.43429448190325182765112891891661
  E                       Natural constant     2.7182818284590452353602874713527
  hLn2Pi                  Ln(2*PI)/2           0.91893853320467274178032973640562
  inv2Pi                  0.5 / Pi             0.159154943091895
  TwoToPower63            2^63                 9223372036854775808.0
  MaxAngle                                     Depends on selected float data type.
  MaxTanH                                      Depends on selected float data type.
  MaxFactorial                                 Depends on selected float data type.
  MaxFloatingPoint                             Depends on selected float data type.
  MinFloatingPoint                             Depends on selected float data type.
</TABLE>
--------------------------------------------------------------------------------
@@Cbrt2
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@Cbrt3
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@Cbrt10
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@Cbrt100
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@CbrtPi
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@Pi
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@PiOn2
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@PiOn3
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@PiOn4
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@Sqrt2
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@Sqrt3
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@Sqrt5
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@Sqrt10
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@SqrtPi
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@Sqrt2Pi
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@TwoPi
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@ThreePi
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@Ln2
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@Ln10
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@LnPi
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@Log2
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@Log3
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@LogPi
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@LogE
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@E
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@hLn2Pi
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@inv2Pi
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@TwoToPower63
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@MaxAngle
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@MaxTanH
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@MaxFactorial
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@MaxFloatingPoint
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@MinFloatingPoint
<ALIAS MathConstants>
--------------------------------------------------------------------------------
@@IsPrime
<GROUP MathRoutines.Miscellaneous>
Summary:
  Determines whether a value is a prime number.
Description:
  Determines whether the value N is a prime number according the currently active
  Primality Test. You should set the Primality Test using the SetPrimalityTest function.
Parameters:
  N - The value to test.
See also:
  SetPrimalityTest
Donator:
  Matthias Thoma
--------------------------------------------------------------------------------
@@Epsilon
<GROUP MathRoutines.Floatsupport>
Summary:
  Epsilon and related variables hold the calculated machine Epsilon.
Description:
  Epsilon holds the calculated machine Epsilon. If no Epsilon has been calaculated
  by the CalcMachineEps procedure the value of Epsilon is undetermined.
  
  Nontheless Epsilon is not used for any calculations. Per definition,
  all JCL functions which need a specific epsilon use the PrecisionTolerance
  variable instead. Therefor you need to call either SetPrecisionTolerance or
  SetPrecisionToleranceToEpsilon.
--------------------------------------------------------------------------------
@@ThreeEpsilon
<COMBINE Epsilon>
@@EpsSingle
<COMBINE Epsilon>
@@EpsDouble
<COMBINE Epsilon>
@@EpsExtended
<COMBINE Epsilon>
@@ThreeEpsSingle
<COMBINE Epsilon>
@@ThreeEpsDouble
<COMBINE Epsilon>
@@ThreeEpsExtended
<COMBINE Epsilon>
--------------------------------------------------------------------------------
@@PrecisionTolerance
<GROUP MathRoutines.Floatsupport>
Summary:
  PrecisionTolerance holds the value of the tolerance used within the JCL.
Description:
  Several JCL functions and procedures are using PrecisionTolerance. For example,
  IsFloatZero uses this variable to determine if a value is zero or near by zero.
--------------------------------------------------------------------------------
@@TJclASet
Description:
  Ancestor class for different implementations of bit fields.

  Do not use this class directly, it doesn't implement anything
  but exposes abstract functions to manage the field of bits.

  Depending on your data, you should use TJclFlatSet or
  TJclSparseFlatSet.
See also:
  TJclFlatSet
  TJclSparseFlatSet
--------------------------------------------------------------------------------
@@TJclASet.Clear
Summary:
  Clear the field of bits. After a call to this function, the
  number of stored bits is set to 0.
Parameters:
  This function has no parameter.
Result:
  This function returns nothing.
--------------------------------------------------------------------------------
@@TJclASet.GetBit@Integer
Summary:
  This function returns the state for the indexed bit. To set
  the value of this bit, use TJclASet.SetBit.
Parameters:
  Idx - Index of the bit.
Result:
  The return value is the value of the indexed bit.
See also:
  TJclASet.SetBit
--------------------------------------------------------------------------------
@@TJclASet.GetRange@Integer@Integer@Boolean
Summary:
  This function returns true if all bits in the specified range
  are equal to the Value.

  To set a range of bits to a predefined value, use
  TJclASet.SetRange.
Parameters:
  Low -  Lower bound of the range.
  High - Higher bound of the range.
  Value - Value for reference.
Result:
  This function returns true if all bits are equals to the
  reference value, false otherwise.
See also:
  TJclASet.SetRange
--------------------------------------------------------------------------------
@@TJclASet.Invert
Summary:
  This function invert the value of all bits in the stored field.

  To set the value of one bit, use the TJclASet.SetBit
  function.To set a range of bits to a predefined value, use
  the TJclASet.SetRange function.
Parameters:
  TODO
Result:
  This function returns nothing.
See also:
  TJclASet.SetBit
  TJclASet.SetRange
--------------------------------------------------------------------------------
@@TJclASet.SetBit@Integer@Boolean
Summary:
  This function sets the value for the indexed bit.

  To set a range a bits to a predefined value, use the
  TJclASet.SetRange function.

  To get the value of a bit, use the TJclASet.GetBit function.
Parameters:
  Idx - Index of the bit.
  Value - New value for this bit.
Result:
  This function returns nothing.
See also:
  TJclASet.SetRange
  TJclASet.GetBit
--------------------------------------------------------------------------------
@@TJclASet.SetRange@Integer@Integer@Boolean
Summary:
  This function sets a range of bits to a predefined value.

  To set a value to a single bit, use the TJclASet.SetBit
  function.

  To test the value of a range of bits, use the
  TJclASet.GetRange function.
Parameters:
  Low - Lower bound of the range.
  High - Higher bound of the range.
  Value -New value for all bits in the range.
Result:
  This function returns nothing.
See also:
  TJclASet.SetBit
  TJclASet.GetRange
--------------------------------------------------------------------------------
@@TJclFlatSet
Summary:
  This class implements functions to handle a field of
  contiguous bits. It inherits from TJclASet and implements all
  the abstract functions defined in its ancestor.

  the TJclSparseFlatSet class is preferred to handle a field of
  sparse bits (not contiguous).
See also:
  TJclASet
  TJclSparseFlatSet
--------------------------------------------------------------------------------
@@TJclFlatSet.Create
Summary:
  Create an empty field of contiguous bits.
--------------------------------------------------------------------------------
@@TJclFlatSet.Destroy
Summary:
  Destroy the array of contiguous bits.
--------------------------------------------------------------------------------
@@TJclSparseFlatSet
Summary:
  This class implements functions to handle a field of
  discontinuous bits. It inherits from TJclASet and implements
  all the abstract functions defined in its ancestor.

  A sparse field lowers the memory usage when some ranges of
  bits are not needed.

  The TJclFlatSet class is preferred to handle a field of
  contiguous bits.
See also:
  TJclASet
  TJclFlatSet
--------------------------------------------------------------------------------
@@TJclSparseFlatSet.Destroy
Summary:
  Destroy the field of bits.
--------------------------------------------------------------------------------
@@TJclRational
Summary:
  This class handles operations for rational numbers.

  A rational number is represented as a fraction
  numerator/denominator where both numerator and denominator
  are signed integers.

  This format can be used to represent integer number as well
  as floating point numbers (which are approximated as a
  fraction).

  All basic operations (addition, subtraction, multiplication,
  division, power, square root) are exposed as functions as
  well as equality test.
--------------------------------------------------------------------------------
@@TJclRational.AsFloat
Summary:
  This property converts the rational number from/to a floating
  point representation.

  Some rational numbers cannot be exactly represented as
  floating point numbers (such as 1/3), they are represented as
  the nearest floating point value.

  To have a string representation of the rational number, use
  the TJclRational.AsString property.
See also:
  TJclRational.AsString
--------------------------------------------------------------------------------
@@TJclRational.AsString
Summary:
  This property converts the rational number from/to a string
  representation.

  On read, the string format is always 'Numerator/Denominator',
  on write this property accepts a floating point
  representation of a number as well as the
  'Numerator/Denominator' representation.

  To have a floating point representation of the rational
  number, use the TJclRational.AsFloat property.
See also:
  TJclRational.AsFloat
--------------------------------------------------------------------------------
@@TJclRational.Denominator
Summary:
  This property is a read-only access to the denominator of the
  rational number.
See also:
  TJclRational.Numerator
--------------------------------------------------------------------------------
@@TJclRational.Numerator
Summary:
  This property is a read-only access to the numerator of the
  rational number.
See also:
  TJclRational.Denominator
--------------------------------------------------------------------------------
@@TJclRational.Abs
Summary:
  This function replaces the rational number by its absolute
  value: a positive number is not changed, a negative number is
  changed to its opposite value.

  To get the sign of the number, use the Sgn property. To
  change the sign of the number, use the Negate method.
Parameters:
  This function has no parameter.
Result:
  This function returns nothing.
See also:
  TJclRational.Sgn
  TJclRational.Negate
--------------------------------------------------------------------------------
@@TJclRational.Add@Float
Summary:
  Add the specified floating point number to this number.

  The current value is converted to a float, then added to the
  argument. The result of this addition is converted back to a
  rational number.
Parameters:
  V - Floating point number to be added.
Result:
  This function returns nothing.
See also:
  TJclRational.Subtract
--------------------------------------------------------------------------------
@@TJclRational.Add@Integer
Summary:
  Add the specified integer number to this rational number.
Parameters:
  V - Integer number to be added.
Result:
  This function returns nothing.
See also:
  TJclRational.Subtract
--------------------------------------------------------------------------------
@@TJclRational.Add@TJclRational
Summary:
  Add the rational number to this number.
Parameters:
V - Rational number to be added.
Result:
  This function returns nothing.
See also:
  TJclRational.Subtract
--------------------------------------------------------------------------------
@@!!OVERLOADED_Add_TJclRational
Summary:
  These overloaded functions add a number to this number.

  This operation is implemented with three different versions
  depending on the type of the number to added:
    * To add a floating point number: TJclRational.Add Method (Float)
    * To add an integer number: TJclRational.Add Method (Integer)
    * To add a rational number: TJclRational.Add Method (TJclRational)
See also:
  TJclRational.Add@Float
  TJclRational.Add@Integer
  TJclRational.Add@TJclRational

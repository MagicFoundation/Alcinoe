(*$JPPDEFINEMACRO ITERPROCEDURE(ITERATEPROCEDURETYPENAME, CONSTKEYWORD, PARAMETERNAME, TYPENAME)
ITERATEPROCEDURETYPENAME = procedure(CONSTKEYWORDPARAMETERNAME: TYPENAME);*)
(*$JPPDEFINEMACRO APPLYFUNCTION(APPLYFUNCTIONTYPENAME, CONSTKEYWORD, PARAMETERNAME, TYPENAME)
APPLYFUNCTIONTYPENAME = function(CONSTKEYWORDPARAMETERNAME: TYPENAME): TYPENAME;*)
(*$JPPDEFINEMACRO COMPAREFUNCTION(COMPAREFUNCTIONTYPENAME, CONSTKEYWORD, TYPENAME)
COMPAREFUNCTIONTYPENAME = function(CONSTKEYWORDObj1, Obj2: TYPENAME): Integer;*)
(*$JPPDEFINEMACRO EQUALITYCOMPAREFUNCTION(EQUALITYCOMPAREFUNCTIONTYPENAME, CONSTKEYWORD, TYPENAME)
EQUALITYCOMPAREFUNCTIONTYPENAME = function(CONSTKEYWORDObj1, Obj2: TYPENAME): Boolean;*)
(*$JPPDEFINEMACRO HASHFUNCTION(HASHCONVERTFUNCTIONTYPENAME, CONSTKEYWORD, PARAMETERNAME, TYPENAME)
HASHCONVERTFUNCTIONTYPENAME = function(CONSTKEYWORDPARAMETERNAME: TYPENAME): Integer;*)
(*$JPPDEFINEMACRO SORTPROC(SORTPROCEDURETYPENAME, LISTINTERFACENAME, COMPAREFUNCTIONTYPENAME)
SORTPROCEDURETYPENAME = procedure(const AList: LISTINTERFACENAME; L, R: Integer; AComparator: COMPAREFUNCTIONTYPENAME);*)
(*$JPPDEFINEMACRO CONTAINER(INTERFACENAME, GUID)
INTERFACENAME = interface(IJclBaseContainer)
  ['GUID']
end;
*)
(*$JPPDEFINEMACRO FLATCONTAINER(INTERFACENAME, GUID, ANCESTORNAME)
INTERFACENAME = interface(ANCESTORNAME)
  ['GUID']
end;
*)
(*$JPPDEFINEMACRO EQUALITYCOMPARER(INTERFACENAME, GUID, EQUALITYCOMPAREFUNCTIONTYPENAME, CONSTKEYWORD, TYPENAME)
INTERFACENAME = interface
  ['GUID']
  function GetEqualityCompare: EQUALITYCOMPAREFUNCTIONTYPENAME;
  procedure SetEqualityCompare(Value: EQUALITYCOMPAREFUNCTIONTYPENAME);
  function ItemsEqual(CONSTKEYWORDA, B: TYPENAME): Boolean;
  property EqualityCompare: EQUALITYCOMPAREFUNCTIONTYPENAME read GetEqualityCompare write SetEqualityCompare;
end;
*)
(*$JPPDEFINEMACRO COMPARER(INTERFACENAME, GUID, COMPAREFUNCTIONTYPENAME, CONSTKEYWORD, TYPENAME)
INTERFACENAME = interface
  ['GUID']
  function GetCompare: COMPAREFUNCTIONTYPENAME;
  procedure SetCompare(Value: COMPAREFUNCTIONTYPENAME);
  function ItemsCompare(CONSTKEYWORDA, B: TYPENAME): Integer;
  property Compare: COMPAREFUNCTIONTYPENAME read GetCompare write SetCompare;
end;*)
(*$JPPDEFINEMACRO HASHCONVERTER(INTERFACENAME, GUID, HASHCONVERTFUNCTIONTYPENAME, CONSTKEYWORD, PARAMETERNAME, TYPENAME)
INTERFACENAME = interface
  ['GUID']
  function GetHashConvert: HASHCONVERTFUNCTIONTYPENAME;
  procedure SetHashConvert(Value: HASHCONVERTFUNCTIONTYPENAME);
  function Hash(CONSTKEYWORDPARAMETERNAME: TYPENAME): Integer;
  property HashConvert: HASHCONVERTFUNCTIONTYPENAME read GetHashConvert write SetHashConvert;
end;
*)
(*$JPPDEFINEMACRO RELEASEEVENT(EVENTTYPENAME, PARAMETERNAME, TYPENAME)
EVENTTYPENAME = function (var PARAMETERNAME: TYPENAME): TYPENAME of object;
*)
(*$JPPDEFINEMACRO OWNER(INTERFACENAME, ANCESTORNAME, GUID, RELEASERFUNCTIONNAME, RELEASEEVENTNAME, RELEASEEVENTTYPENAME, PARAMETERNAME, TYPENAME, OWNERADDITIONAL)
INTERFACENAME = interface(ANCESTORNAME)
  ['GUID']
  function GetRELEASEEVENTNAME: RELEASEEVENTTYPENAME;
  function RELEASERFUNCTIONNAME(var PARAMETERNAME: TYPENAME): TYPENAME;
  procedure SetRELEASEEVENTNAME(Value: RELEASEEVENTTYPENAME);
  property RELEASEEVENTNAME: RELEASEEVENTTYPENAME read GetRELEASEEVENTNAME write SetRELEASEEVENTNAME;OWNERADDITIONAL
end;
*)
(*$JPPDEFINEMACRO ITERATOR(INTERFACENAME, ANCESTORNAME, GUID, CONSTKEYWORD, PARAMETERNAME, TYPENAME, GETTERFUNCTIONNAME, SETTERPROCEDURENAME)
INTERFACENAME = interface(ANCESTORNAME)
  ['GUID']
  function Add(CONSTKEYWORDPARAMETERNAME: TYPENAME): Boolean;
  procedure Extract;
  function GETTERFUNCTIONNAME: TYPENAME;
  function HasNext: Boolean;
  function HasPrevious: Boolean;
  function Insert(CONSTKEYWORDPARAMETERNAME: TYPENAME): Boolean;
  function IteratorEquals(const AIterator: INTERFACENAME): Boolean;
  function Next: TYPENAME;
  function NextIndex: Integer;
  function Previous: TYPENAME;
  function PreviousIndex: Integer;
  procedure Remove;
  procedure Reset;
  procedure SETTERPROCEDURENAME(CONSTKEYWORDPARAMETERNAME: TYPENAME);
  {$IFDEF SUPPORTS_FOR_IN}
  function MoveNext: Boolean;
  property Current: TYPENAME read GETTERFUNCTIONNAME;
  {$ENDIF SUPPORTS_FOR_IN}
end;*)
(*$JPPDEFINEMACRO TREEITERATOR(INTERFACENAME, ANCESTORNAME, GUID, CONSTKEYWORD, PARAMETERNAME, TYPENAME)
INTERFACENAME = interface(ANCESTORNAME)
  ['GUID']
  function AddChild(CONSTKEYWORDPARAMETERNAME: TYPENAME): Boolean;
  function ChildrenCount: Integer;
  procedure DeleteChild(Index: Integer);
  procedure DeleteChildren;
  procedure ExtractChild(Index: Integer);
  procedure ExtractChildren;
  function GetChild(Index: Integer): TYPENAME;
  function HasChild(Index: Integer): Boolean;
  function HasParent: Boolean;
  function IndexOfChild(CONSTKEYWORDPARAMETERNAME: TYPENAME): Integer;
  function InsertChild(Index: Integer; CONSTKEYWORDPARAMETERNAME: TYPENAME): Boolean;
  function Parent: TYPENAME;
  procedure SetChild(Index: Integer; CONSTKEYWORDPARAMETERNAME: TYPENAME);
  property Children[Index: Integer]: TYPENAME read GetChild write SetChild;
end;*)
(*$JPPDEFINEMACRO BINTREEITERATOR(INTERFACENAME, ANCESTORNAME, GUID, TYPENAME)
INTERFACENAME = interface(ANCESTORNAME)
  ['GUID']
  function HasLeft: Boolean;
  function HasRight: Boolean;
  function Left: TYPENAME;
  function Right: TYPENAME;
end;*)
(*$JPPDEFINEMACRO COLLECTION(INTERFACENAME, ANCESTORNAME, GUID, CONSTKEYWORD, PARAMETERNAME, TYPENAME, ITRNAME)
INTERFACENAME = interface(ANCESTORNAME)
  ['GUID']
  function Add(CONSTKEYWORDPARAMETERNAME: TYPENAME): Boolean;
  function AddAll(const ACollection: INTERFACENAME): Boolean;
  procedure Clear;
  function Contains(CONSTKEYWORDPARAMETERNAME: TYPENAME): Boolean;
  function ContainsAll(const ACollection: INTERFACENAME): Boolean;
  function CollectionEquals(const ACollection: INTERFACENAME): Boolean;
  function Extract(CONSTKEYWORDPARAMETERNAME: TYPENAME): Boolean;
  function ExtractAll(const ACollection: INTERFACENAME): Boolean;
  function First: ITRNAME;
  function IsEmpty: Boolean;
  function Last: ITRNAME;
  function Remove(CONSTKEYWORDPARAMETERNAME: TYPENAME): Boolean;
  function RemoveAll(const ACollection: INTERFACENAME): Boolean;
  function RetainAll(const ACollection: INTERFACENAME): Boolean;
  function Size: Integer;
  {$IFDEF SUPPORTS_FOR_IN}
  function GetEnumerator: ITRNAME;
  {$ENDIF SUPPORTS_FOR_IN}
end;*)
(*$JPPDEFINEMACRO LIST(INTERFACENAME, ANCESTORNAME, GUID, CONSTKEYWORD, PARAMETERNAME, TYPENAME, GETTERFUNCTIONNAME, SETTERPROCEDURENAME, ARRAYPROPERTYNAME)
INTERFACENAME = interface(ANCESTORNAME)
  ['GUID']
  function Delete(Index: Integer): TYPENAME;
  function ExtractIndex(Index: Integer): TYPENAME;
  function GETTERFUNCTIONNAME(Index: Integer): TYPENAME;
  function IndexOf(CONSTKEYWORDPARAMETERNAME: TYPENAME): Integer;
  function Insert(Index: Integer; CONSTKEYWORDPARAMETERNAME: TYPENAME): Boolean;
  function InsertAll(Index: Integer; const ACollection: ANCESTORNAME): Boolean;
  function LastIndexOf(CONSTKEYWORDPARAMETERNAME: TYPENAME): Integer;
  procedure SETTERPROCEDURENAME(Index: Integer; CONSTKEYWORDPARAMETERNAME: TYPENAME);
  function SubList(First, Count: Integer): INTERFACENAME;
  property ARRAYPROPERTYNAME[Key: Integer]: TYPENAME read GETTERFUNCTIONNAME write SETTERPROCEDURENAME; default;
end;*)
(*$JPPDEFINEMACRO ARRAY(INTERFACENAME, ANCESTORNAME, GUID, CONSTKEYWORD, PARAMETERNAME, TYPENAME, GETTERFUNCTIONNAME, SETTERPROCEDURENAME, ARRAYPROPERTYNAME)
INTERFACENAME = interface(ANCESTORNAME)
  ['GUID']
  function GETTERFUNCTIONNAME(Index: Integer): TYPENAME;
  procedure SETTERPROCEDURENAME(Index: Integer; CONSTKEYWORDPARAMETERNAME: TYPENAME);
  property ARRAYPROPERTYNAME[Index: Integer]: TYPENAME read GETTERFUNCTIONNAME write SETTERPROCEDURENAME; default;
end;*)
(*$JPPDEFINEMACRO SET(INTERFACENAME, ANCESTORNAME, GUID)
INTERFACENAME = interface(ANCESTORNAME)
  ['GUID']
  procedure Intersect(const ACollection: ANCESTORNAME);
  procedure Subtract(const ACollection: ANCESTORNAME);
  procedure Union(const ACollection: ANCESTORNAME);
end;*)
(*$JPPDEFINEMACRO TREE(INTERFACENAME, ANCESTORNAME, GUID, ITRNAME)
INTERFACENAME = interface(ANCESTORNAME)
  ['GUID']
  function GetRoot: ITRNAME;
  function GetTraverseOrder: TJclTraverseOrder;
  procedure SetTraverseOrder(Value: TJclTraverseOrder);
  property Root: ITRNAME read GetRoot;
  property TraverseOrder: TJclTraverseOrder read GetTraverseOrder write SetTraverseOrder;
end;*)
(*$JPPDEFINEMACRO MAP(INTERFACENAME, ANCESTORNAME, GUID, KEYCONSTKEYWORD, KEYTYPENAME, KEYSETNAME, VALUECONSTKEYWORD, VALUETYPENAME, VALUECOLLECTIONNAME)
INTERFACENAME = interface(ANCESTORNAME)
  ['GUID']
  procedure Clear;
  function ContainsKey(KEYCONSTKEYWORDKey: KEYTYPENAME): Boolean;
  function ContainsValue(VALUECONSTKEYWORDValue: VALUETYPENAME): Boolean;
  function Extract(KEYCONSTKEYWORDKey: KEYTYPENAME): VALUETYPENAME;
  function GetValue(KEYCONSTKEYWORDKey: KEYTYPENAME): VALUETYPENAME;
  function IsEmpty: Boolean;
  function KeyOfValue(VALUECONSTKEYWORDValue: VALUETYPENAME): KEYTYPENAME;
  function KeySet: KEYSETNAME;
  function MapEquals(const AMap: INTERFACENAME): Boolean;
  procedure PutAll(const AMap: INTERFACENAME);
  procedure PutValue(KEYCONSTKEYWORDKey: KEYTYPENAME; VALUECONSTKEYWORDValue: VALUETYPENAME);
  function Remove(KEYCONSTKEYWORDKey: KEYTYPENAME): VALUETYPENAME;
  function Size: Integer;
  function Values: VALUECOLLECTIONNAME;
  property Items[KEYCONSTKEYWORDKey: KEYTYPENAME]: VALUETYPENAME read GetValue write PutValue;
    {$IFNDEF BUGGY_DEFAULT_INDEXED_PROP} default; {$ENDIF ~BUGGY_DEFAULT_INDEXED_PROP}
end;*)
(*$JPPDEFINEMACRO QUEUE(INTERFACENAME, ANCESTORNAME, GUID, CONSTKEYWORD, PARAMETERNAME, TYPENAME)
INTERFACENAME = interface(ANCESTORNAME)
  ['GUID']
  procedure Clear;
  function Contains(CONSTKEYWORDPARAMETERNAME: TYPENAME): Boolean;
  function Dequeue: TYPENAME;
  function Empty: Boolean;
  function Enqueue(CONSTKEYWORDPARAMETERNAME: TYPENAME): Boolean;
  function Peek: TYPENAME;
  function Size: Integer;
end;*)
(*$JPPDEFINEMACRO SORTEDMAP(INTERFACENAME, ANCESTORNAME, GUID, KEYCONSTKEYWORD, KEYTYPENAME)
INTERFACENAME = interface(ANCESTORNAME)
  ['GUID']
  function FirstKey: KEYTYPENAME;
  function HeadMap(KEYCONSTKEYWORDToKey: KEYTYPENAME): INTERFACENAME;
  function LastKey: KEYTYPENAME;
  function SubMap(KEYCONSTKEYWORDFromKey, ToKey: KEYTYPENAME): INTERFACENAME;
  function TailMap(KEYCONSTKEYWORDFromKey: KEYTYPENAME): INTERFACENAME;
end;*)
(*$JPPDEFINEMACRO SORTEDSET(INTERFACENAME, ANCESTORNAME, GUID, CONSTKEYWORD, TYPENAME)
INTERFACENAME = interface(ANCESTORNAME)
  ['GUID']
  function HeadSet(CONSTKEYWORDFinish: TYPENAME): INTERFACENAME;
  function SubSet(CONSTKEYWORDStart, Finish: TYPENAME): INTERFACENAME;
  function TailSet(CONSTKEYWORDStart: TYPENAME): INTERFACENAME;
end;*)
(*$JPPDEFINEMACRO STACK(INTERFACENAME, ANCESTORNAME, GUID, CONSTKEYWORD, PARAMETERNAME, TYPENAME)
INTERFACENAME = interface(ANCESTORNAME)
  ['GUID']
  procedure Clear;
  function Contains(CONSTKEYWORDPARAMETERNAME: TYPENAME): Boolean;
  function Empty: Boolean;
  function Peek: TYPENAME;
  function Pop: TYPENAME;
  function Push(CONSTKEYWORDPARAMETERNAME: TYPENAME): Boolean;
  function Size: Integer;
end;*)

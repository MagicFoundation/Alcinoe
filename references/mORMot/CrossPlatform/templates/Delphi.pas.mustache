/// remote access to a mORMot server using mORMot units
{{#uri}}
// - retrieved from http://{{host}}/{{uri}}
// at {{time}} using "{{templateName}}" template
{{/uri}}
{{^uri}}
// - generated at {{time}}
{{/uri}}
unit {{fileName}};

{
  WARNING:
    This unit has been generated by a mORMot {{mORMotVersion}} server.
    Any manual modification of this file may be lost after regeneration.

  Synopse mORMot framework. Copyright (C) {{year}} Arnaud Bouchez
    Synopse Informatique - http://synopse.info

  This unit is released under a MPL/GPL/LGPL tri-license,
  and therefore may be freely included in any application.

  This unit would work on Delphi 6 and later, under Win32 and Win64 platforms,
  and with FPC 2.7/trunk revision, under Win32 and Linux32.
}

interface

uses
  SynCommons,
  mORMot;
{{! recursive partials used to write records type definition}}
{{<writerec}}packed record
{{#fields}}
{{nestedIdentation}}    {{propName}}: {{#typeDelphi}}{{typeDelphi}};{{/typeDelphi}}{{#nestedRecord}}{{>writerec}}{{nestedIdentation}}    end;{{/nestedRecord}}{{#nestedSimpleArray}}array of {{typeDelphi}};{{/nestedSimpleArray}}{{#nestedRecordArray}}array of {{>writerec}}{{nestedIdentation}}    end;{{/nestedRecordArray}}
{{/fields}}{{/writerec}}
{{<textrec}}{{#fields}}{{propName}} {{#typeDelphi}}{{typeDelphi}}{{/typeDelphi}}{{#nestedRecord}}{ {{>textrec}} }{{/nestedRecord}}{{#nestedSimpleArray}}array of {{typeDelphi}}{{/nestedSimpleArray}}{{#nestedRecordArray}}[ {{>textrec}} ]{{/nestedRecordArray}} {{/fields}}{{/textrec}}
{{#withEnumerates}}
type // define some enumeration types, used below
{{#enumerates}}
  {{name}} = ({{#values}}{{.}}{{^-last}}, {{/-last}}{{/values}});
{{/enumerates}}

{{/withEnumerates}}
{{#withSets}}
type // define some set types, used below
{{#sets}}
  {{name}} = set of({{#values}}{{.}}{{^-last}}, {{/-last}}{{/values}});
{{/sets}}

{{/withSets}}
{{#withRecords}}
type // define some record types, used as properties below
{{#records}}
  {{name}} = {{>writerec}}  end;

{{/records}}
{{/withRecords}}
{{#withArrays}}
type // define some dynamic array types, used as properties below
{{#arrays}}
  {{name}} = array of {{typeSource}};
{{/arrays}}

{{/withArrays}}
{{<method}}{{verb}} {{methodName}}({{#args}}{{^dirResult}}{{dirName}} {{argName}}: {{typeDelphi}}{{commaArg}}{{/dirResult}}{{/args}}){{#args}}{{#dirResult}}: {{typeDelphi}}{{/dirResult}}{{/args}};{{/method}}
type
  {{#orm}}
  {{^isInMormotPas}}
  /// map "{{tableName}}" table
  {{className}} = class({{classParent}})
  protected
    {{#fields}}
    f{{name}}: {{typeDelphi}}; 
    {{/fields}}
  {{#hasRecords}}
  public
    class procedure InternalRegisterCustomProperties(Props: TSQLRecordProperties); override;
    {{#fields}}
    {{#isrecord}}
    property {{name}}: {{typeDelphi}} read f{{name}} write f{{name}}{{#unique}} stored AS_UNIQUE{{/unique}};
    {{/isrecord}}
    {{/fields}}
  {{/hasRecords}}
  published
    {{#fields}}
    {{^isrecord}}
    property {{name}}: {{typeDelphi}}{{#width}} index {{width}}{{/width}} read f{{name}} write f{{name}}{{#unique}} stored AS_UNIQUE{{/unique}};
    {{/isrecord}}
    {{/fields}}
  end;
  
  {{/isInMormotPas}}
  {{/orm}}
  {{#soa.services}}
  /// service accessible {{#uri}}via http://{{host}}/{{root}}/{{uri}}{{/uri}}
  // - this service will run in sic{{instanceCreationName}} mode
  I{{interfaceURI}} = interface(IInvokable)
    ['{{GUID}}']
{{#methods}}
    {{>method}}
{{/methods}}
  end;

  {{/soa.services}}
  
/// return the database Model corresponding to this server
function GetModel: TSQLModel;

const
  /// the server port{{#uri}}, corresponding to http://{{host}}{{/uri}}
  SERVER_PORT = {{port}};


{{#soa.enabled}}
/// define the interface-based services to be consummed by the client
// - will define the following interfaces:
{{#soa.services}}
// ! I{{interfaceURI}}   sic{{instanceCreationName}}   {{GUID}}
{{/soa.services}}
procedure RegisterServices(Client: TSQLRestClientURI);
{{/soa.enabled}}


implementation

{{#orm}}
{{#hasRecords}}
{ {{className}} }

class procedure {{className}}.InternalRegisterCustomProperties(
  Props: TSQLRecordProperties);
begin
{{#fields}}
{{#isrecord}}
  Props.RegisterCustomPropertyFromRTTI(Self,TypeInfo({{typeDelphi}}),
    '{{name}}',@{{className}}(nil).f{{name}});
{{/isrecord}}
{{/fields}}
end;

{{/hasRecords}}
{{/orm}}

function GetModel: TSQLModel;
begin
  result := TSQLModel.Create([{{#orm}}{{className}}{{comma}}{{/orm}}],'{{root}}');
end;

{{#soa.enabled}}
procedure RegisterServices(Client: TSQLRestClientURI);
begin
{{#soa.services}}
  Client.ServiceRegister(TypeInfo(I{{interfaceURI}}),sic{{instanceCreationName}});
{{/soa.services}}
end;
{{/soa.enabled}}

{{#withRecords}}
const // text-based types definition for records and dynamic arrays
{{#records}}
  __{{name}} = '{{>textrec}}';
{{/records}}

initialization
{{#enumerates}}
  TTextWriter.RegisterCustomJSONSerializerFromTextSimpleType(
    TypeInfo({{name}}));
{{/enumerates}}
{{#records}}
  TTextWriter.RegisterCustomJSONSerializerFromText(
    TypeInfo({{name}}),__{{name}});
{{/records}}
{{/withRecords}}
end.
/// {{#units}}{{.}} {{/units}}generated types for a FPC mORMot server 
{{#uri}}
// - retrieved from http://{{host}}/{{uri}}
// at {{time}} using "{{templateName}}" template
{{/uri}}
{{^uri}}
// - generated at {{time}}
{{/uri}}
unit {{fileName}};

(*
  WARNING:
    This unit has been generated by a mORMot {{mORMotVersion}} server.
    Any manual modification of this file may be lost after regeneration.

  Synopse mORMot framework. Copyright (C) {{year}} Arnaud Bouchez
    Synopse Informatique - http://synopse.info

  This unit is released under a MPL/GPL/LGPL tri-license,
  and therefore may be freely included in any application.

  This unit is intended to work on older FPC compilers, which lack of RTTI
  for interfaces and records. As a result, you would be able to compile
  your server executable for hosting in Linux.

  It will also include RTTI for records for versions prior to Delphi 2010.
  
  USAGE:

  1. Compile your code using latest versions of Delphi (which supports
     record definition as published properties since XE5)

  2. Enumerations, sets, dynamic arrays and records type definitions
     would be shared from the original Delphi units

  3. Add a reference to this {{fileName}} unit to your uses clause, so that
     missing RTTI would be available for the following types:
{{#records}}
      - {{name}} record
{{/records}}
{{#soa.services}}
      - I{{interfaceURI}} interface
{{/soa.services}}
{{#ORMWithRecords}}

  4. Ensure there is a reference to {$I Synopse.inc} at the beginning of the following units:
{{#units}}
      - {{.}}.pas
{{/units}}
   
  5. Modify the following type definitions to include the information
     about record published properties:
{{#orm}}
{{#hasRecords}}

  {{className}} = class({{classParent}}) // in {{unitName}}.pas
  ...
  public
    {$ifndef PUBLISHRECORD} // defined in Synopse.inc
    class procedure InternalRegisterCustomProperties(Props: TSQLRecordProperties); override;   
    {$endif}
  ...
  
{$ifndef PUBLISHRECORD}
class procedure {{className}}.InternalRegisterCustomProperties(Props: TSQLRecordProperties);
begin
{{#fields}}
{{#isrecord}}
  Props.RegisterCustomPropertyFromRTTI(Self,TypeInfo({{typeDelphi}}),
    '{{name}}',@{{className}}(nil).f{{name}});
{{/isrecord}}
{{/fields}}
end;
{$endif} 
{{/hasRecords}}
{{/orm}}
{{/ORMWithRecords}}  
*)

interface

{$I Synopse.inc} // needed for setting HASINTERFACERTTI and proper FPC modes

uses
  SysUtils,
  Classes,
  SynCommons,
  mORMot,
  mORMotDDD{{#units}},
  {{.}}{{/units}};


implementation

{$ifndef HASINTERFACERTTI} // circumvent a old FPC bug
{{#soa.enabled}}

{ TInterfaceFactoryDefinition }

type
  /// define and manage missing interface RTTI for defined interfaces
  TInterfaceFactoryDefinition = class(TInterfaceFactoryGenerated)
  protected
    /// will declare the following types to the interface factory:
{{#soa.services}}
    // - I{{interfaceURI}}
{{/soa.services}}
    procedure AddMethodsFromTypeInfo(aInterface: PTypeInfo); override;
  end;

procedure TInterfaceFactoryDefinition.AddMethodsFromTypeInfo(aInterface: PTypeInfo);
begin
{{#soa.services}}
  if aInterface=TypeInfo(I{{interfaceURI}}) then begin
{{#methods}}
    AddMethod('{{methodName}}',[
{{#args}}      ord(smd{{dirName}}),'{{argName}}',TypeInfo({{typeSource}}){{#isArgLast}}]);{{/isArgLast}}{{^isArgLast}},
{{/isArgLast}}{{/args}}
{{/methods}}
    exit;
  end;
{{/soa.services}}
end;

{$endif HASINTERFACERTTI}
{{/soa.enabled}}
{{#withRecords}}
{{<textrec}}{{#fields}}{{propName}} {{#typeDelphi}}{{typeDelphi}}{{/typeDelphi}}{{#nestedRecord}}{ {{>textrec}} }{{/nestedRecord}}{{#nestedSimpleArray}}array of {{typeDelphi}}{{/nestedSimpleArray}}{{#nestedRecordArray}}[ {{>textrec}} ]{{/nestedRecordArray}} {{/fields}}{{/textrec}}

{$ifndef ISDELPHI2010}

const // text-based types definition for records and dynamic arrays
{{#records}}
  __{{name}} = '{{>textrec}}';
{{/records}}

{{/withRecords}}
initialization
{{#enumerates}}
  TTextWriter.RegisterCustomJSONSerializerFromTextSimpleType(
    TypeInfo({{name}}));
{{/enumerates}}
{{#records}}
  TTextWriter.RegisterCustomJSONSerializerFromText(
    TypeInfo({{name}}),__{{name}});
{{/records}}
{{#soa.enabled}}
{$ifndef HASINTERFACERTTI} // circumvent a old FPC bug
{{#soa.services}}
  TInterfaceFactoryDefinition.RegisterInterface(
    TypeInfo(I{{interfaceURI}}));
{{/soa.services}}
{$endif HASINTERFACERTTI}
{{/soa.enabled}}

{$endif ISDELPHI2010}
end.
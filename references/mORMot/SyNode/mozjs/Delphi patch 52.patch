# HG changeset patch
# User Vadim.Orel@gmail.com
# Date 1489584287 -7200
#      Wed Mar 15 15:24:47 2017 +0200
# Node ID 450090eb5719b1fc676082229bf26a5d498c8041
# Parent  ce1a4a27b63bf41158f526d713c2d8029f291a81
Add delphi compatibility

diff -r ce1a4a27b63b -r 450090eb5719 js/public/Initialization.h
--- a/js/public/Initialization.h	Mon Mar 06 07:39:32 2017 -0800
+++ b/js/public/Initialization.h	Wed Mar 15 15:24:47 2017 +0200
@@ -119,7 +119,7 @@
  * is, calling JS_Init/JSAPI methods/JS_ShutDown in that order, then doing so
  * again).  This restriction may eventually be lifted.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ShutDown(void);
 
 #endif /* js_Initialization_h */
diff -r ce1a4a27b63b -r 450090eb5719 js/src/jsapi.cpp
--- a/js/src/jsapi.cpp	Mon Mar 06 07:39:32 2017 -0800
+++ b/js/src/jsapi.cpp	Wed Mar 15 15:24:47 2017 +0200
@@ -6807,3 +6807,152 @@
 {
     return cx->stackFormat();
 }
+///////////////Orel added
+
+JS_PUBLIC_API(JSObject*)
+JS_NewDateObjectMsec(JSContext* cx, double msec)
+{
+	AssertHeapIsIdle(cx);
+	CHECK_REQUEST(cx);
+	JS::ClippedTime time = JS::TimeClip(msec);
+	return NewDateObjectMsec(cx, time);
+}
+
+JS_PUBLIC_API(void*)
+JS_NewRootedValue(JSContext* cx, uint64_t initial)
+{
+	return js_new<JS::RootedValue>(cx, JS::Value::fromRawBits(initial));
+}
+
+JS_PUBLIC_API(void)
+JS_FreeRooteValue(void* val)
+{
+	js_delete(reinterpret_cast<JS::RootedValue*>(val));
+}
+
+JS_PUBLIC_API(void*)
+JS_NewRootedObject(JSContext* cx, JSObject* initial)
+{
+	return js_new<JS::RootedObject>(cx, initial);
+}
+
+JS_PUBLIC_API(void)
+JS_FreeRootedObject(void* obj)
+{
+	js_delete(reinterpret_cast<JS::RootedObject*>(obj));
+}
+
+JS_PUBLIC_API(void*)
+JS_NewRootedString(JSContext* cx, JSString* initial)
+{
+	return js_new<JS::RootedString>(cx, initial);
+}
+
+JS_PUBLIC_API(void)
+JS_FreeRootedString(void* str)
+{
+	js_delete(reinterpret_cast<JS::RootedString*>(str));
+}
+
+
+JS_PUBLIC_API(void*)
+JS_NewCompileOptions(JSContext* cx)
+{
+	return js_new<JS::CompileOptions>(cx);
+}
+
+JS_PUBLIC_API(void)
+JS_FreeCompileOptions(void* co)
+{
+	js_delete(reinterpret_cast<JS::CompileOptions*>(co));
+}
+
+JS_PUBLIC_API(void*)
+JS_NewCompartmentOptions()
+{
+	return js_new<JS::CompartmentOptions>();
+}
+
+JS_PUBLIC_API(void)
+JS_FreeCompartmentOptions(void* opt)
+{
+	js_delete(reinterpret_cast<JS::CompartmentOptions*>(opt));
+}
+
+JS_PUBLIC_API(void*)
+JS_NewAutoCheckCannotGC()
+{
+	return js_new<JS::AutoCheckCannotGC>();
+}
+
+JS_PUBLIC_API(void)
+JS_FreeAutoCheckCannotGC(void* ac)
+{
+	js_delete(reinterpret_cast<JS::AutoCheckCannotGC*>(ac));
+}
+
+JS_PUBLIC_API(void*)
+JS_GetContextOptions(JSContext* cx)
+{
+	return &JS::ContextOptionsRef(cx);
+}
+
+JS_PUBLIC_API(bool)
+JS_EvaluateScript(JSContext* cx, const JS::CompileOptions& options,
+	const char* bytes, size_t length, JS::MutableHandleValue rval)
+{
+	return JS::Evaluate(cx, options, bytes, length, rval);
+}
+
+JS_PUBLIC_API(bool)
+JS_EvaluateUCScript(JSContext* cx, const JS::CompileOptions& options,
+	const char16_t* chars, size_t length, JS::MutableHandleValue rval)
+{
+	return JS::Evaluate(cx, options, chars, length, rval);
+}
+
+JS_PUBLIC_API(JSObject*)
+JS_NewArrayObject2(JSContext* cx, const JS::HandleValueArray& contents)
+{
+	return JS_NewArrayObject(cx, contents);
+}
+
+JS_PUBLIC_API(bool)
+JS_InitModuleClasses(JSContext* cx, HandleObject obj)
+{
+	//return js::InitModuleClasses(cx, obj);
+	return true;
+}
+
+JS_PUBLIC_API(JSObject*)
+JS_CompileModule(JSContext* cx, HandleObject obj, JS::CompileOptions& options,
+	const char16_t* chars, size_t length)
+{
+	SourceBufferHolder srcBuf(chars, length, SourceBufferHolder::NoOwnership);
+	return frontend::CompileModule(cx, options, srcBuf);
+}
+
+JS_PUBLIC_API(void)
+JS_SetModuleResolveHook(JSContext* cx, HandleFunction hook)
+{
+	Rooted<GlobalObject*> global(cx, cx->global());
+	global->setModuleResolveHook(hook);
+}
+
+JS_PUBLIC_API(JS::Value)
+JS_ComputeThis(JSContext* cx, JS::Value* vp)
+{
+	return JS::detail::ComputeThis(cx, vp);
+}
+
+JS_PUBLIC_API(bool)
+JS_Initialize(void)
+{
+	return JS_Init();
+}
+
+JS_PUBLIC_API(uint64_t)
+JS_GetReservedSlot1(JSObject* obj, uint32_t index)
+{
+	return obj->as<NativeObject>().getReservedSlot(index).asRawBits();
+}
diff -r ce1a4a27b63b -r 450090eb5719 js/src/jsapi.h
--- a/js/src/jsapi.h	Mon Mar 06 07:39:32 2017 -0800
+++ b/js/src/jsapi.h	Wed Mar 15 15:24:47 2017 +0200
@@ -915,41 +915,41 @@
                                             from script. */
 
 /** Microseconds since the epoch, midnight, January 1, 1970 UTC. */
-extern JS_PUBLIC_API(int64_t)
+extern "C" JS_PUBLIC_API(int64_t)
 JS_Now(void);
 
 /** Don't want to export data, so provide accessors for non-inline Values. */
-extern JS_PUBLIC_API(JS::Value)
+extern "C" JS_PUBLIC_API(JS::Value)
 JS_GetNaNValue(JSContext* cx);
 
-extern JS_PUBLIC_API(JS::Value)
+extern "C" JS_PUBLIC_API(JS::Value)
 JS_GetNegativeInfinityValue(JSContext* cx);
 
-extern JS_PUBLIC_API(JS::Value)
+extern "C" JS_PUBLIC_API(JS::Value)
 JS_GetPositiveInfinityValue(JSContext* cx);
 
-extern JS_PUBLIC_API(JS::Value)
+extern "C" JS_PUBLIC_API(JS::Value)
 JS_GetEmptyStringValue(JSContext* cx);
 
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_GetEmptyString(JSContext* cx);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_ValueToObject(JSContext* cx, JS::HandleValue v, JS::MutableHandleObject objp);
 
-extern JS_PUBLIC_API(JSFunction*)
+extern "C" JS_PUBLIC_API(JSFunction*)
 JS_ValueToFunction(JSContext* cx, JS::HandleValue v);
 
-extern JS_PUBLIC_API(JSFunction*)
+extern "C" JS_PUBLIC_API(JSFunction*)
 JS_ValueToConstructor(JSContext* cx, JS::HandleValue v);
 
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_ValueToSource(JSContext* cx, JS::Handle<JS::Value> v);
 
 extern JS_PUBLIC_API(bool)
 JS_DoubleIsInt32(double d, int32_t* ip);
 
-extern JS_PUBLIC_API(JSType)
+extern "C" JS_PUBLIC_API(JSType)
 JS_TypeOfValue(JSContext* cx, JS::Handle<JS::Value> v);
 
 namespace JS {
@@ -959,21 +959,21 @@
 
 } /* namespace JS */
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_StrictlyEqual(JSContext* cx, JS::Handle<JS::Value> v1, JS::Handle<JS::Value> v2, bool* equal);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_LooselyEqual(JSContext* cx, JS::Handle<JS::Value> v1, JS::Handle<JS::Value> v2, bool* equal);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_SameValue(JSContext* cx, JS::Handle<JS::Value> v1, JS::Handle<JS::Value> v2, bool* same);
 
 /** True iff fun is the global eval function. */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_IsBuiltinEvalFunction(JSFunction* fun);
 
 /** True iff fun is the Function constructor. */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_IsBuiltinFunctionConstructor(JSFunction* fun);
 
 /************************************************************************/
@@ -987,12 +987,12 @@
  * See: http://developer.mozilla.org/en/docs/Category:JSAPI_Reference
  */
 
-extern JS_PUBLIC_API(JSContext*)
+extern "C" JS_PUBLIC_API(JSContext*)
 JS_NewContext(uint32_t maxbytes,
               uint32_t maxNurseryBytes = JS::DefaultNurseryBytes,
               JSContext* parentContext = nullptr);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_DestroyContext(JSContext* cx);
 
 typedef double (*JS_CurrentEmbedderTimeFunction)();
@@ -1014,22 +1014,22 @@
 JS_PUBLIC_API(double)
 JS_GetCurrentEmbedderTime();
 
-JS_PUBLIC_API(void*)
+extern "C" JS_PUBLIC_API(void*)
 JS_GetContextPrivate(JSContext* cx);
 
-JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetContextPrivate(JSContext* cx, void* data);
 
-extern JS_PUBLIC_API(JSContext*)
+extern "C" JS_PUBLIC_API(JSContext*)
 JS_GetParentContext(JSContext* cx);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_BeginRequest(JSContext* cx);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_EndRequest(JSContext* cx);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetFutexCanWait(JSContext* cx);
 
 namespace js {
@@ -1064,7 +1064,7 @@
 #endif
 };
 
-extern JS_PUBLIC_API(JSVersion)
+extern "C" JS_PUBLIC_API(JSVersion)
 JS_GetVersion(JSContext* cx);
 
 /**
@@ -1078,10 +1078,10 @@
 JS_PUBLIC_API(void)
 JS_SetVersionForCompartment(JSCompartment* compartment, JSVersion version);
 
-extern JS_PUBLIC_API(const char*)
+extern "C" JS_PUBLIC_API(const char*)
 JS_VersionToString(JSVersion version);
 
-extern JS_PUBLIC_API(JSVersion)
+extern "C" JS_PUBLIC_API(JSVersion)
 JS_StringToVersion(const char* string);
 
 namespace JS {
@@ -1251,7 +1251,7 @@
  * exactly once per runtime/context, before the first JS_NewGlobalObject
  * call.
  */
-JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 InitSelfHostedCode(JSContext* cx);
 
 /**
@@ -1263,50 +1263,50 @@
 
 } /* namespace JS */
 
-extern JS_PUBLIC_API(const char*)
+extern "C" JS_PUBLIC_API(const char*)
 JS_GetImplementationVersion(void);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetDestroyCompartmentCallback(JSContext* cx, JSDestroyCompartmentCallback callback);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetSizeOfIncludingThisCompartmentCallback(JSContext* cx,
                                              JSSizeOfIncludingThisCompartmentCallback callback);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetDestroyZoneCallback(JSContext* cx, JSZoneCallback callback);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetSweepZoneCallback(JSContext* cx, JSZoneCallback callback);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetCompartmentNameCallback(JSContext* cx, JSCompartmentNameCallback callback);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetWrapObjectCallbacks(JSContext* cx, const JSWrapObjectCallbacks* callbacks);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetCompartmentPrivate(JSCompartment* compartment, void* data);
 
-extern JS_PUBLIC_API(void*)
+extern "C" JS_PUBLIC_API(void*)
 JS_GetCompartmentPrivate(JSCompartment* compartment);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetZoneUserData(JS::Zone* zone, void* data);
 
-extern JS_PUBLIC_API(void*)
+extern "C" JS_PUBLIC_API(void*)
 JS_GetZoneUserData(JS::Zone* zone);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_WrapObject(JSContext* cx, JS::MutableHandleObject objp);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_WrapValue(JSContext* cx, JS::MutableHandleValue vp);
 
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_TransplantObject(JSContext* cx, JS::HandleObject origobj, JS::HandleObject target);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_RefreshCrossCompartmentWrappers(JSContext* cx, JS::Handle<JSObject*> obj);
 
 /*
@@ -1371,10 +1371,10 @@
 };
 
 /** NB: This API is infallible; a nullptr return value does not indicate error. */
-extern JS_PUBLIC_API(JSCompartment*)
+extern "C" JS_PUBLIC_API(JSCompartment*)
 JS_EnterCompartment(JSContext* cx, JSObject* target);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_LeaveCompartment(JSContext* cx, JSCompartment* oldCompartment);
 
 typedef void (*JSIterateCompartmentCallback)(JSContext* cx, void* data, JSCompartment* compartment);
@@ -1384,7 +1384,7 @@
  * there is no guarantee that the compartment will survive after the callback
  * returns. Also, barriers are disabled via the TraceSession.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_IterateCompartments(JSContext* cx, void* data,
                        JSIterateCompartmentCallback compartmentCallback);
 
@@ -1395,7 +1395,7 @@
  *
  * NB: This sets cx's global object to obj if it was null.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_InitStandardClasses(JSContext* cx, JS::Handle<JSObject*> obj);
 
 /**
@@ -1411,19 +1411,19 @@
  * JS_EnumerateStandardClasses(cx, obj), to define eagerly during for..in
  * loops any classes not yet resolved lazily.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_ResolveStandardClass(JSContext* cx, JS::HandleObject obj, JS::HandleId id, bool* resolved);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_MayResolveStandardClass(const JSAtomState& names, jsid id, JSObject* maybeObj);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_EnumerateStandardClasses(JSContext* cx, JS::HandleObject obj);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_GetClassObject(JSContext* cx, JSProtoKey key, JS::MutableHandle<JSObject*> objp);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_GetClassPrototype(JSContext* cx, JSProtoKey key, JS::MutableHandle<JSObject*> objp);
 
 namespace JS {
@@ -1450,69 +1450,69 @@
 
 } /* namespace JS */
 
-extern JS_PUBLIC_API(JSProtoKey)
+extern "C" JS_PUBLIC_API(JSProtoKey)
 JS_IdToProtoKey(JSContext* cx, JS::HandleId id);
 
 /**
  * Returns the original value of |Function.prototype| from the global object in
  * which |forObj| was created.
  */
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_GetFunctionPrototype(JSContext* cx, JS::HandleObject forObj);
 
 /**
  * Returns the original value of |Object.prototype| from the global object in
  * which |forObj| was created.
  */
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_GetObjectPrototype(JSContext* cx, JS::HandleObject forObj);
 
 /**
  * Returns the original value of |Array.prototype| from the global object in
  * which |forObj| was created.
  */
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_GetArrayPrototype(JSContext* cx, JS::HandleObject forObj);
 
 /**
  * Returns the original value of |Error.prototype| from the global
  * object of the current compartment of cx.
  */
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_GetErrorPrototype(JSContext* cx);
 
 /**
  * Returns the %IteratorPrototype% object that all built-in iterator prototype
  * chains go through for the global object of the current compartment of cx.
  */
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_GetIteratorPrototype(JSContext* cx);
 
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_GetGlobalForObject(JSContext* cx, JSObject* obj);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_IsGlobalObject(JSObject* obj);
 
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_GlobalLexicalEnvironment(JSObject* obj);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_HasExtensibleLexicalEnvironment(JSObject* obj);
 
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_ExtensibleLexicalEnvironment(JSObject* obj);
 
 /**
  * May return nullptr, if |c| never had a global (e.g. the atoms compartment),
  * or if |c|'s global has been collected.
  */
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_GetGlobalForCompartmentOrNull(JSContext* cx, JSCompartment* c);
 
 namespace JS {
 
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 CurrentGlobalOrNull(JSContext* cx);
 
 } // namespace JS
@@ -1521,18 +1521,18 @@
  * Add 'Reflect.parse', a SpiderMonkey extension, to the Reflect object on the
  * given global.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_InitReflectParse(JSContext* cx, JS::HandleObject global);
 
 /**
  * Add various profiling-related functions as properties of the given object.
  * Defined in builtin/Profilers.cpp.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_DefineProfilingFunctions(JSContext* cx, JS::HandleObject obj);
 
 /* Defined in vm/Debugger.cpp. */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_DefineDebuggerObject(JSContext* cx, JS::HandleObject obj);
 
 #ifdef JS_HAS_CTYPES
@@ -1540,7 +1540,7 @@
  * Initialize the 'ctypes' object on a global variable 'obj'. The 'ctypes'
  * object will be sealed.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_InitCTypesClass(JSContext* cx, JS::HandleObject global);
 
 /**
@@ -1568,14 +1568,14 @@
  * may safely be altered after calling this function and without having
  * to call this function again.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetCTypesCallbacks(JSObject* ctypesObj, const JSCTypesCallbacks* callbacks);
 #endif
 
-extern JS_PUBLIC_API(void*)
+extern "C" JS_PUBLIC_API(void*)
 JS_malloc(JSContext* cx, size_t nbytes);
 
-extern JS_PUBLIC_API(void*)
+extern "C" JS_PUBLIC_API(void*)
 JS_realloc(JSContext* cx, void* p, size_t oldBytes, size_t newBytes);
 
 /**
@@ -1583,20 +1583,20 @@
  * performance optimization.
  * cx may be nullptr.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_free(JSContext* cx, void* p);
 
 /**
  * A wrapper for js_free(p) that may delay js_free(p) invocation as a
  * performance optimization as specified by the given JSFreeOp instance.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_freeop(JSFreeOp* fop, void* p);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_updateMallocCounter(JSContext* cx, size_t nbytes);
 
-extern JS_PUBLIC_API(char*)
+extern "C" JS_PUBLIC_API(char*)
 JS_strdup(JSContext* cx, const char* s);
 
 /**
@@ -1606,33 +1606,33 @@
  *          JS::TraceEdge whenever the root contains a traceable thing.
  * data:    the data argument to pass to each invocation of traceOp.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_AddExtraGCRootsTracer(JSContext* cx, JSTraceDataOp traceOp, void* data);
 
 /** Undo a call to JS_AddExtraGCRootsTracer. */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_RemoveExtraGCRootsTracer(JSContext* cx, JSTraceDataOp traceOp, void* data);
 
 /*
  * Garbage collector API.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_GC(JSContext* cx);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_MaybeGC(JSContext* cx);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetGCCallback(JSContext* cx, JSGCCallback cb, void* data);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetObjectsTenuredCallback(JSContext* cx, JSObjectsTenuredCallback cb,
                              void* data);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_AddFinalizeCallback(JSContext* cx, JSFinalizeCallback cb, void* data);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_RemoveFinalizeCallback(JSContext* cx, JSFinalizeCallback cb);
 
 /*
@@ -1669,23 +1669,23 @@
  * re-inserted with the correct hash.
  */
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_AddWeakPointerZoneGroupCallback(JSContext* cx, JSWeakPointerZoneGroupCallback cb, void* data);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_RemoveWeakPointerZoneGroupCallback(JSContext* cx, JSWeakPointerZoneGroupCallback cb);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_AddWeakPointerCompartmentCallback(JSContext* cx, JSWeakPointerCompartmentCallback cb,
                                      void* data);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_RemoveWeakPointerCompartmentCallback(JSContext* cx, JSWeakPointerCompartmentCallback cb);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_UpdateWeakPointerAfterGC(JS::Heap<JSObject*>* objp);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_UpdateWeakPointerAfterGCUnbarriered(JSObject** objp);
 
 typedef enum JSGCParamKey {
@@ -1765,20 +1765,20 @@
     JSGC_REFRESH_FRAME_SLICES_ENABLED = 24,
 } JSGCParamKey;
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetGCParameter(JSContext* cx, JSGCParamKey key, uint32_t value);
 
-extern JS_PUBLIC_API(uint32_t)
+extern "C" JS_PUBLIC_API(uint32_t)
 JS_GetGCParameter(JSContext* cx, JSGCParamKey key);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetGCParametersBasedOnAvailableMemory(JSContext* cx, uint32_t availMem);
 
 /**
  * Create a new JSString whose chars member refers to external memory, i.e.,
  * memory requiring application-specific finalization.
  */
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_NewExternalString(JSContext* cx, const char16_t* chars, size_t length,
                      const JSStringFinalizer* fin);
 
@@ -1786,13 +1786,13 @@
  * Return whether 'str' was created with JS_NewExternalString or
  * JS_NewExternalStringWithClosure.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_IsExternalString(JSString* str);
 
 /**
  * Return the 'fin' arg passed to JS_NewExternalString.
  */
-extern JS_PUBLIC_API(const JSStringFinalizer*)
+extern "C" JS_PUBLIC_API(const JSStringFinalizer*)
 JS_GetExternalStringFinalizer(JSString* str);
 
 /**
@@ -1813,20 +1813,20 @@
  * This function may only be called immediately after the runtime is initialized
  * and before any code is executed and/or interrupts requested.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetNativeStackQuota(JSContext* cx, size_t systemCodeStackSize,
                        size_t trustedScriptStackSize = 0,
                        size_t untrustedScriptStackSize = 0);
 
 /************************************************************************/
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_ValueToId(JSContext* cx, JS::HandleValue v, JS::MutableHandleId idp);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_StringToId(JSContext* cx, JS::HandleString s, JS::MutableHandleId idp);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_IdToValue(JSContext* cx, jsid id, JS::MutableHandle<JS::Value> vp);
 
 namespace JS {
@@ -1855,11 +1855,11 @@
 
 } /* namespace JS */
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_PropertyStub(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                 JS::MutableHandleValue vp);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_StrictPropertyStub(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                       JS::MutableHandleValue vp, JS::ObjectOpResult& result);
 
@@ -2114,7 +2114,7 @@
 #define JS_FNSPEC(name,call,info,nargs,flags,selfHostedName)                  \
     {name, {call, info}, nargs, flags, selfHostedName}
 
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_InitClass(JSContext* cx, JS::HandleObject obj, JS::HandleObject parent_proto,
              const JSClass* clasp, JSNative constructor, unsigned nargs,
              const JSPropertySpec* ps, const JSFunctionSpec* fs,
@@ -2124,17 +2124,17 @@
  * Set up ctor.prototype = proto and proto.constructor = ctor with the
  * right property flags.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_LinkConstructorAndPrototype(JSContext* cx, JS::Handle<JSObject*> ctor,
                                JS::Handle<JSObject*> proto);
 
-extern JS_PUBLIC_API(const JSClass*)
+extern "C" JS_PUBLIC_API(const JSClass*)
 JS_GetClass(JSObject* obj);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_InstanceOf(JSContext* cx, JS::Handle<JSObject*> obj, const JSClass* clasp, JS::CallArgs* args);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_HasInstance(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<JS::Value> v, bool* bp);
 
 namespace JS {
@@ -2148,17 +2148,17 @@
 
 } // namespace JS
 
-extern JS_PUBLIC_API(void*)
+extern "C" JS_PUBLIC_API(void*)
 JS_GetPrivate(JSObject* obj);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetPrivate(JSObject* obj, void* data);
 
-extern JS_PUBLIC_API(void*)
+extern "C" JS_PUBLIC_API(void*)
 JS_GetInstancePrivate(JSContext* cx, JS::Handle<JSObject*> obj, const JSClass* clasp,
                       JS::CallArgs* args);
 
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_GetConstructor(JSContext* cx, JS::Handle<JSObject*> proto);
 
 namespace JS {
@@ -2456,7 +2456,7 @@
 
 } /* namespace JS */
 
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_NewGlobalObject(JSContext* cx, const JSClass* clasp, JSPrincipals* principals,
                    JS::OnNewGlobalHookOption hookOption,
                    const JS::CompartmentOptions& options);
@@ -2469,27 +2469,27 @@
  * It is still possible to specify custom trace hooks for global object classes. They can be
  * provided via the CompartmentOptions passed to JS_NewGlobalObject.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_GlobalObjectTraceHook(JSTracer* trc, JSObject* global);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_FireOnNewGlobalObject(JSContext* cx, JS::HandleObject global);
 
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_NewObject(JSContext* cx, const JSClass* clasp);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_IsNative(JSObject* obj);
 
 /**
  * Unlike JS_NewObject, JS_NewObjectWithGivenProto does not compute a default
  * proto. If proto is nullptr, the JS object will have `null` as [[Prototype]].
  */
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_NewObjectWithGivenProto(JSContext* cx, const JSClass* clasp, JS::Handle<JSObject*> proto);
 
 /** Creates a new plain object, like `new Object()`, with Object.prototype as [[Prototype]]. */
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_NewPlainObject(JSContext* cx);
 
 /**
@@ -2497,13 +2497,13 @@
  * through non-extensible objects, on the assumption that those are already
  * deep-frozen.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_DeepFreezeObject(JSContext* cx, JS::Handle<JSObject*> obj);
 
 /**
  * Freezes an object; see ES5's Object.freeze(obj) method.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_FreezeObject(JSContext* cx, JS::Handle<JSObject*> obj);
 
 
@@ -2831,7 +2831,7 @@
  *
  * Implements: ES6 [[GetPrototypeOf]] internal method.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_GetPrototype(JSContext* cx, JS::HandleObject obj, JS::MutableHandleObject result);
 
 /**
@@ -2841,7 +2841,7 @@
  * in |result|.  Otherwise set |*isOrdinary = false|.  In case of error, both
  * outparams have unspecified value.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_GetPrototypeIfOrdinary(JSContext* cx, JS::HandleObject obj, bool* isOrdinary,
                           JS::MutableHandleObject result);
 
@@ -2858,7 +2858,7 @@
  * all other objects in the same "group" as obj to be permanently deoptimized.
  * It's better to create the object with the right prototype from the start.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_SetPrototype(JSContext* cx, JS::HandleObject obj, JS::HandleObject proto);
 
 /**
@@ -2868,7 +2868,7 @@
  *
  * Implements: ES6 [[IsExtensible]] internal method.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_IsExtensible(JSContext* cx, JS::HandleObject obj, bool* extensible);
 
 /**
@@ -2879,7 +2879,7 @@
  *
  * Implements: ES6 [[PreventExtensions]] internal method.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_PreventExtensions(JSContext* cx, JS::HandleObject obj, JS::ObjectOpResult& result);
 
 /**
@@ -2891,7 +2891,7 @@
  *
  * This is a nonstandard internal method.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_SetImmutablePrototype(JSContext* cx, JS::HandleObject obj, bool* succeeded);
 
 /**
@@ -2900,15 +2900,15 @@
  *
  * Implements: ES6 [[GetOwnProperty]] internal method.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_GetOwnPropertyDescriptorById(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                                 JS::MutableHandle<JS::PropertyDescriptor> desc);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_GetOwnPropertyDescriptor(JSContext* cx, JS::HandleObject obj, const char* name,
                             JS::MutableHandle<JS::PropertyDescriptor> desc);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_GetOwnUCPropertyDescriptor(JSContext* cx, JS::HandleObject obj, const char16_t* name,
                               JS::MutableHandle<JS::PropertyDescriptor> desc);
 
@@ -2918,11 +2918,11 @@
  * property is found is returned in desc.object(). If the property is not found
  * on the prototype chain, this returns true with desc.object() set to null.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_GetPropertyDescriptorById(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                              JS::MutableHandle<JS::PropertyDescriptor> desc);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_GetPropertyDescriptor(JSContext* cx, JS::HandleObject obj, const char* name,
                          JS::MutableHandle<JS::PropertyDescriptor> desc);
 
@@ -2950,7 +2950,7 @@
 JS_DefinePropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                       JS::Handle<JS::PropertyDescriptor> desc);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_DefinePropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id, JS::HandleValue value,
                       unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);
 
@@ -2974,7 +2974,7 @@
 JS_DefinePropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id, double value,
                       unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_DefineProperty(JSContext* cx, JS::HandleObject obj, const char* name, JS::HandleValue value,
                   unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);
 
@@ -3007,7 +3007,7 @@
 JS_DefineUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
                     JS::Handle<JS::PropertyDescriptor> desc);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_DefineUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
                     JS::HandleValue value, unsigned attrs,
                     JSNative getter = nullptr, JSNative setter = nullptr);
@@ -3037,7 +3037,7 @@
                     double value, unsigned attrs,
                     JSNative getter = nullptr, JSNative setter = nullptr);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_DefineElement(JSContext* cx, JS::HandleObject obj, uint32_t index, JS::HandleValue value,
                  unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);
 
@@ -3070,17 +3070,17 @@
  *
  * Implements: ES6 [[Has]] internal method.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_HasPropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id, bool* foundp);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_HasProperty(JSContext* cx, JS::HandleObject obj, const char* name, bool* foundp);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_HasUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
                  bool* vp);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_HasElement(JSContext* cx, JS::HandleObject obj, uint32_t index, bool* foundp);
 
 /**
@@ -3088,10 +3088,10 @@
  *
  * Implements: ES6 7.3.11 HasOwnProperty(O, P).
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_HasOwnPropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id, bool* foundp);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_HasOwnProperty(JSContext* cx, JS::HandleObject obj, const char* name, bool* foundp);
 
 /**
@@ -3105,11 +3105,11 @@
  *
  * Implements: ES6 [[Get]] internal method.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_ForwardGetPropertyTo(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                         JS::HandleValue receiver, JS::MutableHandleValue vp);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_ForwardGetElementTo(JSContext* cx, JS::HandleObject obj, uint32_t index,
                        JS::HandleObject receiver, JS::MutableHandleValue vp);
 
@@ -3119,18 +3119,18 @@
  *
  * Implements: ES6 7.3.1 Get(O, P).
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_GetPropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                    JS::MutableHandleValue vp);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_GetProperty(JSContext* cx, JS::HandleObject obj, const char* name, JS::MutableHandleValue vp);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_GetUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
                  JS::MutableHandleValue vp);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_GetElement(JSContext* cx, JS::HandleObject obj, uint32_t index, JS::MutableHandleValue vp);
 
 /**
@@ -3141,7 +3141,7 @@
  *
  * Implements: ES6 [[Set]] internal method.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_ForwardSetPropertyTo(JSContext* cx, JS::HandleObject obj, JS::HandleId id, JS::HandleValue v,
                         JS::HandleValue receiver, JS::ObjectOpResult& result);
 
@@ -3151,17 +3151,17 @@
  * This function performs non-strict assignment, so if the property is
  * read-only, nothing happens and no error is thrown.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_SetPropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id, JS::HandleValue v);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_SetProperty(JSContext* cx, JS::HandleObject obj, const char* name, JS::HandleValue v);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_SetUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
                  JS::HandleValue v);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_SetElement(JSContext* cx, JS::HandleObject obj, uint32_t index, JS::HandleValue v);
 
 extern JS_PUBLIC_API(bool)
@@ -3190,19 +3190,19 @@
  *
  * Implements: ES6 [[Delete]] internal method.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_DeletePropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                       JS::ObjectOpResult& result);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_DeleteProperty(JSContext* cx, JS::HandleObject obj, const char* name,
                   JS::ObjectOpResult& result);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_DeleteUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
                     JS::ObjectOpResult& result);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_DeleteElement(JSContext* cx, JS::HandleObject obj, uint32_t index, JS::ObjectOpResult& result);
 
 /**
@@ -3233,7 +3233,7 @@
  * The array of ids returned by JS_Enumerate must be rooted to protect its
  * contents from garbage collection. Use JS::Rooted<JS::IdVector>.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_Enumerate(JSContext* cx, JS::HandleObject obj, JS::MutableHandle<JS::IdVector> props);
 
 /*
@@ -3279,18 +3279,18 @@
  * Implements: ES6 7.3.12 Call(F, V, [argumentsList]).
  * Use this function to invoke the [[Call]] internal method.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_CallFunctionValue(JSContext* cx, JS::HandleObject obj, JS::HandleValue fval,
                      const JS::HandleValueArray& args, JS::MutableHandleValue rval);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_CallFunction(JSContext* cx, JS::HandleObject obj, JS::HandleFunction fun,
                 const JS::HandleValueArray& args, JS::MutableHandleValue rval);
 
 /**
  * Perform the method call `rval = obj[name](args)`.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_CallFunctionName(JSContext* cx, JS::HandleObject obj, const char* name,
                     const JS::HandleValueArray& args, JS::MutableHandleValue rval);
 
@@ -3363,47 +3363,47 @@
  * Invoke a constructor, like the JS expression `new ctor(...args)`. Returns
  * the new object, or null on error.
  */
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_New(JSContext* cx, JS::HandleObject ctor, const JS::HandleValueArray& args);
 
 
 /*** Other property-defining functions ***********************************************************/
 
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_DefineObject(JSContext* cx, JS::HandleObject obj, const char* name,
                 const JSClass* clasp = nullptr, unsigned attrs = 0);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_DefineConstDoubles(JSContext* cx, JS::HandleObject obj, const JSConstDoubleSpec* cds);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_DefineConstIntegers(JSContext* cx, JS::HandleObject obj, const JSConstIntegerSpec* cis);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_DefineProperties(JSContext* cx, JS::HandleObject obj, const JSPropertySpec* ps);
 
 
 /* * */
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_AlreadyHasOwnPropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
                              bool* foundp);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_AlreadyHasOwnProperty(JSContext* cx, JS::HandleObject obj, const char* name,
                          bool* foundp);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_AlreadyHasOwnUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name,
                            size_t namelen, bool* foundp);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_AlreadyHasOwnElement(JSContext* cx, JS::HandleObject obj, uint32_t index, bool* foundp);
 
 extern JS_PUBLIC_API(JSObject*)
 JS_NewArrayObject(JSContext* cx, const JS::HandleValueArray& contents);
 
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_NewArrayObject(JSContext* cx, size_t length);
 
 /**
@@ -3423,13 +3423,13 @@
  * This method returns true with |*isArray == false| when passed a proxy whose
  * target is an Array, or when passed a revoked proxy.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_IsArrayObject(JSContext* cx, JS::HandleObject obj, bool* isArray);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_GetArrayLength(JSContext* cx, JS::Handle<JSObject*> obj, uint32_t* lengthp);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_SetArrayLength(JSContext* cx, JS::Handle<JSObject*> obj, uint32_t length);
 
 namespace JS {
@@ -3468,14 +3468,14 @@
  * these contents to free(). On success, the ownership is transferred to the
  * new array buffer.
  */
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_NewArrayBufferWithContents(JSContext* cx, size_t nbytes, void* contents);
 
 /**
  * Create a new array buffer with the given contents.  The array buffer does not take ownership of
  * contents, and JS_DetachArrayBuffer must be called before the contents are disposed of.
  */
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_NewArrayBufferWithExternalContents(JSContext* cx, size_t nbytes, void* contents);
 
 /**
@@ -3484,7 +3484,7 @@
  * of the return value and must free it or transfer ownership via
  * JS_NewArrayBufferWithContents when done using it.
  */
-extern JS_PUBLIC_API(void*)
+extern "C" JS_PUBLIC_API(void*)
 JS_StealArrayBufferContents(JSContext* cx, JS::HandleObject obj);
 
 /**
@@ -3503,7 +3503,7 @@
  *
  * If |obj| isn't an ArrayBuffer, this function returns null and reports an error.
  */
-extern JS_PUBLIC_API(void*)
+extern "C" JS_PUBLIC_API(void*)
 JS_ExternalizeArrayBufferContents(JSContext* cx, JS::HandleObject obj);
 
 /**
@@ -3511,14 +3511,14 @@
  * must be legal to free the contents pointer by unmapping it. On success,
  * ownership is transferred to the new mapped array buffer.
  */
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_NewMappedArrayBufferWithContents(JSContext* cx, size_t nbytes, void* contents);
 
 /**
  * Create memory mapped array buffer contents.
  * Caller must take care of closing fd after calling this function.
  */
-extern JS_PUBLIC_API(void*)
+extern "C" JS_PUBLIC_API(void*)
 JS_CreateMappedArrayBufferContents(int fd, size_t offset, size_t length);
 
 /**
@@ -3528,13 +3528,13 @@
  * with this content, then JS_DetachArrayBuffer() should be used instead to
  * release the resource used by the object.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ReleaseMappedArrayBufferContents(void* contents, size_t length);
 
-extern JS_PUBLIC_API(JS::Value)
+extern "C" JS_PUBLIC_API(JS::Value)
 JS_GetReservedSlot(JSObject* obj, uint32_t index);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetReservedSlot(JSObject* obj, uint32_t index, const JS::Value& v);
 
 
@@ -3543,7 +3543,7 @@
 /*
  * Functions and scripts.
  */
-extern JS_PUBLIC_API(JSFunction*)
+extern "C" JS_PUBLIC_API(JSFunction*)
 JS_NewFunction(JSContext* cx, JSNative call, unsigned nargs, unsigned flags,
                const char* name);
 
@@ -3566,7 +3566,7 @@
 
 } /* namespace JS */
 
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_GetFunctionObject(JSFunction* fun);
 
 /**
@@ -3575,7 +3575,7 @@
  * reference to it if fun is well-connected or rooted, and provided you bound
  * the use of the saved reference by fun's lifetime.
  */
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_GetFunctionId(JSFunction* fun);
 
 /**
@@ -3585,13 +3585,13 @@
  * still return nullptr if a useful display name could not be inferred. The
  * same restrictions on rooting as those in JS_GetFunctionId apply.
  */
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_GetFunctionDisplayId(JSFunction* fun);
 
 /*
  * Return the arity (length) of fun.
  */
-extern JS_PUBLIC_API(uint16_t)
+extern "C" JS_PUBLIC_API(uint16_t)
 JS_GetFunctionArity(JSFunction* fun);
 
 /**
@@ -3600,36 +3600,36 @@
  * overwritten the "Function" identifier with a different constructor and then
  * created instances using that constructor that might be passed in as obj).
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_ObjectIsFunction(JSContext* cx, JSObject* obj);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_IsNativeFunction(JSObject* funobj, JSNative call);
 
 /** Return whether the given function is a valid constructor. */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_IsConstructor(JSFunction* fun);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_DefineFunctions(JSContext* cx, JS::Handle<JSObject*> obj, const JSFunctionSpec* fs);
 
-extern JS_PUBLIC_API(JSFunction*)
+extern "C" JS_PUBLIC_API(JSFunction*)
 JS_DefineFunction(JSContext* cx, JS::Handle<JSObject*> obj, const char* name, JSNative call,
                   unsigned nargs, unsigned attrs);
 
-extern JS_PUBLIC_API(JSFunction*)
+extern "C" JS_PUBLIC_API(JSFunction*)
 JS_DefineUCFunction(JSContext* cx, JS::Handle<JSObject*> obj,
                     const char16_t* name, size_t namelen, JSNative call,
                     unsigned nargs, unsigned attrs);
 
-extern JS_PUBLIC_API(JSFunction*)
+extern "C" JS_PUBLIC_API(JSFunction*)
 JS_DefineFunctionById(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JSNative call,
                       unsigned nargs, unsigned attrs);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_IsFunctionBound(JSFunction* fun);
 
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_GetBoundFunctionTarget(JSFunction* fun);
 
 namespace JS {
@@ -3658,14 +3658,14 @@
  * lines in a buffer until JS_BufferIsCompilableUnit is true, then pass it to
  * the compiler.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_BufferIsCompilableUnit(JSContext* cx, JS::Handle<JSObject*> obj, const char* utf8,
                           size_t length);
 
 /**
  * |script| will always be set. On failure, it will be set to nullptr.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_CompileScript(JSContext* cx, const char* ascii, size_t length,
                  const JS::CompileOptions& options,
                  JS::MutableHandleScript script);
@@ -3673,21 +3673,21 @@
 /**
  * |script| will always be set. On failure, it will be set to nullptr.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_CompileUCScript(JSContext* cx, const char16_t* chars, size_t length,
                    const JS::CompileOptions& options,
                    JS::MutableHandleScript script);
 
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_GetGlobalFromScript(JSScript* script);
 
-extern JS_PUBLIC_API(const char*)
+extern "C" JS_PUBLIC_API(const char*)
 JS_GetScriptFilename(JSScript* script);
 
-extern JS_PUBLIC_API(unsigned)
+extern "C" JS_PUBLIC_API(unsigned)
 JS_GetScriptBaseLineNumber(JSContext* cx, JSScript* script);
 
-extern JS_PUBLIC_API(JSScript*)
+extern "C" JS_PUBLIC_API(JSScript*)
 JS_GetFunctionScript(JSContext* cx, JS::HandleFunction fun);
 
 namespace JS {
@@ -4186,7 +4186,7 @@
 
 } /* namespace JS */
 
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_DecompileScript(JSContext* cx, JS::Handle<JSScript*> script, const char* name, unsigned indent);
 
 /*
@@ -4195,7 +4195,7 @@
  */
 #define JS_DONT_PRETTY_PRINT    ((unsigned)0x8000)
 
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_DecompileFunction(JSContext* cx, JS::Handle<JSFunction*> fun, unsigned indent);
 
 
@@ -4219,7 +4219,7 @@
 /**
  * Evaluate a script in the scope of the current global of cx.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_ExecuteScript(JSContext* cx, JS::HandleScript script, JS::MutableHandleValue rval);
 
 extern JS_PUBLIC_API(bool)
@@ -4373,7 +4373,7 @@
 
 } /* namespace JS */
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_CheckForInterrupt(JSContext* cx);
 
 /*
@@ -4389,16 +4389,16 @@
  * if it re-enters the JS engine. The embedding must ensure that the callback
  * is disconnected before attempting such re-entry.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_AddInterruptCallback(JSContext* cx, JSInterruptCallback callback);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_DisableInterruptCallback(JSContext* cx);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ResetInterruptCallback(JSContext* cx, bool enable);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_RequestInterruptCallback(JSContext* cx);
 
 namespace JS {
@@ -4635,7 +4635,7 @@
 
 } // namespace JS
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_IsRunning(JSContext* cx);
 
 namespace JS {
@@ -4702,64 +4702,64 @@
  * for them. In contrast, all the JS_New*StringCopy* functions do not take
  * ownership of the character memory passed to them -- they copy it.
  */
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_NewStringCopyN(JSContext* cx, const char* s, size_t n);
 
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_NewStringCopyZ(JSContext* cx, const char* s);
 
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_NewStringCopyUTF8Z(JSContext* cx, const JS::ConstUTF8CharsZ s);
 
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_NewStringCopyUTF8N(JSContext* cx, const JS::UTF8Chars s);
 
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_AtomizeAndPinJSString(JSContext* cx, JS::HandleString str);
 
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_AtomizeStringN(JSContext* cx, const char* s, size_t length);
 
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_AtomizeString(JSContext* cx, const char* s);
 
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_AtomizeAndPinStringN(JSContext* cx, const char* s, size_t length);
 
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_AtomizeAndPinString(JSContext* cx, const char* s);
 
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_NewUCString(JSContext* cx, char16_t* chars, size_t length);
 
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_NewUCStringCopyN(JSContext* cx, const char16_t* s, size_t n);
 
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_NewUCStringCopyZ(JSContext* cx, const char16_t* s);
 
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_AtomizeUCStringN(JSContext* cx, const char16_t* s, size_t length);
 
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_AtomizeUCString(JSContext* cx, const char16_t* s);
 
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_AtomizeAndPinUCStringN(JSContext* cx, const char16_t* s, size_t length);
 
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_AtomizeAndPinUCString(JSContext* cx, const char16_t* s);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_CompareStrings(JSContext* cx, JSString* str1, JSString* str2, int32_t* result);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_StringEqualsAscii(JSContext* cx, JSString* str, const char* asciiBytes, bool* match);
 
-extern JS_PUBLIC_API(size_t)
+extern "C" JS_PUBLIC_API(size_t)
 JS_PutEscapedString(JSContext* cx, char* buffer, size_t size, JSString* str, char quote);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_FileEscapedString(FILE* fp, JSString* str, char quote);
 
 /*
@@ -4801,43 +4801,43 @@
  * strings.
  */
 
-extern JS_PUBLIC_API(size_t)
+extern "C" JS_PUBLIC_API(size_t)
 JS_GetStringLength(JSString* str);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_StringIsFlat(JSString* str);
 
 /** Returns true iff the string's characters are stored as Latin1. */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_StringHasLatin1Chars(JSString* str);
 
-extern JS_PUBLIC_API(const JS::Latin1Char*)
+extern "C" JS_PUBLIC_API(const JS::Latin1Char*)
 JS_GetLatin1StringCharsAndLength(JSContext* cx, const JS::AutoCheckCannotGC& nogc, JSString* str,
                                  size_t* length);
 
-extern JS_PUBLIC_API(const char16_t*)
+extern "C" JS_PUBLIC_API(const char16_t*)
 JS_GetTwoByteStringCharsAndLength(JSContext* cx, const JS::AutoCheckCannotGC& nogc, JSString* str,
                                   size_t* length);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_GetStringCharAt(JSContext* cx, JSString* str, size_t index, char16_t* res);
 
-extern JS_PUBLIC_API(char16_t)
+extern "C" JS_PUBLIC_API(char16_t)
 JS_GetFlatStringCharAt(JSFlatString* str, size_t index);
 
-extern JS_PUBLIC_API(const char16_t*)
+extern "C" JS_PUBLIC_API(const char16_t*)
 JS_GetTwoByteExternalStringChars(JSString* str);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_CopyStringChars(JSContext* cx, mozilla::Range<char16_t> dest, JSString* str);
 
-extern JS_PUBLIC_API(JSFlatString*)
+extern "C" JS_PUBLIC_API(JSFlatString*)
 JS_FlattenString(JSContext* cx, JSString* str);
 
-extern JS_PUBLIC_API(const JS::Latin1Char*)
+extern "C" JS_PUBLIC_API(const JS::Latin1Char*)
 JS_GetLatin1FlatStringChars(const JS::AutoCheckCannotGC& nogc, JSFlatString* str);
 
-extern JS_PUBLIC_API(const char16_t*)
+extern "C" JS_PUBLIC_API(const char16_t*)
 JS_GetTwoByteFlatStringChars(const JS::AutoCheckCannotGC& nogc, JSFlatString* str);
 
 static MOZ_ALWAYS_INLINE JSFlatString*
@@ -4864,10 +4864,10 @@
  * Additional APIs that avoid fallibility when given a flat string.
  */
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_FlatStringEqualsAscii(JSFlatString* str, const char* asciiBytes);
 
-extern JS_PUBLIC_API(size_t)
+extern "C" JS_PUBLIC_API(size_t)
 JS_PutEscapedFlatString(char* buffer, size_t size, JSFlatString* str, char quote);
 
 /**
@@ -4875,7 +4875,7 @@
  * but that refers to a slice of another string's chars.  Dependent strings
  * are mutable by definition, so the thread safety comments above apply.
  */
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_NewDependentString(JSContext* cx, JS::HandleString str, size_t start,
                       size_t length);
 
@@ -4883,7 +4883,7 @@
  * Concatenate two strings, possibly resulting in a rope.
  * See above for thread safety comments.
  */
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_ConcatStrings(JSContext* cx, JS::HandleString left, JS::HandleString right);
 
 /**
@@ -5135,7 +5135,7 @@
 /**
  * JSON.stringify as specified by ES5.
  */
-JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_Stringify(JSContext* cx, JS::MutableHandleValue value, JS::HandleObject replacer,
              JS::HandleValue space, JSONWriteCallback callback, void* data);
 
@@ -5167,7 +5167,7 @@
 /**
  * JSON.parse as specified by ES5.
  */
-JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_ParseJSON(JSContext* cx, const char16_t* chars, uint32_t len, JS::MutableHandleValue vp);
 
 JS_PUBLIC_API(bool)
@@ -5190,7 +5190,7 @@
  * specify their own locales.
  * The locale string remains owned by the caller.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_SetDefaultLocale(JSContext* cx, const char* locale);
 
 /**
@@ -5202,7 +5202,7 @@
 /**
  * Reset the default locale to OS defaults.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ResetDefaultLocale(JSContext* cx);
 
 /**
@@ -5219,14 +5219,14 @@
  * Establish locale callbacks. The pointer must persist as long as the
  * JSContext.  Passing nullptr restores the default behaviour.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetLocaleCallbacks(JSContext* cx, const JSLocaleCallbacks* callbacks);
 
 /**
  * Return the address of the current locale callbacks struct, which may
  * be nullptr.
  */
-extern JS_PUBLIC_API(const JSLocaleCallbacks*)
+extern "C" JS_PUBLIC_API(const JSLocaleCallbacks*)
 JS_GetLocaleCallbacks(JSContext* cx);
 
 /************************************************************************/
@@ -5243,45 +5243,45 @@
  * Report an exception represented by the sprintf-like conversion of format
  * and its arguments.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ReportErrorASCII(JSContext* cx, const char* format, ...)
     MOZ_FORMAT_PRINTF(2, 3);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ReportErrorLatin1(JSContext* cx, const char* format, ...)
     MOZ_FORMAT_PRINTF(2, 3);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ReportErrorUTF8(JSContext* cx, const char* format, ...)
     MOZ_FORMAT_PRINTF(2, 3);
 
 /*
  * Use an errorNumber to retrieve the format string, args are char*
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ReportErrorNumberASCII(JSContext* cx, JSErrorCallback errorCallback,
                           void* userRef, const unsigned errorNumber, ...);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ReportErrorNumberASCIIVA(JSContext* cx, JSErrorCallback errorCallback,
                             void* userRef, const unsigned errorNumber, va_list ap);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ReportErrorNumberLatin1(JSContext* cx, JSErrorCallback errorCallback,
                            void* userRef, const unsigned errorNumber, ...);
 
 #ifdef va_start
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ReportErrorNumberLatin1VA(JSContext* cx, JSErrorCallback errorCallback,
                              void* userRef, const unsigned errorNumber, va_list ap);
 #endif
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ReportErrorNumberUTF8(JSContext* cx, JSErrorCallback errorCallback,
                            void* userRef, const unsigned errorNumber, ...);
 
 #ifdef va_start
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ReportErrorNumberUTF8VA(JSContext* cx, JSErrorCallback errorCallback,
                            void* userRef, const unsigned errorNumber, va_list ap);
 #endif
@@ -5289,11 +5289,11 @@
 /*
  * Use an errorNumber to retrieve the format string, args are char16_t*
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ReportErrorNumberUC(JSContext* cx, JSErrorCallback errorCallback,
                      void* userRef, const unsigned errorNumber, ...);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ReportErrorNumberUCArray(JSContext* cx, JSErrorCallback errorCallback,
                             void* userRef, const unsigned errorNumber,
                             const char16_t** args);
@@ -5304,34 +5304,34 @@
  * warning was not converted into an error due to the JSOPTION_WERROR option
  * being set, false otherwise.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_ReportWarningASCII(JSContext* cx, const char* format, ...)
     MOZ_FORMAT_PRINTF(2, 3);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_ReportWarningLatin1(JSContext* cx, const char* format, ...)
     MOZ_FORMAT_PRINTF(2, 3);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_ReportWarningUTF8(JSContext* cx, const char* format, ...)
     MOZ_FORMAT_PRINTF(2, 3);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_ReportErrorFlagsAndNumberASCII(JSContext* cx, unsigned flags,
                                   JSErrorCallback errorCallback, void* userRef,
                                   const unsigned errorNumber, ...);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_ReportErrorFlagsAndNumberLatin1(JSContext* cx, unsigned flags,
                                    JSErrorCallback errorCallback, void* userRef,
                                    const unsigned errorNumber, ...);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_ReportErrorFlagsAndNumberUTF8(JSContext* cx, unsigned flags,
                                  JSErrorCallback errorCallback, void* userRef,
                                  const unsigned errorNumber, ...);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_ReportErrorFlagsAndNumberUC(JSContext* cx, unsigned flags,
                                JSErrorCallback errorCallback, void* userRef,
                                const unsigned errorNumber, ...);
@@ -5339,13 +5339,13 @@
 /**
  * Complain when out of memory.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ReportOutOfMemory(JSContext* cx);
 
 /**
  * Complain when an allocation size overflows the maximum supported limit.
  */
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ReportAllocationOverflow(JSContext* cx);
 
 class JSErrorReport
@@ -5450,10 +5450,10 @@
 
 using WarningReporter = void (*)(JSContext* cx, JSErrorReport* report);
 
-extern JS_PUBLIC_API(WarningReporter)
+extern "C" JS_PUBLIC_API(WarningReporter)
 SetWarningReporter(JSContext* cx, WarningReporter reporter);
 
-extern JS_PUBLIC_API(WarningReporter)
+extern "C" JS_PUBLIC_API(WarningReporter)
 GetWarningReporter(JSContext* cx);
 
 extern JS_PUBLIC_API(bool)
@@ -5557,7 +5557,7 @@
  * Dates.
  */
 
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_NewDateObject(JSContext* cx, int year, int mon, int mday, int hour, int min, int sec);
 
 /**
@@ -5567,7 +5567,7 @@
  * This method returns true with |*isDate == false| when passed a proxy whose
  * target is a Date, or when passed a revoked proxy.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_ObjectIsDate(JSContext* cx, JS::HandleObject obj, bool* isDate);
 
 /************************************************************************/
@@ -5581,26 +5581,26 @@
 #define JSREG_STICKY    0x08u   /* only match starting at lastIndex */
 #define JSREG_UNICODE   0x10u   /* unicode */
 
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_NewRegExpObject(JSContext* cx, const char* bytes, size_t length, unsigned flags);
 
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_NewUCRegExpObject(JSContext* cx, const char16_t* chars, size_t length, unsigned flags);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_SetRegExpInput(JSContext* cx, JS::HandleObject obj, JS::HandleString input);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_ClearRegExpStatics(JSContext* cx, JS::HandleObject obj);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_ExecuteRegExp(JSContext* cx, JS::HandleObject obj, JS::HandleObject reobj,
                  char16_t* chars, size_t length, size_t* indexp, bool test,
                  JS::MutableHandleValue rval);
 
 /* RegExp interface for clients without a global object. */
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_ExecuteRegExpNoStatics(JSContext* cx, JS::HandleObject reobj, char16_t* chars, size_t length,
                           size_t* indexp, bool test, JS::MutableHandleValue rval);
 
@@ -5611,27 +5611,27 @@
  * This method returns true with |*isRegExp == false| when passed a proxy whose
  * target is a RegExp, or when passed a revoked proxy.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_ObjectIsRegExp(JSContext* cx, JS::HandleObject obj, bool* isRegExp);
 
-extern JS_PUBLIC_API(unsigned)
+extern "C" JS_PUBLIC_API(unsigned)
 JS_GetRegExpFlags(JSContext* cx, JS::HandleObject obj);
 
-extern JS_PUBLIC_API(JSString*)
+extern "C" JS_PUBLIC_API(JSString*)
 JS_GetRegExpSource(JSContext* cx, JS::HandleObject obj);
 
 /************************************************************************/
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_IsExceptionPending(JSContext* cx);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_GetPendingException(JSContext* cx, JS::MutableHandleValue vp);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetPendingException(JSContext* cx, JS::HandleValue v);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_ClearPendingException(JSContext* cx);
 
 namespace JS {
@@ -5692,13 +5692,13 @@
 } /* namespace JS */
 
 /* Deprecated API. Use AutoSaveExceptionState instead. */
-extern JS_PUBLIC_API(JSExceptionState*)
+extern "C" JS_PUBLIC_API(JSExceptionState*)
 JS_SaveExceptionState(JSContext* cx);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_RestoreExceptionState(JSContext* cx, JSExceptionState* state);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_DropExceptionState(JSContext* cx, JSExceptionState* state);
 
 /**
@@ -5708,7 +5708,7 @@
  * of the error report struct that might be returned is the same as the
  * lifetime of the exception object.
  */
-extern JS_PUBLIC_API(JSErrorReport*)
+extern "C" JS_PUBLIC_API(JSErrorReport*)
 JS_ErrorFromException(JSContext* cx, JS::HandleObject obj);
 
 /**
@@ -5718,16 +5718,16 @@
  * (including if it's null or a security wrapper that can't be unwrapped) or if
  * the exception has no stack.
  */
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 ExceptionStackOrNull(JS::HandleObject obj);
 
 /*
  * Throws a StopIteration exception on cx.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_ThrowStopIteration(JSContext* cx);
 
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_IsStopIteration(const JS::Value& v);
 
 /**
@@ -5740,7 +5740,7 @@
  * non-debug builds).
  */
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_AbortIfWrongThread(JSContext* cx);
 
 /************************************************************************/
@@ -5750,7 +5750,7 @@
  * object of the given class, using the callee to determine parentage and
  * [[Prototype]].
  */
-extern JS_PUBLIC_API(JSObject*)
+extern "C" JS_PUBLIC_API(JSObject*)
 JS_NewObjectForConstructor(JSContext* cx, const JSClass* clasp, const JS::CallArgs& args);
 
 /************************************************************************/
@@ -5768,10 +5768,10 @@
 JS_ScheduleGC(JSContext* cx, uint32_t count);
 #endif
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetParallelParsingEnabled(JSContext* cx, bool enabled);
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetOffthreadIonCompilationEnabled(JSContext* cx, bool enabled);
 
 #define JIT_COMPILER_OPTIONS(Register)                                     \
@@ -5799,15 +5799,15 @@
     JSJITCOMPILER_NOT_AN_OPTION
 } JSJitCompilerOption;
 
-extern JS_PUBLIC_API(void)
+extern "C" JS_PUBLIC_API(void)
 JS_SetGlobalJitCompilerOption(JSContext* cx, JSJitCompilerOption opt, uint32_t value);
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_GetGlobalJitCompilerOption(JSContext* cx, JSJitCompilerOption opt, uint32_t* valueOut);
 
 /**
  * Convert a uint32_t index into a jsid.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_IndexToId(JSContext* cx, uint32_t index, JS::MutableHandleId);
 
 /**
@@ -5815,13 +5815,13 @@
  *
  * |chars| may not be an index.
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_CharsToId(JSContext* cx, JS::TwoByteChars chars, JS::MutableHandleId);
 
 /**
  *  Test if the given string is a valid ECMAScript identifier
  */
-extern JS_PUBLIC_API(bool)
+extern "C" JS_PUBLIC_API(bool)
 JS_IsIdentifier(JSContext* cx, JS::HandleString str, bool* isIdentifier);
 
 /**
@@ -6627,4 +6627,72 @@
 } /* namespace js */
 
 
+  /////////////// orel added
+extern "C" JS_PUBLIC_API(JSObject*)
+JS_NewArrayObject2(JSContext* cx, const JS::HandleValueArray& contents);
+
+extern "C" JS_PUBLIC_API(JSObject*)
+JS_NewDateObjectMsec(JSContext* cx, double msec);
+
+extern "C" JS_PUBLIC_API(void*)
+JS_GetContextOptions(JSContext* cx);
+
+extern "C" JS_PUBLIC_API(void*)
+JS_NewRootedValue(JSContext* cx, uint64_t initial);
+
+extern "C" JS_PUBLIC_API(void)
+JS_FreeRooteValue(void* val);
+
+extern "C" JS_PUBLIC_API(void*)
+JS_NewRootedObject(JSContext* cx, JSObject* initial);
+
+extern "C" JS_PUBLIC_API(void)
+JS_FreeRootedObject(void* obj);
+
+extern "C" JS_PUBLIC_API(void*)
+JS_NewRootedString(JSContext* cx, JSString* initial);
+
+extern "C" JS_PUBLIC_API(void)
+JS_FreeRootedString(void* str);
+
+extern "C" JS_PUBLIC_API(void*)
+JS_NewCompileOptions(JSContext* cx);
+
+extern "C" JS_PUBLIC_API(void)
+JS_FreeCompileOptions(void* co);
+
+extern "C" JS_PUBLIC_API(void*)
+JS_NewCompartmentOptions();
+
+extern "C" JS_PUBLIC_API(void)
+JS_FreeCompartmentOptions(void* opt);
+
+extern "C" JS_PUBLIC_API(bool)
+JS_EvaluateScript(JSContext* cx, const JS::CompileOptions& options,
+	const char* bytes, size_t length, JS::MutableHandleValue rval);
+
+extern "C" JS_PUBLIC_API(bool)
+JS_EvaluateUCScript(JSContext* cx, const JS::CompileOptions& options,
+	const char16_t* chars, size_t length, JS::MutableHandleValue rval);
+
+
+extern "C" JS_PUBLIC_API(bool)
+JS_InitModuleClasses(JSContext* cx, JS::Handle<JSObject*> obj);
+
+extern "C" JS_PUBLIC_API(JSObject*)
+JS_CompileModule(JSContext* cx, JS::Handle<JSObject*> obj, JS::CompileOptions& options,
+	const char16_t* chars, size_t length);
+
+extern "C" JS_PUBLIC_API(void)
+JS_SetModuleResolveHook(JSContext* cx, JS::Handle<JSFunction*> hook);
+
+extern "C" JS_PUBLIC_API(JS::Value)
+JS_ComputeThis(JSContext* cx, JS::Value* vp);
+
+extern "C" JS_PUBLIC_API(bool)
+JS_Initialize(void);
+
+extern "C" JS_PUBLIC_API(uint64_t)
+JS_GetReservedSlot1(JSObject* obj, uint32_t index);
+
 #endif /* jsapi_h */
diff -r ce1a4a27b63b -r 450090eb5719 js/src/jsfriendapi.h
--- a/js/src/jsfriendapi.h	Mon Mar 06 07:39:32 2017 -0800
+++ b/js/src/jsfriendapi.h	Wed Mar 15 15:24:47 2017 +0200
@@ -1637,23 +1637,23 @@
  * These functions (except the WithBuffer variants) fill in the array with zeros.
  */
 
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewInt8Array(JSContext* cx, uint32_t nelements);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewUint8Array(JSContext* cx, uint32_t nelements);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewUint8ClampedArray(JSContext* cx, uint32_t nelements);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewInt16Array(JSContext* cx, uint32_t nelements);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewUint16Array(JSContext* cx, uint32_t nelements);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewInt32Array(JSContext* cx, uint32_t nelements);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewUint32Array(JSContext* cx, uint32_t nelements);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewFloat32Array(JSContext* cx, uint32_t nelements);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewFloat64Array(JSContext* cx, uint32_t nelements);
 
 /*
@@ -1664,23 +1664,23 @@
  * conversion to the typed array element type.
  */
 
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewInt8ArrayFromArray(JSContext* cx, JS::HandleObject array);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewUint8ArrayFromArray(JSContext* cx, JS::HandleObject array);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewUint8ClampedArrayFromArray(JSContext* cx, JS::HandleObject array);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewInt16ArrayFromArray(JSContext* cx, JS::HandleObject array);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewUint16ArrayFromArray(JSContext* cx, JS::HandleObject array);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewInt32ArrayFromArray(JSContext* cx, JS::HandleObject array);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewUint32ArrayFromArray(JSContext* cx, JS::HandleObject array);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewFloat32ArrayFromArray(JSContext* cx, JS::HandleObject array);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewFloat64ArrayFromArray(JSContext* cx, JS::HandleObject array);
 
 /*
@@ -1690,31 +1690,31 @@
  * array is used as the default value.
  */
 
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewInt8ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
                           uint32_t byteOffset, int32_t length);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewUint8ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
                            uint32_t byteOffset, int32_t length);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewUint8ClampedArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
                                   uint32_t byteOffset, int32_t length);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewInt16ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
                            uint32_t byteOffset, int32_t length);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewUint16ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
                             uint32_t byteOffset, int32_t length);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewInt32ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
                            uint32_t byteOffset, int32_t length);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewUint32ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
                             uint32_t byteOffset, int32_t length);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewFloat32ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
                              uint32_t byteOffset, int32_t length);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewFloat64ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
                              uint32_t byteOffset, int32_t length);
 
@@ -1724,13 +1724,13 @@
  * JS::CompartmentCreationOptionsRef(cx).getSharedMemoryAndAtomicsEnabled() is
  * true.
  */
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewSharedArrayBuffer(JSContext* cx, uint32_t nbytes);
 
 /**
  * Create a new ArrayBuffer with the given byte length.
  */
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_NewArrayBuffer(JSContext* cx, uint32_t nbytes);
 
 /**
@@ -1739,7 +1739,7 @@
  * this test or one of the JS_Is*Array tests succeeds, then it is safe to call
  * the various accessor JSAPI calls defined below.
  */
-extern JS_FRIEND_API(bool)
+extern "C" JS_FRIEND_API(bool)
 JS_IsTypedArrayObject(JSObject* obj);
 
 /**
@@ -1749,30 +1749,30 @@
  * is safe to call the various ArrayBufferView accessor JSAPI calls defined
  * below.
  */
-extern JS_FRIEND_API(bool)
+extern "C" JS_FRIEND_API(bool)
 JS_IsArrayBufferViewObject(JSObject* obj);
 
 /*
  * Test for specific typed array types (ArrayBufferView subtypes)
  */
 
-extern JS_FRIEND_API(bool)
+extern "C" JS_FRIEND_API(bool)
 JS_IsInt8Array(JSObject* obj);
-extern JS_FRIEND_API(bool)
+extern "C" JS_FRIEND_API(bool)
 JS_IsUint8Array(JSObject* obj);
-extern JS_FRIEND_API(bool)
+extern "C" JS_FRIEND_API(bool)
 JS_IsUint8ClampedArray(JSObject* obj);
-extern JS_FRIEND_API(bool)
+extern "C" JS_FRIEND_API(bool)
 JS_IsInt16Array(JSObject* obj);
-extern JS_FRIEND_API(bool)
+extern "C" JS_FRIEND_API(bool)
 JS_IsUint16Array(JSObject* obj);
-extern JS_FRIEND_API(bool)
+extern "C" JS_FRIEND_API(bool)
 JS_IsInt32Array(JSObject* obj);
-extern JS_FRIEND_API(bool)
+extern "C" JS_FRIEND_API(bool)
 JS_IsUint32Array(JSObject* obj);
-extern JS_FRIEND_API(bool)
+extern "C" JS_FRIEND_API(bool)
 JS_IsFloat32Array(JSObject* obj);
-extern JS_FRIEND_API(bool)
+extern "C" JS_FRIEND_API(bool)
 JS_IsFloat64Array(JSObject* obj);
 
 /**
@@ -1783,7 +1783,7 @@
  * be known that it would pass such a test: it is a typed array or a wrapper of
  * a typed array, and the unwrapping will succeed.
  */
-extern JS_FRIEND_API(bool)
+extern "C" JS_FRIEND_API(bool)
 JS_GetTypedArraySharedness(JSObject* obj);
 
 /*
@@ -1891,31 +1891,31 @@
  * object cannot be viewed as the correct typed array, or the typed array
  * object on success, filling both outparameters.
  */
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_GetObjectAsInt8Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, int8_t** data);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_GetObjectAsUint8Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint8_t** data);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_GetObjectAsUint8ClampedArray(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint8_t** data);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_GetObjectAsInt16Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, int16_t** data);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_GetObjectAsUint16Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint16_t** data);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_GetObjectAsInt32Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, int32_t** data);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_GetObjectAsUint32Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint32_t** data);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_GetObjectAsFloat32Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, float** data);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_GetObjectAsFloat64Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, double** data);
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_GetObjectAsArrayBufferView(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint8_t** data);
 
 /*
  * Unwrap an ArrayBuffer, return nullptr if it's a different type.
  */
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_GetObjectAsArrayBuffer(JSObject* obj, uint32_t* length, uint8_t** data);
 
 /*
@@ -1925,10 +1925,10 @@
  * be known that it would pass such a test: it is an ArrayBufferView or a
  * wrapper of an ArrayBufferView, and the unwrapping will succeed.
  */
-extern JS_FRIEND_API(js::Scalar::Type)
+extern "C" JS_FRIEND_API(js::Scalar::Type)
 JS_GetArrayBufferViewType(JSObject* obj);
 
-extern JS_FRIEND_API(js::Scalar::Type)
+extern "C" JS_FRIEND_API(js::Scalar::Type)
 JS_GetSharedArrayBufferViewType(JSObject* obj);
 
 /*
@@ -1937,10 +1937,10 @@
  * unwrapping. If this test succeeds, then it is safe to call the various
  * accessor JSAPI calls defined below.
  */
-extern JS_FRIEND_API(bool)
+extern "C" JS_FRIEND_API(bool)
 JS_IsArrayBufferObject(JSObject* obj);
 
-extern JS_FRIEND_API(bool)
+extern "C" JS_FRIEND_API(bool)
 JS_IsSharedArrayBufferObject(JSObject* obj);
 
 /**
@@ -1950,10 +1950,10 @@
  * that it would pass such a test: it is an ArrayBuffer or a wrapper of an
  * ArrayBuffer, and the unwrapping will succeed.
  */
-extern JS_FRIEND_API(uint32_t)
+extern "C" JS_FRIEND_API(uint32_t)
 JS_GetArrayBufferByteLength(JSObject* obj);
 
-extern JS_FRIEND_API(uint32_t)
+extern "C" JS_FRIEND_API(uint32_t)
 JS_GetSharedArrayBufferByteLength(JSObject* obj);
 
 /**
@@ -1964,7 +1964,7 @@
  * that it would pass such a test: it is an ArrayBuffer or a wrapper of an
  * ArrayBuffer, and the unwrapping will succeed.
  */
-extern JS_FRIEND_API(bool)
+extern "C" JS_FRIEND_API(bool)
 JS_ArrayBufferHasData(JSObject* obj);
 
 /**
@@ -1981,7 +1981,7 @@
  * *isSharedMemory will be set to false, the argument is present to simplify
  * its use from code that also interacts with SharedArrayBuffer.
  */
-extern JS_FRIEND_API(uint8_t*)
+extern "C" JS_FRIEND_API(uint8_t*)
 JS_GetArrayBufferData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
 
 /**
@@ -1989,7 +1989,7 @@
  * may return false if a security wrapper is encountered that denies the
  * unwrapping.
  */
-extern JS_FRIEND_API(bool)
+extern "C" JS_FRIEND_API(bool)
 JS_IsMappedArrayBufferObject(JSObject* obj);
 
 /**
@@ -1999,7 +1999,7 @@
  * be known that it would pass such a test: it is a typed array or a wrapper of
  * a typed array, and the unwrapping will succeed.
  */
-extern JS_FRIEND_API(uint32_t)
+extern "C" JS_FRIEND_API(uint32_t)
 JS_GetTypedArrayLength(JSObject* obj);
 
 /**
@@ -2010,7 +2010,7 @@
  * be known that it would pass such a test: it is a typed array or a wrapper of
  * a typed array, and the unwrapping will succeed.
  */
-extern JS_FRIEND_API(uint32_t)
+extern "C" JS_FRIEND_API(uint32_t)
 JS_GetTypedArrayByteOffset(JSObject* obj);
 
 /**
@@ -2020,7 +2020,7 @@
  * be known that it would pass such a test: it is a typed array or a wrapper of
  * a typed array, and the unwrapping will succeed.
  */
-extern JS_FRIEND_API(uint32_t)
+extern "C" JS_FRIEND_API(uint32_t)
 JS_GetTypedArrayByteLength(JSObject* obj);
 
 /**
@@ -2028,13 +2028,13 @@
  * return false if a security wrapper is encountered that denies the
  * unwrapping.
  */
-extern JS_FRIEND_API(bool)
+extern "C" JS_FRIEND_API(bool)
 JS_IsArrayBufferViewObject(JSObject* obj);
 
 /**
  * More generic name for JS_GetTypedArrayByteLength to cover DataViews as well
  */
-extern JS_FRIEND_API(uint32_t)
+extern "C" JS_FRIEND_API(uint32_t)
 JS_GetArrayBufferViewByteLength(JSObject* obj);
 
 /*
@@ -2052,30 +2052,30 @@
  * SharedArrayBuffer, otherwise to false.
  */
 
-extern JS_FRIEND_API(int8_t*)
+extern "C" JS_FRIEND_API(int8_t*)
 JS_GetInt8ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
-extern JS_FRIEND_API(uint8_t*)
+extern "C" JS_FRIEND_API(uint8_t*)
 JS_GetUint8ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
-extern JS_FRIEND_API(uint8_t*)
+extern "C" JS_FRIEND_API(uint8_t*)
 JS_GetUint8ClampedArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
-extern JS_FRIEND_API(int16_t*)
+extern "C" JS_FRIEND_API(int16_t*)
 JS_GetInt16ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
-extern JS_FRIEND_API(uint16_t*)
+extern "C" JS_FRIEND_API(uint16_t*)
 JS_GetUint16ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
-extern JS_FRIEND_API(int32_t*)
+extern "C" JS_FRIEND_API(int32_t*)
 JS_GetInt32ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
-extern JS_FRIEND_API(uint32_t*)
+extern "C" JS_FRIEND_API(uint32_t*)
 JS_GetUint32ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
-extern JS_FRIEND_API(float*)
+extern "C" JS_FRIEND_API(float*)
 JS_GetFloat32ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
-extern JS_FRIEND_API(double*)
+extern "C" JS_FRIEND_API(double*)
 JS_GetFloat64ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
 
 /**
  * Same as above, but for any kind of ArrayBufferView. Prefer the type-specific
  * versions when possible.
  */
-extern JS_FRIEND_API(void*)
+extern "C" JS_FRIEND_API(void*)
 JS_GetArrayBufferViewData(JSObject* obj, bool* isSharedMemory, const JS::AutoCheckCannotGC&);
 
 /**
@@ -2083,7 +2083,7 @@
  * This may return a detached buffer.  |obj| must be an object that would
  * return true for JS_IsArrayBufferViewObject().
  */
-extern JS_FRIEND_API(JSObject*)
+extern "C" JS_FRIEND_API(JSObject*)
 JS_GetArrayBufferViewBuffer(JSContext* cx, JS::HandleObject obj, bool* isSharedMemory);
 
 /**
@@ -2092,7 +2092,7 @@
  *
  * The |changeData| argument is obsolete and ignored.
  */
-extern JS_FRIEND_API(bool)
+extern "C" JS_FRIEND_API(bool)
 JS_DetachArrayBuffer(JSContext* cx, JS::HandleObject obj);
 
 /**
@@ -2100,7 +2100,7 @@
  * return false if a security wrapper is encountered that denies the
  * unwrapping.
  */
-extern JS_FRIEND_API(bool)
+extern "C" JS_FRIEND_API(bool)
 JS_IsDetachedArrayBufferObject(JSObject* obj);
 
 /**
